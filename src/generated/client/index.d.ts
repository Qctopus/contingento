
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model BusinessContinuityPlan
 * 
 */
export type BusinessContinuityPlan = $Result.DefaultSelection<Prisma.$BusinessContinuityPlanPayload>
/**
 * Model PlanInformation
 * 
 */
export type PlanInformation = $Result.DefaultSelection<Prisma.$PlanInformationPayload>
/**
 * Model BusinessOverview
 * 
 */
export type BusinessOverview = $Result.DefaultSelection<Prisma.$BusinessOverviewPayload>
/**
 * Model EssentialFunction
 * 
 */
export type EssentialFunction = $Result.DefaultSelection<Prisma.$EssentialFunctionPayload>
/**
 * Model RiskAssessment
 * 
 */
export type RiskAssessment = $Result.DefaultSelection<Prisma.$RiskAssessmentPayload>
/**
 * Model Strategy
 * 
 */
export type Strategy = $Result.DefaultSelection<Prisma.$StrategyPayload>
/**
 * Model ActionPlan
 * 
 */
export type ActionPlan = $Result.DefaultSelection<Prisma.$ActionPlanPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model BusinessProfile
 * 
 */
export type BusinessProfile = $Result.DefaultSelection<Prisma.$BusinessProfilePayload>
/**
 * Model ContactsInformation
 * 
 */
export type ContactsInformation = $Result.DefaultSelection<Prisma.$ContactsInformationPayload>
/**
 * Model TestingMaintenance
 * 
 */
export type TestingMaintenance = $Result.DefaultSelection<Prisma.$TestingMaintenancePayload>
/**
 * Model AnonymousSession
 * 
 */
export type AnonymousSession = $Result.DefaultSelection<Prisma.$AnonymousSessionPayload>
/**
 * Model AdminBusinessType
 * 
 */
export type AdminBusinessType = $Result.DefaultSelection<Prisma.$AdminBusinessTypePayload>
/**
 * Model AdminHazardType
 * 
 */
export type AdminHazardType = $Result.DefaultSelection<Prisma.$AdminHazardTypePayload>
/**
 * Model AdminLocation
 * 
 */
export type AdminLocation = $Result.DefaultSelection<Prisma.$AdminLocationPayload>
/**
 * Model AdminBusinessTypeHazard
 * 
 */
export type AdminBusinessTypeHazard = $Result.DefaultSelection<Prisma.$AdminBusinessTypeHazardPayload>
/**
 * Model AdminLocationHazard
 * 
 */
export type AdminLocationHazard = $Result.DefaultSelection<Prisma.$AdminLocationHazardPayload>
/**
 * Model AdminStrategy
 * 
 */
export type AdminStrategy = $Result.DefaultSelection<Prisma.$AdminStrategyPayload>
/**
 * Model AdminHazardStrategy
 * 
 */
export type AdminHazardStrategy = $Result.DefaultSelection<Prisma.$AdminHazardStrategyPayload>
/**
 * Model AdminActionPlan
 * 
 */
export type AdminActionPlan = $Result.DefaultSelection<Prisma.$AdminActionPlanPayload>
/**
 * Model AdminHazardActionPlan
 * 
 */
export type AdminHazardActionPlan = $Result.DefaultSelection<Prisma.$AdminHazardActionPlanPayload>
/**
 * Model AdminRiskProfile
 * 
 */
export type AdminRiskProfile = $Result.DefaultSelection<Prisma.$AdminRiskProfilePayload>
/**
 * Model Country
 * 
 */
export type Country = $Result.DefaultSelection<Prisma.$CountryPayload>
/**
 * Model AdminUnit
 * 
 */
export type AdminUnit = $Result.DefaultSelection<Prisma.$AdminUnitPayload>
/**
 * Model Parish
 * 
 */
export type Parish = $Result.DefaultSelection<Prisma.$ParishPayload>
/**
 * Model AdminUnitRisk
 * 
 */
export type AdminUnitRisk = $Result.DefaultSelection<Prisma.$AdminUnitRiskPayload>
/**
 * Model AdminUnitRiskChangeLog
 * 
 */
export type AdminUnitRiskChangeLog = $Result.DefaultSelection<Prisma.$AdminUnitRiskChangeLogPayload>
/**
 * Model ParishRisk
 * 
 */
export type ParishRisk = $Result.DefaultSelection<Prisma.$ParishRiskPayload>
/**
 * Model RiskChangeLog
 * 
 */
export type RiskChangeLog = $Result.DefaultSelection<Prisma.$RiskChangeLogPayload>
/**
 * Model BusinessType
 * 
 */
export type BusinessType = $Result.DefaultSelection<Prisma.$BusinessTypePayload>
/**
 * Model BusinessRiskVulnerability
 * 
 */
export type BusinessRiskVulnerability = $Result.DefaultSelection<Prisma.$BusinessRiskVulnerabilityPayload>
/**
 * Model RiskMitigationStrategy
 * 
 */
export type RiskMitigationStrategy = $Result.DefaultSelection<Prisma.$RiskMitigationStrategyPayload>
/**
 * Model ActionStep
 * 
 */
export type ActionStep = $Result.DefaultSelection<Prisma.$ActionStepPayload>
/**
 * Model BusinessTypeStrategy
 * 
 */
export type BusinessTypeStrategy = $Result.DefaultSelection<Prisma.$BusinessTypeStrategyPayload>
/**
 * Model BusinessRiskProfile
 * 
 */
export type BusinessRiskProfile = $Result.DefaultSelection<Prisma.$BusinessRiskProfilePayload>
/**
 * Model RiskMultiplier
 * 
 */
export type RiskMultiplier = $Result.DefaultSelection<Prisma.$RiskMultiplierPayload>
/**
 * Model CostItem
 * 
 */
export type CostItem = $Result.DefaultSelection<Prisma.$CostItemPayload>
/**
 * Model CountryCostMultiplier
 * 
 */
export type CountryCostMultiplier = $Result.DefaultSelection<Prisma.$CountryCostMultiplierPayload>
/**
 * Model StrategyItemCost
 * 
 */
export type StrategyItemCost = $Result.DefaultSelection<Prisma.$StrategyItemCostPayload>
/**
 * Model ActionStepItemCost
 * 
 */
export type ActionStepItemCost = $Result.DefaultSelection<Prisma.$ActionStepItemCostPayload>
/**
 * Model BusinessTypeTranslation
 * 
 */
export type BusinessTypeTranslation = $Result.DefaultSelection<Prisma.$BusinessTypeTranslationPayload>
/**
 * Model StrategyTranslation
 * 
 */
export type StrategyTranslation = $Result.DefaultSelection<Prisma.$StrategyTranslationPayload>
/**
 * Model ActionStepTranslation
 * 
 */
export type ActionStepTranslation = $Result.DefaultSelection<Prisma.$ActionStepTranslationPayload>
/**
 * Model HazardTranslation
 * 
 */
export type HazardTranslation = $Result.DefaultSelection<Prisma.$HazardTranslationPayload>
/**
 * Model RiskMultiplierTranslation
 * 
 */
export type RiskMultiplierTranslation = $Result.DefaultSelection<Prisma.$RiskMultiplierTranslationPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more BusinessContinuityPlans
 * const businessContinuityPlans = await prisma.businessContinuityPlan.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more BusinessContinuityPlans
   * const businessContinuityPlans = await prisma.businessContinuityPlan.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.businessContinuityPlan`: Exposes CRUD operations for the **BusinessContinuityPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BusinessContinuityPlans
    * const businessContinuityPlans = await prisma.businessContinuityPlan.findMany()
    * ```
    */
  get businessContinuityPlan(): Prisma.BusinessContinuityPlanDelegate<ExtArgs>;

  /**
   * `prisma.planInformation`: Exposes CRUD operations for the **PlanInformation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlanInformations
    * const planInformations = await prisma.planInformation.findMany()
    * ```
    */
  get planInformation(): Prisma.PlanInformationDelegate<ExtArgs>;

  /**
   * `prisma.businessOverview`: Exposes CRUD operations for the **BusinessOverview** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BusinessOverviews
    * const businessOverviews = await prisma.businessOverview.findMany()
    * ```
    */
  get businessOverview(): Prisma.BusinessOverviewDelegate<ExtArgs>;

  /**
   * `prisma.essentialFunction`: Exposes CRUD operations for the **EssentialFunction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EssentialFunctions
    * const essentialFunctions = await prisma.essentialFunction.findMany()
    * ```
    */
  get essentialFunction(): Prisma.EssentialFunctionDelegate<ExtArgs>;

  /**
   * `prisma.riskAssessment`: Exposes CRUD operations for the **RiskAssessment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RiskAssessments
    * const riskAssessments = await prisma.riskAssessment.findMany()
    * ```
    */
  get riskAssessment(): Prisma.RiskAssessmentDelegate<ExtArgs>;

  /**
   * `prisma.strategy`: Exposes CRUD operations for the **Strategy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Strategies
    * const strategies = await prisma.strategy.findMany()
    * ```
    */
  get strategy(): Prisma.StrategyDelegate<ExtArgs>;

  /**
   * `prisma.actionPlan`: Exposes CRUD operations for the **ActionPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActionPlans
    * const actionPlans = await prisma.actionPlan.findMany()
    * ```
    */
  get actionPlan(): Prisma.ActionPlanDelegate<ExtArgs>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs>;

  /**
   * `prisma.businessProfile`: Exposes CRUD operations for the **BusinessProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BusinessProfiles
    * const businessProfiles = await prisma.businessProfile.findMany()
    * ```
    */
  get businessProfile(): Prisma.BusinessProfileDelegate<ExtArgs>;

  /**
   * `prisma.contactsInformation`: Exposes CRUD operations for the **ContactsInformation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContactsInformations
    * const contactsInformations = await prisma.contactsInformation.findMany()
    * ```
    */
  get contactsInformation(): Prisma.ContactsInformationDelegate<ExtArgs>;

  /**
   * `prisma.testingMaintenance`: Exposes CRUD operations for the **TestingMaintenance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TestingMaintenances
    * const testingMaintenances = await prisma.testingMaintenance.findMany()
    * ```
    */
  get testingMaintenance(): Prisma.TestingMaintenanceDelegate<ExtArgs>;

  /**
   * `prisma.anonymousSession`: Exposes CRUD operations for the **AnonymousSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AnonymousSessions
    * const anonymousSessions = await prisma.anonymousSession.findMany()
    * ```
    */
  get anonymousSession(): Prisma.AnonymousSessionDelegate<ExtArgs>;

  /**
   * `prisma.adminBusinessType`: Exposes CRUD operations for the **AdminBusinessType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminBusinessTypes
    * const adminBusinessTypes = await prisma.adminBusinessType.findMany()
    * ```
    */
  get adminBusinessType(): Prisma.AdminBusinessTypeDelegate<ExtArgs>;

  /**
   * `prisma.adminHazardType`: Exposes CRUD operations for the **AdminHazardType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminHazardTypes
    * const adminHazardTypes = await prisma.adminHazardType.findMany()
    * ```
    */
  get adminHazardType(): Prisma.AdminHazardTypeDelegate<ExtArgs>;

  /**
   * `prisma.adminLocation`: Exposes CRUD operations for the **AdminLocation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminLocations
    * const adminLocations = await prisma.adminLocation.findMany()
    * ```
    */
  get adminLocation(): Prisma.AdminLocationDelegate<ExtArgs>;

  /**
   * `prisma.adminBusinessTypeHazard`: Exposes CRUD operations for the **AdminBusinessTypeHazard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminBusinessTypeHazards
    * const adminBusinessTypeHazards = await prisma.adminBusinessTypeHazard.findMany()
    * ```
    */
  get adminBusinessTypeHazard(): Prisma.AdminBusinessTypeHazardDelegate<ExtArgs>;

  /**
   * `prisma.adminLocationHazard`: Exposes CRUD operations for the **AdminLocationHazard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminLocationHazards
    * const adminLocationHazards = await prisma.adminLocationHazard.findMany()
    * ```
    */
  get adminLocationHazard(): Prisma.AdminLocationHazardDelegate<ExtArgs>;

  /**
   * `prisma.adminStrategy`: Exposes CRUD operations for the **AdminStrategy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminStrategies
    * const adminStrategies = await prisma.adminStrategy.findMany()
    * ```
    */
  get adminStrategy(): Prisma.AdminStrategyDelegate<ExtArgs>;

  /**
   * `prisma.adminHazardStrategy`: Exposes CRUD operations for the **AdminHazardStrategy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminHazardStrategies
    * const adminHazardStrategies = await prisma.adminHazardStrategy.findMany()
    * ```
    */
  get adminHazardStrategy(): Prisma.AdminHazardStrategyDelegate<ExtArgs>;

  /**
   * `prisma.adminActionPlan`: Exposes CRUD operations for the **AdminActionPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminActionPlans
    * const adminActionPlans = await prisma.adminActionPlan.findMany()
    * ```
    */
  get adminActionPlan(): Prisma.AdminActionPlanDelegate<ExtArgs>;

  /**
   * `prisma.adminHazardActionPlan`: Exposes CRUD operations for the **AdminHazardActionPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminHazardActionPlans
    * const adminHazardActionPlans = await prisma.adminHazardActionPlan.findMany()
    * ```
    */
  get adminHazardActionPlan(): Prisma.AdminHazardActionPlanDelegate<ExtArgs>;

  /**
   * `prisma.adminRiskProfile`: Exposes CRUD operations for the **AdminRiskProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminRiskProfiles
    * const adminRiskProfiles = await prisma.adminRiskProfile.findMany()
    * ```
    */
  get adminRiskProfile(): Prisma.AdminRiskProfileDelegate<ExtArgs>;

  /**
   * `prisma.country`: Exposes CRUD operations for the **Country** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Countries
    * const countries = await prisma.country.findMany()
    * ```
    */
  get country(): Prisma.CountryDelegate<ExtArgs>;

  /**
   * `prisma.adminUnit`: Exposes CRUD operations for the **AdminUnit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminUnits
    * const adminUnits = await prisma.adminUnit.findMany()
    * ```
    */
  get adminUnit(): Prisma.AdminUnitDelegate<ExtArgs>;

  /**
   * `prisma.parish`: Exposes CRUD operations for the **Parish** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Parishes
    * const parishes = await prisma.parish.findMany()
    * ```
    */
  get parish(): Prisma.ParishDelegate<ExtArgs>;

  /**
   * `prisma.adminUnitRisk`: Exposes CRUD operations for the **AdminUnitRisk** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminUnitRisks
    * const adminUnitRisks = await prisma.adminUnitRisk.findMany()
    * ```
    */
  get adminUnitRisk(): Prisma.AdminUnitRiskDelegate<ExtArgs>;

  /**
   * `prisma.adminUnitRiskChangeLog`: Exposes CRUD operations for the **AdminUnitRiskChangeLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminUnitRiskChangeLogs
    * const adminUnitRiskChangeLogs = await prisma.adminUnitRiskChangeLog.findMany()
    * ```
    */
  get adminUnitRiskChangeLog(): Prisma.AdminUnitRiskChangeLogDelegate<ExtArgs>;

  /**
   * `prisma.parishRisk`: Exposes CRUD operations for the **ParishRisk** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ParishRisks
    * const parishRisks = await prisma.parishRisk.findMany()
    * ```
    */
  get parishRisk(): Prisma.ParishRiskDelegate<ExtArgs>;

  /**
   * `prisma.riskChangeLog`: Exposes CRUD operations for the **RiskChangeLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RiskChangeLogs
    * const riskChangeLogs = await prisma.riskChangeLog.findMany()
    * ```
    */
  get riskChangeLog(): Prisma.RiskChangeLogDelegate<ExtArgs>;

  /**
   * `prisma.businessType`: Exposes CRUD operations for the **BusinessType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BusinessTypes
    * const businessTypes = await prisma.businessType.findMany()
    * ```
    */
  get businessType(): Prisma.BusinessTypeDelegate<ExtArgs>;

  /**
   * `prisma.businessRiskVulnerability`: Exposes CRUD operations for the **BusinessRiskVulnerability** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BusinessRiskVulnerabilities
    * const businessRiskVulnerabilities = await prisma.businessRiskVulnerability.findMany()
    * ```
    */
  get businessRiskVulnerability(): Prisma.BusinessRiskVulnerabilityDelegate<ExtArgs>;

  /**
   * `prisma.riskMitigationStrategy`: Exposes CRUD operations for the **RiskMitigationStrategy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RiskMitigationStrategies
    * const riskMitigationStrategies = await prisma.riskMitigationStrategy.findMany()
    * ```
    */
  get riskMitigationStrategy(): Prisma.RiskMitigationStrategyDelegate<ExtArgs>;

  /**
   * `prisma.actionStep`: Exposes CRUD operations for the **ActionStep** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActionSteps
    * const actionSteps = await prisma.actionStep.findMany()
    * ```
    */
  get actionStep(): Prisma.ActionStepDelegate<ExtArgs>;

  /**
   * `prisma.businessTypeStrategy`: Exposes CRUD operations for the **BusinessTypeStrategy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BusinessTypeStrategies
    * const businessTypeStrategies = await prisma.businessTypeStrategy.findMany()
    * ```
    */
  get businessTypeStrategy(): Prisma.BusinessTypeStrategyDelegate<ExtArgs>;

  /**
   * `prisma.businessRiskProfile`: Exposes CRUD operations for the **BusinessRiskProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BusinessRiskProfiles
    * const businessRiskProfiles = await prisma.businessRiskProfile.findMany()
    * ```
    */
  get businessRiskProfile(): Prisma.BusinessRiskProfileDelegate<ExtArgs>;

  /**
   * `prisma.riskMultiplier`: Exposes CRUD operations for the **RiskMultiplier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RiskMultipliers
    * const riskMultipliers = await prisma.riskMultiplier.findMany()
    * ```
    */
  get riskMultiplier(): Prisma.RiskMultiplierDelegate<ExtArgs>;

  /**
   * `prisma.costItem`: Exposes CRUD operations for the **CostItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CostItems
    * const costItems = await prisma.costItem.findMany()
    * ```
    */
  get costItem(): Prisma.CostItemDelegate<ExtArgs>;

  /**
   * `prisma.countryCostMultiplier`: Exposes CRUD operations for the **CountryCostMultiplier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CountryCostMultipliers
    * const countryCostMultipliers = await prisma.countryCostMultiplier.findMany()
    * ```
    */
  get countryCostMultiplier(): Prisma.CountryCostMultiplierDelegate<ExtArgs>;

  /**
   * `prisma.strategyItemCost`: Exposes CRUD operations for the **StrategyItemCost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StrategyItemCosts
    * const strategyItemCosts = await prisma.strategyItemCost.findMany()
    * ```
    */
  get strategyItemCost(): Prisma.StrategyItemCostDelegate<ExtArgs>;

  /**
   * `prisma.actionStepItemCost`: Exposes CRUD operations for the **ActionStepItemCost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActionStepItemCosts
    * const actionStepItemCosts = await prisma.actionStepItemCost.findMany()
    * ```
    */
  get actionStepItemCost(): Prisma.ActionStepItemCostDelegate<ExtArgs>;

  /**
   * `prisma.businessTypeTranslation`: Exposes CRUD operations for the **BusinessTypeTranslation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BusinessTypeTranslations
    * const businessTypeTranslations = await prisma.businessTypeTranslation.findMany()
    * ```
    */
  get businessTypeTranslation(): Prisma.BusinessTypeTranslationDelegate<ExtArgs>;

  /**
   * `prisma.strategyTranslation`: Exposes CRUD operations for the **StrategyTranslation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StrategyTranslations
    * const strategyTranslations = await prisma.strategyTranslation.findMany()
    * ```
    */
  get strategyTranslation(): Prisma.StrategyTranslationDelegate<ExtArgs>;

  /**
   * `prisma.actionStepTranslation`: Exposes CRUD operations for the **ActionStepTranslation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActionStepTranslations
    * const actionStepTranslations = await prisma.actionStepTranslation.findMany()
    * ```
    */
  get actionStepTranslation(): Prisma.ActionStepTranslationDelegate<ExtArgs>;

  /**
   * `prisma.hazardTranslation`: Exposes CRUD operations for the **HazardTranslation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HazardTranslations
    * const hazardTranslations = await prisma.hazardTranslation.findMany()
    * ```
    */
  get hazardTranslation(): Prisma.HazardTranslationDelegate<ExtArgs>;

  /**
   * `prisma.riskMultiplierTranslation`: Exposes CRUD operations for the **RiskMultiplierTranslation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RiskMultiplierTranslations
    * const riskMultiplierTranslations = await prisma.riskMultiplierTranslation.findMany()
    * ```
    */
  get riskMultiplierTranslation(): Prisma.RiskMultiplierTranslationDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    BusinessContinuityPlan: 'BusinessContinuityPlan',
    PlanInformation: 'PlanInformation',
    BusinessOverview: 'BusinessOverview',
    EssentialFunction: 'EssentialFunction',
    RiskAssessment: 'RiskAssessment',
    Strategy: 'Strategy',
    ActionPlan: 'ActionPlan',
    Session: 'Session',
    BusinessProfile: 'BusinessProfile',
    ContactsInformation: 'ContactsInformation',
    TestingMaintenance: 'TestingMaintenance',
    AnonymousSession: 'AnonymousSession',
    AdminBusinessType: 'AdminBusinessType',
    AdminHazardType: 'AdminHazardType',
    AdminLocation: 'AdminLocation',
    AdminBusinessTypeHazard: 'AdminBusinessTypeHazard',
    AdminLocationHazard: 'AdminLocationHazard',
    AdminStrategy: 'AdminStrategy',
    AdminHazardStrategy: 'AdminHazardStrategy',
    AdminActionPlan: 'AdminActionPlan',
    AdminHazardActionPlan: 'AdminHazardActionPlan',
    AdminRiskProfile: 'AdminRiskProfile',
    Country: 'Country',
    AdminUnit: 'AdminUnit',
    Parish: 'Parish',
    AdminUnitRisk: 'AdminUnitRisk',
    AdminUnitRiskChangeLog: 'AdminUnitRiskChangeLog',
    ParishRisk: 'ParishRisk',
    RiskChangeLog: 'RiskChangeLog',
    BusinessType: 'BusinessType',
    BusinessRiskVulnerability: 'BusinessRiskVulnerability',
    RiskMitigationStrategy: 'RiskMitigationStrategy',
    ActionStep: 'ActionStep',
    BusinessTypeStrategy: 'BusinessTypeStrategy',
    BusinessRiskProfile: 'BusinessRiskProfile',
    RiskMultiplier: 'RiskMultiplier',
    CostItem: 'CostItem',
    CountryCostMultiplier: 'CountryCostMultiplier',
    StrategyItemCost: 'StrategyItemCost',
    ActionStepItemCost: 'ActionStepItemCost',
    BusinessTypeTranslation: 'BusinessTypeTranslation',
    StrategyTranslation: 'StrategyTranslation',
    ActionStepTranslation: 'ActionStepTranslation',
    HazardTranslation: 'HazardTranslation',
    RiskMultiplierTranslation: 'RiskMultiplierTranslation'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "businessContinuityPlan" | "planInformation" | "businessOverview" | "essentialFunction" | "riskAssessment" | "strategy" | "actionPlan" | "session" | "businessProfile" | "contactsInformation" | "testingMaintenance" | "anonymousSession" | "adminBusinessType" | "adminHazardType" | "adminLocation" | "adminBusinessTypeHazard" | "adminLocationHazard" | "adminStrategy" | "adminHazardStrategy" | "adminActionPlan" | "adminHazardActionPlan" | "adminRiskProfile" | "country" | "adminUnit" | "parish" | "adminUnitRisk" | "adminUnitRiskChangeLog" | "parishRisk" | "riskChangeLog" | "businessType" | "businessRiskVulnerability" | "riskMitigationStrategy" | "actionStep" | "businessTypeStrategy" | "businessRiskProfile" | "riskMultiplier" | "costItem" | "countryCostMultiplier" | "strategyItemCost" | "actionStepItemCost" | "businessTypeTranslation" | "strategyTranslation" | "actionStepTranslation" | "hazardTranslation" | "riskMultiplierTranslation"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      BusinessContinuityPlan: {
        payload: Prisma.$BusinessContinuityPlanPayload<ExtArgs>
        fields: Prisma.BusinessContinuityPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BusinessContinuityPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessContinuityPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BusinessContinuityPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessContinuityPlanPayload>
          }
          findFirst: {
            args: Prisma.BusinessContinuityPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessContinuityPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BusinessContinuityPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessContinuityPlanPayload>
          }
          findMany: {
            args: Prisma.BusinessContinuityPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessContinuityPlanPayload>[]
          }
          create: {
            args: Prisma.BusinessContinuityPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessContinuityPlanPayload>
          }
          createMany: {
            args: Prisma.BusinessContinuityPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BusinessContinuityPlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessContinuityPlanPayload>[]
          }
          delete: {
            args: Prisma.BusinessContinuityPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessContinuityPlanPayload>
          }
          update: {
            args: Prisma.BusinessContinuityPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessContinuityPlanPayload>
          }
          deleteMany: {
            args: Prisma.BusinessContinuityPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BusinessContinuityPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BusinessContinuityPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessContinuityPlanPayload>
          }
          aggregate: {
            args: Prisma.BusinessContinuityPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBusinessContinuityPlan>
          }
          groupBy: {
            args: Prisma.BusinessContinuityPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<BusinessContinuityPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.BusinessContinuityPlanCountArgs<ExtArgs>
            result: $Utils.Optional<BusinessContinuityPlanCountAggregateOutputType> | number
          }
        }
      }
      PlanInformation: {
        payload: Prisma.$PlanInformationPayload<ExtArgs>
        fields: Prisma.PlanInformationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlanInformationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanInformationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlanInformationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanInformationPayload>
          }
          findFirst: {
            args: Prisma.PlanInformationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanInformationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlanInformationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanInformationPayload>
          }
          findMany: {
            args: Prisma.PlanInformationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanInformationPayload>[]
          }
          create: {
            args: Prisma.PlanInformationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanInformationPayload>
          }
          createMany: {
            args: Prisma.PlanInformationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlanInformationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanInformationPayload>[]
          }
          delete: {
            args: Prisma.PlanInformationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanInformationPayload>
          }
          update: {
            args: Prisma.PlanInformationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanInformationPayload>
          }
          deleteMany: {
            args: Prisma.PlanInformationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlanInformationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlanInformationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanInformationPayload>
          }
          aggregate: {
            args: Prisma.PlanInformationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlanInformation>
          }
          groupBy: {
            args: Prisma.PlanInformationGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlanInformationGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlanInformationCountArgs<ExtArgs>
            result: $Utils.Optional<PlanInformationCountAggregateOutputType> | number
          }
        }
      }
      BusinessOverview: {
        payload: Prisma.$BusinessOverviewPayload<ExtArgs>
        fields: Prisma.BusinessOverviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BusinessOverviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessOverviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BusinessOverviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessOverviewPayload>
          }
          findFirst: {
            args: Prisma.BusinessOverviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessOverviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BusinessOverviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessOverviewPayload>
          }
          findMany: {
            args: Prisma.BusinessOverviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessOverviewPayload>[]
          }
          create: {
            args: Prisma.BusinessOverviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessOverviewPayload>
          }
          createMany: {
            args: Prisma.BusinessOverviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BusinessOverviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessOverviewPayload>[]
          }
          delete: {
            args: Prisma.BusinessOverviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessOverviewPayload>
          }
          update: {
            args: Prisma.BusinessOverviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessOverviewPayload>
          }
          deleteMany: {
            args: Prisma.BusinessOverviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BusinessOverviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BusinessOverviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessOverviewPayload>
          }
          aggregate: {
            args: Prisma.BusinessOverviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBusinessOverview>
          }
          groupBy: {
            args: Prisma.BusinessOverviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<BusinessOverviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.BusinessOverviewCountArgs<ExtArgs>
            result: $Utils.Optional<BusinessOverviewCountAggregateOutputType> | number
          }
        }
      }
      EssentialFunction: {
        payload: Prisma.$EssentialFunctionPayload<ExtArgs>
        fields: Prisma.EssentialFunctionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EssentialFunctionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EssentialFunctionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EssentialFunctionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EssentialFunctionPayload>
          }
          findFirst: {
            args: Prisma.EssentialFunctionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EssentialFunctionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EssentialFunctionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EssentialFunctionPayload>
          }
          findMany: {
            args: Prisma.EssentialFunctionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EssentialFunctionPayload>[]
          }
          create: {
            args: Prisma.EssentialFunctionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EssentialFunctionPayload>
          }
          createMany: {
            args: Prisma.EssentialFunctionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EssentialFunctionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EssentialFunctionPayload>[]
          }
          delete: {
            args: Prisma.EssentialFunctionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EssentialFunctionPayload>
          }
          update: {
            args: Prisma.EssentialFunctionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EssentialFunctionPayload>
          }
          deleteMany: {
            args: Prisma.EssentialFunctionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EssentialFunctionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EssentialFunctionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EssentialFunctionPayload>
          }
          aggregate: {
            args: Prisma.EssentialFunctionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEssentialFunction>
          }
          groupBy: {
            args: Prisma.EssentialFunctionGroupByArgs<ExtArgs>
            result: $Utils.Optional<EssentialFunctionGroupByOutputType>[]
          }
          count: {
            args: Prisma.EssentialFunctionCountArgs<ExtArgs>
            result: $Utils.Optional<EssentialFunctionCountAggregateOutputType> | number
          }
        }
      }
      RiskAssessment: {
        payload: Prisma.$RiskAssessmentPayload<ExtArgs>
        fields: Prisma.RiskAssessmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RiskAssessmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAssessmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RiskAssessmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAssessmentPayload>
          }
          findFirst: {
            args: Prisma.RiskAssessmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAssessmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RiskAssessmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAssessmentPayload>
          }
          findMany: {
            args: Prisma.RiskAssessmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAssessmentPayload>[]
          }
          create: {
            args: Prisma.RiskAssessmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAssessmentPayload>
          }
          createMany: {
            args: Prisma.RiskAssessmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RiskAssessmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAssessmentPayload>[]
          }
          delete: {
            args: Prisma.RiskAssessmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAssessmentPayload>
          }
          update: {
            args: Prisma.RiskAssessmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAssessmentPayload>
          }
          deleteMany: {
            args: Prisma.RiskAssessmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RiskAssessmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RiskAssessmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAssessmentPayload>
          }
          aggregate: {
            args: Prisma.RiskAssessmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRiskAssessment>
          }
          groupBy: {
            args: Prisma.RiskAssessmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<RiskAssessmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.RiskAssessmentCountArgs<ExtArgs>
            result: $Utils.Optional<RiskAssessmentCountAggregateOutputType> | number
          }
        }
      }
      Strategy: {
        payload: Prisma.$StrategyPayload<ExtArgs>
        fields: Prisma.StrategyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StrategyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrategyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StrategyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrategyPayload>
          }
          findFirst: {
            args: Prisma.StrategyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrategyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StrategyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrategyPayload>
          }
          findMany: {
            args: Prisma.StrategyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrategyPayload>[]
          }
          create: {
            args: Prisma.StrategyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrategyPayload>
          }
          createMany: {
            args: Prisma.StrategyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StrategyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrategyPayload>[]
          }
          delete: {
            args: Prisma.StrategyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrategyPayload>
          }
          update: {
            args: Prisma.StrategyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrategyPayload>
          }
          deleteMany: {
            args: Prisma.StrategyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StrategyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StrategyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrategyPayload>
          }
          aggregate: {
            args: Prisma.StrategyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStrategy>
          }
          groupBy: {
            args: Prisma.StrategyGroupByArgs<ExtArgs>
            result: $Utils.Optional<StrategyGroupByOutputType>[]
          }
          count: {
            args: Prisma.StrategyCountArgs<ExtArgs>
            result: $Utils.Optional<StrategyCountAggregateOutputType> | number
          }
        }
      }
      ActionPlan: {
        payload: Prisma.$ActionPlanPayload<ExtArgs>
        fields: Prisma.ActionPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActionPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActionPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPlanPayload>
          }
          findFirst: {
            args: Prisma.ActionPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActionPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPlanPayload>
          }
          findMany: {
            args: Prisma.ActionPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPlanPayload>[]
          }
          create: {
            args: Prisma.ActionPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPlanPayload>
          }
          createMany: {
            args: Prisma.ActionPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActionPlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPlanPayload>[]
          }
          delete: {
            args: Prisma.ActionPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPlanPayload>
          }
          update: {
            args: Prisma.ActionPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPlanPayload>
          }
          deleteMany: {
            args: Prisma.ActionPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActionPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ActionPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPlanPayload>
          }
          aggregate: {
            args: Prisma.ActionPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActionPlan>
          }
          groupBy: {
            args: Prisma.ActionPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActionPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActionPlanCountArgs<ExtArgs>
            result: $Utils.Optional<ActionPlanCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      BusinessProfile: {
        payload: Prisma.$BusinessProfilePayload<ExtArgs>
        fields: Prisma.BusinessProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BusinessProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BusinessProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessProfilePayload>
          }
          findFirst: {
            args: Prisma.BusinessProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BusinessProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessProfilePayload>
          }
          findMany: {
            args: Prisma.BusinessProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessProfilePayload>[]
          }
          create: {
            args: Prisma.BusinessProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessProfilePayload>
          }
          createMany: {
            args: Prisma.BusinessProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BusinessProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessProfilePayload>[]
          }
          delete: {
            args: Prisma.BusinessProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessProfilePayload>
          }
          update: {
            args: Prisma.BusinessProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessProfilePayload>
          }
          deleteMany: {
            args: Prisma.BusinessProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BusinessProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BusinessProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessProfilePayload>
          }
          aggregate: {
            args: Prisma.BusinessProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBusinessProfile>
          }
          groupBy: {
            args: Prisma.BusinessProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<BusinessProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.BusinessProfileCountArgs<ExtArgs>
            result: $Utils.Optional<BusinessProfileCountAggregateOutputType> | number
          }
        }
      }
      ContactsInformation: {
        payload: Prisma.$ContactsInformationPayload<ExtArgs>
        fields: Prisma.ContactsInformationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactsInformationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactsInformationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactsInformationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactsInformationPayload>
          }
          findFirst: {
            args: Prisma.ContactsInformationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactsInformationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactsInformationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactsInformationPayload>
          }
          findMany: {
            args: Prisma.ContactsInformationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactsInformationPayload>[]
          }
          create: {
            args: Prisma.ContactsInformationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactsInformationPayload>
          }
          createMany: {
            args: Prisma.ContactsInformationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactsInformationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactsInformationPayload>[]
          }
          delete: {
            args: Prisma.ContactsInformationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactsInformationPayload>
          }
          update: {
            args: Prisma.ContactsInformationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactsInformationPayload>
          }
          deleteMany: {
            args: Prisma.ContactsInformationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactsInformationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContactsInformationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactsInformationPayload>
          }
          aggregate: {
            args: Prisma.ContactsInformationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContactsInformation>
          }
          groupBy: {
            args: Prisma.ContactsInformationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactsInformationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactsInformationCountArgs<ExtArgs>
            result: $Utils.Optional<ContactsInformationCountAggregateOutputType> | number
          }
        }
      }
      TestingMaintenance: {
        payload: Prisma.$TestingMaintenancePayload<ExtArgs>
        fields: Prisma.TestingMaintenanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TestingMaintenanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestingMaintenancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TestingMaintenanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestingMaintenancePayload>
          }
          findFirst: {
            args: Prisma.TestingMaintenanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestingMaintenancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TestingMaintenanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestingMaintenancePayload>
          }
          findMany: {
            args: Prisma.TestingMaintenanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestingMaintenancePayload>[]
          }
          create: {
            args: Prisma.TestingMaintenanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestingMaintenancePayload>
          }
          createMany: {
            args: Prisma.TestingMaintenanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TestingMaintenanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestingMaintenancePayload>[]
          }
          delete: {
            args: Prisma.TestingMaintenanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestingMaintenancePayload>
          }
          update: {
            args: Prisma.TestingMaintenanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestingMaintenancePayload>
          }
          deleteMany: {
            args: Prisma.TestingMaintenanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TestingMaintenanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TestingMaintenanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestingMaintenancePayload>
          }
          aggregate: {
            args: Prisma.TestingMaintenanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTestingMaintenance>
          }
          groupBy: {
            args: Prisma.TestingMaintenanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<TestingMaintenanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.TestingMaintenanceCountArgs<ExtArgs>
            result: $Utils.Optional<TestingMaintenanceCountAggregateOutputType> | number
          }
        }
      }
      AnonymousSession: {
        payload: Prisma.$AnonymousSessionPayload<ExtArgs>
        fields: Prisma.AnonymousSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnonymousSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnonymousSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnonymousSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnonymousSessionPayload>
          }
          findFirst: {
            args: Prisma.AnonymousSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnonymousSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnonymousSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnonymousSessionPayload>
          }
          findMany: {
            args: Prisma.AnonymousSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnonymousSessionPayload>[]
          }
          create: {
            args: Prisma.AnonymousSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnonymousSessionPayload>
          }
          createMany: {
            args: Prisma.AnonymousSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnonymousSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnonymousSessionPayload>[]
          }
          delete: {
            args: Prisma.AnonymousSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnonymousSessionPayload>
          }
          update: {
            args: Prisma.AnonymousSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnonymousSessionPayload>
          }
          deleteMany: {
            args: Prisma.AnonymousSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnonymousSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AnonymousSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnonymousSessionPayload>
          }
          aggregate: {
            args: Prisma.AnonymousSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnonymousSession>
          }
          groupBy: {
            args: Prisma.AnonymousSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnonymousSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnonymousSessionCountArgs<ExtArgs>
            result: $Utils.Optional<AnonymousSessionCountAggregateOutputType> | number
          }
        }
      }
      AdminBusinessType: {
        payload: Prisma.$AdminBusinessTypePayload<ExtArgs>
        fields: Prisma.AdminBusinessTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminBusinessTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminBusinessTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminBusinessTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminBusinessTypePayload>
          }
          findFirst: {
            args: Prisma.AdminBusinessTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminBusinessTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminBusinessTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminBusinessTypePayload>
          }
          findMany: {
            args: Prisma.AdminBusinessTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminBusinessTypePayload>[]
          }
          create: {
            args: Prisma.AdminBusinessTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminBusinessTypePayload>
          }
          createMany: {
            args: Prisma.AdminBusinessTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminBusinessTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminBusinessTypePayload>[]
          }
          delete: {
            args: Prisma.AdminBusinessTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminBusinessTypePayload>
          }
          update: {
            args: Prisma.AdminBusinessTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminBusinessTypePayload>
          }
          deleteMany: {
            args: Prisma.AdminBusinessTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminBusinessTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdminBusinessTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminBusinessTypePayload>
          }
          aggregate: {
            args: Prisma.AdminBusinessTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminBusinessType>
          }
          groupBy: {
            args: Prisma.AdminBusinessTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminBusinessTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminBusinessTypeCountArgs<ExtArgs>
            result: $Utils.Optional<AdminBusinessTypeCountAggregateOutputType> | number
          }
        }
      }
      AdminHazardType: {
        payload: Prisma.$AdminHazardTypePayload<ExtArgs>
        fields: Prisma.AdminHazardTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminHazardTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminHazardTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminHazardTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminHazardTypePayload>
          }
          findFirst: {
            args: Prisma.AdminHazardTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminHazardTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminHazardTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminHazardTypePayload>
          }
          findMany: {
            args: Prisma.AdminHazardTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminHazardTypePayload>[]
          }
          create: {
            args: Prisma.AdminHazardTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminHazardTypePayload>
          }
          createMany: {
            args: Prisma.AdminHazardTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminHazardTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminHazardTypePayload>[]
          }
          delete: {
            args: Prisma.AdminHazardTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminHazardTypePayload>
          }
          update: {
            args: Prisma.AdminHazardTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminHazardTypePayload>
          }
          deleteMany: {
            args: Prisma.AdminHazardTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminHazardTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdminHazardTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminHazardTypePayload>
          }
          aggregate: {
            args: Prisma.AdminHazardTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminHazardType>
          }
          groupBy: {
            args: Prisma.AdminHazardTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminHazardTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminHazardTypeCountArgs<ExtArgs>
            result: $Utils.Optional<AdminHazardTypeCountAggregateOutputType> | number
          }
        }
      }
      AdminLocation: {
        payload: Prisma.$AdminLocationPayload<ExtArgs>
        fields: Prisma.AdminLocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminLocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminLocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminLocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminLocationPayload>
          }
          findFirst: {
            args: Prisma.AdminLocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminLocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminLocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminLocationPayload>
          }
          findMany: {
            args: Prisma.AdminLocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminLocationPayload>[]
          }
          create: {
            args: Prisma.AdminLocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminLocationPayload>
          }
          createMany: {
            args: Prisma.AdminLocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminLocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminLocationPayload>[]
          }
          delete: {
            args: Prisma.AdminLocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminLocationPayload>
          }
          update: {
            args: Prisma.AdminLocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminLocationPayload>
          }
          deleteMany: {
            args: Prisma.AdminLocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminLocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdminLocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminLocationPayload>
          }
          aggregate: {
            args: Prisma.AdminLocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminLocation>
          }
          groupBy: {
            args: Prisma.AdminLocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminLocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminLocationCountArgs<ExtArgs>
            result: $Utils.Optional<AdminLocationCountAggregateOutputType> | number
          }
        }
      }
      AdminBusinessTypeHazard: {
        payload: Prisma.$AdminBusinessTypeHazardPayload<ExtArgs>
        fields: Prisma.AdminBusinessTypeHazardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminBusinessTypeHazardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminBusinessTypeHazardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminBusinessTypeHazardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminBusinessTypeHazardPayload>
          }
          findFirst: {
            args: Prisma.AdminBusinessTypeHazardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminBusinessTypeHazardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminBusinessTypeHazardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminBusinessTypeHazardPayload>
          }
          findMany: {
            args: Prisma.AdminBusinessTypeHazardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminBusinessTypeHazardPayload>[]
          }
          create: {
            args: Prisma.AdminBusinessTypeHazardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminBusinessTypeHazardPayload>
          }
          createMany: {
            args: Prisma.AdminBusinessTypeHazardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminBusinessTypeHazardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminBusinessTypeHazardPayload>[]
          }
          delete: {
            args: Prisma.AdminBusinessTypeHazardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminBusinessTypeHazardPayload>
          }
          update: {
            args: Prisma.AdminBusinessTypeHazardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminBusinessTypeHazardPayload>
          }
          deleteMany: {
            args: Prisma.AdminBusinessTypeHazardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminBusinessTypeHazardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdminBusinessTypeHazardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminBusinessTypeHazardPayload>
          }
          aggregate: {
            args: Prisma.AdminBusinessTypeHazardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminBusinessTypeHazard>
          }
          groupBy: {
            args: Prisma.AdminBusinessTypeHazardGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminBusinessTypeHazardGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminBusinessTypeHazardCountArgs<ExtArgs>
            result: $Utils.Optional<AdminBusinessTypeHazardCountAggregateOutputType> | number
          }
        }
      }
      AdminLocationHazard: {
        payload: Prisma.$AdminLocationHazardPayload<ExtArgs>
        fields: Prisma.AdminLocationHazardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminLocationHazardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminLocationHazardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminLocationHazardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminLocationHazardPayload>
          }
          findFirst: {
            args: Prisma.AdminLocationHazardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminLocationHazardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminLocationHazardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminLocationHazardPayload>
          }
          findMany: {
            args: Prisma.AdminLocationHazardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminLocationHazardPayload>[]
          }
          create: {
            args: Prisma.AdminLocationHazardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminLocationHazardPayload>
          }
          createMany: {
            args: Prisma.AdminLocationHazardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminLocationHazardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminLocationHazardPayload>[]
          }
          delete: {
            args: Prisma.AdminLocationHazardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminLocationHazardPayload>
          }
          update: {
            args: Prisma.AdminLocationHazardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminLocationHazardPayload>
          }
          deleteMany: {
            args: Prisma.AdminLocationHazardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminLocationHazardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdminLocationHazardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminLocationHazardPayload>
          }
          aggregate: {
            args: Prisma.AdminLocationHazardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminLocationHazard>
          }
          groupBy: {
            args: Prisma.AdminLocationHazardGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminLocationHazardGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminLocationHazardCountArgs<ExtArgs>
            result: $Utils.Optional<AdminLocationHazardCountAggregateOutputType> | number
          }
        }
      }
      AdminStrategy: {
        payload: Prisma.$AdminStrategyPayload<ExtArgs>
        fields: Prisma.AdminStrategyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminStrategyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminStrategyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminStrategyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminStrategyPayload>
          }
          findFirst: {
            args: Prisma.AdminStrategyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminStrategyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminStrategyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminStrategyPayload>
          }
          findMany: {
            args: Prisma.AdminStrategyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminStrategyPayload>[]
          }
          create: {
            args: Prisma.AdminStrategyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminStrategyPayload>
          }
          createMany: {
            args: Prisma.AdminStrategyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminStrategyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminStrategyPayload>[]
          }
          delete: {
            args: Prisma.AdminStrategyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminStrategyPayload>
          }
          update: {
            args: Prisma.AdminStrategyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminStrategyPayload>
          }
          deleteMany: {
            args: Prisma.AdminStrategyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminStrategyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdminStrategyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminStrategyPayload>
          }
          aggregate: {
            args: Prisma.AdminStrategyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminStrategy>
          }
          groupBy: {
            args: Prisma.AdminStrategyGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminStrategyGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminStrategyCountArgs<ExtArgs>
            result: $Utils.Optional<AdminStrategyCountAggregateOutputType> | number
          }
        }
      }
      AdminHazardStrategy: {
        payload: Prisma.$AdminHazardStrategyPayload<ExtArgs>
        fields: Prisma.AdminHazardStrategyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminHazardStrategyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminHazardStrategyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminHazardStrategyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminHazardStrategyPayload>
          }
          findFirst: {
            args: Prisma.AdminHazardStrategyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminHazardStrategyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminHazardStrategyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminHazardStrategyPayload>
          }
          findMany: {
            args: Prisma.AdminHazardStrategyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminHazardStrategyPayload>[]
          }
          create: {
            args: Prisma.AdminHazardStrategyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminHazardStrategyPayload>
          }
          createMany: {
            args: Prisma.AdminHazardStrategyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminHazardStrategyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminHazardStrategyPayload>[]
          }
          delete: {
            args: Prisma.AdminHazardStrategyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminHazardStrategyPayload>
          }
          update: {
            args: Prisma.AdminHazardStrategyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminHazardStrategyPayload>
          }
          deleteMany: {
            args: Prisma.AdminHazardStrategyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminHazardStrategyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdminHazardStrategyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminHazardStrategyPayload>
          }
          aggregate: {
            args: Prisma.AdminHazardStrategyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminHazardStrategy>
          }
          groupBy: {
            args: Prisma.AdminHazardStrategyGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminHazardStrategyGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminHazardStrategyCountArgs<ExtArgs>
            result: $Utils.Optional<AdminHazardStrategyCountAggregateOutputType> | number
          }
        }
      }
      AdminActionPlan: {
        payload: Prisma.$AdminActionPlanPayload<ExtArgs>
        fields: Prisma.AdminActionPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminActionPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminActionPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminActionPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminActionPlanPayload>
          }
          findFirst: {
            args: Prisma.AdminActionPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminActionPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminActionPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminActionPlanPayload>
          }
          findMany: {
            args: Prisma.AdminActionPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminActionPlanPayload>[]
          }
          create: {
            args: Prisma.AdminActionPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminActionPlanPayload>
          }
          createMany: {
            args: Prisma.AdminActionPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminActionPlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminActionPlanPayload>[]
          }
          delete: {
            args: Prisma.AdminActionPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminActionPlanPayload>
          }
          update: {
            args: Prisma.AdminActionPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminActionPlanPayload>
          }
          deleteMany: {
            args: Prisma.AdminActionPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminActionPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdminActionPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminActionPlanPayload>
          }
          aggregate: {
            args: Prisma.AdminActionPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminActionPlan>
          }
          groupBy: {
            args: Prisma.AdminActionPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminActionPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminActionPlanCountArgs<ExtArgs>
            result: $Utils.Optional<AdminActionPlanCountAggregateOutputType> | number
          }
        }
      }
      AdminHazardActionPlan: {
        payload: Prisma.$AdminHazardActionPlanPayload<ExtArgs>
        fields: Prisma.AdminHazardActionPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminHazardActionPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminHazardActionPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminHazardActionPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminHazardActionPlanPayload>
          }
          findFirst: {
            args: Prisma.AdminHazardActionPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminHazardActionPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminHazardActionPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminHazardActionPlanPayload>
          }
          findMany: {
            args: Prisma.AdminHazardActionPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminHazardActionPlanPayload>[]
          }
          create: {
            args: Prisma.AdminHazardActionPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminHazardActionPlanPayload>
          }
          createMany: {
            args: Prisma.AdminHazardActionPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminHazardActionPlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminHazardActionPlanPayload>[]
          }
          delete: {
            args: Prisma.AdminHazardActionPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminHazardActionPlanPayload>
          }
          update: {
            args: Prisma.AdminHazardActionPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminHazardActionPlanPayload>
          }
          deleteMany: {
            args: Prisma.AdminHazardActionPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminHazardActionPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdminHazardActionPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminHazardActionPlanPayload>
          }
          aggregate: {
            args: Prisma.AdminHazardActionPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminHazardActionPlan>
          }
          groupBy: {
            args: Prisma.AdminHazardActionPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminHazardActionPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminHazardActionPlanCountArgs<ExtArgs>
            result: $Utils.Optional<AdminHazardActionPlanCountAggregateOutputType> | number
          }
        }
      }
      AdminRiskProfile: {
        payload: Prisma.$AdminRiskProfilePayload<ExtArgs>
        fields: Prisma.AdminRiskProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminRiskProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminRiskProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminRiskProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminRiskProfilePayload>
          }
          findFirst: {
            args: Prisma.AdminRiskProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminRiskProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminRiskProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminRiskProfilePayload>
          }
          findMany: {
            args: Prisma.AdminRiskProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminRiskProfilePayload>[]
          }
          create: {
            args: Prisma.AdminRiskProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminRiskProfilePayload>
          }
          createMany: {
            args: Prisma.AdminRiskProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminRiskProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminRiskProfilePayload>[]
          }
          delete: {
            args: Prisma.AdminRiskProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminRiskProfilePayload>
          }
          update: {
            args: Prisma.AdminRiskProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminRiskProfilePayload>
          }
          deleteMany: {
            args: Prisma.AdminRiskProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminRiskProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdminRiskProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminRiskProfilePayload>
          }
          aggregate: {
            args: Prisma.AdminRiskProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminRiskProfile>
          }
          groupBy: {
            args: Prisma.AdminRiskProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminRiskProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminRiskProfileCountArgs<ExtArgs>
            result: $Utils.Optional<AdminRiskProfileCountAggregateOutputType> | number
          }
        }
      }
      Country: {
        payload: Prisma.$CountryPayload<ExtArgs>
        fields: Prisma.CountryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CountryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CountryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          findFirst: {
            args: Prisma.CountryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CountryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          findMany: {
            args: Prisma.CountryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>[]
          }
          create: {
            args: Prisma.CountryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          createMany: {
            args: Prisma.CountryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CountryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>[]
          }
          delete: {
            args: Prisma.CountryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          update: {
            args: Prisma.CountryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          deleteMany: {
            args: Prisma.CountryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CountryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CountryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          aggregate: {
            args: Prisma.CountryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCountry>
          }
          groupBy: {
            args: Prisma.CountryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CountryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CountryCountArgs<ExtArgs>
            result: $Utils.Optional<CountryCountAggregateOutputType> | number
          }
        }
      }
      AdminUnit: {
        payload: Prisma.$AdminUnitPayload<ExtArgs>
        fields: Prisma.AdminUnitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminUnitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUnitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminUnitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUnitPayload>
          }
          findFirst: {
            args: Prisma.AdminUnitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUnitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminUnitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUnitPayload>
          }
          findMany: {
            args: Prisma.AdminUnitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUnitPayload>[]
          }
          create: {
            args: Prisma.AdminUnitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUnitPayload>
          }
          createMany: {
            args: Prisma.AdminUnitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminUnitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUnitPayload>[]
          }
          delete: {
            args: Prisma.AdminUnitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUnitPayload>
          }
          update: {
            args: Prisma.AdminUnitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUnitPayload>
          }
          deleteMany: {
            args: Prisma.AdminUnitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUnitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdminUnitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUnitPayload>
          }
          aggregate: {
            args: Prisma.AdminUnitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminUnit>
          }
          groupBy: {
            args: Prisma.AdminUnitGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminUnitGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminUnitCountArgs<ExtArgs>
            result: $Utils.Optional<AdminUnitCountAggregateOutputType> | number
          }
        }
      }
      Parish: {
        payload: Prisma.$ParishPayload<ExtArgs>
        fields: Prisma.ParishFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ParishFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParishPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ParishFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParishPayload>
          }
          findFirst: {
            args: Prisma.ParishFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParishPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ParishFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParishPayload>
          }
          findMany: {
            args: Prisma.ParishFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParishPayload>[]
          }
          create: {
            args: Prisma.ParishCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParishPayload>
          }
          createMany: {
            args: Prisma.ParishCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ParishCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParishPayload>[]
          }
          delete: {
            args: Prisma.ParishDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParishPayload>
          }
          update: {
            args: Prisma.ParishUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParishPayload>
          }
          deleteMany: {
            args: Prisma.ParishDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ParishUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ParishUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParishPayload>
          }
          aggregate: {
            args: Prisma.ParishAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParish>
          }
          groupBy: {
            args: Prisma.ParishGroupByArgs<ExtArgs>
            result: $Utils.Optional<ParishGroupByOutputType>[]
          }
          count: {
            args: Prisma.ParishCountArgs<ExtArgs>
            result: $Utils.Optional<ParishCountAggregateOutputType> | number
          }
        }
      }
      AdminUnitRisk: {
        payload: Prisma.$AdminUnitRiskPayload<ExtArgs>
        fields: Prisma.AdminUnitRiskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminUnitRiskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUnitRiskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminUnitRiskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUnitRiskPayload>
          }
          findFirst: {
            args: Prisma.AdminUnitRiskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUnitRiskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminUnitRiskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUnitRiskPayload>
          }
          findMany: {
            args: Prisma.AdminUnitRiskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUnitRiskPayload>[]
          }
          create: {
            args: Prisma.AdminUnitRiskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUnitRiskPayload>
          }
          createMany: {
            args: Prisma.AdminUnitRiskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminUnitRiskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUnitRiskPayload>[]
          }
          delete: {
            args: Prisma.AdminUnitRiskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUnitRiskPayload>
          }
          update: {
            args: Prisma.AdminUnitRiskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUnitRiskPayload>
          }
          deleteMany: {
            args: Prisma.AdminUnitRiskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUnitRiskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdminUnitRiskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUnitRiskPayload>
          }
          aggregate: {
            args: Prisma.AdminUnitRiskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminUnitRisk>
          }
          groupBy: {
            args: Prisma.AdminUnitRiskGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminUnitRiskGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminUnitRiskCountArgs<ExtArgs>
            result: $Utils.Optional<AdminUnitRiskCountAggregateOutputType> | number
          }
        }
      }
      AdminUnitRiskChangeLog: {
        payload: Prisma.$AdminUnitRiskChangeLogPayload<ExtArgs>
        fields: Prisma.AdminUnitRiskChangeLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminUnitRiskChangeLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUnitRiskChangeLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminUnitRiskChangeLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUnitRiskChangeLogPayload>
          }
          findFirst: {
            args: Prisma.AdminUnitRiskChangeLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUnitRiskChangeLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminUnitRiskChangeLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUnitRiskChangeLogPayload>
          }
          findMany: {
            args: Prisma.AdminUnitRiskChangeLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUnitRiskChangeLogPayload>[]
          }
          create: {
            args: Prisma.AdminUnitRiskChangeLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUnitRiskChangeLogPayload>
          }
          createMany: {
            args: Prisma.AdminUnitRiskChangeLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminUnitRiskChangeLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUnitRiskChangeLogPayload>[]
          }
          delete: {
            args: Prisma.AdminUnitRiskChangeLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUnitRiskChangeLogPayload>
          }
          update: {
            args: Prisma.AdminUnitRiskChangeLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUnitRiskChangeLogPayload>
          }
          deleteMany: {
            args: Prisma.AdminUnitRiskChangeLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUnitRiskChangeLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdminUnitRiskChangeLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUnitRiskChangeLogPayload>
          }
          aggregate: {
            args: Prisma.AdminUnitRiskChangeLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminUnitRiskChangeLog>
          }
          groupBy: {
            args: Prisma.AdminUnitRiskChangeLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminUnitRiskChangeLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminUnitRiskChangeLogCountArgs<ExtArgs>
            result: $Utils.Optional<AdminUnitRiskChangeLogCountAggregateOutputType> | number
          }
        }
      }
      ParishRisk: {
        payload: Prisma.$ParishRiskPayload<ExtArgs>
        fields: Prisma.ParishRiskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ParishRiskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParishRiskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ParishRiskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParishRiskPayload>
          }
          findFirst: {
            args: Prisma.ParishRiskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParishRiskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ParishRiskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParishRiskPayload>
          }
          findMany: {
            args: Prisma.ParishRiskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParishRiskPayload>[]
          }
          create: {
            args: Prisma.ParishRiskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParishRiskPayload>
          }
          createMany: {
            args: Prisma.ParishRiskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ParishRiskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParishRiskPayload>[]
          }
          delete: {
            args: Prisma.ParishRiskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParishRiskPayload>
          }
          update: {
            args: Prisma.ParishRiskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParishRiskPayload>
          }
          deleteMany: {
            args: Prisma.ParishRiskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ParishRiskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ParishRiskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParishRiskPayload>
          }
          aggregate: {
            args: Prisma.ParishRiskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParishRisk>
          }
          groupBy: {
            args: Prisma.ParishRiskGroupByArgs<ExtArgs>
            result: $Utils.Optional<ParishRiskGroupByOutputType>[]
          }
          count: {
            args: Prisma.ParishRiskCountArgs<ExtArgs>
            result: $Utils.Optional<ParishRiskCountAggregateOutputType> | number
          }
        }
      }
      RiskChangeLog: {
        payload: Prisma.$RiskChangeLogPayload<ExtArgs>
        fields: Prisma.RiskChangeLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RiskChangeLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskChangeLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RiskChangeLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskChangeLogPayload>
          }
          findFirst: {
            args: Prisma.RiskChangeLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskChangeLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RiskChangeLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskChangeLogPayload>
          }
          findMany: {
            args: Prisma.RiskChangeLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskChangeLogPayload>[]
          }
          create: {
            args: Prisma.RiskChangeLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskChangeLogPayload>
          }
          createMany: {
            args: Prisma.RiskChangeLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RiskChangeLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskChangeLogPayload>[]
          }
          delete: {
            args: Prisma.RiskChangeLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskChangeLogPayload>
          }
          update: {
            args: Prisma.RiskChangeLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskChangeLogPayload>
          }
          deleteMany: {
            args: Prisma.RiskChangeLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RiskChangeLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RiskChangeLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskChangeLogPayload>
          }
          aggregate: {
            args: Prisma.RiskChangeLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRiskChangeLog>
          }
          groupBy: {
            args: Prisma.RiskChangeLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<RiskChangeLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.RiskChangeLogCountArgs<ExtArgs>
            result: $Utils.Optional<RiskChangeLogCountAggregateOutputType> | number
          }
        }
      }
      BusinessType: {
        payload: Prisma.$BusinessTypePayload<ExtArgs>
        fields: Prisma.BusinessTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BusinessTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BusinessTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessTypePayload>
          }
          findFirst: {
            args: Prisma.BusinessTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BusinessTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessTypePayload>
          }
          findMany: {
            args: Prisma.BusinessTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessTypePayload>[]
          }
          create: {
            args: Prisma.BusinessTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessTypePayload>
          }
          createMany: {
            args: Prisma.BusinessTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BusinessTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessTypePayload>[]
          }
          delete: {
            args: Prisma.BusinessTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessTypePayload>
          }
          update: {
            args: Prisma.BusinessTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessTypePayload>
          }
          deleteMany: {
            args: Prisma.BusinessTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BusinessTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BusinessTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessTypePayload>
          }
          aggregate: {
            args: Prisma.BusinessTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBusinessType>
          }
          groupBy: {
            args: Prisma.BusinessTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<BusinessTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.BusinessTypeCountArgs<ExtArgs>
            result: $Utils.Optional<BusinessTypeCountAggregateOutputType> | number
          }
        }
      }
      BusinessRiskVulnerability: {
        payload: Prisma.$BusinessRiskVulnerabilityPayload<ExtArgs>
        fields: Prisma.BusinessRiskVulnerabilityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BusinessRiskVulnerabilityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessRiskVulnerabilityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BusinessRiskVulnerabilityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessRiskVulnerabilityPayload>
          }
          findFirst: {
            args: Prisma.BusinessRiskVulnerabilityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessRiskVulnerabilityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BusinessRiskVulnerabilityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessRiskVulnerabilityPayload>
          }
          findMany: {
            args: Prisma.BusinessRiskVulnerabilityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessRiskVulnerabilityPayload>[]
          }
          create: {
            args: Prisma.BusinessRiskVulnerabilityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessRiskVulnerabilityPayload>
          }
          createMany: {
            args: Prisma.BusinessRiskVulnerabilityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BusinessRiskVulnerabilityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessRiskVulnerabilityPayload>[]
          }
          delete: {
            args: Prisma.BusinessRiskVulnerabilityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessRiskVulnerabilityPayload>
          }
          update: {
            args: Prisma.BusinessRiskVulnerabilityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessRiskVulnerabilityPayload>
          }
          deleteMany: {
            args: Prisma.BusinessRiskVulnerabilityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BusinessRiskVulnerabilityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BusinessRiskVulnerabilityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessRiskVulnerabilityPayload>
          }
          aggregate: {
            args: Prisma.BusinessRiskVulnerabilityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBusinessRiskVulnerability>
          }
          groupBy: {
            args: Prisma.BusinessRiskVulnerabilityGroupByArgs<ExtArgs>
            result: $Utils.Optional<BusinessRiskVulnerabilityGroupByOutputType>[]
          }
          count: {
            args: Prisma.BusinessRiskVulnerabilityCountArgs<ExtArgs>
            result: $Utils.Optional<BusinessRiskVulnerabilityCountAggregateOutputType> | number
          }
        }
      }
      RiskMitigationStrategy: {
        payload: Prisma.$RiskMitigationStrategyPayload<ExtArgs>
        fields: Prisma.RiskMitigationStrategyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RiskMitigationStrategyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskMitigationStrategyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RiskMitigationStrategyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskMitigationStrategyPayload>
          }
          findFirst: {
            args: Prisma.RiskMitigationStrategyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskMitigationStrategyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RiskMitigationStrategyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskMitigationStrategyPayload>
          }
          findMany: {
            args: Prisma.RiskMitigationStrategyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskMitigationStrategyPayload>[]
          }
          create: {
            args: Prisma.RiskMitigationStrategyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskMitigationStrategyPayload>
          }
          createMany: {
            args: Prisma.RiskMitigationStrategyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RiskMitigationStrategyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskMitigationStrategyPayload>[]
          }
          delete: {
            args: Prisma.RiskMitigationStrategyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskMitigationStrategyPayload>
          }
          update: {
            args: Prisma.RiskMitigationStrategyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskMitigationStrategyPayload>
          }
          deleteMany: {
            args: Prisma.RiskMitigationStrategyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RiskMitigationStrategyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RiskMitigationStrategyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskMitigationStrategyPayload>
          }
          aggregate: {
            args: Prisma.RiskMitigationStrategyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRiskMitigationStrategy>
          }
          groupBy: {
            args: Prisma.RiskMitigationStrategyGroupByArgs<ExtArgs>
            result: $Utils.Optional<RiskMitigationStrategyGroupByOutputType>[]
          }
          count: {
            args: Prisma.RiskMitigationStrategyCountArgs<ExtArgs>
            result: $Utils.Optional<RiskMitigationStrategyCountAggregateOutputType> | number
          }
        }
      }
      ActionStep: {
        payload: Prisma.$ActionStepPayload<ExtArgs>
        fields: Prisma.ActionStepFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActionStepFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionStepPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActionStepFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionStepPayload>
          }
          findFirst: {
            args: Prisma.ActionStepFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionStepPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActionStepFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionStepPayload>
          }
          findMany: {
            args: Prisma.ActionStepFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionStepPayload>[]
          }
          create: {
            args: Prisma.ActionStepCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionStepPayload>
          }
          createMany: {
            args: Prisma.ActionStepCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActionStepCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionStepPayload>[]
          }
          delete: {
            args: Prisma.ActionStepDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionStepPayload>
          }
          update: {
            args: Prisma.ActionStepUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionStepPayload>
          }
          deleteMany: {
            args: Prisma.ActionStepDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActionStepUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ActionStepUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionStepPayload>
          }
          aggregate: {
            args: Prisma.ActionStepAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActionStep>
          }
          groupBy: {
            args: Prisma.ActionStepGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActionStepGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActionStepCountArgs<ExtArgs>
            result: $Utils.Optional<ActionStepCountAggregateOutputType> | number
          }
        }
      }
      BusinessTypeStrategy: {
        payload: Prisma.$BusinessTypeStrategyPayload<ExtArgs>
        fields: Prisma.BusinessTypeStrategyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BusinessTypeStrategyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessTypeStrategyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BusinessTypeStrategyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessTypeStrategyPayload>
          }
          findFirst: {
            args: Prisma.BusinessTypeStrategyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessTypeStrategyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BusinessTypeStrategyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessTypeStrategyPayload>
          }
          findMany: {
            args: Prisma.BusinessTypeStrategyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessTypeStrategyPayload>[]
          }
          create: {
            args: Prisma.BusinessTypeStrategyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessTypeStrategyPayload>
          }
          createMany: {
            args: Prisma.BusinessTypeStrategyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BusinessTypeStrategyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessTypeStrategyPayload>[]
          }
          delete: {
            args: Prisma.BusinessTypeStrategyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessTypeStrategyPayload>
          }
          update: {
            args: Prisma.BusinessTypeStrategyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessTypeStrategyPayload>
          }
          deleteMany: {
            args: Prisma.BusinessTypeStrategyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BusinessTypeStrategyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BusinessTypeStrategyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessTypeStrategyPayload>
          }
          aggregate: {
            args: Prisma.BusinessTypeStrategyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBusinessTypeStrategy>
          }
          groupBy: {
            args: Prisma.BusinessTypeStrategyGroupByArgs<ExtArgs>
            result: $Utils.Optional<BusinessTypeStrategyGroupByOutputType>[]
          }
          count: {
            args: Prisma.BusinessTypeStrategyCountArgs<ExtArgs>
            result: $Utils.Optional<BusinessTypeStrategyCountAggregateOutputType> | number
          }
        }
      }
      BusinessRiskProfile: {
        payload: Prisma.$BusinessRiskProfilePayload<ExtArgs>
        fields: Prisma.BusinessRiskProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BusinessRiskProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessRiskProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BusinessRiskProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessRiskProfilePayload>
          }
          findFirst: {
            args: Prisma.BusinessRiskProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessRiskProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BusinessRiskProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessRiskProfilePayload>
          }
          findMany: {
            args: Prisma.BusinessRiskProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessRiskProfilePayload>[]
          }
          create: {
            args: Prisma.BusinessRiskProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessRiskProfilePayload>
          }
          createMany: {
            args: Prisma.BusinessRiskProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BusinessRiskProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessRiskProfilePayload>[]
          }
          delete: {
            args: Prisma.BusinessRiskProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessRiskProfilePayload>
          }
          update: {
            args: Prisma.BusinessRiskProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessRiskProfilePayload>
          }
          deleteMany: {
            args: Prisma.BusinessRiskProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BusinessRiskProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BusinessRiskProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessRiskProfilePayload>
          }
          aggregate: {
            args: Prisma.BusinessRiskProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBusinessRiskProfile>
          }
          groupBy: {
            args: Prisma.BusinessRiskProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<BusinessRiskProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.BusinessRiskProfileCountArgs<ExtArgs>
            result: $Utils.Optional<BusinessRiskProfileCountAggregateOutputType> | number
          }
        }
      }
      RiskMultiplier: {
        payload: Prisma.$RiskMultiplierPayload<ExtArgs>
        fields: Prisma.RiskMultiplierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RiskMultiplierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskMultiplierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RiskMultiplierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskMultiplierPayload>
          }
          findFirst: {
            args: Prisma.RiskMultiplierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskMultiplierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RiskMultiplierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskMultiplierPayload>
          }
          findMany: {
            args: Prisma.RiskMultiplierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskMultiplierPayload>[]
          }
          create: {
            args: Prisma.RiskMultiplierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskMultiplierPayload>
          }
          createMany: {
            args: Prisma.RiskMultiplierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RiskMultiplierCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskMultiplierPayload>[]
          }
          delete: {
            args: Prisma.RiskMultiplierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskMultiplierPayload>
          }
          update: {
            args: Prisma.RiskMultiplierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskMultiplierPayload>
          }
          deleteMany: {
            args: Prisma.RiskMultiplierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RiskMultiplierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RiskMultiplierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskMultiplierPayload>
          }
          aggregate: {
            args: Prisma.RiskMultiplierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRiskMultiplier>
          }
          groupBy: {
            args: Prisma.RiskMultiplierGroupByArgs<ExtArgs>
            result: $Utils.Optional<RiskMultiplierGroupByOutputType>[]
          }
          count: {
            args: Prisma.RiskMultiplierCountArgs<ExtArgs>
            result: $Utils.Optional<RiskMultiplierCountAggregateOutputType> | number
          }
        }
      }
      CostItem: {
        payload: Prisma.$CostItemPayload<ExtArgs>
        fields: Prisma.CostItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CostItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CostItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostItemPayload>
          }
          findFirst: {
            args: Prisma.CostItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CostItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostItemPayload>
          }
          findMany: {
            args: Prisma.CostItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostItemPayload>[]
          }
          create: {
            args: Prisma.CostItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostItemPayload>
          }
          createMany: {
            args: Prisma.CostItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CostItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostItemPayload>[]
          }
          delete: {
            args: Prisma.CostItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostItemPayload>
          }
          update: {
            args: Prisma.CostItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostItemPayload>
          }
          deleteMany: {
            args: Prisma.CostItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CostItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CostItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostItemPayload>
          }
          aggregate: {
            args: Prisma.CostItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCostItem>
          }
          groupBy: {
            args: Prisma.CostItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<CostItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.CostItemCountArgs<ExtArgs>
            result: $Utils.Optional<CostItemCountAggregateOutputType> | number
          }
        }
      }
      CountryCostMultiplier: {
        payload: Prisma.$CountryCostMultiplierPayload<ExtArgs>
        fields: Prisma.CountryCostMultiplierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CountryCostMultiplierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryCostMultiplierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CountryCostMultiplierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryCostMultiplierPayload>
          }
          findFirst: {
            args: Prisma.CountryCostMultiplierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryCostMultiplierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CountryCostMultiplierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryCostMultiplierPayload>
          }
          findMany: {
            args: Prisma.CountryCostMultiplierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryCostMultiplierPayload>[]
          }
          create: {
            args: Prisma.CountryCostMultiplierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryCostMultiplierPayload>
          }
          createMany: {
            args: Prisma.CountryCostMultiplierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CountryCostMultiplierCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryCostMultiplierPayload>[]
          }
          delete: {
            args: Prisma.CountryCostMultiplierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryCostMultiplierPayload>
          }
          update: {
            args: Prisma.CountryCostMultiplierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryCostMultiplierPayload>
          }
          deleteMany: {
            args: Prisma.CountryCostMultiplierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CountryCostMultiplierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CountryCostMultiplierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryCostMultiplierPayload>
          }
          aggregate: {
            args: Prisma.CountryCostMultiplierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCountryCostMultiplier>
          }
          groupBy: {
            args: Prisma.CountryCostMultiplierGroupByArgs<ExtArgs>
            result: $Utils.Optional<CountryCostMultiplierGroupByOutputType>[]
          }
          count: {
            args: Prisma.CountryCostMultiplierCountArgs<ExtArgs>
            result: $Utils.Optional<CountryCostMultiplierCountAggregateOutputType> | number
          }
        }
      }
      StrategyItemCost: {
        payload: Prisma.$StrategyItemCostPayload<ExtArgs>
        fields: Prisma.StrategyItemCostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StrategyItemCostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrategyItemCostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StrategyItemCostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrategyItemCostPayload>
          }
          findFirst: {
            args: Prisma.StrategyItemCostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrategyItemCostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StrategyItemCostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrategyItemCostPayload>
          }
          findMany: {
            args: Prisma.StrategyItemCostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrategyItemCostPayload>[]
          }
          create: {
            args: Prisma.StrategyItemCostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrategyItemCostPayload>
          }
          createMany: {
            args: Prisma.StrategyItemCostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StrategyItemCostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrategyItemCostPayload>[]
          }
          delete: {
            args: Prisma.StrategyItemCostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrategyItemCostPayload>
          }
          update: {
            args: Prisma.StrategyItemCostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrategyItemCostPayload>
          }
          deleteMany: {
            args: Prisma.StrategyItemCostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StrategyItemCostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StrategyItemCostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrategyItemCostPayload>
          }
          aggregate: {
            args: Prisma.StrategyItemCostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStrategyItemCost>
          }
          groupBy: {
            args: Prisma.StrategyItemCostGroupByArgs<ExtArgs>
            result: $Utils.Optional<StrategyItemCostGroupByOutputType>[]
          }
          count: {
            args: Prisma.StrategyItemCostCountArgs<ExtArgs>
            result: $Utils.Optional<StrategyItemCostCountAggregateOutputType> | number
          }
        }
      }
      ActionStepItemCost: {
        payload: Prisma.$ActionStepItemCostPayload<ExtArgs>
        fields: Prisma.ActionStepItemCostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActionStepItemCostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionStepItemCostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActionStepItemCostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionStepItemCostPayload>
          }
          findFirst: {
            args: Prisma.ActionStepItemCostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionStepItemCostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActionStepItemCostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionStepItemCostPayload>
          }
          findMany: {
            args: Prisma.ActionStepItemCostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionStepItemCostPayload>[]
          }
          create: {
            args: Prisma.ActionStepItemCostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionStepItemCostPayload>
          }
          createMany: {
            args: Prisma.ActionStepItemCostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActionStepItemCostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionStepItemCostPayload>[]
          }
          delete: {
            args: Prisma.ActionStepItemCostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionStepItemCostPayload>
          }
          update: {
            args: Prisma.ActionStepItemCostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionStepItemCostPayload>
          }
          deleteMany: {
            args: Prisma.ActionStepItemCostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActionStepItemCostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ActionStepItemCostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionStepItemCostPayload>
          }
          aggregate: {
            args: Prisma.ActionStepItemCostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActionStepItemCost>
          }
          groupBy: {
            args: Prisma.ActionStepItemCostGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActionStepItemCostGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActionStepItemCostCountArgs<ExtArgs>
            result: $Utils.Optional<ActionStepItemCostCountAggregateOutputType> | number
          }
        }
      }
      BusinessTypeTranslation: {
        payload: Prisma.$BusinessTypeTranslationPayload<ExtArgs>
        fields: Prisma.BusinessTypeTranslationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BusinessTypeTranslationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessTypeTranslationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BusinessTypeTranslationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessTypeTranslationPayload>
          }
          findFirst: {
            args: Prisma.BusinessTypeTranslationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessTypeTranslationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BusinessTypeTranslationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessTypeTranslationPayload>
          }
          findMany: {
            args: Prisma.BusinessTypeTranslationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessTypeTranslationPayload>[]
          }
          create: {
            args: Prisma.BusinessTypeTranslationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessTypeTranslationPayload>
          }
          createMany: {
            args: Prisma.BusinessTypeTranslationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BusinessTypeTranslationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessTypeTranslationPayload>[]
          }
          delete: {
            args: Prisma.BusinessTypeTranslationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessTypeTranslationPayload>
          }
          update: {
            args: Prisma.BusinessTypeTranslationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessTypeTranslationPayload>
          }
          deleteMany: {
            args: Prisma.BusinessTypeTranslationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BusinessTypeTranslationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BusinessTypeTranslationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessTypeTranslationPayload>
          }
          aggregate: {
            args: Prisma.BusinessTypeTranslationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBusinessTypeTranslation>
          }
          groupBy: {
            args: Prisma.BusinessTypeTranslationGroupByArgs<ExtArgs>
            result: $Utils.Optional<BusinessTypeTranslationGroupByOutputType>[]
          }
          count: {
            args: Prisma.BusinessTypeTranslationCountArgs<ExtArgs>
            result: $Utils.Optional<BusinessTypeTranslationCountAggregateOutputType> | number
          }
        }
      }
      StrategyTranslation: {
        payload: Prisma.$StrategyTranslationPayload<ExtArgs>
        fields: Prisma.StrategyTranslationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StrategyTranslationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrategyTranslationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StrategyTranslationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrategyTranslationPayload>
          }
          findFirst: {
            args: Prisma.StrategyTranslationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrategyTranslationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StrategyTranslationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrategyTranslationPayload>
          }
          findMany: {
            args: Prisma.StrategyTranslationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrategyTranslationPayload>[]
          }
          create: {
            args: Prisma.StrategyTranslationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrategyTranslationPayload>
          }
          createMany: {
            args: Prisma.StrategyTranslationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StrategyTranslationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrategyTranslationPayload>[]
          }
          delete: {
            args: Prisma.StrategyTranslationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrategyTranslationPayload>
          }
          update: {
            args: Prisma.StrategyTranslationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrategyTranslationPayload>
          }
          deleteMany: {
            args: Prisma.StrategyTranslationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StrategyTranslationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StrategyTranslationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrategyTranslationPayload>
          }
          aggregate: {
            args: Prisma.StrategyTranslationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStrategyTranslation>
          }
          groupBy: {
            args: Prisma.StrategyTranslationGroupByArgs<ExtArgs>
            result: $Utils.Optional<StrategyTranslationGroupByOutputType>[]
          }
          count: {
            args: Prisma.StrategyTranslationCountArgs<ExtArgs>
            result: $Utils.Optional<StrategyTranslationCountAggregateOutputType> | number
          }
        }
      }
      ActionStepTranslation: {
        payload: Prisma.$ActionStepTranslationPayload<ExtArgs>
        fields: Prisma.ActionStepTranslationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActionStepTranslationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionStepTranslationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActionStepTranslationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionStepTranslationPayload>
          }
          findFirst: {
            args: Prisma.ActionStepTranslationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionStepTranslationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActionStepTranslationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionStepTranslationPayload>
          }
          findMany: {
            args: Prisma.ActionStepTranslationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionStepTranslationPayload>[]
          }
          create: {
            args: Prisma.ActionStepTranslationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionStepTranslationPayload>
          }
          createMany: {
            args: Prisma.ActionStepTranslationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActionStepTranslationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionStepTranslationPayload>[]
          }
          delete: {
            args: Prisma.ActionStepTranslationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionStepTranslationPayload>
          }
          update: {
            args: Prisma.ActionStepTranslationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionStepTranslationPayload>
          }
          deleteMany: {
            args: Prisma.ActionStepTranslationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActionStepTranslationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ActionStepTranslationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionStepTranslationPayload>
          }
          aggregate: {
            args: Prisma.ActionStepTranslationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActionStepTranslation>
          }
          groupBy: {
            args: Prisma.ActionStepTranslationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActionStepTranslationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActionStepTranslationCountArgs<ExtArgs>
            result: $Utils.Optional<ActionStepTranslationCountAggregateOutputType> | number
          }
        }
      }
      HazardTranslation: {
        payload: Prisma.$HazardTranslationPayload<ExtArgs>
        fields: Prisma.HazardTranslationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HazardTranslationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HazardTranslationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HazardTranslationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HazardTranslationPayload>
          }
          findFirst: {
            args: Prisma.HazardTranslationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HazardTranslationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HazardTranslationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HazardTranslationPayload>
          }
          findMany: {
            args: Prisma.HazardTranslationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HazardTranslationPayload>[]
          }
          create: {
            args: Prisma.HazardTranslationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HazardTranslationPayload>
          }
          createMany: {
            args: Prisma.HazardTranslationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HazardTranslationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HazardTranslationPayload>[]
          }
          delete: {
            args: Prisma.HazardTranslationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HazardTranslationPayload>
          }
          update: {
            args: Prisma.HazardTranslationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HazardTranslationPayload>
          }
          deleteMany: {
            args: Prisma.HazardTranslationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HazardTranslationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HazardTranslationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HazardTranslationPayload>
          }
          aggregate: {
            args: Prisma.HazardTranslationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHazardTranslation>
          }
          groupBy: {
            args: Prisma.HazardTranslationGroupByArgs<ExtArgs>
            result: $Utils.Optional<HazardTranslationGroupByOutputType>[]
          }
          count: {
            args: Prisma.HazardTranslationCountArgs<ExtArgs>
            result: $Utils.Optional<HazardTranslationCountAggregateOutputType> | number
          }
        }
      }
      RiskMultiplierTranslation: {
        payload: Prisma.$RiskMultiplierTranslationPayload<ExtArgs>
        fields: Prisma.RiskMultiplierTranslationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RiskMultiplierTranslationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskMultiplierTranslationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RiskMultiplierTranslationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskMultiplierTranslationPayload>
          }
          findFirst: {
            args: Prisma.RiskMultiplierTranslationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskMultiplierTranslationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RiskMultiplierTranslationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskMultiplierTranslationPayload>
          }
          findMany: {
            args: Prisma.RiskMultiplierTranslationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskMultiplierTranslationPayload>[]
          }
          create: {
            args: Prisma.RiskMultiplierTranslationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskMultiplierTranslationPayload>
          }
          createMany: {
            args: Prisma.RiskMultiplierTranslationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RiskMultiplierTranslationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskMultiplierTranslationPayload>[]
          }
          delete: {
            args: Prisma.RiskMultiplierTranslationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskMultiplierTranslationPayload>
          }
          update: {
            args: Prisma.RiskMultiplierTranslationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskMultiplierTranslationPayload>
          }
          deleteMany: {
            args: Prisma.RiskMultiplierTranslationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RiskMultiplierTranslationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RiskMultiplierTranslationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskMultiplierTranslationPayload>
          }
          aggregate: {
            args: Prisma.RiskMultiplierTranslationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRiskMultiplierTranslation>
          }
          groupBy: {
            args: Prisma.RiskMultiplierTranslationGroupByArgs<ExtArgs>
            result: $Utils.Optional<RiskMultiplierTranslationGroupByOutputType>[]
          }
          count: {
            args: Prisma.RiskMultiplierTranslationCountArgs<ExtArgs>
            result: $Utils.Optional<RiskMultiplierTranslationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AdminBusinessTypeCountOutputType
   */

  export type AdminBusinessTypeCountOutputType = {
    businessTypeHazards: number
    riskProfiles: number
  }

  export type AdminBusinessTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businessTypeHazards?: boolean | AdminBusinessTypeCountOutputTypeCountBusinessTypeHazardsArgs
    riskProfiles?: boolean | AdminBusinessTypeCountOutputTypeCountRiskProfilesArgs
  }

  // Custom InputTypes
  /**
   * AdminBusinessTypeCountOutputType without action
   */
  export type AdminBusinessTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminBusinessTypeCountOutputType
     */
    select?: AdminBusinessTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdminBusinessTypeCountOutputType without action
   */
  export type AdminBusinessTypeCountOutputTypeCountBusinessTypeHazardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminBusinessTypeHazardWhereInput
  }

  /**
   * AdminBusinessTypeCountOutputType without action
   */
  export type AdminBusinessTypeCountOutputTypeCountRiskProfilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminRiskProfileWhereInput
  }


  /**
   * Count Type AdminHazardTypeCountOutputType
   */

  export type AdminHazardTypeCountOutputType = {
    businessTypeHazards: number
    locationHazards: number
    hazardStrategies: number
    hazardActionPlans: number
    translations: number
  }

  export type AdminHazardTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businessTypeHazards?: boolean | AdminHazardTypeCountOutputTypeCountBusinessTypeHazardsArgs
    locationHazards?: boolean | AdminHazardTypeCountOutputTypeCountLocationHazardsArgs
    hazardStrategies?: boolean | AdminHazardTypeCountOutputTypeCountHazardStrategiesArgs
    hazardActionPlans?: boolean | AdminHazardTypeCountOutputTypeCountHazardActionPlansArgs
    translations?: boolean | AdminHazardTypeCountOutputTypeCountTranslationsArgs
  }

  // Custom InputTypes
  /**
   * AdminHazardTypeCountOutputType without action
   */
  export type AdminHazardTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminHazardTypeCountOutputType
     */
    select?: AdminHazardTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdminHazardTypeCountOutputType without action
   */
  export type AdminHazardTypeCountOutputTypeCountBusinessTypeHazardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminBusinessTypeHazardWhereInput
  }

  /**
   * AdminHazardTypeCountOutputType without action
   */
  export type AdminHazardTypeCountOutputTypeCountLocationHazardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminLocationHazardWhereInput
  }

  /**
   * AdminHazardTypeCountOutputType without action
   */
  export type AdminHazardTypeCountOutputTypeCountHazardStrategiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminHazardStrategyWhereInput
  }

  /**
   * AdminHazardTypeCountOutputType without action
   */
  export type AdminHazardTypeCountOutputTypeCountHazardActionPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminHazardActionPlanWhereInput
  }

  /**
   * AdminHazardTypeCountOutputType without action
   */
  export type AdminHazardTypeCountOutputTypeCountTranslationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HazardTranslationWhereInput
  }


  /**
   * Count Type AdminLocationCountOutputType
   */

  export type AdminLocationCountOutputType = {
    locationHazards: number
    riskProfiles: number
  }

  export type AdminLocationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    locationHazards?: boolean | AdminLocationCountOutputTypeCountLocationHazardsArgs
    riskProfiles?: boolean | AdminLocationCountOutputTypeCountRiskProfilesArgs
  }

  // Custom InputTypes
  /**
   * AdminLocationCountOutputType without action
   */
  export type AdminLocationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminLocationCountOutputType
     */
    select?: AdminLocationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdminLocationCountOutputType without action
   */
  export type AdminLocationCountOutputTypeCountLocationHazardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminLocationHazardWhereInput
  }

  /**
   * AdminLocationCountOutputType without action
   */
  export type AdminLocationCountOutputTypeCountRiskProfilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminRiskProfileWhereInput
  }


  /**
   * Count Type AdminStrategyCountOutputType
   */

  export type AdminStrategyCountOutputType = {
    hazardStrategies: number
  }

  export type AdminStrategyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hazardStrategies?: boolean | AdminStrategyCountOutputTypeCountHazardStrategiesArgs
  }

  // Custom InputTypes
  /**
   * AdminStrategyCountOutputType without action
   */
  export type AdminStrategyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminStrategyCountOutputType
     */
    select?: AdminStrategyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdminStrategyCountOutputType without action
   */
  export type AdminStrategyCountOutputTypeCountHazardStrategiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminHazardStrategyWhereInput
  }


  /**
   * Count Type AdminActionPlanCountOutputType
   */

  export type AdminActionPlanCountOutputType = {
    AdminHazardActionPlan: number
  }

  export type AdminActionPlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AdminHazardActionPlan?: boolean | AdminActionPlanCountOutputTypeCountAdminHazardActionPlanArgs
  }

  // Custom InputTypes
  /**
   * AdminActionPlanCountOutputType without action
   */
  export type AdminActionPlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminActionPlanCountOutputType
     */
    select?: AdminActionPlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdminActionPlanCountOutputType without action
   */
  export type AdminActionPlanCountOutputTypeCountAdminHazardActionPlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminHazardActionPlanWhereInput
  }


  /**
   * Count Type CountryCountOutputType
   */

  export type CountryCountOutputType = {
    adminUnits: number
  }

  export type CountryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    adminUnits?: boolean | CountryCountOutputTypeCountAdminUnitsArgs
  }

  // Custom InputTypes
  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCountOutputType
     */
    select?: CountryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeCountAdminUnitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminUnitWhereInput
  }


  /**
   * Count Type ParishCountOutputType
   */

  export type ParishCountOutputType = {
    businessRiskProfiles: number
  }

  export type ParishCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businessRiskProfiles?: boolean | ParishCountOutputTypeCountBusinessRiskProfilesArgs
  }

  // Custom InputTypes
  /**
   * ParishCountOutputType without action
   */
  export type ParishCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParishCountOutputType
     */
    select?: ParishCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ParishCountOutputType without action
   */
  export type ParishCountOutputTypeCountBusinessRiskProfilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessRiskProfileWhereInput
  }


  /**
   * Count Type AdminUnitRiskCountOutputType
   */

  export type AdminUnitRiskCountOutputType = {
    changeLogs: number
  }

  export type AdminUnitRiskCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    changeLogs?: boolean | AdminUnitRiskCountOutputTypeCountChangeLogsArgs
  }

  // Custom InputTypes
  /**
   * AdminUnitRiskCountOutputType without action
   */
  export type AdminUnitRiskCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUnitRiskCountOutputType
     */
    select?: AdminUnitRiskCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdminUnitRiskCountOutputType without action
   */
  export type AdminUnitRiskCountOutputTypeCountChangeLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminUnitRiskChangeLogWhereInput
  }


  /**
   * Count Type ParishRiskCountOutputType
   */

  export type ParishRiskCountOutputType = {
    changeLogs: number
  }

  export type ParishRiskCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    changeLogs?: boolean | ParishRiskCountOutputTypeCountChangeLogsArgs
  }

  // Custom InputTypes
  /**
   * ParishRiskCountOutputType without action
   */
  export type ParishRiskCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParishRiskCountOutputType
     */
    select?: ParishRiskCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ParishRiskCountOutputType without action
   */
  export type ParishRiskCountOutputTypeCountChangeLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RiskChangeLogWhereInput
  }


  /**
   * Count Type BusinessTypeCountOutputType
   */

  export type BusinessTypeCountOutputType = {
    riskVulnerabilities: number
    businessTypeStrategies: number
    businessRiskProfiles: number
    translations: number
  }

  export type BusinessTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    riskVulnerabilities?: boolean | BusinessTypeCountOutputTypeCountRiskVulnerabilitiesArgs
    businessTypeStrategies?: boolean | BusinessTypeCountOutputTypeCountBusinessTypeStrategiesArgs
    businessRiskProfiles?: boolean | BusinessTypeCountOutputTypeCountBusinessRiskProfilesArgs
    translations?: boolean | BusinessTypeCountOutputTypeCountTranslationsArgs
  }

  // Custom InputTypes
  /**
   * BusinessTypeCountOutputType without action
   */
  export type BusinessTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessTypeCountOutputType
     */
    select?: BusinessTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BusinessTypeCountOutputType without action
   */
  export type BusinessTypeCountOutputTypeCountRiskVulnerabilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessRiskVulnerabilityWhereInput
  }

  /**
   * BusinessTypeCountOutputType without action
   */
  export type BusinessTypeCountOutputTypeCountBusinessTypeStrategiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessTypeStrategyWhereInput
  }

  /**
   * BusinessTypeCountOutputType without action
   */
  export type BusinessTypeCountOutputTypeCountBusinessRiskProfilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessRiskProfileWhereInput
  }

  /**
   * BusinessTypeCountOutputType without action
   */
  export type BusinessTypeCountOutputTypeCountTranslationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessTypeTranslationWhereInput
  }


  /**
   * Count Type RiskMitigationStrategyCountOutputType
   */

  export type RiskMitigationStrategyCountOutputType = {
    businessTypeStrategies: number
    actionSteps: number
    itemCosts: number
    translations: number
  }

  export type RiskMitigationStrategyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businessTypeStrategies?: boolean | RiskMitigationStrategyCountOutputTypeCountBusinessTypeStrategiesArgs
    actionSteps?: boolean | RiskMitigationStrategyCountOutputTypeCountActionStepsArgs
    itemCosts?: boolean | RiskMitigationStrategyCountOutputTypeCountItemCostsArgs
    translations?: boolean | RiskMitigationStrategyCountOutputTypeCountTranslationsArgs
  }

  // Custom InputTypes
  /**
   * RiskMitigationStrategyCountOutputType without action
   */
  export type RiskMitigationStrategyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskMitigationStrategyCountOutputType
     */
    select?: RiskMitigationStrategyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RiskMitigationStrategyCountOutputType without action
   */
  export type RiskMitigationStrategyCountOutputTypeCountBusinessTypeStrategiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessTypeStrategyWhereInput
  }

  /**
   * RiskMitigationStrategyCountOutputType without action
   */
  export type RiskMitigationStrategyCountOutputTypeCountActionStepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActionStepWhereInput
  }

  /**
   * RiskMitigationStrategyCountOutputType without action
   */
  export type RiskMitigationStrategyCountOutputTypeCountItemCostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StrategyItemCostWhereInput
  }

  /**
   * RiskMitigationStrategyCountOutputType without action
   */
  export type RiskMitigationStrategyCountOutputTypeCountTranslationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StrategyTranslationWhereInput
  }


  /**
   * Count Type ActionStepCountOutputType
   */

  export type ActionStepCountOutputType = {
    itemCosts: number
    translations: number
  }

  export type ActionStepCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    itemCosts?: boolean | ActionStepCountOutputTypeCountItemCostsArgs
    translations?: boolean | ActionStepCountOutputTypeCountTranslationsArgs
  }

  // Custom InputTypes
  /**
   * ActionStepCountOutputType without action
   */
  export type ActionStepCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionStepCountOutputType
     */
    select?: ActionStepCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ActionStepCountOutputType without action
   */
  export type ActionStepCountOutputTypeCountItemCostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActionStepItemCostWhereInput
  }

  /**
   * ActionStepCountOutputType without action
   */
  export type ActionStepCountOutputTypeCountTranslationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActionStepTranslationWhereInput
  }


  /**
   * Count Type RiskMultiplierCountOutputType
   */

  export type RiskMultiplierCountOutputType = {
    translations: number
  }

  export type RiskMultiplierCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    translations?: boolean | RiskMultiplierCountOutputTypeCountTranslationsArgs
  }

  // Custom InputTypes
  /**
   * RiskMultiplierCountOutputType without action
   */
  export type RiskMultiplierCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskMultiplierCountOutputType
     */
    select?: RiskMultiplierCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RiskMultiplierCountOutputType without action
   */
  export type RiskMultiplierCountOutputTypeCountTranslationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RiskMultiplierTranslationWhereInput
  }


  /**
   * Count Type CostItemCountOutputType
   */

  export type CostItemCountOutputType = {
    strategyItems: number
    actionStepItems: number
  }

  export type CostItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    strategyItems?: boolean | CostItemCountOutputTypeCountStrategyItemsArgs
    actionStepItems?: boolean | CostItemCountOutputTypeCountActionStepItemsArgs
  }

  // Custom InputTypes
  /**
   * CostItemCountOutputType without action
   */
  export type CostItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItemCountOutputType
     */
    select?: CostItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CostItemCountOutputType without action
   */
  export type CostItemCountOutputTypeCountStrategyItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StrategyItemCostWhereInput
  }

  /**
   * CostItemCountOutputType without action
   */
  export type CostItemCountOutputTypeCountActionStepItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActionStepItemCostWhereInput
  }


  /**
   * Models
   */

  /**
   * Model BusinessContinuityPlan
   */

  export type AggregateBusinessContinuityPlan = {
    _count: BusinessContinuityPlanCountAggregateOutputType | null
    _min: BusinessContinuityPlanMinAggregateOutputType | null
    _max: BusinessContinuityPlanMaxAggregateOutputType | null
  }

  export type BusinessContinuityPlanMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BusinessContinuityPlanMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BusinessContinuityPlanCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BusinessContinuityPlanMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BusinessContinuityPlanMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BusinessContinuityPlanCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BusinessContinuityPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessContinuityPlan to aggregate.
     */
    where?: BusinessContinuityPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessContinuityPlans to fetch.
     */
    orderBy?: BusinessContinuityPlanOrderByWithRelationInput | BusinessContinuityPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BusinessContinuityPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessContinuityPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessContinuityPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BusinessContinuityPlans
    **/
    _count?: true | BusinessContinuityPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BusinessContinuityPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BusinessContinuityPlanMaxAggregateInputType
  }

  export type GetBusinessContinuityPlanAggregateType<T extends BusinessContinuityPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateBusinessContinuityPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBusinessContinuityPlan[P]>
      : GetScalarType<T[P], AggregateBusinessContinuityPlan[P]>
  }




  export type BusinessContinuityPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessContinuityPlanWhereInput
    orderBy?: BusinessContinuityPlanOrderByWithAggregationInput | BusinessContinuityPlanOrderByWithAggregationInput[]
    by: BusinessContinuityPlanScalarFieldEnum[] | BusinessContinuityPlanScalarFieldEnum
    having?: BusinessContinuityPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BusinessContinuityPlanCountAggregateInputType | true
    _min?: BusinessContinuityPlanMinAggregateInputType
    _max?: BusinessContinuityPlanMaxAggregateInputType
  }

  export type BusinessContinuityPlanGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    _count: BusinessContinuityPlanCountAggregateOutputType | null
    _min: BusinessContinuityPlanMinAggregateOutputType | null
    _max: BusinessContinuityPlanMaxAggregateOutputType | null
  }

  type GetBusinessContinuityPlanGroupByPayload<T extends BusinessContinuityPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BusinessContinuityPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BusinessContinuityPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BusinessContinuityPlanGroupByOutputType[P]>
            : GetScalarType<T[P], BusinessContinuityPlanGroupByOutputType[P]>
        }
      >
    >


  export type BusinessContinuityPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    planInformation?: boolean | BusinessContinuityPlan$planInformationArgs<ExtArgs>
    businessOverview?: boolean | BusinessContinuityPlan$businessOverviewArgs<ExtArgs>
    essentialFunction?: boolean | BusinessContinuityPlan$essentialFunctionArgs<ExtArgs>
    riskAssessment?: boolean | BusinessContinuityPlan$riskAssessmentArgs<ExtArgs>
    strategy?: boolean | BusinessContinuityPlan$strategyArgs<ExtArgs>
    actionPlan?: boolean | BusinessContinuityPlan$actionPlanArgs<ExtArgs>
    contactsInformation?: boolean | BusinessContinuityPlan$contactsInformationArgs<ExtArgs>
    testingMaintenance?: boolean | BusinessContinuityPlan$testingMaintenanceArgs<ExtArgs>
  }, ExtArgs["result"]["businessContinuityPlan"]>

  export type BusinessContinuityPlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["businessContinuityPlan"]>

  export type BusinessContinuityPlanSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BusinessContinuityPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    planInformation?: boolean | BusinessContinuityPlan$planInformationArgs<ExtArgs>
    businessOverview?: boolean | BusinessContinuityPlan$businessOverviewArgs<ExtArgs>
    essentialFunction?: boolean | BusinessContinuityPlan$essentialFunctionArgs<ExtArgs>
    riskAssessment?: boolean | BusinessContinuityPlan$riskAssessmentArgs<ExtArgs>
    strategy?: boolean | BusinessContinuityPlan$strategyArgs<ExtArgs>
    actionPlan?: boolean | BusinessContinuityPlan$actionPlanArgs<ExtArgs>
    contactsInformation?: boolean | BusinessContinuityPlan$contactsInformationArgs<ExtArgs>
    testingMaintenance?: boolean | BusinessContinuityPlan$testingMaintenanceArgs<ExtArgs>
  }
  export type BusinessContinuityPlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BusinessContinuityPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BusinessContinuityPlan"
    objects: {
      planInformation: Prisma.$PlanInformationPayload<ExtArgs> | null
      businessOverview: Prisma.$BusinessOverviewPayload<ExtArgs> | null
      essentialFunction: Prisma.$EssentialFunctionPayload<ExtArgs> | null
      riskAssessment: Prisma.$RiskAssessmentPayload<ExtArgs> | null
      strategy: Prisma.$StrategyPayload<ExtArgs> | null
      actionPlan: Prisma.$ActionPlanPayload<ExtArgs> | null
      contactsInformation: Prisma.$ContactsInformationPayload<ExtArgs> | null
      testingMaintenance: Prisma.$TestingMaintenancePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["businessContinuityPlan"]>
    composites: {}
  }

  type BusinessContinuityPlanGetPayload<S extends boolean | null | undefined | BusinessContinuityPlanDefaultArgs> = $Result.GetResult<Prisma.$BusinessContinuityPlanPayload, S>

  type BusinessContinuityPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BusinessContinuityPlanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BusinessContinuityPlanCountAggregateInputType | true
    }

  export interface BusinessContinuityPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BusinessContinuityPlan'], meta: { name: 'BusinessContinuityPlan' } }
    /**
     * Find zero or one BusinessContinuityPlan that matches the filter.
     * @param {BusinessContinuityPlanFindUniqueArgs} args - Arguments to find a BusinessContinuityPlan
     * @example
     * // Get one BusinessContinuityPlan
     * const businessContinuityPlan = await prisma.businessContinuityPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BusinessContinuityPlanFindUniqueArgs>(args: SelectSubset<T, BusinessContinuityPlanFindUniqueArgs<ExtArgs>>): Prisma__BusinessContinuityPlanClient<$Result.GetResult<Prisma.$BusinessContinuityPlanPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BusinessContinuityPlan that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BusinessContinuityPlanFindUniqueOrThrowArgs} args - Arguments to find a BusinessContinuityPlan
     * @example
     * // Get one BusinessContinuityPlan
     * const businessContinuityPlan = await prisma.businessContinuityPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BusinessContinuityPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, BusinessContinuityPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BusinessContinuityPlanClient<$Result.GetResult<Prisma.$BusinessContinuityPlanPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BusinessContinuityPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessContinuityPlanFindFirstArgs} args - Arguments to find a BusinessContinuityPlan
     * @example
     * // Get one BusinessContinuityPlan
     * const businessContinuityPlan = await prisma.businessContinuityPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BusinessContinuityPlanFindFirstArgs>(args?: SelectSubset<T, BusinessContinuityPlanFindFirstArgs<ExtArgs>>): Prisma__BusinessContinuityPlanClient<$Result.GetResult<Prisma.$BusinessContinuityPlanPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BusinessContinuityPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessContinuityPlanFindFirstOrThrowArgs} args - Arguments to find a BusinessContinuityPlan
     * @example
     * // Get one BusinessContinuityPlan
     * const businessContinuityPlan = await prisma.businessContinuityPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BusinessContinuityPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, BusinessContinuityPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__BusinessContinuityPlanClient<$Result.GetResult<Prisma.$BusinessContinuityPlanPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BusinessContinuityPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessContinuityPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BusinessContinuityPlans
     * const businessContinuityPlans = await prisma.businessContinuityPlan.findMany()
     * 
     * // Get first 10 BusinessContinuityPlans
     * const businessContinuityPlans = await prisma.businessContinuityPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const businessContinuityPlanWithIdOnly = await prisma.businessContinuityPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BusinessContinuityPlanFindManyArgs>(args?: SelectSubset<T, BusinessContinuityPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessContinuityPlanPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BusinessContinuityPlan.
     * @param {BusinessContinuityPlanCreateArgs} args - Arguments to create a BusinessContinuityPlan.
     * @example
     * // Create one BusinessContinuityPlan
     * const BusinessContinuityPlan = await prisma.businessContinuityPlan.create({
     *   data: {
     *     // ... data to create a BusinessContinuityPlan
     *   }
     * })
     * 
     */
    create<T extends BusinessContinuityPlanCreateArgs>(args: SelectSubset<T, BusinessContinuityPlanCreateArgs<ExtArgs>>): Prisma__BusinessContinuityPlanClient<$Result.GetResult<Prisma.$BusinessContinuityPlanPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BusinessContinuityPlans.
     * @param {BusinessContinuityPlanCreateManyArgs} args - Arguments to create many BusinessContinuityPlans.
     * @example
     * // Create many BusinessContinuityPlans
     * const businessContinuityPlan = await prisma.businessContinuityPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BusinessContinuityPlanCreateManyArgs>(args?: SelectSubset<T, BusinessContinuityPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BusinessContinuityPlans and returns the data saved in the database.
     * @param {BusinessContinuityPlanCreateManyAndReturnArgs} args - Arguments to create many BusinessContinuityPlans.
     * @example
     * // Create many BusinessContinuityPlans
     * const businessContinuityPlan = await prisma.businessContinuityPlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BusinessContinuityPlans and only return the `id`
     * const businessContinuityPlanWithIdOnly = await prisma.businessContinuityPlan.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BusinessContinuityPlanCreateManyAndReturnArgs>(args?: SelectSubset<T, BusinessContinuityPlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessContinuityPlanPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BusinessContinuityPlan.
     * @param {BusinessContinuityPlanDeleteArgs} args - Arguments to delete one BusinessContinuityPlan.
     * @example
     * // Delete one BusinessContinuityPlan
     * const BusinessContinuityPlan = await prisma.businessContinuityPlan.delete({
     *   where: {
     *     // ... filter to delete one BusinessContinuityPlan
     *   }
     * })
     * 
     */
    delete<T extends BusinessContinuityPlanDeleteArgs>(args: SelectSubset<T, BusinessContinuityPlanDeleteArgs<ExtArgs>>): Prisma__BusinessContinuityPlanClient<$Result.GetResult<Prisma.$BusinessContinuityPlanPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BusinessContinuityPlan.
     * @param {BusinessContinuityPlanUpdateArgs} args - Arguments to update one BusinessContinuityPlan.
     * @example
     * // Update one BusinessContinuityPlan
     * const businessContinuityPlan = await prisma.businessContinuityPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BusinessContinuityPlanUpdateArgs>(args: SelectSubset<T, BusinessContinuityPlanUpdateArgs<ExtArgs>>): Prisma__BusinessContinuityPlanClient<$Result.GetResult<Prisma.$BusinessContinuityPlanPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BusinessContinuityPlans.
     * @param {BusinessContinuityPlanDeleteManyArgs} args - Arguments to filter BusinessContinuityPlans to delete.
     * @example
     * // Delete a few BusinessContinuityPlans
     * const { count } = await prisma.businessContinuityPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BusinessContinuityPlanDeleteManyArgs>(args?: SelectSubset<T, BusinessContinuityPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BusinessContinuityPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessContinuityPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BusinessContinuityPlans
     * const businessContinuityPlan = await prisma.businessContinuityPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BusinessContinuityPlanUpdateManyArgs>(args: SelectSubset<T, BusinessContinuityPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BusinessContinuityPlan.
     * @param {BusinessContinuityPlanUpsertArgs} args - Arguments to update or create a BusinessContinuityPlan.
     * @example
     * // Update or create a BusinessContinuityPlan
     * const businessContinuityPlan = await prisma.businessContinuityPlan.upsert({
     *   create: {
     *     // ... data to create a BusinessContinuityPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BusinessContinuityPlan we want to update
     *   }
     * })
     */
    upsert<T extends BusinessContinuityPlanUpsertArgs>(args: SelectSubset<T, BusinessContinuityPlanUpsertArgs<ExtArgs>>): Prisma__BusinessContinuityPlanClient<$Result.GetResult<Prisma.$BusinessContinuityPlanPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BusinessContinuityPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessContinuityPlanCountArgs} args - Arguments to filter BusinessContinuityPlans to count.
     * @example
     * // Count the number of BusinessContinuityPlans
     * const count = await prisma.businessContinuityPlan.count({
     *   where: {
     *     // ... the filter for the BusinessContinuityPlans we want to count
     *   }
     * })
    **/
    count<T extends BusinessContinuityPlanCountArgs>(
      args?: Subset<T, BusinessContinuityPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BusinessContinuityPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BusinessContinuityPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessContinuityPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BusinessContinuityPlanAggregateArgs>(args: Subset<T, BusinessContinuityPlanAggregateArgs>): Prisma.PrismaPromise<GetBusinessContinuityPlanAggregateType<T>>

    /**
     * Group by BusinessContinuityPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessContinuityPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BusinessContinuityPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BusinessContinuityPlanGroupByArgs['orderBy'] }
        : { orderBy?: BusinessContinuityPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BusinessContinuityPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBusinessContinuityPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BusinessContinuityPlan model
   */
  readonly fields: BusinessContinuityPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BusinessContinuityPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BusinessContinuityPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    planInformation<T extends BusinessContinuityPlan$planInformationArgs<ExtArgs> = {}>(args?: Subset<T, BusinessContinuityPlan$planInformationArgs<ExtArgs>>): Prisma__PlanInformationClient<$Result.GetResult<Prisma.$PlanInformationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    businessOverview<T extends BusinessContinuityPlan$businessOverviewArgs<ExtArgs> = {}>(args?: Subset<T, BusinessContinuityPlan$businessOverviewArgs<ExtArgs>>): Prisma__BusinessOverviewClient<$Result.GetResult<Prisma.$BusinessOverviewPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    essentialFunction<T extends BusinessContinuityPlan$essentialFunctionArgs<ExtArgs> = {}>(args?: Subset<T, BusinessContinuityPlan$essentialFunctionArgs<ExtArgs>>): Prisma__EssentialFunctionClient<$Result.GetResult<Prisma.$EssentialFunctionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    riskAssessment<T extends BusinessContinuityPlan$riskAssessmentArgs<ExtArgs> = {}>(args?: Subset<T, BusinessContinuityPlan$riskAssessmentArgs<ExtArgs>>): Prisma__RiskAssessmentClient<$Result.GetResult<Prisma.$RiskAssessmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    strategy<T extends BusinessContinuityPlan$strategyArgs<ExtArgs> = {}>(args?: Subset<T, BusinessContinuityPlan$strategyArgs<ExtArgs>>): Prisma__StrategyClient<$Result.GetResult<Prisma.$StrategyPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    actionPlan<T extends BusinessContinuityPlan$actionPlanArgs<ExtArgs> = {}>(args?: Subset<T, BusinessContinuityPlan$actionPlanArgs<ExtArgs>>): Prisma__ActionPlanClient<$Result.GetResult<Prisma.$ActionPlanPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    contactsInformation<T extends BusinessContinuityPlan$contactsInformationArgs<ExtArgs> = {}>(args?: Subset<T, BusinessContinuityPlan$contactsInformationArgs<ExtArgs>>): Prisma__ContactsInformationClient<$Result.GetResult<Prisma.$ContactsInformationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    testingMaintenance<T extends BusinessContinuityPlan$testingMaintenanceArgs<ExtArgs> = {}>(args?: Subset<T, BusinessContinuityPlan$testingMaintenanceArgs<ExtArgs>>): Prisma__TestingMaintenanceClient<$Result.GetResult<Prisma.$TestingMaintenancePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BusinessContinuityPlan model
   */ 
  interface BusinessContinuityPlanFieldRefs {
    readonly id: FieldRef<"BusinessContinuityPlan", 'String'>
    readonly createdAt: FieldRef<"BusinessContinuityPlan", 'DateTime'>
    readonly updatedAt: FieldRef<"BusinessContinuityPlan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BusinessContinuityPlan findUnique
   */
  export type BusinessContinuityPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessContinuityPlan
     */
    select?: BusinessContinuityPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessContinuityPlanInclude<ExtArgs> | null
    /**
     * Filter, which BusinessContinuityPlan to fetch.
     */
    where: BusinessContinuityPlanWhereUniqueInput
  }

  /**
   * BusinessContinuityPlan findUniqueOrThrow
   */
  export type BusinessContinuityPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessContinuityPlan
     */
    select?: BusinessContinuityPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessContinuityPlanInclude<ExtArgs> | null
    /**
     * Filter, which BusinessContinuityPlan to fetch.
     */
    where: BusinessContinuityPlanWhereUniqueInput
  }

  /**
   * BusinessContinuityPlan findFirst
   */
  export type BusinessContinuityPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessContinuityPlan
     */
    select?: BusinessContinuityPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessContinuityPlanInclude<ExtArgs> | null
    /**
     * Filter, which BusinessContinuityPlan to fetch.
     */
    where?: BusinessContinuityPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessContinuityPlans to fetch.
     */
    orderBy?: BusinessContinuityPlanOrderByWithRelationInput | BusinessContinuityPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessContinuityPlans.
     */
    cursor?: BusinessContinuityPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessContinuityPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessContinuityPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessContinuityPlans.
     */
    distinct?: BusinessContinuityPlanScalarFieldEnum | BusinessContinuityPlanScalarFieldEnum[]
  }

  /**
   * BusinessContinuityPlan findFirstOrThrow
   */
  export type BusinessContinuityPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessContinuityPlan
     */
    select?: BusinessContinuityPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessContinuityPlanInclude<ExtArgs> | null
    /**
     * Filter, which BusinessContinuityPlan to fetch.
     */
    where?: BusinessContinuityPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessContinuityPlans to fetch.
     */
    orderBy?: BusinessContinuityPlanOrderByWithRelationInput | BusinessContinuityPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessContinuityPlans.
     */
    cursor?: BusinessContinuityPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessContinuityPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessContinuityPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessContinuityPlans.
     */
    distinct?: BusinessContinuityPlanScalarFieldEnum | BusinessContinuityPlanScalarFieldEnum[]
  }

  /**
   * BusinessContinuityPlan findMany
   */
  export type BusinessContinuityPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessContinuityPlan
     */
    select?: BusinessContinuityPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessContinuityPlanInclude<ExtArgs> | null
    /**
     * Filter, which BusinessContinuityPlans to fetch.
     */
    where?: BusinessContinuityPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessContinuityPlans to fetch.
     */
    orderBy?: BusinessContinuityPlanOrderByWithRelationInput | BusinessContinuityPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BusinessContinuityPlans.
     */
    cursor?: BusinessContinuityPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessContinuityPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessContinuityPlans.
     */
    skip?: number
    distinct?: BusinessContinuityPlanScalarFieldEnum | BusinessContinuityPlanScalarFieldEnum[]
  }

  /**
   * BusinessContinuityPlan create
   */
  export type BusinessContinuityPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessContinuityPlan
     */
    select?: BusinessContinuityPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessContinuityPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a BusinessContinuityPlan.
     */
    data: XOR<BusinessContinuityPlanCreateInput, BusinessContinuityPlanUncheckedCreateInput>
  }

  /**
   * BusinessContinuityPlan createMany
   */
  export type BusinessContinuityPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BusinessContinuityPlans.
     */
    data: BusinessContinuityPlanCreateManyInput | BusinessContinuityPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BusinessContinuityPlan createManyAndReturn
   */
  export type BusinessContinuityPlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessContinuityPlan
     */
    select?: BusinessContinuityPlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BusinessContinuityPlans.
     */
    data: BusinessContinuityPlanCreateManyInput | BusinessContinuityPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BusinessContinuityPlan update
   */
  export type BusinessContinuityPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessContinuityPlan
     */
    select?: BusinessContinuityPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessContinuityPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a BusinessContinuityPlan.
     */
    data: XOR<BusinessContinuityPlanUpdateInput, BusinessContinuityPlanUncheckedUpdateInput>
    /**
     * Choose, which BusinessContinuityPlan to update.
     */
    where: BusinessContinuityPlanWhereUniqueInput
  }

  /**
   * BusinessContinuityPlan updateMany
   */
  export type BusinessContinuityPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BusinessContinuityPlans.
     */
    data: XOR<BusinessContinuityPlanUpdateManyMutationInput, BusinessContinuityPlanUncheckedUpdateManyInput>
    /**
     * Filter which BusinessContinuityPlans to update
     */
    where?: BusinessContinuityPlanWhereInput
  }

  /**
   * BusinessContinuityPlan upsert
   */
  export type BusinessContinuityPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessContinuityPlan
     */
    select?: BusinessContinuityPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessContinuityPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the BusinessContinuityPlan to update in case it exists.
     */
    where: BusinessContinuityPlanWhereUniqueInput
    /**
     * In case the BusinessContinuityPlan found by the `where` argument doesn't exist, create a new BusinessContinuityPlan with this data.
     */
    create: XOR<BusinessContinuityPlanCreateInput, BusinessContinuityPlanUncheckedCreateInput>
    /**
     * In case the BusinessContinuityPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BusinessContinuityPlanUpdateInput, BusinessContinuityPlanUncheckedUpdateInput>
  }

  /**
   * BusinessContinuityPlan delete
   */
  export type BusinessContinuityPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessContinuityPlan
     */
    select?: BusinessContinuityPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessContinuityPlanInclude<ExtArgs> | null
    /**
     * Filter which BusinessContinuityPlan to delete.
     */
    where: BusinessContinuityPlanWhereUniqueInput
  }

  /**
   * BusinessContinuityPlan deleteMany
   */
  export type BusinessContinuityPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessContinuityPlans to delete
     */
    where?: BusinessContinuityPlanWhereInput
  }

  /**
   * BusinessContinuityPlan.planInformation
   */
  export type BusinessContinuityPlan$planInformationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanInformation
     */
    select?: PlanInformationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInformationInclude<ExtArgs> | null
    where?: PlanInformationWhereInput
  }

  /**
   * BusinessContinuityPlan.businessOverview
   */
  export type BusinessContinuityPlan$businessOverviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessOverview
     */
    select?: BusinessOverviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessOverviewInclude<ExtArgs> | null
    where?: BusinessOverviewWhereInput
  }

  /**
   * BusinessContinuityPlan.essentialFunction
   */
  export type BusinessContinuityPlan$essentialFunctionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EssentialFunction
     */
    select?: EssentialFunctionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EssentialFunctionInclude<ExtArgs> | null
    where?: EssentialFunctionWhereInput
  }

  /**
   * BusinessContinuityPlan.riskAssessment
   */
  export type BusinessContinuityPlan$riskAssessmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskAssessmentInclude<ExtArgs> | null
    where?: RiskAssessmentWhereInput
  }

  /**
   * BusinessContinuityPlan.strategy
   */
  export type BusinessContinuityPlan$strategyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Strategy
     */
    select?: StrategySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyInclude<ExtArgs> | null
    where?: StrategyWhereInput
  }

  /**
   * BusinessContinuityPlan.actionPlan
   */
  export type BusinessContinuityPlan$actionPlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionPlan
     */
    select?: ActionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionPlanInclude<ExtArgs> | null
    where?: ActionPlanWhereInput
  }

  /**
   * BusinessContinuityPlan.contactsInformation
   */
  export type BusinessContinuityPlan$contactsInformationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactsInformation
     */
    select?: ContactsInformationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactsInformationInclude<ExtArgs> | null
    where?: ContactsInformationWhereInput
  }

  /**
   * BusinessContinuityPlan.testingMaintenance
   */
  export type BusinessContinuityPlan$testingMaintenanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestingMaintenance
     */
    select?: TestingMaintenanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestingMaintenanceInclude<ExtArgs> | null
    where?: TestingMaintenanceWhereInput
  }

  /**
   * BusinessContinuityPlan without action
   */
  export type BusinessContinuityPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessContinuityPlan
     */
    select?: BusinessContinuityPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessContinuityPlanInclude<ExtArgs> | null
  }


  /**
   * Model PlanInformation
   */

  export type AggregatePlanInformation = {
    _count: PlanInformationCountAggregateOutputType | null
    _min: PlanInformationMinAggregateOutputType | null
    _max: PlanInformationMaxAggregateOutputType | null
  }

  export type PlanInformationMinAggregateOutputType = {
    id: string | null
    planId: string | null
    companyName: string | null
    planManager: string | null
    alternateManager: string | null
    physicalPlanLocation: string | null
    digitalPlanLocation: string | null
  }

  export type PlanInformationMaxAggregateOutputType = {
    id: string | null
    planId: string | null
    companyName: string | null
    planManager: string | null
    alternateManager: string | null
    physicalPlanLocation: string | null
    digitalPlanLocation: string | null
  }

  export type PlanInformationCountAggregateOutputType = {
    id: number
    planId: number
    companyName: number
    planManager: number
    alternateManager: number
    physicalPlanLocation: number
    digitalPlanLocation: number
    _all: number
  }


  export type PlanInformationMinAggregateInputType = {
    id?: true
    planId?: true
    companyName?: true
    planManager?: true
    alternateManager?: true
    physicalPlanLocation?: true
    digitalPlanLocation?: true
  }

  export type PlanInformationMaxAggregateInputType = {
    id?: true
    planId?: true
    companyName?: true
    planManager?: true
    alternateManager?: true
    physicalPlanLocation?: true
    digitalPlanLocation?: true
  }

  export type PlanInformationCountAggregateInputType = {
    id?: true
    planId?: true
    companyName?: true
    planManager?: true
    alternateManager?: true
    physicalPlanLocation?: true
    digitalPlanLocation?: true
    _all?: true
  }

  export type PlanInformationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlanInformation to aggregate.
     */
    where?: PlanInformationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanInformations to fetch.
     */
    orderBy?: PlanInformationOrderByWithRelationInput | PlanInformationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlanInformationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanInformations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanInformations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlanInformations
    **/
    _count?: true | PlanInformationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanInformationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanInformationMaxAggregateInputType
  }

  export type GetPlanInformationAggregateType<T extends PlanInformationAggregateArgs> = {
        [P in keyof T & keyof AggregatePlanInformation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlanInformation[P]>
      : GetScalarType<T[P], AggregatePlanInformation[P]>
  }




  export type PlanInformationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanInformationWhereInput
    orderBy?: PlanInformationOrderByWithAggregationInput | PlanInformationOrderByWithAggregationInput[]
    by: PlanInformationScalarFieldEnum[] | PlanInformationScalarFieldEnum
    having?: PlanInformationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanInformationCountAggregateInputType | true
    _min?: PlanInformationMinAggregateInputType
    _max?: PlanInformationMaxAggregateInputType
  }

  export type PlanInformationGroupByOutputType = {
    id: string
    planId: string
    companyName: string
    planManager: string
    alternateManager: string | null
    physicalPlanLocation: string
    digitalPlanLocation: string | null
    _count: PlanInformationCountAggregateOutputType | null
    _min: PlanInformationMinAggregateOutputType | null
    _max: PlanInformationMaxAggregateOutputType | null
  }

  type GetPlanInformationGroupByPayload<T extends PlanInformationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanInformationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanInformationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanInformationGroupByOutputType[P]>
            : GetScalarType<T[P], PlanInformationGroupByOutputType[P]>
        }
      >
    >


  export type PlanInformationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    companyName?: boolean
    planManager?: boolean
    alternateManager?: boolean
    physicalPlanLocation?: boolean
    digitalPlanLocation?: boolean
    plan?: boolean | BusinessContinuityPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planInformation"]>

  export type PlanInformationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    companyName?: boolean
    planManager?: boolean
    alternateManager?: boolean
    physicalPlanLocation?: boolean
    digitalPlanLocation?: boolean
    plan?: boolean | BusinessContinuityPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planInformation"]>

  export type PlanInformationSelectScalar = {
    id?: boolean
    planId?: boolean
    companyName?: boolean
    planManager?: boolean
    alternateManager?: boolean
    physicalPlanLocation?: boolean
    digitalPlanLocation?: boolean
  }

  export type PlanInformationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | BusinessContinuityPlanDefaultArgs<ExtArgs>
  }
  export type PlanInformationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | BusinessContinuityPlanDefaultArgs<ExtArgs>
  }

  export type $PlanInformationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlanInformation"
    objects: {
      plan: Prisma.$BusinessContinuityPlanPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      planId: string
      companyName: string
      planManager: string
      alternateManager: string | null
      physicalPlanLocation: string
      digitalPlanLocation: string | null
    }, ExtArgs["result"]["planInformation"]>
    composites: {}
  }

  type PlanInformationGetPayload<S extends boolean | null | undefined | PlanInformationDefaultArgs> = $Result.GetResult<Prisma.$PlanInformationPayload, S>

  type PlanInformationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PlanInformationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PlanInformationCountAggregateInputType | true
    }

  export interface PlanInformationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlanInformation'], meta: { name: 'PlanInformation' } }
    /**
     * Find zero or one PlanInformation that matches the filter.
     * @param {PlanInformationFindUniqueArgs} args - Arguments to find a PlanInformation
     * @example
     * // Get one PlanInformation
     * const planInformation = await prisma.planInformation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlanInformationFindUniqueArgs>(args: SelectSubset<T, PlanInformationFindUniqueArgs<ExtArgs>>): Prisma__PlanInformationClient<$Result.GetResult<Prisma.$PlanInformationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PlanInformation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PlanInformationFindUniqueOrThrowArgs} args - Arguments to find a PlanInformation
     * @example
     * // Get one PlanInformation
     * const planInformation = await prisma.planInformation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlanInformationFindUniqueOrThrowArgs>(args: SelectSubset<T, PlanInformationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlanInformationClient<$Result.GetResult<Prisma.$PlanInformationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PlanInformation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanInformationFindFirstArgs} args - Arguments to find a PlanInformation
     * @example
     * // Get one PlanInformation
     * const planInformation = await prisma.planInformation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlanInformationFindFirstArgs>(args?: SelectSubset<T, PlanInformationFindFirstArgs<ExtArgs>>): Prisma__PlanInformationClient<$Result.GetResult<Prisma.$PlanInformationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PlanInformation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanInformationFindFirstOrThrowArgs} args - Arguments to find a PlanInformation
     * @example
     * // Get one PlanInformation
     * const planInformation = await prisma.planInformation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlanInformationFindFirstOrThrowArgs>(args?: SelectSubset<T, PlanInformationFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlanInformationClient<$Result.GetResult<Prisma.$PlanInformationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PlanInformations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanInformationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlanInformations
     * const planInformations = await prisma.planInformation.findMany()
     * 
     * // Get first 10 PlanInformations
     * const planInformations = await prisma.planInformation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const planInformationWithIdOnly = await prisma.planInformation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlanInformationFindManyArgs>(args?: SelectSubset<T, PlanInformationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanInformationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PlanInformation.
     * @param {PlanInformationCreateArgs} args - Arguments to create a PlanInformation.
     * @example
     * // Create one PlanInformation
     * const PlanInformation = await prisma.planInformation.create({
     *   data: {
     *     // ... data to create a PlanInformation
     *   }
     * })
     * 
     */
    create<T extends PlanInformationCreateArgs>(args: SelectSubset<T, PlanInformationCreateArgs<ExtArgs>>): Prisma__PlanInformationClient<$Result.GetResult<Prisma.$PlanInformationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PlanInformations.
     * @param {PlanInformationCreateManyArgs} args - Arguments to create many PlanInformations.
     * @example
     * // Create many PlanInformations
     * const planInformation = await prisma.planInformation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlanInformationCreateManyArgs>(args?: SelectSubset<T, PlanInformationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlanInformations and returns the data saved in the database.
     * @param {PlanInformationCreateManyAndReturnArgs} args - Arguments to create many PlanInformations.
     * @example
     * // Create many PlanInformations
     * const planInformation = await prisma.planInformation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlanInformations and only return the `id`
     * const planInformationWithIdOnly = await prisma.planInformation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlanInformationCreateManyAndReturnArgs>(args?: SelectSubset<T, PlanInformationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanInformationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PlanInformation.
     * @param {PlanInformationDeleteArgs} args - Arguments to delete one PlanInformation.
     * @example
     * // Delete one PlanInformation
     * const PlanInformation = await prisma.planInformation.delete({
     *   where: {
     *     // ... filter to delete one PlanInformation
     *   }
     * })
     * 
     */
    delete<T extends PlanInformationDeleteArgs>(args: SelectSubset<T, PlanInformationDeleteArgs<ExtArgs>>): Prisma__PlanInformationClient<$Result.GetResult<Prisma.$PlanInformationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PlanInformation.
     * @param {PlanInformationUpdateArgs} args - Arguments to update one PlanInformation.
     * @example
     * // Update one PlanInformation
     * const planInformation = await prisma.planInformation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlanInformationUpdateArgs>(args: SelectSubset<T, PlanInformationUpdateArgs<ExtArgs>>): Prisma__PlanInformationClient<$Result.GetResult<Prisma.$PlanInformationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PlanInformations.
     * @param {PlanInformationDeleteManyArgs} args - Arguments to filter PlanInformations to delete.
     * @example
     * // Delete a few PlanInformations
     * const { count } = await prisma.planInformation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlanInformationDeleteManyArgs>(args?: SelectSubset<T, PlanInformationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlanInformations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanInformationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlanInformations
     * const planInformation = await prisma.planInformation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlanInformationUpdateManyArgs>(args: SelectSubset<T, PlanInformationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PlanInformation.
     * @param {PlanInformationUpsertArgs} args - Arguments to update or create a PlanInformation.
     * @example
     * // Update or create a PlanInformation
     * const planInformation = await prisma.planInformation.upsert({
     *   create: {
     *     // ... data to create a PlanInformation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlanInformation we want to update
     *   }
     * })
     */
    upsert<T extends PlanInformationUpsertArgs>(args: SelectSubset<T, PlanInformationUpsertArgs<ExtArgs>>): Prisma__PlanInformationClient<$Result.GetResult<Prisma.$PlanInformationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PlanInformations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanInformationCountArgs} args - Arguments to filter PlanInformations to count.
     * @example
     * // Count the number of PlanInformations
     * const count = await prisma.planInformation.count({
     *   where: {
     *     // ... the filter for the PlanInformations we want to count
     *   }
     * })
    **/
    count<T extends PlanInformationCountArgs>(
      args?: Subset<T, PlanInformationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanInformationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlanInformation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanInformationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanInformationAggregateArgs>(args: Subset<T, PlanInformationAggregateArgs>): Prisma.PrismaPromise<GetPlanInformationAggregateType<T>>

    /**
     * Group by PlanInformation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanInformationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlanInformationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanInformationGroupByArgs['orderBy'] }
        : { orderBy?: PlanInformationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlanInformationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanInformationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlanInformation model
   */
  readonly fields: PlanInformationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlanInformation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlanInformationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plan<T extends BusinessContinuityPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BusinessContinuityPlanDefaultArgs<ExtArgs>>): Prisma__BusinessContinuityPlanClient<$Result.GetResult<Prisma.$BusinessContinuityPlanPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlanInformation model
   */ 
  interface PlanInformationFieldRefs {
    readonly id: FieldRef<"PlanInformation", 'String'>
    readonly planId: FieldRef<"PlanInformation", 'String'>
    readonly companyName: FieldRef<"PlanInformation", 'String'>
    readonly planManager: FieldRef<"PlanInformation", 'String'>
    readonly alternateManager: FieldRef<"PlanInformation", 'String'>
    readonly physicalPlanLocation: FieldRef<"PlanInformation", 'String'>
    readonly digitalPlanLocation: FieldRef<"PlanInformation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PlanInformation findUnique
   */
  export type PlanInformationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanInformation
     */
    select?: PlanInformationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInformationInclude<ExtArgs> | null
    /**
     * Filter, which PlanInformation to fetch.
     */
    where: PlanInformationWhereUniqueInput
  }

  /**
   * PlanInformation findUniqueOrThrow
   */
  export type PlanInformationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanInformation
     */
    select?: PlanInformationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInformationInclude<ExtArgs> | null
    /**
     * Filter, which PlanInformation to fetch.
     */
    where: PlanInformationWhereUniqueInput
  }

  /**
   * PlanInformation findFirst
   */
  export type PlanInformationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanInformation
     */
    select?: PlanInformationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInformationInclude<ExtArgs> | null
    /**
     * Filter, which PlanInformation to fetch.
     */
    where?: PlanInformationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanInformations to fetch.
     */
    orderBy?: PlanInformationOrderByWithRelationInput | PlanInformationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlanInformations.
     */
    cursor?: PlanInformationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanInformations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanInformations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlanInformations.
     */
    distinct?: PlanInformationScalarFieldEnum | PlanInformationScalarFieldEnum[]
  }

  /**
   * PlanInformation findFirstOrThrow
   */
  export type PlanInformationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanInformation
     */
    select?: PlanInformationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInformationInclude<ExtArgs> | null
    /**
     * Filter, which PlanInformation to fetch.
     */
    where?: PlanInformationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanInformations to fetch.
     */
    orderBy?: PlanInformationOrderByWithRelationInput | PlanInformationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlanInformations.
     */
    cursor?: PlanInformationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanInformations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanInformations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlanInformations.
     */
    distinct?: PlanInformationScalarFieldEnum | PlanInformationScalarFieldEnum[]
  }

  /**
   * PlanInformation findMany
   */
  export type PlanInformationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanInformation
     */
    select?: PlanInformationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInformationInclude<ExtArgs> | null
    /**
     * Filter, which PlanInformations to fetch.
     */
    where?: PlanInformationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanInformations to fetch.
     */
    orderBy?: PlanInformationOrderByWithRelationInput | PlanInformationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlanInformations.
     */
    cursor?: PlanInformationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanInformations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanInformations.
     */
    skip?: number
    distinct?: PlanInformationScalarFieldEnum | PlanInformationScalarFieldEnum[]
  }

  /**
   * PlanInformation create
   */
  export type PlanInformationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanInformation
     */
    select?: PlanInformationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInformationInclude<ExtArgs> | null
    /**
     * The data needed to create a PlanInformation.
     */
    data: XOR<PlanInformationCreateInput, PlanInformationUncheckedCreateInput>
  }

  /**
   * PlanInformation createMany
   */
  export type PlanInformationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlanInformations.
     */
    data: PlanInformationCreateManyInput | PlanInformationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlanInformation createManyAndReturn
   */
  export type PlanInformationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanInformation
     */
    select?: PlanInformationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PlanInformations.
     */
    data: PlanInformationCreateManyInput | PlanInformationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInformationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlanInformation update
   */
  export type PlanInformationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanInformation
     */
    select?: PlanInformationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInformationInclude<ExtArgs> | null
    /**
     * The data needed to update a PlanInformation.
     */
    data: XOR<PlanInformationUpdateInput, PlanInformationUncheckedUpdateInput>
    /**
     * Choose, which PlanInformation to update.
     */
    where: PlanInformationWhereUniqueInput
  }

  /**
   * PlanInformation updateMany
   */
  export type PlanInformationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlanInformations.
     */
    data: XOR<PlanInformationUpdateManyMutationInput, PlanInformationUncheckedUpdateManyInput>
    /**
     * Filter which PlanInformations to update
     */
    where?: PlanInformationWhereInput
  }

  /**
   * PlanInformation upsert
   */
  export type PlanInformationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanInformation
     */
    select?: PlanInformationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInformationInclude<ExtArgs> | null
    /**
     * The filter to search for the PlanInformation to update in case it exists.
     */
    where: PlanInformationWhereUniqueInput
    /**
     * In case the PlanInformation found by the `where` argument doesn't exist, create a new PlanInformation with this data.
     */
    create: XOR<PlanInformationCreateInput, PlanInformationUncheckedCreateInput>
    /**
     * In case the PlanInformation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlanInformationUpdateInput, PlanInformationUncheckedUpdateInput>
  }

  /**
   * PlanInformation delete
   */
  export type PlanInformationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanInformation
     */
    select?: PlanInformationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInformationInclude<ExtArgs> | null
    /**
     * Filter which PlanInformation to delete.
     */
    where: PlanInformationWhereUniqueInput
  }

  /**
   * PlanInformation deleteMany
   */
  export type PlanInformationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlanInformations to delete
     */
    where?: PlanInformationWhereInput
  }

  /**
   * PlanInformation without action
   */
  export type PlanInformationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanInformation
     */
    select?: PlanInformationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInformationInclude<ExtArgs> | null
  }


  /**
   * Model BusinessOverview
   */

  export type AggregateBusinessOverview = {
    _count: BusinessOverviewCountAggregateOutputType | null
    _min: BusinessOverviewMinAggregateOutputType | null
    _max: BusinessOverviewMaxAggregateOutputType | null
  }

  export type BusinessOverviewMinAggregateOutputType = {
    id: string | null
    planId: string | null
    businessLicenseNumber: string | null
    businessPurpose: string | null
    productsAndServices: string | null
    serviceDeliveryMethods: string | null
    operatingHours: string | null
    keyPersonnel: string | null
    minimumResources: string | null
    customerBase: string | null
    serviceProviderBCP: string | null
  }

  export type BusinessOverviewMaxAggregateOutputType = {
    id: string | null
    planId: string | null
    businessLicenseNumber: string | null
    businessPurpose: string | null
    productsAndServices: string | null
    serviceDeliveryMethods: string | null
    operatingHours: string | null
    keyPersonnel: string | null
    minimumResources: string | null
    customerBase: string | null
    serviceProviderBCP: string | null
  }

  export type BusinessOverviewCountAggregateOutputType = {
    id: number
    planId: number
    businessLicenseNumber: number
    businessPurpose: number
    productsAndServices: number
    serviceDeliveryMethods: number
    operatingHours: number
    keyPersonnel: number
    minimumResources: number
    customerBase: number
    serviceProviderBCP: number
    _all: number
  }


  export type BusinessOverviewMinAggregateInputType = {
    id?: true
    planId?: true
    businessLicenseNumber?: true
    businessPurpose?: true
    productsAndServices?: true
    serviceDeliveryMethods?: true
    operatingHours?: true
    keyPersonnel?: true
    minimumResources?: true
    customerBase?: true
    serviceProviderBCP?: true
  }

  export type BusinessOverviewMaxAggregateInputType = {
    id?: true
    planId?: true
    businessLicenseNumber?: true
    businessPurpose?: true
    productsAndServices?: true
    serviceDeliveryMethods?: true
    operatingHours?: true
    keyPersonnel?: true
    minimumResources?: true
    customerBase?: true
    serviceProviderBCP?: true
  }

  export type BusinessOverviewCountAggregateInputType = {
    id?: true
    planId?: true
    businessLicenseNumber?: true
    businessPurpose?: true
    productsAndServices?: true
    serviceDeliveryMethods?: true
    operatingHours?: true
    keyPersonnel?: true
    minimumResources?: true
    customerBase?: true
    serviceProviderBCP?: true
    _all?: true
  }

  export type BusinessOverviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessOverview to aggregate.
     */
    where?: BusinessOverviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessOverviews to fetch.
     */
    orderBy?: BusinessOverviewOrderByWithRelationInput | BusinessOverviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BusinessOverviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessOverviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessOverviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BusinessOverviews
    **/
    _count?: true | BusinessOverviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BusinessOverviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BusinessOverviewMaxAggregateInputType
  }

  export type GetBusinessOverviewAggregateType<T extends BusinessOverviewAggregateArgs> = {
        [P in keyof T & keyof AggregateBusinessOverview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBusinessOverview[P]>
      : GetScalarType<T[P], AggregateBusinessOverview[P]>
  }




  export type BusinessOverviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessOverviewWhereInput
    orderBy?: BusinessOverviewOrderByWithAggregationInput | BusinessOverviewOrderByWithAggregationInput[]
    by: BusinessOverviewScalarFieldEnum[] | BusinessOverviewScalarFieldEnum
    having?: BusinessOverviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BusinessOverviewCountAggregateInputType | true
    _min?: BusinessOverviewMinAggregateInputType
    _max?: BusinessOverviewMaxAggregateInputType
  }

  export type BusinessOverviewGroupByOutputType = {
    id: string
    planId: string
    businessLicenseNumber: string
    businessPurpose: string
    productsAndServices: string
    serviceDeliveryMethods: string
    operatingHours: string
    keyPersonnel: string
    minimumResources: string
    customerBase: string
    serviceProviderBCP: string
    _count: BusinessOverviewCountAggregateOutputType | null
    _min: BusinessOverviewMinAggregateOutputType | null
    _max: BusinessOverviewMaxAggregateOutputType | null
  }

  type GetBusinessOverviewGroupByPayload<T extends BusinessOverviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BusinessOverviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BusinessOverviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BusinessOverviewGroupByOutputType[P]>
            : GetScalarType<T[P], BusinessOverviewGroupByOutputType[P]>
        }
      >
    >


  export type BusinessOverviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    businessLicenseNumber?: boolean
    businessPurpose?: boolean
    productsAndServices?: boolean
    serviceDeliveryMethods?: boolean
    operatingHours?: boolean
    keyPersonnel?: boolean
    minimumResources?: boolean
    customerBase?: boolean
    serviceProviderBCP?: boolean
    plan?: boolean | BusinessContinuityPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["businessOverview"]>

  export type BusinessOverviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    businessLicenseNumber?: boolean
    businessPurpose?: boolean
    productsAndServices?: boolean
    serviceDeliveryMethods?: boolean
    operatingHours?: boolean
    keyPersonnel?: boolean
    minimumResources?: boolean
    customerBase?: boolean
    serviceProviderBCP?: boolean
    plan?: boolean | BusinessContinuityPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["businessOverview"]>

  export type BusinessOverviewSelectScalar = {
    id?: boolean
    planId?: boolean
    businessLicenseNumber?: boolean
    businessPurpose?: boolean
    productsAndServices?: boolean
    serviceDeliveryMethods?: boolean
    operatingHours?: boolean
    keyPersonnel?: boolean
    minimumResources?: boolean
    customerBase?: boolean
    serviceProviderBCP?: boolean
  }

  export type BusinessOverviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | BusinessContinuityPlanDefaultArgs<ExtArgs>
  }
  export type BusinessOverviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | BusinessContinuityPlanDefaultArgs<ExtArgs>
  }

  export type $BusinessOverviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BusinessOverview"
    objects: {
      plan: Prisma.$BusinessContinuityPlanPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      planId: string
      businessLicenseNumber: string
      businessPurpose: string
      productsAndServices: string
      serviceDeliveryMethods: string
      operatingHours: string
      keyPersonnel: string
      minimumResources: string
      customerBase: string
      serviceProviderBCP: string
    }, ExtArgs["result"]["businessOverview"]>
    composites: {}
  }

  type BusinessOverviewGetPayload<S extends boolean | null | undefined | BusinessOverviewDefaultArgs> = $Result.GetResult<Prisma.$BusinessOverviewPayload, S>

  type BusinessOverviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BusinessOverviewFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BusinessOverviewCountAggregateInputType | true
    }

  export interface BusinessOverviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BusinessOverview'], meta: { name: 'BusinessOverview' } }
    /**
     * Find zero or one BusinessOverview that matches the filter.
     * @param {BusinessOverviewFindUniqueArgs} args - Arguments to find a BusinessOverview
     * @example
     * // Get one BusinessOverview
     * const businessOverview = await prisma.businessOverview.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BusinessOverviewFindUniqueArgs>(args: SelectSubset<T, BusinessOverviewFindUniqueArgs<ExtArgs>>): Prisma__BusinessOverviewClient<$Result.GetResult<Prisma.$BusinessOverviewPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BusinessOverview that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BusinessOverviewFindUniqueOrThrowArgs} args - Arguments to find a BusinessOverview
     * @example
     * // Get one BusinessOverview
     * const businessOverview = await prisma.businessOverview.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BusinessOverviewFindUniqueOrThrowArgs>(args: SelectSubset<T, BusinessOverviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BusinessOverviewClient<$Result.GetResult<Prisma.$BusinessOverviewPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BusinessOverview that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessOverviewFindFirstArgs} args - Arguments to find a BusinessOverview
     * @example
     * // Get one BusinessOverview
     * const businessOverview = await prisma.businessOverview.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BusinessOverviewFindFirstArgs>(args?: SelectSubset<T, BusinessOverviewFindFirstArgs<ExtArgs>>): Prisma__BusinessOverviewClient<$Result.GetResult<Prisma.$BusinessOverviewPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BusinessOverview that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessOverviewFindFirstOrThrowArgs} args - Arguments to find a BusinessOverview
     * @example
     * // Get one BusinessOverview
     * const businessOverview = await prisma.businessOverview.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BusinessOverviewFindFirstOrThrowArgs>(args?: SelectSubset<T, BusinessOverviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__BusinessOverviewClient<$Result.GetResult<Prisma.$BusinessOverviewPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BusinessOverviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessOverviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BusinessOverviews
     * const businessOverviews = await prisma.businessOverview.findMany()
     * 
     * // Get first 10 BusinessOverviews
     * const businessOverviews = await prisma.businessOverview.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const businessOverviewWithIdOnly = await prisma.businessOverview.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BusinessOverviewFindManyArgs>(args?: SelectSubset<T, BusinessOverviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessOverviewPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BusinessOverview.
     * @param {BusinessOverviewCreateArgs} args - Arguments to create a BusinessOverview.
     * @example
     * // Create one BusinessOverview
     * const BusinessOverview = await prisma.businessOverview.create({
     *   data: {
     *     // ... data to create a BusinessOverview
     *   }
     * })
     * 
     */
    create<T extends BusinessOverviewCreateArgs>(args: SelectSubset<T, BusinessOverviewCreateArgs<ExtArgs>>): Prisma__BusinessOverviewClient<$Result.GetResult<Prisma.$BusinessOverviewPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BusinessOverviews.
     * @param {BusinessOverviewCreateManyArgs} args - Arguments to create many BusinessOverviews.
     * @example
     * // Create many BusinessOverviews
     * const businessOverview = await prisma.businessOverview.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BusinessOverviewCreateManyArgs>(args?: SelectSubset<T, BusinessOverviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BusinessOverviews and returns the data saved in the database.
     * @param {BusinessOverviewCreateManyAndReturnArgs} args - Arguments to create many BusinessOverviews.
     * @example
     * // Create many BusinessOverviews
     * const businessOverview = await prisma.businessOverview.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BusinessOverviews and only return the `id`
     * const businessOverviewWithIdOnly = await prisma.businessOverview.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BusinessOverviewCreateManyAndReturnArgs>(args?: SelectSubset<T, BusinessOverviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessOverviewPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BusinessOverview.
     * @param {BusinessOverviewDeleteArgs} args - Arguments to delete one BusinessOverview.
     * @example
     * // Delete one BusinessOverview
     * const BusinessOverview = await prisma.businessOverview.delete({
     *   where: {
     *     // ... filter to delete one BusinessOverview
     *   }
     * })
     * 
     */
    delete<T extends BusinessOverviewDeleteArgs>(args: SelectSubset<T, BusinessOverviewDeleteArgs<ExtArgs>>): Prisma__BusinessOverviewClient<$Result.GetResult<Prisma.$BusinessOverviewPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BusinessOverview.
     * @param {BusinessOverviewUpdateArgs} args - Arguments to update one BusinessOverview.
     * @example
     * // Update one BusinessOverview
     * const businessOverview = await prisma.businessOverview.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BusinessOverviewUpdateArgs>(args: SelectSubset<T, BusinessOverviewUpdateArgs<ExtArgs>>): Prisma__BusinessOverviewClient<$Result.GetResult<Prisma.$BusinessOverviewPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BusinessOverviews.
     * @param {BusinessOverviewDeleteManyArgs} args - Arguments to filter BusinessOverviews to delete.
     * @example
     * // Delete a few BusinessOverviews
     * const { count } = await prisma.businessOverview.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BusinessOverviewDeleteManyArgs>(args?: SelectSubset<T, BusinessOverviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BusinessOverviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessOverviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BusinessOverviews
     * const businessOverview = await prisma.businessOverview.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BusinessOverviewUpdateManyArgs>(args: SelectSubset<T, BusinessOverviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BusinessOverview.
     * @param {BusinessOverviewUpsertArgs} args - Arguments to update or create a BusinessOverview.
     * @example
     * // Update or create a BusinessOverview
     * const businessOverview = await prisma.businessOverview.upsert({
     *   create: {
     *     // ... data to create a BusinessOverview
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BusinessOverview we want to update
     *   }
     * })
     */
    upsert<T extends BusinessOverviewUpsertArgs>(args: SelectSubset<T, BusinessOverviewUpsertArgs<ExtArgs>>): Prisma__BusinessOverviewClient<$Result.GetResult<Prisma.$BusinessOverviewPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BusinessOverviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessOverviewCountArgs} args - Arguments to filter BusinessOverviews to count.
     * @example
     * // Count the number of BusinessOverviews
     * const count = await prisma.businessOverview.count({
     *   where: {
     *     // ... the filter for the BusinessOverviews we want to count
     *   }
     * })
    **/
    count<T extends BusinessOverviewCountArgs>(
      args?: Subset<T, BusinessOverviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BusinessOverviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BusinessOverview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessOverviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BusinessOverviewAggregateArgs>(args: Subset<T, BusinessOverviewAggregateArgs>): Prisma.PrismaPromise<GetBusinessOverviewAggregateType<T>>

    /**
     * Group by BusinessOverview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessOverviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BusinessOverviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BusinessOverviewGroupByArgs['orderBy'] }
        : { orderBy?: BusinessOverviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BusinessOverviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBusinessOverviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BusinessOverview model
   */
  readonly fields: BusinessOverviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BusinessOverview.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BusinessOverviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plan<T extends BusinessContinuityPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BusinessContinuityPlanDefaultArgs<ExtArgs>>): Prisma__BusinessContinuityPlanClient<$Result.GetResult<Prisma.$BusinessContinuityPlanPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BusinessOverview model
   */ 
  interface BusinessOverviewFieldRefs {
    readonly id: FieldRef<"BusinessOverview", 'String'>
    readonly planId: FieldRef<"BusinessOverview", 'String'>
    readonly businessLicenseNumber: FieldRef<"BusinessOverview", 'String'>
    readonly businessPurpose: FieldRef<"BusinessOverview", 'String'>
    readonly productsAndServices: FieldRef<"BusinessOverview", 'String'>
    readonly serviceDeliveryMethods: FieldRef<"BusinessOverview", 'String'>
    readonly operatingHours: FieldRef<"BusinessOverview", 'String'>
    readonly keyPersonnel: FieldRef<"BusinessOverview", 'String'>
    readonly minimumResources: FieldRef<"BusinessOverview", 'String'>
    readonly customerBase: FieldRef<"BusinessOverview", 'String'>
    readonly serviceProviderBCP: FieldRef<"BusinessOverview", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BusinessOverview findUnique
   */
  export type BusinessOverviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessOverview
     */
    select?: BusinessOverviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessOverviewInclude<ExtArgs> | null
    /**
     * Filter, which BusinessOverview to fetch.
     */
    where: BusinessOverviewWhereUniqueInput
  }

  /**
   * BusinessOverview findUniqueOrThrow
   */
  export type BusinessOverviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessOverview
     */
    select?: BusinessOverviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessOverviewInclude<ExtArgs> | null
    /**
     * Filter, which BusinessOverview to fetch.
     */
    where: BusinessOverviewWhereUniqueInput
  }

  /**
   * BusinessOverview findFirst
   */
  export type BusinessOverviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessOverview
     */
    select?: BusinessOverviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessOverviewInclude<ExtArgs> | null
    /**
     * Filter, which BusinessOverview to fetch.
     */
    where?: BusinessOverviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessOverviews to fetch.
     */
    orderBy?: BusinessOverviewOrderByWithRelationInput | BusinessOverviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessOverviews.
     */
    cursor?: BusinessOverviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessOverviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessOverviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessOverviews.
     */
    distinct?: BusinessOverviewScalarFieldEnum | BusinessOverviewScalarFieldEnum[]
  }

  /**
   * BusinessOverview findFirstOrThrow
   */
  export type BusinessOverviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessOverview
     */
    select?: BusinessOverviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessOverviewInclude<ExtArgs> | null
    /**
     * Filter, which BusinessOverview to fetch.
     */
    where?: BusinessOverviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessOverviews to fetch.
     */
    orderBy?: BusinessOverviewOrderByWithRelationInput | BusinessOverviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessOverviews.
     */
    cursor?: BusinessOverviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessOverviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessOverviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessOverviews.
     */
    distinct?: BusinessOverviewScalarFieldEnum | BusinessOverviewScalarFieldEnum[]
  }

  /**
   * BusinessOverview findMany
   */
  export type BusinessOverviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessOverview
     */
    select?: BusinessOverviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessOverviewInclude<ExtArgs> | null
    /**
     * Filter, which BusinessOverviews to fetch.
     */
    where?: BusinessOverviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessOverviews to fetch.
     */
    orderBy?: BusinessOverviewOrderByWithRelationInput | BusinessOverviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BusinessOverviews.
     */
    cursor?: BusinessOverviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessOverviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessOverviews.
     */
    skip?: number
    distinct?: BusinessOverviewScalarFieldEnum | BusinessOverviewScalarFieldEnum[]
  }

  /**
   * BusinessOverview create
   */
  export type BusinessOverviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessOverview
     */
    select?: BusinessOverviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessOverviewInclude<ExtArgs> | null
    /**
     * The data needed to create a BusinessOverview.
     */
    data: XOR<BusinessOverviewCreateInput, BusinessOverviewUncheckedCreateInput>
  }

  /**
   * BusinessOverview createMany
   */
  export type BusinessOverviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BusinessOverviews.
     */
    data: BusinessOverviewCreateManyInput | BusinessOverviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BusinessOverview createManyAndReturn
   */
  export type BusinessOverviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessOverview
     */
    select?: BusinessOverviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BusinessOverviews.
     */
    data: BusinessOverviewCreateManyInput | BusinessOverviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessOverviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BusinessOverview update
   */
  export type BusinessOverviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessOverview
     */
    select?: BusinessOverviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessOverviewInclude<ExtArgs> | null
    /**
     * The data needed to update a BusinessOverview.
     */
    data: XOR<BusinessOverviewUpdateInput, BusinessOverviewUncheckedUpdateInput>
    /**
     * Choose, which BusinessOverview to update.
     */
    where: BusinessOverviewWhereUniqueInput
  }

  /**
   * BusinessOverview updateMany
   */
  export type BusinessOverviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BusinessOverviews.
     */
    data: XOR<BusinessOverviewUpdateManyMutationInput, BusinessOverviewUncheckedUpdateManyInput>
    /**
     * Filter which BusinessOverviews to update
     */
    where?: BusinessOverviewWhereInput
  }

  /**
   * BusinessOverview upsert
   */
  export type BusinessOverviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessOverview
     */
    select?: BusinessOverviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessOverviewInclude<ExtArgs> | null
    /**
     * The filter to search for the BusinessOverview to update in case it exists.
     */
    where: BusinessOverviewWhereUniqueInput
    /**
     * In case the BusinessOverview found by the `where` argument doesn't exist, create a new BusinessOverview with this data.
     */
    create: XOR<BusinessOverviewCreateInput, BusinessOverviewUncheckedCreateInput>
    /**
     * In case the BusinessOverview was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BusinessOverviewUpdateInput, BusinessOverviewUncheckedUpdateInput>
  }

  /**
   * BusinessOverview delete
   */
  export type BusinessOverviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessOverview
     */
    select?: BusinessOverviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessOverviewInclude<ExtArgs> | null
    /**
     * Filter which BusinessOverview to delete.
     */
    where: BusinessOverviewWhereUniqueInput
  }

  /**
   * BusinessOverview deleteMany
   */
  export type BusinessOverviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessOverviews to delete
     */
    where?: BusinessOverviewWhereInput
  }

  /**
   * BusinessOverview without action
   */
  export type BusinessOverviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessOverview
     */
    select?: BusinessOverviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessOverviewInclude<ExtArgs> | null
  }


  /**
   * Model EssentialFunction
   */

  export type AggregateEssentialFunction = {
    _count: EssentialFunctionCountAggregateOutputType | null
    _min: EssentialFunctionMinAggregateOutputType | null
    _max: EssentialFunctionMaxAggregateOutputType | null
  }

  export type EssentialFunctionMinAggregateOutputType = {
    id: string | null
    planId: string | null
    supplyChainManagement: string | null
    staffManagement: string | null
    technology: string | null
    productsServices: string | null
    infrastructureFacilities: string | null
    sales: string | null
    administration: string | null
  }

  export type EssentialFunctionMaxAggregateOutputType = {
    id: string | null
    planId: string | null
    supplyChainManagement: string | null
    staffManagement: string | null
    technology: string | null
    productsServices: string | null
    infrastructureFacilities: string | null
    sales: string | null
    administration: string | null
  }

  export type EssentialFunctionCountAggregateOutputType = {
    id: number
    planId: number
    supplyChainManagement: number
    staffManagement: number
    technology: number
    productsServices: number
    infrastructureFacilities: number
    sales: number
    administration: number
    _all: number
  }


  export type EssentialFunctionMinAggregateInputType = {
    id?: true
    planId?: true
    supplyChainManagement?: true
    staffManagement?: true
    technology?: true
    productsServices?: true
    infrastructureFacilities?: true
    sales?: true
    administration?: true
  }

  export type EssentialFunctionMaxAggregateInputType = {
    id?: true
    planId?: true
    supplyChainManagement?: true
    staffManagement?: true
    technology?: true
    productsServices?: true
    infrastructureFacilities?: true
    sales?: true
    administration?: true
  }

  export type EssentialFunctionCountAggregateInputType = {
    id?: true
    planId?: true
    supplyChainManagement?: true
    staffManagement?: true
    technology?: true
    productsServices?: true
    infrastructureFacilities?: true
    sales?: true
    administration?: true
    _all?: true
  }

  export type EssentialFunctionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EssentialFunction to aggregate.
     */
    where?: EssentialFunctionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EssentialFunctions to fetch.
     */
    orderBy?: EssentialFunctionOrderByWithRelationInput | EssentialFunctionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EssentialFunctionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EssentialFunctions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EssentialFunctions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EssentialFunctions
    **/
    _count?: true | EssentialFunctionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EssentialFunctionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EssentialFunctionMaxAggregateInputType
  }

  export type GetEssentialFunctionAggregateType<T extends EssentialFunctionAggregateArgs> = {
        [P in keyof T & keyof AggregateEssentialFunction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEssentialFunction[P]>
      : GetScalarType<T[P], AggregateEssentialFunction[P]>
  }




  export type EssentialFunctionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EssentialFunctionWhereInput
    orderBy?: EssentialFunctionOrderByWithAggregationInput | EssentialFunctionOrderByWithAggregationInput[]
    by: EssentialFunctionScalarFieldEnum[] | EssentialFunctionScalarFieldEnum
    having?: EssentialFunctionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EssentialFunctionCountAggregateInputType | true
    _min?: EssentialFunctionMinAggregateInputType
    _max?: EssentialFunctionMaxAggregateInputType
  }

  export type EssentialFunctionGroupByOutputType = {
    id: string
    planId: string
    supplyChainManagement: string
    staffManagement: string
    technology: string
    productsServices: string
    infrastructureFacilities: string
    sales: string
    administration: string
    _count: EssentialFunctionCountAggregateOutputType | null
    _min: EssentialFunctionMinAggregateOutputType | null
    _max: EssentialFunctionMaxAggregateOutputType | null
  }

  type GetEssentialFunctionGroupByPayload<T extends EssentialFunctionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EssentialFunctionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EssentialFunctionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EssentialFunctionGroupByOutputType[P]>
            : GetScalarType<T[P], EssentialFunctionGroupByOutputType[P]>
        }
      >
    >


  export type EssentialFunctionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    supplyChainManagement?: boolean
    staffManagement?: boolean
    technology?: boolean
    productsServices?: boolean
    infrastructureFacilities?: boolean
    sales?: boolean
    administration?: boolean
    plan?: boolean | BusinessContinuityPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["essentialFunction"]>

  export type EssentialFunctionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    supplyChainManagement?: boolean
    staffManagement?: boolean
    technology?: boolean
    productsServices?: boolean
    infrastructureFacilities?: boolean
    sales?: boolean
    administration?: boolean
    plan?: boolean | BusinessContinuityPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["essentialFunction"]>

  export type EssentialFunctionSelectScalar = {
    id?: boolean
    planId?: boolean
    supplyChainManagement?: boolean
    staffManagement?: boolean
    technology?: boolean
    productsServices?: boolean
    infrastructureFacilities?: boolean
    sales?: boolean
    administration?: boolean
  }

  export type EssentialFunctionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | BusinessContinuityPlanDefaultArgs<ExtArgs>
  }
  export type EssentialFunctionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | BusinessContinuityPlanDefaultArgs<ExtArgs>
  }

  export type $EssentialFunctionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EssentialFunction"
    objects: {
      plan: Prisma.$BusinessContinuityPlanPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      planId: string
      supplyChainManagement: string
      staffManagement: string
      technology: string
      productsServices: string
      infrastructureFacilities: string
      sales: string
      administration: string
    }, ExtArgs["result"]["essentialFunction"]>
    composites: {}
  }

  type EssentialFunctionGetPayload<S extends boolean | null | undefined | EssentialFunctionDefaultArgs> = $Result.GetResult<Prisma.$EssentialFunctionPayload, S>

  type EssentialFunctionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EssentialFunctionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EssentialFunctionCountAggregateInputType | true
    }

  export interface EssentialFunctionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EssentialFunction'], meta: { name: 'EssentialFunction' } }
    /**
     * Find zero or one EssentialFunction that matches the filter.
     * @param {EssentialFunctionFindUniqueArgs} args - Arguments to find a EssentialFunction
     * @example
     * // Get one EssentialFunction
     * const essentialFunction = await prisma.essentialFunction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EssentialFunctionFindUniqueArgs>(args: SelectSubset<T, EssentialFunctionFindUniqueArgs<ExtArgs>>): Prisma__EssentialFunctionClient<$Result.GetResult<Prisma.$EssentialFunctionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EssentialFunction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EssentialFunctionFindUniqueOrThrowArgs} args - Arguments to find a EssentialFunction
     * @example
     * // Get one EssentialFunction
     * const essentialFunction = await prisma.essentialFunction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EssentialFunctionFindUniqueOrThrowArgs>(args: SelectSubset<T, EssentialFunctionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EssentialFunctionClient<$Result.GetResult<Prisma.$EssentialFunctionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EssentialFunction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EssentialFunctionFindFirstArgs} args - Arguments to find a EssentialFunction
     * @example
     * // Get one EssentialFunction
     * const essentialFunction = await prisma.essentialFunction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EssentialFunctionFindFirstArgs>(args?: SelectSubset<T, EssentialFunctionFindFirstArgs<ExtArgs>>): Prisma__EssentialFunctionClient<$Result.GetResult<Prisma.$EssentialFunctionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EssentialFunction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EssentialFunctionFindFirstOrThrowArgs} args - Arguments to find a EssentialFunction
     * @example
     * // Get one EssentialFunction
     * const essentialFunction = await prisma.essentialFunction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EssentialFunctionFindFirstOrThrowArgs>(args?: SelectSubset<T, EssentialFunctionFindFirstOrThrowArgs<ExtArgs>>): Prisma__EssentialFunctionClient<$Result.GetResult<Prisma.$EssentialFunctionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EssentialFunctions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EssentialFunctionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EssentialFunctions
     * const essentialFunctions = await prisma.essentialFunction.findMany()
     * 
     * // Get first 10 EssentialFunctions
     * const essentialFunctions = await prisma.essentialFunction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const essentialFunctionWithIdOnly = await prisma.essentialFunction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EssentialFunctionFindManyArgs>(args?: SelectSubset<T, EssentialFunctionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EssentialFunctionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EssentialFunction.
     * @param {EssentialFunctionCreateArgs} args - Arguments to create a EssentialFunction.
     * @example
     * // Create one EssentialFunction
     * const EssentialFunction = await prisma.essentialFunction.create({
     *   data: {
     *     // ... data to create a EssentialFunction
     *   }
     * })
     * 
     */
    create<T extends EssentialFunctionCreateArgs>(args: SelectSubset<T, EssentialFunctionCreateArgs<ExtArgs>>): Prisma__EssentialFunctionClient<$Result.GetResult<Prisma.$EssentialFunctionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EssentialFunctions.
     * @param {EssentialFunctionCreateManyArgs} args - Arguments to create many EssentialFunctions.
     * @example
     * // Create many EssentialFunctions
     * const essentialFunction = await prisma.essentialFunction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EssentialFunctionCreateManyArgs>(args?: SelectSubset<T, EssentialFunctionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EssentialFunctions and returns the data saved in the database.
     * @param {EssentialFunctionCreateManyAndReturnArgs} args - Arguments to create many EssentialFunctions.
     * @example
     * // Create many EssentialFunctions
     * const essentialFunction = await prisma.essentialFunction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EssentialFunctions and only return the `id`
     * const essentialFunctionWithIdOnly = await prisma.essentialFunction.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EssentialFunctionCreateManyAndReturnArgs>(args?: SelectSubset<T, EssentialFunctionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EssentialFunctionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EssentialFunction.
     * @param {EssentialFunctionDeleteArgs} args - Arguments to delete one EssentialFunction.
     * @example
     * // Delete one EssentialFunction
     * const EssentialFunction = await prisma.essentialFunction.delete({
     *   where: {
     *     // ... filter to delete one EssentialFunction
     *   }
     * })
     * 
     */
    delete<T extends EssentialFunctionDeleteArgs>(args: SelectSubset<T, EssentialFunctionDeleteArgs<ExtArgs>>): Prisma__EssentialFunctionClient<$Result.GetResult<Prisma.$EssentialFunctionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EssentialFunction.
     * @param {EssentialFunctionUpdateArgs} args - Arguments to update one EssentialFunction.
     * @example
     * // Update one EssentialFunction
     * const essentialFunction = await prisma.essentialFunction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EssentialFunctionUpdateArgs>(args: SelectSubset<T, EssentialFunctionUpdateArgs<ExtArgs>>): Prisma__EssentialFunctionClient<$Result.GetResult<Prisma.$EssentialFunctionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EssentialFunctions.
     * @param {EssentialFunctionDeleteManyArgs} args - Arguments to filter EssentialFunctions to delete.
     * @example
     * // Delete a few EssentialFunctions
     * const { count } = await prisma.essentialFunction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EssentialFunctionDeleteManyArgs>(args?: SelectSubset<T, EssentialFunctionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EssentialFunctions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EssentialFunctionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EssentialFunctions
     * const essentialFunction = await prisma.essentialFunction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EssentialFunctionUpdateManyArgs>(args: SelectSubset<T, EssentialFunctionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EssentialFunction.
     * @param {EssentialFunctionUpsertArgs} args - Arguments to update or create a EssentialFunction.
     * @example
     * // Update or create a EssentialFunction
     * const essentialFunction = await prisma.essentialFunction.upsert({
     *   create: {
     *     // ... data to create a EssentialFunction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EssentialFunction we want to update
     *   }
     * })
     */
    upsert<T extends EssentialFunctionUpsertArgs>(args: SelectSubset<T, EssentialFunctionUpsertArgs<ExtArgs>>): Prisma__EssentialFunctionClient<$Result.GetResult<Prisma.$EssentialFunctionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EssentialFunctions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EssentialFunctionCountArgs} args - Arguments to filter EssentialFunctions to count.
     * @example
     * // Count the number of EssentialFunctions
     * const count = await prisma.essentialFunction.count({
     *   where: {
     *     // ... the filter for the EssentialFunctions we want to count
     *   }
     * })
    **/
    count<T extends EssentialFunctionCountArgs>(
      args?: Subset<T, EssentialFunctionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EssentialFunctionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EssentialFunction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EssentialFunctionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EssentialFunctionAggregateArgs>(args: Subset<T, EssentialFunctionAggregateArgs>): Prisma.PrismaPromise<GetEssentialFunctionAggregateType<T>>

    /**
     * Group by EssentialFunction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EssentialFunctionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EssentialFunctionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EssentialFunctionGroupByArgs['orderBy'] }
        : { orderBy?: EssentialFunctionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EssentialFunctionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEssentialFunctionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EssentialFunction model
   */
  readonly fields: EssentialFunctionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EssentialFunction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EssentialFunctionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plan<T extends BusinessContinuityPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BusinessContinuityPlanDefaultArgs<ExtArgs>>): Prisma__BusinessContinuityPlanClient<$Result.GetResult<Prisma.$BusinessContinuityPlanPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EssentialFunction model
   */ 
  interface EssentialFunctionFieldRefs {
    readonly id: FieldRef<"EssentialFunction", 'String'>
    readonly planId: FieldRef<"EssentialFunction", 'String'>
    readonly supplyChainManagement: FieldRef<"EssentialFunction", 'String'>
    readonly staffManagement: FieldRef<"EssentialFunction", 'String'>
    readonly technology: FieldRef<"EssentialFunction", 'String'>
    readonly productsServices: FieldRef<"EssentialFunction", 'String'>
    readonly infrastructureFacilities: FieldRef<"EssentialFunction", 'String'>
    readonly sales: FieldRef<"EssentialFunction", 'String'>
    readonly administration: FieldRef<"EssentialFunction", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EssentialFunction findUnique
   */
  export type EssentialFunctionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EssentialFunction
     */
    select?: EssentialFunctionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EssentialFunctionInclude<ExtArgs> | null
    /**
     * Filter, which EssentialFunction to fetch.
     */
    where: EssentialFunctionWhereUniqueInput
  }

  /**
   * EssentialFunction findUniqueOrThrow
   */
  export type EssentialFunctionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EssentialFunction
     */
    select?: EssentialFunctionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EssentialFunctionInclude<ExtArgs> | null
    /**
     * Filter, which EssentialFunction to fetch.
     */
    where: EssentialFunctionWhereUniqueInput
  }

  /**
   * EssentialFunction findFirst
   */
  export type EssentialFunctionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EssentialFunction
     */
    select?: EssentialFunctionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EssentialFunctionInclude<ExtArgs> | null
    /**
     * Filter, which EssentialFunction to fetch.
     */
    where?: EssentialFunctionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EssentialFunctions to fetch.
     */
    orderBy?: EssentialFunctionOrderByWithRelationInput | EssentialFunctionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EssentialFunctions.
     */
    cursor?: EssentialFunctionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EssentialFunctions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EssentialFunctions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EssentialFunctions.
     */
    distinct?: EssentialFunctionScalarFieldEnum | EssentialFunctionScalarFieldEnum[]
  }

  /**
   * EssentialFunction findFirstOrThrow
   */
  export type EssentialFunctionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EssentialFunction
     */
    select?: EssentialFunctionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EssentialFunctionInclude<ExtArgs> | null
    /**
     * Filter, which EssentialFunction to fetch.
     */
    where?: EssentialFunctionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EssentialFunctions to fetch.
     */
    orderBy?: EssentialFunctionOrderByWithRelationInput | EssentialFunctionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EssentialFunctions.
     */
    cursor?: EssentialFunctionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EssentialFunctions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EssentialFunctions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EssentialFunctions.
     */
    distinct?: EssentialFunctionScalarFieldEnum | EssentialFunctionScalarFieldEnum[]
  }

  /**
   * EssentialFunction findMany
   */
  export type EssentialFunctionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EssentialFunction
     */
    select?: EssentialFunctionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EssentialFunctionInclude<ExtArgs> | null
    /**
     * Filter, which EssentialFunctions to fetch.
     */
    where?: EssentialFunctionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EssentialFunctions to fetch.
     */
    orderBy?: EssentialFunctionOrderByWithRelationInput | EssentialFunctionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EssentialFunctions.
     */
    cursor?: EssentialFunctionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EssentialFunctions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EssentialFunctions.
     */
    skip?: number
    distinct?: EssentialFunctionScalarFieldEnum | EssentialFunctionScalarFieldEnum[]
  }

  /**
   * EssentialFunction create
   */
  export type EssentialFunctionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EssentialFunction
     */
    select?: EssentialFunctionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EssentialFunctionInclude<ExtArgs> | null
    /**
     * The data needed to create a EssentialFunction.
     */
    data: XOR<EssentialFunctionCreateInput, EssentialFunctionUncheckedCreateInput>
  }

  /**
   * EssentialFunction createMany
   */
  export type EssentialFunctionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EssentialFunctions.
     */
    data: EssentialFunctionCreateManyInput | EssentialFunctionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EssentialFunction createManyAndReturn
   */
  export type EssentialFunctionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EssentialFunction
     */
    select?: EssentialFunctionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EssentialFunctions.
     */
    data: EssentialFunctionCreateManyInput | EssentialFunctionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EssentialFunctionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EssentialFunction update
   */
  export type EssentialFunctionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EssentialFunction
     */
    select?: EssentialFunctionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EssentialFunctionInclude<ExtArgs> | null
    /**
     * The data needed to update a EssentialFunction.
     */
    data: XOR<EssentialFunctionUpdateInput, EssentialFunctionUncheckedUpdateInput>
    /**
     * Choose, which EssentialFunction to update.
     */
    where: EssentialFunctionWhereUniqueInput
  }

  /**
   * EssentialFunction updateMany
   */
  export type EssentialFunctionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EssentialFunctions.
     */
    data: XOR<EssentialFunctionUpdateManyMutationInput, EssentialFunctionUncheckedUpdateManyInput>
    /**
     * Filter which EssentialFunctions to update
     */
    where?: EssentialFunctionWhereInput
  }

  /**
   * EssentialFunction upsert
   */
  export type EssentialFunctionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EssentialFunction
     */
    select?: EssentialFunctionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EssentialFunctionInclude<ExtArgs> | null
    /**
     * The filter to search for the EssentialFunction to update in case it exists.
     */
    where: EssentialFunctionWhereUniqueInput
    /**
     * In case the EssentialFunction found by the `where` argument doesn't exist, create a new EssentialFunction with this data.
     */
    create: XOR<EssentialFunctionCreateInput, EssentialFunctionUncheckedCreateInput>
    /**
     * In case the EssentialFunction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EssentialFunctionUpdateInput, EssentialFunctionUncheckedUpdateInput>
  }

  /**
   * EssentialFunction delete
   */
  export type EssentialFunctionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EssentialFunction
     */
    select?: EssentialFunctionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EssentialFunctionInclude<ExtArgs> | null
    /**
     * Filter which EssentialFunction to delete.
     */
    where: EssentialFunctionWhereUniqueInput
  }

  /**
   * EssentialFunction deleteMany
   */
  export type EssentialFunctionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EssentialFunctions to delete
     */
    where?: EssentialFunctionWhereInput
  }

  /**
   * EssentialFunction without action
   */
  export type EssentialFunctionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EssentialFunction
     */
    select?: EssentialFunctionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EssentialFunctionInclude<ExtArgs> | null
  }


  /**
   * Model RiskAssessment
   */

  export type AggregateRiskAssessment = {
    _count: RiskAssessmentCountAggregateOutputType | null
    _min: RiskAssessmentMinAggregateOutputType | null
    _max: RiskAssessmentMaxAggregateOutputType | null
  }

  export type RiskAssessmentMinAggregateOutputType = {
    id: string | null
    planId: string | null
    potentialHazards: string | null
    hazards: string | null
  }

  export type RiskAssessmentMaxAggregateOutputType = {
    id: string | null
    planId: string | null
    potentialHazards: string | null
    hazards: string | null
  }

  export type RiskAssessmentCountAggregateOutputType = {
    id: number
    planId: number
    potentialHazards: number
    hazards: number
    _all: number
  }


  export type RiskAssessmentMinAggregateInputType = {
    id?: true
    planId?: true
    potentialHazards?: true
    hazards?: true
  }

  export type RiskAssessmentMaxAggregateInputType = {
    id?: true
    planId?: true
    potentialHazards?: true
    hazards?: true
  }

  export type RiskAssessmentCountAggregateInputType = {
    id?: true
    planId?: true
    potentialHazards?: true
    hazards?: true
    _all?: true
  }

  export type RiskAssessmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RiskAssessment to aggregate.
     */
    where?: RiskAssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskAssessments to fetch.
     */
    orderBy?: RiskAssessmentOrderByWithRelationInput | RiskAssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RiskAssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskAssessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskAssessments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RiskAssessments
    **/
    _count?: true | RiskAssessmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RiskAssessmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RiskAssessmentMaxAggregateInputType
  }

  export type GetRiskAssessmentAggregateType<T extends RiskAssessmentAggregateArgs> = {
        [P in keyof T & keyof AggregateRiskAssessment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRiskAssessment[P]>
      : GetScalarType<T[P], AggregateRiskAssessment[P]>
  }




  export type RiskAssessmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RiskAssessmentWhereInput
    orderBy?: RiskAssessmentOrderByWithAggregationInput | RiskAssessmentOrderByWithAggregationInput[]
    by: RiskAssessmentScalarFieldEnum[] | RiskAssessmentScalarFieldEnum
    having?: RiskAssessmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RiskAssessmentCountAggregateInputType | true
    _min?: RiskAssessmentMinAggregateInputType
    _max?: RiskAssessmentMaxAggregateInputType
  }

  export type RiskAssessmentGroupByOutputType = {
    id: string
    planId: string
    potentialHazards: string
    hazards: string
    _count: RiskAssessmentCountAggregateOutputType | null
    _min: RiskAssessmentMinAggregateOutputType | null
    _max: RiskAssessmentMaxAggregateOutputType | null
  }

  type GetRiskAssessmentGroupByPayload<T extends RiskAssessmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RiskAssessmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RiskAssessmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RiskAssessmentGroupByOutputType[P]>
            : GetScalarType<T[P], RiskAssessmentGroupByOutputType[P]>
        }
      >
    >


  export type RiskAssessmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    potentialHazards?: boolean
    hazards?: boolean
    plan?: boolean | BusinessContinuityPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["riskAssessment"]>

  export type RiskAssessmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    potentialHazards?: boolean
    hazards?: boolean
    plan?: boolean | BusinessContinuityPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["riskAssessment"]>

  export type RiskAssessmentSelectScalar = {
    id?: boolean
    planId?: boolean
    potentialHazards?: boolean
    hazards?: boolean
  }

  export type RiskAssessmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | BusinessContinuityPlanDefaultArgs<ExtArgs>
  }
  export type RiskAssessmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | BusinessContinuityPlanDefaultArgs<ExtArgs>
  }

  export type $RiskAssessmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RiskAssessment"
    objects: {
      plan: Prisma.$BusinessContinuityPlanPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      planId: string
      potentialHazards: string
      hazards: string
    }, ExtArgs["result"]["riskAssessment"]>
    composites: {}
  }

  type RiskAssessmentGetPayload<S extends boolean | null | undefined | RiskAssessmentDefaultArgs> = $Result.GetResult<Prisma.$RiskAssessmentPayload, S>

  type RiskAssessmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RiskAssessmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RiskAssessmentCountAggregateInputType | true
    }

  export interface RiskAssessmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RiskAssessment'], meta: { name: 'RiskAssessment' } }
    /**
     * Find zero or one RiskAssessment that matches the filter.
     * @param {RiskAssessmentFindUniqueArgs} args - Arguments to find a RiskAssessment
     * @example
     * // Get one RiskAssessment
     * const riskAssessment = await prisma.riskAssessment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RiskAssessmentFindUniqueArgs>(args: SelectSubset<T, RiskAssessmentFindUniqueArgs<ExtArgs>>): Prisma__RiskAssessmentClient<$Result.GetResult<Prisma.$RiskAssessmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RiskAssessment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RiskAssessmentFindUniqueOrThrowArgs} args - Arguments to find a RiskAssessment
     * @example
     * // Get one RiskAssessment
     * const riskAssessment = await prisma.riskAssessment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RiskAssessmentFindUniqueOrThrowArgs>(args: SelectSubset<T, RiskAssessmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RiskAssessmentClient<$Result.GetResult<Prisma.$RiskAssessmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RiskAssessment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskAssessmentFindFirstArgs} args - Arguments to find a RiskAssessment
     * @example
     * // Get one RiskAssessment
     * const riskAssessment = await prisma.riskAssessment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RiskAssessmentFindFirstArgs>(args?: SelectSubset<T, RiskAssessmentFindFirstArgs<ExtArgs>>): Prisma__RiskAssessmentClient<$Result.GetResult<Prisma.$RiskAssessmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RiskAssessment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskAssessmentFindFirstOrThrowArgs} args - Arguments to find a RiskAssessment
     * @example
     * // Get one RiskAssessment
     * const riskAssessment = await prisma.riskAssessment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RiskAssessmentFindFirstOrThrowArgs>(args?: SelectSubset<T, RiskAssessmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__RiskAssessmentClient<$Result.GetResult<Prisma.$RiskAssessmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RiskAssessments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskAssessmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RiskAssessments
     * const riskAssessments = await prisma.riskAssessment.findMany()
     * 
     * // Get first 10 RiskAssessments
     * const riskAssessments = await prisma.riskAssessment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const riskAssessmentWithIdOnly = await prisma.riskAssessment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RiskAssessmentFindManyArgs>(args?: SelectSubset<T, RiskAssessmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RiskAssessmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RiskAssessment.
     * @param {RiskAssessmentCreateArgs} args - Arguments to create a RiskAssessment.
     * @example
     * // Create one RiskAssessment
     * const RiskAssessment = await prisma.riskAssessment.create({
     *   data: {
     *     // ... data to create a RiskAssessment
     *   }
     * })
     * 
     */
    create<T extends RiskAssessmentCreateArgs>(args: SelectSubset<T, RiskAssessmentCreateArgs<ExtArgs>>): Prisma__RiskAssessmentClient<$Result.GetResult<Prisma.$RiskAssessmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RiskAssessments.
     * @param {RiskAssessmentCreateManyArgs} args - Arguments to create many RiskAssessments.
     * @example
     * // Create many RiskAssessments
     * const riskAssessment = await prisma.riskAssessment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RiskAssessmentCreateManyArgs>(args?: SelectSubset<T, RiskAssessmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RiskAssessments and returns the data saved in the database.
     * @param {RiskAssessmentCreateManyAndReturnArgs} args - Arguments to create many RiskAssessments.
     * @example
     * // Create many RiskAssessments
     * const riskAssessment = await prisma.riskAssessment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RiskAssessments and only return the `id`
     * const riskAssessmentWithIdOnly = await prisma.riskAssessment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RiskAssessmentCreateManyAndReturnArgs>(args?: SelectSubset<T, RiskAssessmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RiskAssessmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RiskAssessment.
     * @param {RiskAssessmentDeleteArgs} args - Arguments to delete one RiskAssessment.
     * @example
     * // Delete one RiskAssessment
     * const RiskAssessment = await prisma.riskAssessment.delete({
     *   where: {
     *     // ... filter to delete one RiskAssessment
     *   }
     * })
     * 
     */
    delete<T extends RiskAssessmentDeleteArgs>(args: SelectSubset<T, RiskAssessmentDeleteArgs<ExtArgs>>): Prisma__RiskAssessmentClient<$Result.GetResult<Prisma.$RiskAssessmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RiskAssessment.
     * @param {RiskAssessmentUpdateArgs} args - Arguments to update one RiskAssessment.
     * @example
     * // Update one RiskAssessment
     * const riskAssessment = await prisma.riskAssessment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RiskAssessmentUpdateArgs>(args: SelectSubset<T, RiskAssessmentUpdateArgs<ExtArgs>>): Prisma__RiskAssessmentClient<$Result.GetResult<Prisma.$RiskAssessmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RiskAssessments.
     * @param {RiskAssessmentDeleteManyArgs} args - Arguments to filter RiskAssessments to delete.
     * @example
     * // Delete a few RiskAssessments
     * const { count } = await prisma.riskAssessment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RiskAssessmentDeleteManyArgs>(args?: SelectSubset<T, RiskAssessmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RiskAssessments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskAssessmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RiskAssessments
     * const riskAssessment = await prisma.riskAssessment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RiskAssessmentUpdateManyArgs>(args: SelectSubset<T, RiskAssessmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RiskAssessment.
     * @param {RiskAssessmentUpsertArgs} args - Arguments to update or create a RiskAssessment.
     * @example
     * // Update or create a RiskAssessment
     * const riskAssessment = await prisma.riskAssessment.upsert({
     *   create: {
     *     // ... data to create a RiskAssessment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RiskAssessment we want to update
     *   }
     * })
     */
    upsert<T extends RiskAssessmentUpsertArgs>(args: SelectSubset<T, RiskAssessmentUpsertArgs<ExtArgs>>): Prisma__RiskAssessmentClient<$Result.GetResult<Prisma.$RiskAssessmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RiskAssessments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskAssessmentCountArgs} args - Arguments to filter RiskAssessments to count.
     * @example
     * // Count the number of RiskAssessments
     * const count = await prisma.riskAssessment.count({
     *   where: {
     *     // ... the filter for the RiskAssessments we want to count
     *   }
     * })
    **/
    count<T extends RiskAssessmentCountArgs>(
      args?: Subset<T, RiskAssessmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RiskAssessmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RiskAssessment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskAssessmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RiskAssessmentAggregateArgs>(args: Subset<T, RiskAssessmentAggregateArgs>): Prisma.PrismaPromise<GetRiskAssessmentAggregateType<T>>

    /**
     * Group by RiskAssessment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskAssessmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RiskAssessmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RiskAssessmentGroupByArgs['orderBy'] }
        : { orderBy?: RiskAssessmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RiskAssessmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRiskAssessmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RiskAssessment model
   */
  readonly fields: RiskAssessmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RiskAssessment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RiskAssessmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plan<T extends BusinessContinuityPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BusinessContinuityPlanDefaultArgs<ExtArgs>>): Prisma__BusinessContinuityPlanClient<$Result.GetResult<Prisma.$BusinessContinuityPlanPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RiskAssessment model
   */ 
  interface RiskAssessmentFieldRefs {
    readonly id: FieldRef<"RiskAssessment", 'String'>
    readonly planId: FieldRef<"RiskAssessment", 'String'>
    readonly potentialHazards: FieldRef<"RiskAssessment", 'String'>
    readonly hazards: FieldRef<"RiskAssessment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RiskAssessment findUnique
   */
  export type RiskAssessmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskAssessmentInclude<ExtArgs> | null
    /**
     * Filter, which RiskAssessment to fetch.
     */
    where: RiskAssessmentWhereUniqueInput
  }

  /**
   * RiskAssessment findUniqueOrThrow
   */
  export type RiskAssessmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskAssessmentInclude<ExtArgs> | null
    /**
     * Filter, which RiskAssessment to fetch.
     */
    where: RiskAssessmentWhereUniqueInput
  }

  /**
   * RiskAssessment findFirst
   */
  export type RiskAssessmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskAssessmentInclude<ExtArgs> | null
    /**
     * Filter, which RiskAssessment to fetch.
     */
    where?: RiskAssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskAssessments to fetch.
     */
    orderBy?: RiskAssessmentOrderByWithRelationInput | RiskAssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RiskAssessments.
     */
    cursor?: RiskAssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskAssessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskAssessments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RiskAssessments.
     */
    distinct?: RiskAssessmentScalarFieldEnum | RiskAssessmentScalarFieldEnum[]
  }

  /**
   * RiskAssessment findFirstOrThrow
   */
  export type RiskAssessmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskAssessmentInclude<ExtArgs> | null
    /**
     * Filter, which RiskAssessment to fetch.
     */
    where?: RiskAssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskAssessments to fetch.
     */
    orderBy?: RiskAssessmentOrderByWithRelationInput | RiskAssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RiskAssessments.
     */
    cursor?: RiskAssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskAssessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskAssessments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RiskAssessments.
     */
    distinct?: RiskAssessmentScalarFieldEnum | RiskAssessmentScalarFieldEnum[]
  }

  /**
   * RiskAssessment findMany
   */
  export type RiskAssessmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskAssessmentInclude<ExtArgs> | null
    /**
     * Filter, which RiskAssessments to fetch.
     */
    where?: RiskAssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskAssessments to fetch.
     */
    orderBy?: RiskAssessmentOrderByWithRelationInput | RiskAssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RiskAssessments.
     */
    cursor?: RiskAssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskAssessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskAssessments.
     */
    skip?: number
    distinct?: RiskAssessmentScalarFieldEnum | RiskAssessmentScalarFieldEnum[]
  }

  /**
   * RiskAssessment create
   */
  export type RiskAssessmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskAssessmentInclude<ExtArgs> | null
    /**
     * The data needed to create a RiskAssessment.
     */
    data: XOR<RiskAssessmentCreateInput, RiskAssessmentUncheckedCreateInput>
  }

  /**
   * RiskAssessment createMany
   */
  export type RiskAssessmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RiskAssessments.
     */
    data: RiskAssessmentCreateManyInput | RiskAssessmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RiskAssessment createManyAndReturn
   */
  export type RiskAssessmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RiskAssessments.
     */
    data: RiskAssessmentCreateManyInput | RiskAssessmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskAssessmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RiskAssessment update
   */
  export type RiskAssessmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskAssessmentInclude<ExtArgs> | null
    /**
     * The data needed to update a RiskAssessment.
     */
    data: XOR<RiskAssessmentUpdateInput, RiskAssessmentUncheckedUpdateInput>
    /**
     * Choose, which RiskAssessment to update.
     */
    where: RiskAssessmentWhereUniqueInput
  }

  /**
   * RiskAssessment updateMany
   */
  export type RiskAssessmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RiskAssessments.
     */
    data: XOR<RiskAssessmentUpdateManyMutationInput, RiskAssessmentUncheckedUpdateManyInput>
    /**
     * Filter which RiskAssessments to update
     */
    where?: RiskAssessmentWhereInput
  }

  /**
   * RiskAssessment upsert
   */
  export type RiskAssessmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskAssessmentInclude<ExtArgs> | null
    /**
     * The filter to search for the RiskAssessment to update in case it exists.
     */
    where: RiskAssessmentWhereUniqueInput
    /**
     * In case the RiskAssessment found by the `where` argument doesn't exist, create a new RiskAssessment with this data.
     */
    create: XOR<RiskAssessmentCreateInput, RiskAssessmentUncheckedCreateInput>
    /**
     * In case the RiskAssessment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RiskAssessmentUpdateInput, RiskAssessmentUncheckedUpdateInput>
  }

  /**
   * RiskAssessment delete
   */
  export type RiskAssessmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskAssessmentInclude<ExtArgs> | null
    /**
     * Filter which RiskAssessment to delete.
     */
    where: RiskAssessmentWhereUniqueInput
  }

  /**
   * RiskAssessment deleteMany
   */
  export type RiskAssessmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RiskAssessments to delete
     */
    where?: RiskAssessmentWhereInput
  }

  /**
   * RiskAssessment without action
   */
  export type RiskAssessmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskAssessmentInclude<ExtArgs> | null
  }


  /**
   * Model Strategy
   */

  export type AggregateStrategy = {
    _count: StrategyCountAggregateOutputType | null
    _min: StrategyMinAggregateOutputType | null
    _max: StrategyMaxAggregateOutputType | null
  }

  export type StrategyMinAggregateOutputType = {
    id: string | null
    planId: string | null
    preventionStrategies: string | null
    responseStrategies: string | null
    recoveryStrategies: string | null
    longTermRiskReduction: string | null
  }

  export type StrategyMaxAggregateOutputType = {
    id: string | null
    planId: string | null
    preventionStrategies: string | null
    responseStrategies: string | null
    recoveryStrategies: string | null
    longTermRiskReduction: string | null
  }

  export type StrategyCountAggregateOutputType = {
    id: number
    planId: number
    preventionStrategies: number
    responseStrategies: number
    recoveryStrategies: number
    longTermRiskReduction: number
    _all: number
  }


  export type StrategyMinAggregateInputType = {
    id?: true
    planId?: true
    preventionStrategies?: true
    responseStrategies?: true
    recoveryStrategies?: true
    longTermRiskReduction?: true
  }

  export type StrategyMaxAggregateInputType = {
    id?: true
    planId?: true
    preventionStrategies?: true
    responseStrategies?: true
    recoveryStrategies?: true
    longTermRiskReduction?: true
  }

  export type StrategyCountAggregateInputType = {
    id?: true
    planId?: true
    preventionStrategies?: true
    responseStrategies?: true
    recoveryStrategies?: true
    longTermRiskReduction?: true
    _all?: true
  }

  export type StrategyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Strategy to aggregate.
     */
    where?: StrategyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Strategies to fetch.
     */
    orderBy?: StrategyOrderByWithRelationInput | StrategyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StrategyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Strategies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Strategies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Strategies
    **/
    _count?: true | StrategyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StrategyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StrategyMaxAggregateInputType
  }

  export type GetStrategyAggregateType<T extends StrategyAggregateArgs> = {
        [P in keyof T & keyof AggregateStrategy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStrategy[P]>
      : GetScalarType<T[P], AggregateStrategy[P]>
  }




  export type StrategyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StrategyWhereInput
    orderBy?: StrategyOrderByWithAggregationInput | StrategyOrderByWithAggregationInput[]
    by: StrategyScalarFieldEnum[] | StrategyScalarFieldEnum
    having?: StrategyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StrategyCountAggregateInputType | true
    _min?: StrategyMinAggregateInputType
    _max?: StrategyMaxAggregateInputType
  }

  export type StrategyGroupByOutputType = {
    id: string
    planId: string
    preventionStrategies: string
    responseStrategies: string
    recoveryStrategies: string
    longTermRiskReduction: string
    _count: StrategyCountAggregateOutputType | null
    _min: StrategyMinAggregateOutputType | null
    _max: StrategyMaxAggregateOutputType | null
  }

  type GetStrategyGroupByPayload<T extends StrategyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StrategyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StrategyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StrategyGroupByOutputType[P]>
            : GetScalarType<T[P], StrategyGroupByOutputType[P]>
        }
      >
    >


  export type StrategySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    preventionStrategies?: boolean
    responseStrategies?: boolean
    recoveryStrategies?: boolean
    longTermRiskReduction?: boolean
    plan?: boolean | BusinessContinuityPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["strategy"]>

  export type StrategySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    preventionStrategies?: boolean
    responseStrategies?: boolean
    recoveryStrategies?: boolean
    longTermRiskReduction?: boolean
    plan?: boolean | BusinessContinuityPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["strategy"]>

  export type StrategySelectScalar = {
    id?: boolean
    planId?: boolean
    preventionStrategies?: boolean
    responseStrategies?: boolean
    recoveryStrategies?: boolean
    longTermRiskReduction?: boolean
  }

  export type StrategyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | BusinessContinuityPlanDefaultArgs<ExtArgs>
  }
  export type StrategyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | BusinessContinuityPlanDefaultArgs<ExtArgs>
  }

  export type $StrategyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Strategy"
    objects: {
      plan: Prisma.$BusinessContinuityPlanPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      planId: string
      preventionStrategies: string
      responseStrategies: string
      recoveryStrategies: string
      longTermRiskReduction: string
    }, ExtArgs["result"]["strategy"]>
    composites: {}
  }

  type StrategyGetPayload<S extends boolean | null | undefined | StrategyDefaultArgs> = $Result.GetResult<Prisma.$StrategyPayload, S>

  type StrategyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StrategyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StrategyCountAggregateInputType | true
    }

  export interface StrategyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Strategy'], meta: { name: 'Strategy' } }
    /**
     * Find zero or one Strategy that matches the filter.
     * @param {StrategyFindUniqueArgs} args - Arguments to find a Strategy
     * @example
     * // Get one Strategy
     * const strategy = await prisma.strategy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StrategyFindUniqueArgs>(args: SelectSubset<T, StrategyFindUniqueArgs<ExtArgs>>): Prisma__StrategyClient<$Result.GetResult<Prisma.$StrategyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Strategy that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StrategyFindUniqueOrThrowArgs} args - Arguments to find a Strategy
     * @example
     * // Get one Strategy
     * const strategy = await prisma.strategy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StrategyFindUniqueOrThrowArgs>(args: SelectSubset<T, StrategyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StrategyClient<$Result.GetResult<Prisma.$StrategyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Strategy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrategyFindFirstArgs} args - Arguments to find a Strategy
     * @example
     * // Get one Strategy
     * const strategy = await prisma.strategy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StrategyFindFirstArgs>(args?: SelectSubset<T, StrategyFindFirstArgs<ExtArgs>>): Prisma__StrategyClient<$Result.GetResult<Prisma.$StrategyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Strategy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrategyFindFirstOrThrowArgs} args - Arguments to find a Strategy
     * @example
     * // Get one Strategy
     * const strategy = await prisma.strategy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StrategyFindFirstOrThrowArgs>(args?: SelectSubset<T, StrategyFindFirstOrThrowArgs<ExtArgs>>): Prisma__StrategyClient<$Result.GetResult<Prisma.$StrategyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Strategies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrategyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Strategies
     * const strategies = await prisma.strategy.findMany()
     * 
     * // Get first 10 Strategies
     * const strategies = await prisma.strategy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const strategyWithIdOnly = await prisma.strategy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StrategyFindManyArgs>(args?: SelectSubset<T, StrategyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StrategyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Strategy.
     * @param {StrategyCreateArgs} args - Arguments to create a Strategy.
     * @example
     * // Create one Strategy
     * const Strategy = await prisma.strategy.create({
     *   data: {
     *     // ... data to create a Strategy
     *   }
     * })
     * 
     */
    create<T extends StrategyCreateArgs>(args: SelectSubset<T, StrategyCreateArgs<ExtArgs>>): Prisma__StrategyClient<$Result.GetResult<Prisma.$StrategyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Strategies.
     * @param {StrategyCreateManyArgs} args - Arguments to create many Strategies.
     * @example
     * // Create many Strategies
     * const strategy = await prisma.strategy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StrategyCreateManyArgs>(args?: SelectSubset<T, StrategyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Strategies and returns the data saved in the database.
     * @param {StrategyCreateManyAndReturnArgs} args - Arguments to create many Strategies.
     * @example
     * // Create many Strategies
     * const strategy = await prisma.strategy.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Strategies and only return the `id`
     * const strategyWithIdOnly = await prisma.strategy.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StrategyCreateManyAndReturnArgs>(args?: SelectSubset<T, StrategyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StrategyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Strategy.
     * @param {StrategyDeleteArgs} args - Arguments to delete one Strategy.
     * @example
     * // Delete one Strategy
     * const Strategy = await prisma.strategy.delete({
     *   where: {
     *     // ... filter to delete one Strategy
     *   }
     * })
     * 
     */
    delete<T extends StrategyDeleteArgs>(args: SelectSubset<T, StrategyDeleteArgs<ExtArgs>>): Prisma__StrategyClient<$Result.GetResult<Prisma.$StrategyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Strategy.
     * @param {StrategyUpdateArgs} args - Arguments to update one Strategy.
     * @example
     * // Update one Strategy
     * const strategy = await prisma.strategy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StrategyUpdateArgs>(args: SelectSubset<T, StrategyUpdateArgs<ExtArgs>>): Prisma__StrategyClient<$Result.GetResult<Prisma.$StrategyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Strategies.
     * @param {StrategyDeleteManyArgs} args - Arguments to filter Strategies to delete.
     * @example
     * // Delete a few Strategies
     * const { count } = await prisma.strategy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StrategyDeleteManyArgs>(args?: SelectSubset<T, StrategyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Strategies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrategyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Strategies
     * const strategy = await prisma.strategy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StrategyUpdateManyArgs>(args: SelectSubset<T, StrategyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Strategy.
     * @param {StrategyUpsertArgs} args - Arguments to update or create a Strategy.
     * @example
     * // Update or create a Strategy
     * const strategy = await prisma.strategy.upsert({
     *   create: {
     *     // ... data to create a Strategy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Strategy we want to update
     *   }
     * })
     */
    upsert<T extends StrategyUpsertArgs>(args: SelectSubset<T, StrategyUpsertArgs<ExtArgs>>): Prisma__StrategyClient<$Result.GetResult<Prisma.$StrategyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Strategies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrategyCountArgs} args - Arguments to filter Strategies to count.
     * @example
     * // Count the number of Strategies
     * const count = await prisma.strategy.count({
     *   where: {
     *     // ... the filter for the Strategies we want to count
     *   }
     * })
    **/
    count<T extends StrategyCountArgs>(
      args?: Subset<T, StrategyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StrategyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Strategy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrategyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StrategyAggregateArgs>(args: Subset<T, StrategyAggregateArgs>): Prisma.PrismaPromise<GetStrategyAggregateType<T>>

    /**
     * Group by Strategy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrategyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StrategyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StrategyGroupByArgs['orderBy'] }
        : { orderBy?: StrategyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StrategyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStrategyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Strategy model
   */
  readonly fields: StrategyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Strategy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StrategyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plan<T extends BusinessContinuityPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BusinessContinuityPlanDefaultArgs<ExtArgs>>): Prisma__BusinessContinuityPlanClient<$Result.GetResult<Prisma.$BusinessContinuityPlanPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Strategy model
   */ 
  interface StrategyFieldRefs {
    readonly id: FieldRef<"Strategy", 'String'>
    readonly planId: FieldRef<"Strategy", 'String'>
    readonly preventionStrategies: FieldRef<"Strategy", 'String'>
    readonly responseStrategies: FieldRef<"Strategy", 'String'>
    readonly recoveryStrategies: FieldRef<"Strategy", 'String'>
    readonly longTermRiskReduction: FieldRef<"Strategy", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Strategy findUnique
   */
  export type StrategyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Strategy
     */
    select?: StrategySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyInclude<ExtArgs> | null
    /**
     * Filter, which Strategy to fetch.
     */
    where: StrategyWhereUniqueInput
  }

  /**
   * Strategy findUniqueOrThrow
   */
  export type StrategyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Strategy
     */
    select?: StrategySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyInclude<ExtArgs> | null
    /**
     * Filter, which Strategy to fetch.
     */
    where: StrategyWhereUniqueInput
  }

  /**
   * Strategy findFirst
   */
  export type StrategyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Strategy
     */
    select?: StrategySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyInclude<ExtArgs> | null
    /**
     * Filter, which Strategy to fetch.
     */
    where?: StrategyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Strategies to fetch.
     */
    orderBy?: StrategyOrderByWithRelationInput | StrategyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Strategies.
     */
    cursor?: StrategyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Strategies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Strategies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Strategies.
     */
    distinct?: StrategyScalarFieldEnum | StrategyScalarFieldEnum[]
  }

  /**
   * Strategy findFirstOrThrow
   */
  export type StrategyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Strategy
     */
    select?: StrategySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyInclude<ExtArgs> | null
    /**
     * Filter, which Strategy to fetch.
     */
    where?: StrategyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Strategies to fetch.
     */
    orderBy?: StrategyOrderByWithRelationInput | StrategyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Strategies.
     */
    cursor?: StrategyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Strategies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Strategies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Strategies.
     */
    distinct?: StrategyScalarFieldEnum | StrategyScalarFieldEnum[]
  }

  /**
   * Strategy findMany
   */
  export type StrategyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Strategy
     */
    select?: StrategySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyInclude<ExtArgs> | null
    /**
     * Filter, which Strategies to fetch.
     */
    where?: StrategyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Strategies to fetch.
     */
    orderBy?: StrategyOrderByWithRelationInput | StrategyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Strategies.
     */
    cursor?: StrategyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Strategies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Strategies.
     */
    skip?: number
    distinct?: StrategyScalarFieldEnum | StrategyScalarFieldEnum[]
  }

  /**
   * Strategy create
   */
  export type StrategyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Strategy
     */
    select?: StrategySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyInclude<ExtArgs> | null
    /**
     * The data needed to create a Strategy.
     */
    data: XOR<StrategyCreateInput, StrategyUncheckedCreateInput>
  }

  /**
   * Strategy createMany
   */
  export type StrategyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Strategies.
     */
    data: StrategyCreateManyInput | StrategyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Strategy createManyAndReturn
   */
  export type StrategyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Strategy
     */
    select?: StrategySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Strategies.
     */
    data: StrategyCreateManyInput | StrategyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Strategy update
   */
  export type StrategyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Strategy
     */
    select?: StrategySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyInclude<ExtArgs> | null
    /**
     * The data needed to update a Strategy.
     */
    data: XOR<StrategyUpdateInput, StrategyUncheckedUpdateInput>
    /**
     * Choose, which Strategy to update.
     */
    where: StrategyWhereUniqueInput
  }

  /**
   * Strategy updateMany
   */
  export type StrategyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Strategies.
     */
    data: XOR<StrategyUpdateManyMutationInput, StrategyUncheckedUpdateManyInput>
    /**
     * Filter which Strategies to update
     */
    where?: StrategyWhereInput
  }

  /**
   * Strategy upsert
   */
  export type StrategyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Strategy
     */
    select?: StrategySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyInclude<ExtArgs> | null
    /**
     * The filter to search for the Strategy to update in case it exists.
     */
    where: StrategyWhereUniqueInput
    /**
     * In case the Strategy found by the `where` argument doesn't exist, create a new Strategy with this data.
     */
    create: XOR<StrategyCreateInput, StrategyUncheckedCreateInput>
    /**
     * In case the Strategy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StrategyUpdateInput, StrategyUncheckedUpdateInput>
  }

  /**
   * Strategy delete
   */
  export type StrategyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Strategy
     */
    select?: StrategySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyInclude<ExtArgs> | null
    /**
     * Filter which Strategy to delete.
     */
    where: StrategyWhereUniqueInput
  }

  /**
   * Strategy deleteMany
   */
  export type StrategyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Strategies to delete
     */
    where?: StrategyWhereInput
  }

  /**
   * Strategy without action
   */
  export type StrategyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Strategy
     */
    select?: StrategySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyInclude<ExtArgs> | null
  }


  /**
   * Model ActionPlan
   */

  export type AggregateActionPlan = {
    _count: ActionPlanCountAggregateOutputType | null
    _min: ActionPlanMinAggregateOutputType | null
    _max: ActionPlanMaxAggregateOutputType | null
  }

  export type ActionPlanMinAggregateOutputType = {
    id: string | null
    planId: string | null
    actionPlanByRisk: string | null
    implementationTimeline: string | null
    resourceRequirements: string | null
    responsibleParties: string | null
    reviewUpdateSchedule: string | null
    testingAssessmentPlan: string | null
  }

  export type ActionPlanMaxAggregateOutputType = {
    id: string | null
    planId: string | null
    actionPlanByRisk: string | null
    implementationTimeline: string | null
    resourceRequirements: string | null
    responsibleParties: string | null
    reviewUpdateSchedule: string | null
    testingAssessmentPlan: string | null
  }

  export type ActionPlanCountAggregateOutputType = {
    id: number
    planId: number
    actionPlanByRisk: number
    implementationTimeline: number
    resourceRequirements: number
    responsibleParties: number
    reviewUpdateSchedule: number
    testingAssessmentPlan: number
    _all: number
  }


  export type ActionPlanMinAggregateInputType = {
    id?: true
    planId?: true
    actionPlanByRisk?: true
    implementationTimeline?: true
    resourceRequirements?: true
    responsibleParties?: true
    reviewUpdateSchedule?: true
    testingAssessmentPlan?: true
  }

  export type ActionPlanMaxAggregateInputType = {
    id?: true
    planId?: true
    actionPlanByRisk?: true
    implementationTimeline?: true
    resourceRequirements?: true
    responsibleParties?: true
    reviewUpdateSchedule?: true
    testingAssessmentPlan?: true
  }

  export type ActionPlanCountAggregateInputType = {
    id?: true
    planId?: true
    actionPlanByRisk?: true
    implementationTimeline?: true
    resourceRequirements?: true
    responsibleParties?: true
    reviewUpdateSchedule?: true
    testingAssessmentPlan?: true
    _all?: true
  }

  export type ActionPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActionPlan to aggregate.
     */
    where?: ActionPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActionPlans to fetch.
     */
    orderBy?: ActionPlanOrderByWithRelationInput | ActionPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActionPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActionPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActionPlans
    **/
    _count?: true | ActionPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActionPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActionPlanMaxAggregateInputType
  }

  export type GetActionPlanAggregateType<T extends ActionPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateActionPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActionPlan[P]>
      : GetScalarType<T[P], AggregateActionPlan[P]>
  }




  export type ActionPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActionPlanWhereInput
    orderBy?: ActionPlanOrderByWithAggregationInput | ActionPlanOrderByWithAggregationInput[]
    by: ActionPlanScalarFieldEnum[] | ActionPlanScalarFieldEnum
    having?: ActionPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActionPlanCountAggregateInputType | true
    _min?: ActionPlanMinAggregateInputType
    _max?: ActionPlanMaxAggregateInputType
  }

  export type ActionPlanGroupByOutputType = {
    id: string
    planId: string
    actionPlanByRisk: string
    implementationTimeline: string
    resourceRequirements: string
    responsibleParties: string
    reviewUpdateSchedule: string
    testingAssessmentPlan: string
    _count: ActionPlanCountAggregateOutputType | null
    _min: ActionPlanMinAggregateOutputType | null
    _max: ActionPlanMaxAggregateOutputType | null
  }

  type GetActionPlanGroupByPayload<T extends ActionPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActionPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActionPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActionPlanGroupByOutputType[P]>
            : GetScalarType<T[P], ActionPlanGroupByOutputType[P]>
        }
      >
    >


  export type ActionPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    actionPlanByRisk?: boolean
    implementationTimeline?: boolean
    resourceRequirements?: boolean
    responsibleParties?: boolean
    reviewUpdateSchedule?: boolean
    testingAssessmentPlan?: boolean
    plan?: boolean | BusinessContinuityPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["actionPlan"]>

  export type ActionPlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    actionPlanByRisk?: boolean
    implementationTimeline?: boolean
    resourceRequirements?: boolean
    responsibleParties?: boolean
    reviewUpdateSchedule?: boolean
    testingAssessmentPlan?: boolean
    plan?: boolean | BusinessContinuityPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["actionPlan"]>

  export type ActionPlanSelectScalar = {
    id?: boolean
    planId?: boolean
    actionPlanByRisk?: boolean
    implementationTimeline?: boolean
    resourceRequirements?: boolean
    responsibleParties?: boolean
    reviewUpdateSchedule?: boolean
    testingAssessmentPlan?: boolean
  }

  export type ActionPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | BusinessContinuityPlanDefaultArgs<ExtArgs>
  }
  export type ActionPlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | BusinessContinuityPlanDefaultArgs<ExtArgs>
  }

  export type $ActionPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActionPlan"
    objects: {
      plan: Prisma.$BusinessContinuityPlanPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      planId: string
      actionPlanByRisk: string
      implementationTimeline: string
      resourceRequirements: string
      responsibleParties: string
      reviewUpdateSchedule: string
      testingAssessmentPlan: string
    }, ExtArgs["result"]["actionPlan"]>
    composites: {}
  }

  type ActionPlanGetPayload<S extends boolean | null | undefined | ActionPlanDefaultArgs> = $Result.GetResult<Prisma.$ActionPlanPayload, S>

  type ActionPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ActionPlanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ActionPlanCountAggregateInputType | true
    }

  export interface ActionPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActionPlan'], meta: { name: 'ActionPlan' } }
    /**
     * Find zero or one ActionPlan that matches the filter.
     * @param {ActionPlanFindUniqueArgs} args - Arguments to find a ActionPlan
     * @example
     * // Get one ActionPlan
     * const actionPlan = await prisma.actionPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActionPlanFindUniqueArgs>(args: SelectSubset<T, ActionPlanFindUniqueArgs<ExtArgs>>): Prisma__ActionPlanClient<$Result.GetResult<Prisma.$ActionPlanPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ActionPlan that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ActionPlanFindUniqueOrThrowArgs} args - Arguments to find a ActionPlan
     * @example
     * // Get one ActionPlan
     * const actionPlan = await prisma.actionPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActionPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, ActionPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActionPlanClient<$Result.GetResult<Prisma.$ActionPlanPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ActionPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionPlanFindFirstArgs} args - Arguments to find a ActionPlan
     * @example
     * // Get one ActionPlan
     * const actionPlan = await prisma.actionPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActionPlanFindFirstArgs>(args?: SelectSubset<T, ActionPlanFindFirstArgs<ExtArgs>>): Prisma__ActionPlanClient<$Result.GetResult<Prisma.$ActionPlanPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ActionPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionPlanFindFirstOrThrowArgs} args - Arguments to find a ActionPlan
     * @example
     * // Get one ActionPlan
     * const actionPlan = await prisma.actionPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActionPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, ActionPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActionPlanClient<$Result.GetResult<Prisma.$ActionPlanPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ActionPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActionPlans
     * const actionPlans = await prisma.actionPlan.findMany()
     * 
     * // Get first 10 ActionPlans
     * const actionPlans = await prisma.actionPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const actionPlanWithIdOnly = await prisma.actionPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActionPlanFindManyArgs>(args?: SelectSubset<T, ActionPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionPlanPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ActionPlan.
     * @param {ActionPlanCreateArgs} args - Arguments to create a ActionPlan.
     * @example
     * // Create one ActionPlan
     * const ActionPlan = await prisma.actionPlan.create({
     *   data: {
     *     // ... data to create a ActionPlan
     *   }
     * })
     * 
     */
    create<T extends ActionPlanCreateArgs>(args: SelectSubset<T, ActionPlanCreateArgs<ExtArgs>>): Prisma__ActionPlanClient<$Result.GetResult<Prisma.$ActionPlanPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ActionPlans.
     * @param {ActionPlanCreateManyArgs} args - Arguments to create many ActionPlans.
     * @example
     * // Create many ActionPlans
     * const actionPlan = await prisma.actionPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActionPlanCreateManyArgs>(args?: SelectSubset<T, ActionPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ActionPlans and returns the data saved in the database.
     * @param {ActionPlanCreateManyAndReturnArgs} args - Arguments to create many ActionPlans.
     * @example
     * // Create many ActionPlans
     * const actionPlan = await prisma.actionPlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ActionPlans and only return the `id`
     * const actionPlanWithIdOnly = await prisma.actionPlan.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActionPlanCreateManyAndReturnArgs>(args?: SelectSubset<T, ActionPlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionPlanPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ActionPlan.
     * @param {ActionPlanDeleteArgs} args - Arguments to delete one ActionPlan.
     * @example
     * // Delete one ActionPlan
     * const ActionPlan = await prisma.actionPlan.delete({
     *   where: {
     *     // ... filter to delete one ActionPlan
     *   }
     * })
     * 
     */
    delete<T extends ActionPlanDeleteArgs>(args: SelectSubset<T, ActionPlanDeleteArgs<ExtArgs>>): Prisma__ActionPlanClient<$Result.GetResult<Prisma.$ActionPlanPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ActionPlan.
     * @param {ActionPlanUpdateArgs} args - Arguments to update one ActionPlan.
     * @example
     * // Update one ActionPlan
     * const actionPlan = await prisma.actionPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActionPlanUpdateArgs>(args: SelectSubset<T, ActionPlanUpdateArgs<ExtArgs>>): Prisma__ActionPlanClient<$Result.GetResult<Prisma.$ActionPlanPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ActionPlans.
     * @param {ActionPlanDeleteManyArgs} args - Arguments to filter ActionPlans to delete.
     * @example
     * // Delete a few ActionPlans
     * const { count } = await prisma.actionPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActionPlanDeleteManyArgs>(args?: SelectSubset<T, ActionPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActionPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActionPlans
     * const actionPlan = await prisma.actionPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActionPlanUpdateManyArgs>(args: SelectSubset<T, ActionPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ActionPlan.
     * @param {ActionPlanUpsertArgs} args - Arguments to update or create a ActionPlan.
     * @example
     * // Update or create a ActionPlan
     * const actionPlan = await prisma.actionPlan.upsert({
     *   create: {
     *     // ... data to create a ActionPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActionPlan we want to update
     *   }
     * })
     */
    upsert<T extends ActionPlanUpsertArgs>(args: SelectSubset<T, ActionPlanUpsertArgs<ExtArgs>>): Prisma__ActionPlanClient<$Result.GetResult<Prisma.$ActionPlanPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ActionPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionPlanCountArgs} args - Arguments to filter ActionPlans to count.
     * @example
     * // Count the number of ActionPlans
     * const count = await prisma.actionPlan.count({
     *   where: {
     *     // ... the filter for the ActionPlans we want to count
     *   }
     * })
    **/
    count<T extends ActionPlanCountArgs>(
      args?: Subset<T, ActionPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActionPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActionPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActionPlanAggregateArgs>(args: Subset<T, ActionPlanAggregateArgs>): Prisma.PrismaPromise<GetActionPlanAggregateType<T>>

    /**
     * Group by ActionPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActionPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActionPlanGroupByArgs['orderBy'] }
        : { orderBy?: ActionPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActionPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActionPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActionPlan model
   */
  readonly fields: ActionPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActionPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActionPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plan<T extends BusinessContinuityPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BusinessContinuityPlanDefaultArgs<ExtArgs>>): Prisma__BusinessContinuityPlanClient<$Result.GetResult<Prisma.$BusinessContinuityPlanPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActionPlan model
   */ 
  interface ActionPlanFieldRefs {
    readonly id: FieldRef<"ActionPlan", 'String'>
    readonly planId: FieldRef<"ActionPlan", 'String'>
    readonly actionPlanByRisk: FieldRef<"ActionPlan", 'String'>
    readonly implementationTimeline: FieldRef<"ActionPlan", 'String'>
    readonly resourceRequirements: FieldRef<"ActionPlan", 'String'>
    readonly responsibleParties: FieldRef<"ActionPlan", 'String'>
    readonly reviewUpdateSchedule: FieldRef<"ActionPlan", 'String'>
    readonly testingAssessmentPlan: FieldRef<"ActionPlan", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ActionPlan findUnique
   */
  export type ActionPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionPlan
     */
    select?: ActionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionPlanInclude<ExtArgs> | null
    /**
     * Filter, which ActionPlan to fetch.
     */
    where: ActionPlanWhereUniqueInput
  }

  /**
   * ActionPlan findUniqueOrThrow
   */
  export type ActionPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionPlan
     */
    select?: ActionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionPlanInclude<ExtArgs> | null
    /**
     * Filter, which ActionPlan to fetch.
     */
    where: ActionPlanWhereUniqueInput
  }

  /**
   * ActionPlan findFirst
   */
  export type ActionPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionPlan
     */
    select?: ActionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionPlanInclude<ExtArgs> | null
    /**
     * Filter, which ActionPlan to fetch.
     */
    where?: ActionPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActionPlans to fetch.
     */
    orderBy?: ActionPlanOrderByWithRelationInput | ActionPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActionPlans.
     */
    cursor?: ActionPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActionPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActionPlans.
     */
    distinct?: ActionPlanScalarFieldEnum | ActionPlanScalarFieldEnum[]
  }

  /**
   * ActionPlan findFirstOrThrow
   */
  export type ActionPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionPlan
     */
    select?: ActionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionPlanInclude<ExtArgs> | null
    /**
     * Filter, which ActionPlan to fetch.
     */
    where?: ActionPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActionPlans to fetch.
     */
    orderBy?: ActionPlanOrderByWithRelationInput | ActionPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActionPlans.
     */
    cursor?: ActionPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActionPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActionPlans.
     */
    distinct?: ActionPlanScalarFieldEnum | ActionPlanScalarFieldEnum[]
  }

  /**
   * ActionPlan findMany
   */
  export type ActionPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionPlan
     */
    select?: ActionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionPlanInclude<ExtArgs> | null
    /**
     * Filter, which ActionPlans to fetch.
     */
    where?: ActionPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActionPlans to fetch.
     */
    orderBy?: ActionPlanOrderByWithRelationInput | ActionPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActionPlans.
     */
    cursor?: ActionPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActionPlans.
     */
    skip?: number
    distinct?: ActionPlanScalarFieldEnum | ActionPlanScalarFieldEnum[]
  }

  /**
   * ActionPlan create
   */
  export type ActionPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionPlan
     */
    select?: ActionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a ActionPlan.
     */
    data: XOR<ActionPlanCreateInput, ActionPlanUncheckedCreateInput>
  }

  /**
   * ActionPlan createMany
   */
  export type ActionPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActionPlans.
     */
    data: ActionPlanCreateManyInput | ActionPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActionPlan createManyAndReturn
   */
  export type ActionPlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionPlan
     */
    select?: ActionPlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ActionPlans.
     */
    data: ActionPlanCreateManyInput | ActionPlanCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionPlanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActionPlan update
   */
  export type ActionPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionPlan
     */
    select?: ActionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a ActionPlan.
     */
    data: XOR<ActionPlanUpdateInput, ActionPlanUncheckedUpdateInput>
    /**
     * Choose, which ActionPlan to update.
     */
    where: ActionPlanWhereUniqueInput
  }

  /**
   * ActionPlan updateMany
   */
  export type ActionPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActionPlans.
     */
    data: XOR<ActionPlanUpdateManyMutationInput, ActionPlanUncheckedUpdateManyInput>
    /**
     * Filter which ActionPlans to update
     */
    where?: ActionPlanWhereInput
  }

  /**
   * ActionPlan upsert
   */
  export type ActionPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionPlan
     */
    select?: ActionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the ActionPlan to update in case it exists.
     */
    where: ActionPlanWhereUniqueInput
    /**
     * In case the ActionPlan found by the `where` argument doesn't exist, create a new ActionPlan with this data.
     */
    create: XOR<ActionPlanCreateInput, ActionPlanUncheckedCreateInput>
    /**
     * In case the ActionPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActionPlanUpdateInput, ActionPlanUncheckedUpdateInput>
  }

  /**
   * ActionPlan delete
   */
  export type ActionPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionPlan
     */
    select?: ActionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionPlanInclude<ExtArgs> | null
    /**
     * Filter which ActionPlan to delete.
     */
    where: ActionPlanWhereUniqueInput
  }

  /**
   * ActionPlan deleteMany
   */
  export type ActionPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActionPlans to delete
     */
    where?: ActionPlanWhereInput
  }

  /**
   * ActionPlan without action
   */
  export type ActionPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionPlan
     */
    select?: ActionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionPlanInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    currentStep: string | null
    stepData: string | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    currentStep: string | null
    stepData: string | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    currentStep: number
    stepData: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    currentStep?: true
    stepData?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    currentStep?: true
    stepData?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    currentStep?: true
    stepData?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    currentStep: string
    stepData: string
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currentStep?: boolean
    stepData?: boolean
    businessProfile?: boolean | Session$businessProfileArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currentStep?: boolean
    stepData?: boolean
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currentStep?: boolean
    stepData?: boolean
  }

  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businessProfile?: boolean | Session$businessProfileArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      businessProfile: Prisma.$BusinessProfilePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      currentStep: string
      stepData: string
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    businessProfile<T extends Session$businessProfileArgs<ExtArgs> = {}>(args?: Subset<T, Session$businessProfileArgs<ExtArgs>>): Prisma__BusinessProfileClient<$Result.GetResult<Prisma.$BusinessProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */ 
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly updatedAt: FieldRef<"Session", 'DateTime'>
    readonly currentStep: FieldRef<"Session", 'String'>
    readonly stepData: FieldRef<"Session", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
  }

  /**
   * Session.businessProfile
   */
  export type Session$businessProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessProfile
     */
    select?: BusinessProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessProfileInclude<ExtArgs> | null
    where?: BusinessProfileWhereInput
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model BusinessProfile
   */

  export type AggregateBusinessProfile = {
    _count: BusinessProfileCountAggregateOutputType | null
    _min: BusinessProfileMinAggregateOutputType | null
    _max: BusinessProfileMaxAggregateOutputType | null
  }

  export type BusinessProfileMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    name: string | null
    industry: string | null
    size: string | null
    location: string | null
  }

  export type BusinessProfileMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    name: string | null
    industry: string | null
    size: string | null
    location: string | null
  }

  export type BusinessProfileCountAggregateOutputType = {
    id: number
    sessionId: number
    name: number
    industry: number
    size: number
    location: number
    _all: number
  }


  export type BusinessProfileMinAggregateInputType = {
    id?: true
    sessionId?: true
    name?: true
    industry?: true
    size?: true
    location?: true
  }

  export type BusinessProfileMaxAggregateInputType = {
    id?: true
    sessionId?: true
    name?: true
    industry?: true
    size?: true
    location?: true
  }

  export type BusinessProfileCountAggregateInputType = {
    id?: true
    sessionId?: true
    name?: true
    industry?: true
    size?: true
    location?: true
    _all?: true
  }

  export type BusinessProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessProfile to aggregate.
     */
    where?: BusinessProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessProfiles to fetch.
     */
    orderBy?: BusinessProfileOrderByWithRelationInput | BusinessProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BusinessProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BusinessProfiles
    **/
    _count?: true | BusinessProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BusinessProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BusinessProfileMaxAggregateInputType
  }

  export type GetBusinessProfileAggregateType<T extends BusinessProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateBusinessProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBusinessProfile[P]>
      : GetScalarType<T[P], AggregateBusinessProfile[P]>
  }




  export type BusinessProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessProfileWhereInput
    orderBy?: BusinessProfileOrderByWithAggregationInput | BusinessProfileOrderByWithAggregationInput[]
    by: BusinessProfileScalarFieldEnum[] | BusinessProfileScalarFieldEnum
    having?: BusinessProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BusinessProfileCountAggregateInputType | true
    _min?: BusinessProfileMinAggregateInputType
    _max?: BusinessProfileMaxAggregateInputType
  }

  export type BusinessProfileGroupByOutputType = {
    id: string
    sessionId: string
    name: string
    industry: string
    size: string
    location: string
    _count: BusinessProfileCountAggregateOutputType | null
    _min: BusinessProfileMinAggregateOutputType | null
    _max: BusinessProfileMaxAggregateOutputType | null
  }

  type GetBusinessProfileGroupByPayload<T extends BusinessProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BusinessProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BusinessProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BusinessProfileGroupByOutputType[P]>
            : GetScalarType<T[P], BusinessProfileGroupByOutputType[P]>
        }
      >
    >


  export type BusinessProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    name?: boolean
    industry?: boolean
    size?: boolean
    location?: boolean
    session?: boolean | SessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["businessProfile"]>

  export type BusinessProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    name?: boolean
    industry?: boolean
    size?: boolean
    location?: boolean
    session?: boolean | SessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["businessProfile"]>

  export type BusinessProfileSelectScalar = {
    id?: boolean
    sessionId?: boolean
    name?: boolean
    industry?: boolean
    size?: boolean
    location?: boolean
  }

  export type BusinessProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionDefaultArgs<ExtArgs>
  }
  export type BusinessProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionDefaultArgs<ExtArgs>
  }

  export type $BusinessProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BusinessProfile"
    objects: {
      session: Prisma.$SessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      name: string
      industry: string
      size: string
      location: string
    }, ExtArgs["result"]["businessProfile"]>
    composites: {}
  }

  type BusinessProfileGetPayload<S extends boolean | null | undefined | BusinessProfileDefaultArgs> = $Result.GetResult<Prisma.$BusinessProfilePayload, S>

  type BusinessProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BusinessProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BusinessProfileCountAggregateInputType | true
    }

  export interface BusinessProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BusinessProfile'], meta: { name: 'BusinessProfile' } }
    /**
     * Find zero or one BusinessProfile that matches the filter.
     * @param {BusinessProfileFindUniqueArgs} args - Arguments to find a BusinessProfile
     * @example
     * // Get one BusinessProfile
     * const businessProfile = await prisma.businessProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BusinessProfileFindUniqueArgs>(args: SelectSubset<T, BusinessProfileFindUniqueArgs<ExtArgs>>): Prisma__BusinessProfileClient<$Result.GetResult<Prisma.$BusinessProfilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BusinessProfile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BusinessProfileFindUniqueOrThrowArgs} args - Arguments to find a BusinessProfile
     * @example
     * // Get one BusinessProfile
     * const businessProfile = await prisma.businessProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BusinessProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, BusinessProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BusinessProfileClient<$Result.GetResult<Prisma.$BusinessProfilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BusinessProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessProfileFindFirstArgs} args - Arguments to find a BusinessProfile
     * @example
     * // Get one BusinessProfile
     * const businessProfile = await prisma.businessProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BusinessProfileFindFirstArgs>(args?: SelectSubset<T, BusinessProfileFindFirstArgs<ExtArgs>>): Prisma__BusinessProfileClient<$Result.GetResult<Prisma.$BusinessProfilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BusinessProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessProfileFindFirstOrThrowArgs} args - Arguments to find a BusinessProfile
     * @example
     * // Get one BusinessProfile
     * const businessProfile = await prisma.businessProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BusinessProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, BusinessProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__BusinessProfileClient<$Result.GetResult<Prisma.$BusinessProfilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BusinessProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BusinessProfiles
     * const businessProfiles = await prisma.businessProfile.findMany()
     * 
     * // Get first 10 BusinessProfiles
     * const businessProfiles = await prisma.businessProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const businessProfileWithIdOnly = await prisma.businessProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BusinessProfileFindManyArgs>(args?: SelectSubset<T, BusinessProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessProfilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BusinessProfile.
     * @param {BusinessProfileCreateArgs} args - Arguments to create a BusinessProfile.
     * @example
     * // Create one BusinessProfile
     * const BusinessProfile = await prisma.businessProfile.create({
     *   data: {
     *     // ... data to create a BusinessProfile
     *   }
     * })
     * 
     */
    create<T extends BusinessProfileCreateArgs>(args: SelectSubset<T, BusinessProfileCreateArgs<ExtArgs>>): Prisma__BusinessProfileClient<$Result.GetResult<Prisma.$BusinessProfilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BusinessProfiles.
     * @param {BusinessProfileCreateManyArgs} args - Arguments to create many BusinessProfiles.
     * @example
     * // Create many BusinessProfiles
     * const businessProfile = await prisma.businessProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BusinessProfileCreateManyArgs>(args?: SelectSubset<T, BusinessProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BusinessProfiles and returns the data saved in the database.
     * @param {BusinessProfileCreateManyAndReturnArgs} args - Arguments to create many BusinessProfiles.
     * @example
     * // Create many BusinessProfiles
     * const businessProfile = await prisma.businessProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BusinessProfiles and only return the `id`
     * const businessProfileWithIdOnly = await prisma.businessProfile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BusinessProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, BusinessProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessProfilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BusinessProfile.
     * @param {BusinessProfileDeleteArgs} args - Arguments to delete one BusinessProfile.
     * @example
     * // Delete one BusinessProfile
     * const BusinessProfile = await prisma.businessProfile.delete({
     *   where: {
     *     // ... filter to delete one BusinessProfile
     *   }
     * })
     * 
     */
    delete<T extends BusinessProfileDeleteArgs>(args: SelectSubset<T, BusinessProfileDeleteArgs<ExtArgs>>): Prisma__BusinessProfileClient<$Result.GetResult<Prisma.$BusinessProfilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BusinessProfile.
     * @param {BusinessProfileUpdateArgs} args - Arguments to update one BusinessProfile.
     * @example
     * // Update one BusinessProfile
     * const businessProfile = await prisma.businessProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BusinessProfileUpdateArgs>(args: SelectSubset<T, BusinessProfileUpdateArgs<ExtArgs>>): Prisma__BusinessProfileClient<$Result.GetResult<Prisma.$BusinessProfilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BusinessProfiles.
     * @param {BusinessProfileDeleteManyArgs} args - Arguments to filter BusinessProfiles to delete.
     * @example
     * // Delete a few BusinessProfiles
     * const { count } = await prisma.businessProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BusinessProfileDeleteManyArgs>(args?: SelectSubset<T, BusinessProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BusinessProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BusinessProfiles
     * const businessProfile = await prisma.businessProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BusinessProfileUpdateManyArgs>(args: SelectSubset<T, BusinessProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BusinessProfile.
     * @param {BusinessProfileUpsertArgs} args - Arguments to update or create a BusinessProfile.
     * @example
     * // Update or create a BusinessProfile
     * const businessProfile = await prisma.businessProfile.upsert({
     *   create: {
     *     // ... data to create a BusinessProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BusinessProfile we want to update
     *   }
     * })
     */
    upsert<T extends BusinessProfileUpsertArgs>(args: SelectSubset<T, BusinessProfileUpsertArgs<ExtArgs>>): Prisma__BusinessProfileClient<$Result.GetResult<Prisma.$BusinessProfilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BusinessProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessProfileCountArgs} args - Arguments to filter BusinessProfiles to count.
     * @example
     * // Count the number of BusinessProfiles
     * const count = await prisma.businessProfile.count({
     *   where: {
     *     // ... the filter for the BusinessProfiles we want to count
     *   }
     * })
    **/
    count<T extends BusinessProfileCountArgs>(
      args?: Subset<T, BusinessProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BusinessProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BusinessProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BusinessProfileAggregateArgs>(args: Subset<T, BusinessProfileAggregateArgs>): Prisma.PrismaPromise<GetBusinessProfileAggregateType<T>>

    /**
     * Group by BusinessProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BusinessProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BusinessProfileGroupByArgs['orderBy'] }
        : { orderBy?: BusinessProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BusinessProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBusinessProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BusinessProfile model
   */
  readonly fields: BusinessProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BusinessProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BusinessProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends SessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SessionDefaultArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BusinessProfile model
   */ 
  interface BusinessProfileFieldRefs {
    readonly id: FieldRef<"BusinessProfile", 'String'>
    readonly sessionId: FieldRef<"BusinessProfile", 'String'>
    readonly name: FieldRef<"BusinessProfile", 'String'>
    readonly industry: FieldRef<"BusinessProfile", 'String'>
    readonly size: FieldRef<"BusinessProfile", 'String'>
    readonly location: FieldRef<"BusinessProfile", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BusinessProfile findUnique
   */
  export type BusinessProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessProfile
     */
    select?: BusinessProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessProfileInclude<ExtArgs> | null
    /**
     * Filter, which BusinessProfile to fetch.
     */
    where: BusinessProfileWhereUniqueInput
  }

  /**
   * BusinessProfile findUniqueOrThrow
   */
  export type BusinessProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessProfile
     */
    select?: BusinessProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessProfileInclude<ExtArgs> | null
    /**
     * Filter, which BusinessProfile to fetch.
     */
    where: BusinessProfileWhereUniqueInput
  }

  /**
   * BusinessProfile findFirst
   */
  export type BusinessProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessProfile
     */
    select?: BusinessProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessProfileInclude<ExtArgs> | null
    /**
     * Filter, which BusinessProfile to fetch.
     */
    where?: BusinessProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessProfiles to fetch.
     */
    orderBy?: BusinessProfileOrderByWithRelationInput | BusinessProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessProfiles.
     */
    cursor?: BusinessProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessProfiles.
     */
    distinct?: BusinessProfileScalarFieldEnum | BusinessProfileScalarFieldEnum[]
  }

  /**
   * BusinessProfile findFirstOrThrow
   */
  export type BusinessProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessProfile
     */
    select?: BusinessProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessProfileInclude<ExtArgs> | null
    /**
     * Filter, which BusinessProfile to fetch.
     */
    where?: BusinessProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessProfiles to fetch.
     */
    orderBy?: BusinessProfileOrderByWithRelationInput | BusinessProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessProfiles.
     */
    cursor?: BusinessProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessProfiles.
     */
    distinct?: BusinessProfileScalarFieldEnum | BusinessProfileScalarFieldEnum[]
  }

  /**
   * BusinessProfile findMany
   */
  export type BusinessProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessProfile
     */
    select?: BusinessProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessProfileInclude<ExtArgs> | null
    /**
     * Filter, which BusinessProfiles to fetch.
     */
    where?: BusinessProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessProfiles to fetch.
     */
    orderBy?: BusinessProfileOrderByWithRelationInput | BusinessProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BusinessProfiles.
     */
    cursor?: BusinessProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessProfiles.
     */
    skip?: number
    distinct?: BusinessProfileScalarFieldEnum | BusinessProfileScalarFieldEnum[]
  }

  /**
   * BusinessProfile create
   */
  export type BusinessProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessProfile
     */
    select?: BusinessProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a BusinessProfile.
     */
    data: XOR<BusinessProfileCreateInput, BusinessProfileUncheckedCreateInput>
  }

  /**
   * BusinessProfile createMany
   */
  export type BusinessProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BusinessProfiles.
     */
    data: BusinessProfileCreateManyInput | BusinessProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BusinessProfile createManyAndReturn
   */
  export type BusinessProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessProfile
     */
    select?: BusinessProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BusinessProfiles.
     */
    data: BusinessProfileCreateManyInput | BusinessProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BusinessProfile update
   */
  export type BusinessProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessProfile
     */
    select?: BusinessProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a BusinessProfile.
     */
    data: XOR<BusinessProfileUpdateInput, BusinessProfileUncheckedUpdateInput>
    /**
     * Choose, which BusinessProfile to update.
     */
    where: BusinessProfileWhereUniqueInput
  }

  /**
   * BusinessProfile updateMany
   */
  export type BusinessProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BusinessProfiles.
     */
    data: XOR<BusinessProfileUpdateManyMutationInput, BusinessProfileUncheckedUpdateManyInput>
    /**
     * Filter which BusinessProfiles to update
     */
    where?: BusinessProfileWhereInput
  }

  /**
   * BusinessProfile upsert
   */
  export type BusinessProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessProfile
     */
    select?: BusinessProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the BusinessProfile to update in case it exists.
     */
    where: BusinessProfileWhereUniqueInput
    /**
     * In case the BusinessProfile found by the `where` argument doesn't exist, create a new BusinessProfile with this data.
     */
    create: XOR<BusinessProfileCreateInput, BusinessProfileUncheckedCreateInput>
    /**
     * In case the BusinessProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BusinessProfileUpdateInput, BusinessProfileUncheckedUpdateInput>
  }

  /**
   * BusinessProfile delete
   */
  export type BusinessProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessProfile
     */
    select?: BusinessProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessProfileInclude<ExtArgs> | null
    /**
     * Filter which BusinessProfile to delete.
     */
    where: BusinessProfileWhereUniqueInput
  }

  /**
   * BusinessProfile deleteMany
   */
  export type BusinessProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessProfiles to delete
     */
    where?: BusinessProfileWhereInput
  }

  /**
   * BusinessProfile without action
   */
  export type BusinessProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessProfile
     */
    select?: BusinessProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessProfileInclude<ExtArgs> | null
  }


  /**
   * Model ContactsInformation
   */

  export type AggregateContactsInformation = {
    _count: ContactsInformationCountAggregateOutputType | null
    _min: ContactsInformationMinAggregateOutputType | null
    _max: ContactsInformationMaxAggregateOutputType | null
  }

  export type ContactsInformationMinAggregateOutputType = {
    id: string | null
    planId: string | null
    staffContactInfo: string | null
    keyCustomerContacts: string | null
    supplierInformation: string | null
    emergencyServicesUtilities: string | null
    criticalBusinessInfo: string | null
    planDistributionList: string | null
  }

  export type ContactsInformationMaxAggregateOutputType = {
    id: string | null
    planId: string | null
    staffContactInfo: string | null
    keyCustomerContacts: string | null
    supplierInformation: string | null
    emergencyServicesUtilities: string | null
    criticalBusinessInfo: string | null
    planDistributionList: string | null
  }

  export type ContactsInformationCountAggregateOutputType = {
    id: number
    planId: number
    staffContactInfo: number
    keyCustomerContacts: number
    supplierInformation: number
    emergencyServicesUtilities: number
    criticalBusinessInfo: number
    planDistributionList: number
    _all: number
  }


  export type ContactsInformationMinAggregateInputType = {
    id?: true
    planId?: true
    staffContactInfo?: true
    keyCustomerContacts?: true
    supplierInformation?: true
    emergencyServicesUtilities?: true
    criticalBusinessInfo?: true
    planDistributionList?: true
  }

  export type ContactsInformationMaxAggregateInputType = {
    id?: true
    planId?: true
    staffContactInfo?: true
    keyCustomerContacts?: true
    supplierInformation?: true
    emergencyServicesUtilities?: true
    criticalBusinessInfo?: true
    planDistributionList?: true
  }

  export type ContactsInformationCountAggregateInputType = {
    id?: true
    planId?: true
    staffContactInfo?: true
    keyCustomerContacts?: true
    supplierInformation?: true
    emergencyServicesUtilities?: true
    criticalBusinessInfo?: true
    planDistributionList?: true
    _all?: true
  }

  export type ContactsInformationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactsInformation to aggregate.
     */
    where?: ContactsInformationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactsInformations to fetch.
     */
    orderBy?: ContactsInformationOrderByWithRelationInput | ContactsInformationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactsInformationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactsInformations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactsInformations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContactsInformations
    **/
    _count?: true | ContactsInformationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactsInformationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactsInformationMaxAggregateInputType
  }

  export type GetContactsInformationAggregateType<T extends ContactsInformationAggregateArgs> = {
        [P in keyof T & keyof AggregateContactsInformation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContactsInformation[P]>
      : GetScalarType<T[P], AggregateContactsInformation[P]>
  }




  export type ContactsInformationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactsInformationWhereInput
    orderBy?: ContactsInformationOrderByWithAggregationInput | ContactsInformationOrderByWithAggregationInput[]
    by: ContactsInformationScalarFieldEnum[] | ContactsInformationScalarFieldEnum
    having?: ContactsInformationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactsInformationCountAggregateInputType | true
    _min?: ContactsInformationMinAggregateInputType
    _max?: ContactsInformationMaxAggregateInputType
  }

  export type ContactsInformationGroupByOutputType = {
    id: string
    planId: string
    staffContactInfo: string
    keyCustomerContacts: string
    supplierInformation: string
    emergencyServicesUtilities: string
    criticalBusinessInfo: string
    planDistributionList: string
    _count: ContactsInformationCountAggregateOutputType | null
    _min: ContactsInformationMinAggregateOutputType | null
    _max: ContactsInformationMaxAggregateOutputType | null
  }

  type GetContactsInformationGroupByPayload<T extends ContactsInformationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactsInformationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactsInformationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactsInformationGroupByOutputType[P]>
            : GetScalarType<T[P], ContactsInformationGroupByOutputType[P]>
        }
      >
    >


  export type ContactsInformationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    staffContactInfo?: boolean
    keyCustomerContacts?: boolean
    supplierInformation?: boolean
    emergencyServicesUtilities?: boolean
    criticalBusinessInfo?: boolean
    planDistributionList?: boolean
    plan?: boolean | BusinessContinuityPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactsInformation"]>

  export type ContactsInformationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    staffContactInfo?: boolean
    keyCustomerContacts?: boolean
    supplierInformation?: boolean
    emergencyServicesUtilities?: boolean
    criticalBusinessInfo?: boolean
    planDistributionList?: boolean
    plan?: boolean | BusinessContinuityPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactsInformation"]>

  export type ContactsInformationSelectScalar = {
    id?: boolean
    planId?: boolean
    staffContactInfo?: boolean
    keyCustomerContacts?: boolean
    supplierInformation?: boolean
    emergencyServicesUtilities?: boolean
    criticalBusinessInfo?: boolean
    planDistributionList?: boolean
  }

  export type ContactsInformationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | BusinessContinuityPlanDefaultArgs<ExtArgs>
  }
  export type ContactsInformationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | BusinessContinuityPlanDefaultArgs<ExtArgs>
  }

  export type $ContactsInformationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContactsInformation"
    objects: {
      plan: Prisma.$BusinessContinuityPlanPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      planId: string
      staffContactInfo: string
      keyCustomerContacts: string
      supplierInformation: string
      emergencyServicesUtilities: string
      criticalBusinessInfo: string
      planDistributionList: string
    }, ExtArgs["result"]["contactsInformation"]>
    composites: {}
  }

  type ContactsInformationGetPayload<S extends boolean | null | undefined | ContactsInformationDefaultArgs> = $Result.GetResult<Prisma.$ContactsInformationPayload, S>

  type ContactsInformationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContactsInformationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContactsInformationCountAggregateInputType | true
    }

  export interface ContactsInformationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContactsInformation'], meta: { name: 'ContactsInformation' } }
    /**
     * Find zero or one ContactsInformation that matches the filter.
     * @param {ContactsInformationFindUniqueArgs} args - Arguments to find a ContactsInformation
     * @example
     * // Get one ContactsInformation
     * const contactsInformation = await prisma.contactsInformation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactsInformationFindUniqueArgs>(args: SelectSubset<T, ContactsInformationFindUniqueArgs<ExtArgs>>): Prisma__ContactsInformationClient<$Result.GetResult<Prisma.$ContactsInformationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ContactsInformation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ContactsInformationFindUniqueOrThrowArgs} args - Arguments to find a ContactsInformation
     * @example
     * // Get one ContactsInformation
     * const contactsInformation = await prisma.contactsInformation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactsInformationFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactsInformationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactsInformationClient<$Result.GetResult<Prisma.$ContactsInformationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ContactsInformation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactsInformationFindFirstArgs} args - Arguments to find a ContactsInformation
     * @example
     * // Get one ContactsInformation
     * const contactsInformation = await prisma.contactsInformation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactsInformationFindFirstArgs>(args?: SelectSubset<T, ContactsInformationFindFirstArgs<ExtArgs>>): Prisma__ContactsInformationClient<$Result.GetResult<Prisma.$ContactsInformationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ContactsInformation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactsInformationFindFirstOrThrowArgs} args - Arguments to find a ContactsInformation
     * @example
     * // Get one ContactsInformation
     * const contactsInformation = await prisma.contactsInformation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactsInformationFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactsInformationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactsInformationClient<$Result.GetResult<Prisma.$ContactsInformationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ContactsInformations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactsInformationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContactsInformations
     * const contactsInformations = await prisma.contactsInformation.findMany()
     * 
     * // Get first 10 ContactsInformations
     * const contactsInformations = await prisma.contactsInformation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactsInformationWithIdOnly = await prisma.contactsInformation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactsInformationFindManyArgs>(args?: SelectSubset<T, ContactsInformationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactsInformationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ContactsInformation.
     * @param {ContactsInformationCreateArgs} args - Arguments to create a ContactsInformation.
     * @example
     * // Create one ContactsInformation
     * const ContactsInformation = await prisma.contactsInformation.create({
     *   data: {
     *     // ... data to create a ContactsInformation
     *   }
     * })
     * 
     */
    create<T extends ContactsInformationCreateArgs>(args: SelectSubset<T, ContactsInformationCreateArgs<ExtArgs>>): Prisma__ContactsInformationClient<$Result.GetResult<Prisma.$ContactsInformationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ContactsInformations.
     * @param {ContactsInformationCreateManyArgs} args - Arguments to create many ContactsInformations.
     * @example
     * // Create many ContactsInformations
     * const contactsInformation = await prisma.contactsInformation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactsInformationCreateManyArgs>(args?: SelectSubset<T, ContactsInformationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContactsInformations and returns the data saved in the database.
     * @param {ContactsInformationCreateManyAndReturnArgs} args - Arguments to create many ContactsInformations.
     * @example
     * // Create many ContactsInformations
     * const contactsInformation = await prisma.contactsInformation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContactsInformations and only return the `id`
     * const contactsInformationWithIdOnly = await prisma.contactsInformation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactsInformationCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactsInformationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactsInformationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ContactsInformation.
     * @param {ContactsInformationDeleteArgs} args - Arguments to delete one ContactsInformation.
     * @example
     * // Delete one ContactsInformation
     * const ContactsInformation = await prisma.contactsInformation.delete({
     *   where: {
     *     // ... filter to delete one ContactsInformation
     *   }
     * })
     * 
     */
    delete<T extends ContactsInformationDeleteArgs>(args: SelectSubset<T, ContactsInformationDeleteArgs<ExtArgs>>): Prisma__ContactsInformationClient<$Result.GetResult<Prisma.$ContactsInformationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ContactsInformation.
     * @param {ContactsInformationUpdateArgs} args - Arguments to update one ContactsInformation.
     * @example
     * // Update one ContactsInformation
     * const contactsInformation = await prisma.contactsInformation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactsInformationUpdateArgs>(args: SelectSubset<T, ContactsInformationUpdateArgs<ExtArgs>>): Prisma__ContactsInformationClient<$Result.GetResult<Prisma.$ContactsInformationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ContactsInformations.
     * @param {ContactsInformationDeleteManyArgs} args - Arguments to filter ContactsInformations to delete.
     * @example
     * // Delete a few ContactsInformations
     * const { count } = await prisma.contactsInformation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactsInformationDeleteManyArgs>(args?: SelectSubset<T, ContactsInformationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactsInformations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactsInformationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContactsInformations
     * const contactsInformation = await prisma.contactsInformation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactsInformationUpdateManyArgs>(args: SelectSubset<T, ContactsInformationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContactsInformation.
     * @param {ContactsInformationUpsertArgs} args - Arguments to update or create a ContactsInformation.
     * @example
     * // Update or create a ContactsInformation
     * const contactsInformation = await prisma.contactsInformation.upsert({
     *   create: {
     *     // ... data to create a ContactsInformation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContactsInformation we want to update
     *   }
     * })
     */
    upsert<T extends ContactsInformationUpsertArgs>(args: SelectSubset<T, ContactsInformationUpsertArgs<ExtArgs>>): Prisma__ContactsInformationClient<$Result.GetResult<Prisma.$ContactsInformationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ContactsInformations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactsInformationCountArgs} args - Arguments to filter ContactsInformations to count.
     * @example
     * // Count the number of ContactsInformations
     * const count = await prisma.contactsInformation.count({
     *   where: {
     *     // ... the filter for the ContactsInformations we want to count
     *   }
     * })
    **/
    count<T extends ContactsInformationCountArgs>(
      args?: Subset<T, ContactsInformationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactsInformationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContactsInformation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactsInformationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactsInformationAggregateArgs>(args: Subset<T, ContactsInformationAggregateArgs>): Prisma.PrismaPromise<GetContactsInformationAggregateType<T>>

    /**
     * Group by ContactsInformation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactsInformationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactsInformationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactsInformationGroupByArgs['orderBy'] }
        : { orderBy?: ContactsInformationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactsInformationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactsInformationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContactsInformation model
   */
  readonly fields: ContactsInformationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContactsInformation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactsInformationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plan<T extends BusinessContinuityPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BusinessContinuityPlanDefaultArgs<ExtArgs>>): Prisma__BusinessContinuityPlanClient<$Result.GetResult<Prisma.$BusinessContinuityPlanPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContactsInformation model
   */ 
  interface ContactsInformationFieldRefs {
    readonly id: FieldRef<"ContactsInformation", 'String'>
    readonly planId: FieldRef<"ContactsInformation", 'String'>
    readonly staffContactInfo: FieldRef<"ContactsInformation", 'String'>
    readonly keyCustomerContacts: FieldRef<"ContactsInformation", 'String'>
    readonly supplierInformation: FieldRef<"ContactsInformation", 'String'>
    readonly emergencyServicesUtilities: FieldRef<"ContactsInformation", 'String'>
    readonly criticalBusinessInfo: FieldRef<"ContactsInformation", 'String'>
    readonly planDistributionList: FieldRef<"ContactsInformation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ContactsInformation findUnique
   */
  export type ContactsInformationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactsInformation
     */
    select?: ContactsInformationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactsInformationInclude<ExtArgs> | null
    /**
     * Filter, which ContactsInformation to fetch.
     */
    where: ContactsInformationWhereUniqueInput
  }

  /**
   * ContactsInformation findUniqueOrThrow
   */
  export type ContactsInformationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactsInformation
     */
    select?: ContactsInformationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactsInformationInclude<ExtArgs> | null
    /**
     * Filter, which ContactsInformation to fetch.
     */
    where: ContactsInformationWhereUniqueInput
  }

  /**
   * ContactsInformation findFirst
   */
  export type ContactsInformationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactsInformation
     */
    select?: ContactsInformationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactsInformationInclude<ExtArgs> | null
    /**
     * Filter, which ContactsInformation to fetch.
     */
    where?: ContactsInformationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactsInformations to fetch.
     */
    orderBy?: ContactsInformationOrderByWithRelationInput | ContactsInformationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactsInformations.
     */
    cursor?: ContactsInformationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactsInformations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactsInformations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactsInformations.
     */
    distinct?: ContactsInformationScalarFieldEnum | ContactsInformationScalarFieldEnum[]
  }

  /**
   * ContactsInformation findFirstOrThrow
   */
  export type ContactsInformationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactsInformation
     */
    select?: ContactsInformationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactsInformationInclude<ExtArgs> | null
    /**
     * Filter, which ContactsInformation to fetch.
     */
    where?: ContactsInformationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactsInformations to fetch.
     */
    orderBy?: ContactsInformationOrderByWithRelationInput | ContactsInformationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactsInformations.
     */
    cursor?: ContactsInformationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactsInformations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactsInformations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactsInformations.
     */
    distinct?: ContactsInformationScalarFieldEnum | ContactsInformationScalarFieldEnum[]
  }

  /**
   * ContactsInformation findMany
   */
  export type ContactsInformationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactsInformation
     */
    select?: ContactsInformationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactsInformationInclude<ExtArgs> | null
    /**
     * Filter, which ContactsInformations to fetch.
     */
    where?: ContactsInformationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactsInformations to fetch.
     */
    orderBy?: ContactsInformationOrderByWithRelationInput | ContactsInformationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContactsInformations.
     */
    cursor?: ContactsInformationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactsInformations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactsInformations.
     */
    skip?: number
    distinct?: ContactsInformationScalarFieldEnum | ContactsInformationScalarFieldEnum[]
  }

  /**
   * ContactsInformation create
   */
  export type ContactsInformationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactsInformation
     */
    select?: ContactsInformationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactsInformationInclude<ExtArgs> | null
    /**
     * The data needed to create a ContactsInformation.
     */
    data: XOR<ContactsInformationCreateInput, ContactsInformationUncheckedCreateInput>
  }

  /**
   * ContactsInformation createMany
   */
  export type ContactsInformationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContactsInformations.
     */
    data: ContactsInformationCreateManyInput | ContactsInformationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContactsInformation createManyAndReturn
   */
  export type ContactsInformationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactsInformation
     */
    select?: ContactsInformationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ContactsInformations.
     */
    data: ContactsInformationCreateManyInput | ContactsInformationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactsInformationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContactsInformation update
   */
  export type ContactsInformationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactsInformation
     */
    select?: ContactsInformationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactsInformationInclude<ExtArgs> | null
    /**
     * The data needed to update a ContactsInformation.
     */
    data: XOR<ContactsInformationUpdateInput, ContactsInformationUncheckedUpdateInput>
    /**
     * Choose, which ContactsInformation to update.
     */
    where: ContactsInformationWhereUniqueInput
  }

  /**
   * ContactsInformation updateMany
   */
  export type ContactsInformationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContactsInformations.
     */
    data: XOR<ContactsInformationUpdateManyMutationInput, ContactsInformationUncheckedUpdateManyInput>
    /**
     * Filter which ContactsInformations to update
     */
    where?: ContactsInformationWhereInput
  }

  /**
   * ContactsInformation upsert
   */
  export type ContactsInformationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactsInformation
     */
    select?: ContactsInformationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactsInformationInclude<ExtArgs> | null
    /**
     * The filter to search for the ContactsInformation to update in case it exists.
     */
    where: ContactsInformationWhereUniqueInput
    /**
     * In case the ContactsInformation found by the `where` argument doesn't exist, create a new ContactsInformation with this data.
     */
    create: XOR<ContactsInformationCreateInput, ContactsInformationUncheckedCreateInput>
    /**
     * In case the ContactsInformation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactsInformationUpdateInput, ContactsInformationUncheckedUpdateInput>
  }

  /**
   * ContactsInformation delete
   */
  export type ContactsInformationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactsInformation
     */
    select?: ContactsInformationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactsInformationInclude<ExtArgs> | null
    /**
     * Filter which ContactsInformation to delete.
     */
    where: ContactsInformationWhereUniqueInput
  }

  /**
   * ContactsInformation deleteMany
   */
  export type ContactsInformationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactsInformations to delete
     */
    where?: ContactsInformationWhereInput
  }

  /**
   * ContactsInformation without action
   */
  export type ContactsInformationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactsInformation
     */
    select?: ContactsInformationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactsInformationInclude<ExtArgs> | null
  }


  /**
   * Model TestingMaintenance
   */

  export type AggregateTestingMaintenance = {
    _count: TestingMaintenanceCountAggregateOutputType | null
    _min: TestingMaintenanceMinAggregateOutputType | null
    _max: TestingMaintenanceMaxAggregateOutputType | null
  }

  export type TestingMaintenanceMinAggregateOutputType = {
    id: string | null
    planId: string | null
    planTestingSchedule: string | null
    planRevisionHistory: string | null
    improvementTracking: string | null
    annualReviewProcess: string | null
    triggerEventsForUpdates: string | null
  }

  export type TestingMaintenanceMaxAggregateOutputType = {
    id: string | null
    planId: string | null
    planTestingSchedule: string | null
    planRevisionHistory: string | null
    improvementTracking: string | null
    annualReviewProcess: string | null
    triggerEventsForUpdates: string | null
  }

  export type TestingMaintenanceCountAggregateOutputType = {
    id: number
    planId: number
    planTestingSchedule: number
    planRevisionHistory: number
    improvementTracking: number
    annualReviewProcess: number
    triggerEventsForUpdates: number
    _all: number
  }


  export type TestingMaintenanceMinAggregateInputType = {
    id?: true
    planId?: true
    planTestingSchedule?: true
    planRevisionHistory?: true
    improvementTracking?: true
    annualReviewProcess?: true
    triggerEventsForUpdates?: true
  }

  export type TestingMaintenanceMaxAggregateInputType = {
    id?: true
    planId?: true
    planTestingSchedule?: true
    planRevisionHistory?: true
    improvementTracking?: true
    annualReviewProcess?: true
    triggerEventsForUpdates?: true
  }

  export type TestingMaintenanceCountAggregateInputType = {
    id?: true
    planId?: true
    planTestingSchedule?: true
    planRevisionHistory?: true
    improvementTracking?: true
    annualReviewProcess?: true
    triggerEventsForUpdates?: true
    _all?: true
  }

  export type TestingMaintenanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestingMaintenance to aggregate.
     */
    where?: TestingMaintenanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestingMaintenances to fetch.
     */
    orderBy?: TestingMaintenanceOrderByWithRelationInput | TestingMaintenanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TestingMaintenanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestingMaintenances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestingMaintenances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TestingMaintenances
    **/
    _count?: true | TestingMaintenanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestingMaintenanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestingMaintenanceMaxAggregateInputType
  }

  export type GetTestingMaintenanceAggregateType<T extends TestingMaintenanceAggregateArgs> = {
        [P in keyof T & keyof AggregateTestingMaintenance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTestingMaintenance[P]>
      : GetScalarType<T[P], AggregateTestingMaintenance[P]>
  }




  export type TestingMaintenanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestingMaintenanceWhereInput
    orderBy?: TestingMaintenanceOrderByWithAggregationInput | TestingMaintenanceOrderByWithAggregationInput[]
    by: TestingMaintenanceScalarFieldEnum[] | TestingMaintenanceScalarFieldEnum
    having?: TestingMaintenanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestingMaintenanceCountAggregateInputType | true
    _min?: TestingMaintenanceMinAggregateInputType
    _max?: TestingMaintenanceMaxAggregateInputType
  }

  export type TestingMaintenanceGroupByOutputType = {
    id: string
    planId: string
    planTestingSchedule: string
    planRevisionHistory: string
    improvementTracking: string
    annualReviewProcess: string
    triggerEventsForUpdates: string
    _count: TestingMaintenanceCountAggregateOutputType | null
    _min: TestingMaintenanceMinAggregateOutputType | null
    _max: TestingMaintenanceMaxAggregateOutputType | null
  }

  type GetTestingMaintenanceGroupByPayload<T extends TestingMaintenanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TestingMaintenanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestingMaintenanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestingMaintenanceGroupByOutputType[P]>
            : GetScalarType<T[P], TestingMaintenanceGroupByOutputType[P]>
        }
      >
    >


  export type TestingMaintenanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    planTestingSchedule?: boolean
    planRevisionHistory?: boolean
    improvementTracking?: boolean
    annualReviewProcess?: boolean
    triggerEventsForUpdates?: boolean
    plan?: boolean | BusinessContinuityPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testingMaintenance"]>

  export type TestingMaintenanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    planTestingSchedule?: boolean
    planRevisionHistory?: boolean
    improvementTracking?: boolean
    annualReviewProcess?: boolean
    triggerEventsForUpdates?: boolean
    plan?: boolean | BusinessContinuityPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testingMaintenance"]>

  export type TestingMaintenanceSelectScalar = {
    id?: boolean
    planId?: boolean
    planTestingSchedule?: boolean
    planRevisionHistory?: boolean
    improvementTracking?: boolean
    annualReviewProcess?: boolean
    triggerEventsForUpdates?: boolean
  }

  export type TestingMaintenanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | BusinessContinuityPlanDefaultArgs<ExtArgs>
  }
  export type TestingMaintenanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | BusinessContinuityPlanDefaultArgs<ExtArgs>
  }

  export type $TestingMaintenancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TestingMaintenance"
    objects: {
      plan: Prisma.$BusinessContinuityPlanPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      planId: string
      planTestingSchedule: string
      planRevisionHistory: string
      improvementTracking: string
      annualReviewProcess: string
      triggerEventsForUpdates: string
    }, ExtArgs["result"]["testingMaintenance"]>
    composites: {}
  }

  type TestingMaintenanceGetPayload<S extends boolean | null | undefined | TestingMaintenanceDefaultArgs> = $Result.GetResult<Prisma.$TestingMaintenancePayload, S>

  type TestingMaintenanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TestingMaintenanceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TestingMaintenanceCountAggregateInputType | true
    }

  export interface TestingMaintenanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TestingMaintenance'], meta: { name: 'TestingMaintenance' } }
    /**
     * Find zero or one TestingMaintenance that matches the filter.
     * @param {TestingMaintenanceFindUniqueArgs} args - Arguments to find a TestingMaintenance
     * @example
     * // Get one TestingMaintenance
     * const testingMaintenance = await prisma.testingMaintenance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TestingMaintenanceFindUniqueArgs>(args: SelectSubset<T, TestingMaintenanceFindUniqueArgs<ExtArgs>>): Prisma__TestingMaintenanceClient<$Result.GetResult<Prisma.$TestingMaintenancePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TestingMaintenance that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TestingMaintenanceFindUniqueOrThrowArgs} args - Arguments to find a TestingMaintenance
     * @example
     * // Get one TestingMaintenance
     * const testingMaintenance = await prisma.testingMaintenance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TestingMaintenanceFindUniqueOrThrowArgs>(args: SelectSubset<T, TestingMaintenanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TestingMaintenanceClient<$Result.GetResult<Prisma.$TestingMaintenancePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TestingMaintenance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestingMaintenanceFindFirstArgs} args - Arguments to find a TestingMaintenance
     * @example
     * // Get one TestingMaintenance
     * const testingMaintenance = await prisma.testingMaintenance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TestingMaintenanceFindFirstArgs>(args?: SelectSubset<T, TestingMaintenanceFindFirstArgs<ExtArgs>>): Prisma__TestingMaintenanceClient<$Result.GetResult<Prisma.$TestingMaintenancePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TestingMaintenance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestingMaintenanceFindFirstOrThrowArgs} args - Arguments to find a TestingMaintenance
     * @example
     * // Get one TestingMaintenance
     * const testingMaintenance = await prisma.testingMaintenance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TestingMaintenanceFindFirstOrThrowArgs>(args?: SelectSubset<T, TestingMaintenanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__TestingMaintenanceClient<$Result.GetResult<Prisma.$TestingMaintenancePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TestingMaintenances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestingMaintenanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TestingMaintenances
     * const testingMaintenances = await prisma.testingMaintenance.findMany()
     * 
     * // Get first 10 TestingMaintenances
     * const testingMaintenances = await prisma.testingMaintenance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const testingMaintenanceWithIdOnly = await prisma.testingMaintenance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TestingMaintenanceFindManyArgs>(args?: SelectSubset<T, TestingMaintenanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestingMaintenancePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TestingMaintenance.
     * @param {TestingMaintenanceCreateArgs} args - Arguments to create a TestingMaintenance.
     * @example
     * // Create one TestingMaintenance
     * const TestingMaintenance = await prisma.testingMaintenance.create({
     *   data: {
     *     // ... data to create a TestingMaintenance
     *   }
     * })
     * 
     */
    create<T extends TestingMaintenanceCreateArgs>(args: SelectSubset<T, TestingMaintenanceCreateArgs<ExtArgs>>): Prisma__TestingMaintenanceClient<$Result.GetResult<Prisma.$TestingMaintenancePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TestingMaintenances.
     * @param {TestingMaintenanceCreateManyArgs} args - Arguments to create many TestingMaintenances.
     * @example
     * // Create many TestingMaintenances
     * const testingMaintenance = await prisma.testingMaintenance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TestingMaintenanceCreateManyArgs>(args?: SelectSubset<T, TestingMaintenanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TestingMaintenances and returns the data saved in the database.
     * @param {TestingMaintenanceCreateManyAndReturnArgs} args - Arguments to create many TestingMaintenances.
     * @example
     * // Create many TestingMaintenances
     * const testingMaintenance = await prisma.testingMaintenance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TestingMaintenances and only return the `id`
     * const testingMaintenanceWithIdOnly = await prisma.testingMaintenance.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TestingMaintenanceCreateManyAndReturnArgs>(args?: SelectSubset<T, TestingMaintenanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestingMaintenancePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TestingMaintenance.
     * @param {TestingMaintenanceDeleteArgs} args - Arguments to delete one TestingMaintenance.
     * @example
     * // Delete one TestingMaintenance
     * const TestingMaintenance = await prisma.testingMaintenance.delete({
     *   where: {
     *     // ... filter to delete one TestingMaintenance
     *   }
     * })
     * 
     */
    delete<T extends TestingMaintenanceDeleteArgs>(args: SelectSubset<T, TestingMaintenanceDeleteArgs<ExtArgs>>): Prisma__TestingMaintenanceClient<$Result.GetResult<Prisma.$TestingMaintenancePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TestingMaintenance.
     * @param {TestingMaintenanceUpdateArgs} args - Arguments to update one TestingMaintenance.
     * @example
     * // Update one TestingMaintenance
     * const testingMaintenance = await prisma.testingMaintenance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TestingMaintenanceUpdateArgs>(args: SelectSubset<T, TestingMaintenanceUpdateArgs<ExtArgs>>): Prisma__TestingMaintenanceClient<$Result.GetResult<Prisma.$TestingMaintenancePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TestingMaintenances.
     * @param {TestingMaintenanceDeleteManyArgs} args - Arguments to filter TestingMaintenances to delete.
     * @example
     * // Delete a few TestingMaintenances
     * const { count } = await prisma.testingMaintenance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TestingMaintenanceDeleteManyArgs>(args?: SelectSubset<T, TestingMaintenanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TestingMaintenances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestingMaintenanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TestingMaintenances
     * const testingMaintenance = await prisma.testingMaintenance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TestingMaintenanceUpdateManyArgs>(args: SelectSubset<T, TestingMaintenanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TestingMaintenance.
     * @param {TestingMaintenanceUpsertArgs} args - Arguments to update or create a TestingMaintenance.
     * @example
     * // Update or create a TestingMaintenance
     * const testingMaintenance = await prisma.testingMaintenance.upsert({
     *   create: {
     *     // ... data to create a TestingMaintenance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TestingMaintenance we want to update
     *   }
     * })
     */
    upsert<T extends TestingMaintenanceUpsertArgs>(args: SelectSubset<T, TestingMaintenanceUpsertArgs<ExtArgs>>): Prisma__TestingMaintenanceClient<$Result.GetResult<Prisma.$TestingMaintenancePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TestingMaintenances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestingMaintenanceCountArgs} args - Arguments to filter TestingMaintenances to count.
     * @example
     * // Count the number of TestingMaintenances
     * const count = await prisma.testingMaintenance.count({
     *   where: {
     *     // ... the filter for the TestingMaintenances we want to count
     *   }
     * })
    **/
    count<T extends TestingMaintenanceCountArgs>(
      args?: Subset<T, TestingMaintenanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestingMaintenanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TestingMaintenance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestingMaintenanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestingMaintenanceAggregateArgs>(args: Subset<T, TestingMaintenanceAggregateArgs>): Prisma.PrismaPromise<GetTestingMaintenanceAggregateType<T>>

    /**
     * Group by TestingMaintenance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestingMaintenanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TestingMaintenanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TestingMaintenanceGroupByArgs['orderBy'] }
        : { orderBy?: TestingMaintenanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TestingMaintenanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestingMaintenanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TestingMaintenance model
   */
  readonly fields: TestingMaintenanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TestingMaintenance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TestingMaintenanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plan<T extends BusinessContinuityPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BusinessContinuityPlanDefaultArgs<ExtArgs>>): Prisma__BusinessContinuityPlanClient<$Result.GetResult<Prisma.$BusinessContinuityPlanPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TestingMaintenance model
   */ 
  interface TestingMaintenanceFieldRefs {
    readonly id: FieldRef<"TestingMaintenance", 'String'>
    readonly planId: FieldRef<"TestingMaintenance", 'String'>
    readonly planTestingSchedule: FieldRef<"TestingMaintenance", 'String'>
    readonly planRevisionHistory: FieldRef<"TestingMaintenance", 'String'>
    readonly improvementTracking: FieldRef<"TestingMaintenance", 'String'>
    readonly annualReviewProcess: FieldRef<"TestingMaintenance", 'String'>
    readonly triggerEventsForUpdates: FieldRef<"TestingMaintenance", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TestingMaintenance findUnique
   */
  export type TestingMaintenanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestingMaintenance
     */
    select?: TestingMaintenanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestingMaintenanceInclude<ExtArgs> | null
    /**
     * Filter, which TestingMaintenance to fetch.
     */
    where: TestingMaintenanceWhereUniqueInput
  }

  /**
   * TestingMaintenance findUniqueOrThrow
   */
  export type TestingMaintenanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestingMaintenance
     */
    select?: TestingMaintenanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestingMaintenanceInclude<ExtArgs> | null
    /**
     * Filter, which TestingMaintenance to fetch.
     */
    where: TestingMaintenanceWhereUniqueInput
  }

  /**
   * TestingMaintenance findFirst
   */
  export type TestingMaintenanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestingMaintenance
     */
    select?: TestingMaintenanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestingMaintenanceInclude<ExtArgs> | null
    /**
     * Filter, which TestingMaintenance to fetch.
     */
    where?: TestingMaintenanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestingMaintenances to fetch.
     */
    orderBy?: TestingMaintenanceOrderByWithRelationInput | TestingMaintenanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestingMaintenances.
     */
    cursor?: TestingMaintenanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestingMaintenances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestingMaintenances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestingMaintenances.
     */
    distinct?: TestingMaintenanceScalarFieldEnum | TestingMaintenanceScalarFieldEnum[]
  }

  /**
   * TestingMaintenance findFirstOrThrow
   */
  export type TestingMaintenanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestingMaintenance
     */
    select?: TestingMaintenanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestingMaintenanceInclude<ExtArgs> | null
    /**
     * Filter, which TestingMaintenance to fetch.
     */
    where?: TestingMaintenanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestingMaintenances to fetch.
     */
    orderBy?: TestingMaintenanceOrderByWithRelationInput | TestingMaintenanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestingMaintenances.
     */
    cursor?: TestingMaintenanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestingMaintenances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestingMaintenances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestingMaintenances.
     */
    distinct?: TestingMaintenanceScalarFieldEnum | TestingMaintenanceScalarFieldEnum[]
  }

  /**
   * TestingMaintenance findMany
   */
  export type TestingMaintenanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestingMaintenance
     */
    select?: TestingMaintenanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestingMaintenanceInclude<ExtArgs> | null
    /**
     * Filter, which TestingMaintenances to fetch.
     */
    where?: TestingMaintenanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestingMaintenances to fetch.
     */
    orderBy?: TestingMaintenanceOrderByWithRelationInput | TestingMaintenanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TestingMaintenances.
     */
    cursor?: TestingMaintenanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestingMaintenances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestingMaintenances.
     */
    skip?: number
    distinct?: TestingMaintenanceScalarFieldEnum | TestingMaintenanceScalarFieldEnum[]
  }

  /**
   * TestingMaintenance create
   */
  export type TestingMaintenanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestingMaintenance
     */
    select?: TestingMaintenanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestingMaintenanceInclude<ExtArgs> | null
    /**
     * The data needed to create a TestingMaintenance.
     */
    data: XOR<TestingMaintenanceCreateInput, TestingMaintenanceUncheckedCreateInput>
  }

  /**
   * TestingMaintenance createMany
   */
  export type TestingMaintenanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TestingMaintenances.
     */
    data: TestingMaintenanceCreateManyInput | TestingMaintenanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TestingMaintenance createManyAndReturn
   */
  export type TestingMaintenanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestingMaintenance
     */
    select?: TestingMaintenanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TestingMaintenances.
     */
    data: TestingMaintenanceCreateManyInput | TestingMaintenanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestingMaintenanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TestingMaintenance update
   */
  export type TestingMaintenanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestingMaintenance
     */
    select?: TestingMaintenanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestingMaintenanceInclude<ExtArgs> | null
    /**
     * The data needed to update a TestingMaintenance.
     */
    data: XOR<TestingMaintenanceUpdateInput, TestingMaintenanceUncheckedUpdateInput>
    /**
     * Choose, which TestingMaintenance to update.
     */
    where: TestingMaintenanceWhereUniqueInput
  }

  /**
   * TestingMaintenance updateMany
   */
  export type TestingMaintenanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TestingMaintenances.
     */
    data: XOR<TestingMaintenanceUpdateManyMutationInput, TestingMaintenanceUncheckedUpdateManyInput>
    /**
     * Filter which TestingMaintenances to update
     */
    where?: TestingMaintenanceWhereInput
  }

  /**
   * TestingMaintenance upsert
   */
  export type TestingMaintenanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestingMaintenance
     */
    select?: TestingMaintenanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestingMaintenanceInclude<ExtArgs> | null
    /**
     * The filter to search for the TestingMaintenance to update in case it exists.
     */
    where: TestingMaintenanceWhereUniqueInput
    /**
     * In case the TestingMaintenance found by the `where` argument doesn't exist, create a new TestingMaintenance with this data.
     */
    create: XOR<TestingMaintenanceCreateInput, TestingMaintenanceUncheckedCreateInput>
    /**
     * In case the TestingMaintenance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TestingMaintenanceUpdateInput, TestingMaintenanceUncheckedUpdateInput>
  }

  /**
   * TestingMaintenance delete
   */
  export type TestingMaintenanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestingMaintenance
     */
    select?: TestingMaintenanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestingMaintenanceInclude<ExtArgs> | null
    /**
     * Filter which TestingMaintenance to delete.
     */
    where: TestingMaintenanceWhereUniqueInput
  }

  /**
   * TestingMaintenance deleteMany
   */
  export type TestingMaintenanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestingMaintenances to delete
     */
    where?: TestingMaintenanceWhereInput
  }

  /**
   * TestingMaintenance without action
   */
  export type TestingMaintenanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestingMaintenance
     */
    select?: TestingMaintenanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestingMaintenanceInclude<ExtArgs> | null
  }


  /**
   * Model AnonymousSession
   */

  export type AggregateAnonymousSession = {
    _count: AnonymousSessionCountAggregateOutputType | null
    _min: AnonymousSessionMinAggregateOutputType | null
    _max: AnonymousSessionMaxAggregateOutputType | null
  }

  export type AnonymousSessionMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    businessName: string | null
    displayBusinessName: string | null
    pin: string | null
    email: string | null
    planData: string | null
    shareableId: string | null
    allowSharing: boolean | null
    createdAt: Date | null
    lastAccessed: Date | null
  }

  export type AnonymousSessionMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    businessName: string | null
    displayBusinessName: string | null
    pin: string | null
    email: string | null
    planData: string | null
    shareableId: string | null
    allowSharing: boolean | null
    createdAt: Date | null
    lastAccessed: Date | null
  }

  export type AnonymousSessionCountAggregateOutputType = {
    id: number
    sessionId: number
    businessName: number
    displayBusinessName: number
    pin: number
    email: number
    planData: number
    shareableId: number
    allowSharing: number
    createdAt: number
    lastAccessed: number
    _all: number
  }


  export type AnonymousSessionMinAggregateInputType = {
    id?: true
    sessionId?: true
    businessName?: true
    displayBusinessName?: true
    pin?: true
    email?: true
    planData?: true
    shareableId?: true
    allowSharing?: true
    createdAt?: true
    lastAccessed?: true
  }

  export type AnonymousSessionMaxAggregateInputType = {
    id?: true
    sessionId?: true
    businessName?: true
    displayBusinessName?: true
    pin?: true
    email?: true
    planData?: true
    shareableId?: true
    allowSharing?: true
    createdAt?: true
    lastAccessed?: true
  }

  export type AnonymousSessionCountAggregateInputType = {
    id?: true
    sessionId?: true
    businessName?: true
    displayBusinessName?: true
    pin?: true
    email?: true
    planData?: true
    shareableId?: true
    allowSharing?: true
    createdAt?: true
    lastAccessed?: true
    _all?: true
  }

  export type AnonymousSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnonymousSession to aggregate.
     */
    where?: AnonymousSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnonymousSessions to fetch.
     */
    orderBy?: AnonymousSessionOrderByWithRelationInput | AnonymousSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnonymousSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnonymousSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnonymousSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AnonymousSessions
    **/
    _count?: true | AnonymousSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnonymousSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnonymousSessionMaxAggregateInputType
  }

  export type GetAnonymousSessionAggregateType<T extends AnonymousSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateAnonymousSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnonymousSession[P]>
      : GetScalarType<T[P], AggregateAnonymousSession[P]>
  }




  export type AnonymousSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnonymousSessionWhereInput
    orderBy?: AnonymousSessionOrderByWithAggregationInput | AnonymousSessionOrderByWithAggregationInput[]
    by: AnonymousSessionScalarFieldEnum[] | AnonymousSessionScalarFieldEnum
    having?: AnonymousSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnonymousSessionCountAggregateInputType | true
    _min?: AnonymousSessionMinAggregateInputType
    _max?: AnonymousSessionMaxAggregateInputType
  }

  export type AnonymousSessionGroupByOutputType = {
    id: string
    sessionId: string
    businessName: string
    displayBusinessName: string
    pin: string
    email: string | null
    planData: string
    shareableId: string | null
    allowSharing: boolean
    createdAt: Date
    lastAccessed: Date
    _count: AnonymousSessionCountAggregateOutputType | null
    _min: AnonymousSessionMinAggregateOutputType | null
    _max: AnonymousSessionMaxAggregateOutputType | null
  }

  type GetAnonymousSessionGroupByPayload<T extends AnonymousSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnonymousSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnonymousSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnonymousSessionGroupByOutputType[P]>
            : GetScalarType<T[P], AnonymousSessionGroupByOutputType[P]>
        }
      >
    >


  export type AnonymousSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    businessName?: boolean
    displayBusinessName?: boolean
    pin?: boolean
    email?: boolean
    planData?: boolean
    shareableId?: boolean
    allowSharing?: boolean
    createdAt?: boolean
    lastAccessed?: boolean
  }, ExtArgs["result"]["anonymousSession"]>

  export type AnonymousSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    businessName?: boolean
    displayBusinessName?: boolean
    pin?: boolean
    email?: boolean
    planData?: boolean
    shareableId?: boolean
    allowSharing?: boolean
    createdAt?: boolean
    lastAccessed?: boolean
  }, ExtArgs["result"]["anonymousSession"]>

  export type AnonymousSessionSelectScalar = {
    id?: boolean
    sessionId?: boolean
    businessName?: boolean
    displayBusinessName?: boolean
    pin?: boolean
    email?: boolean
    planData?: boolean
    shareableId?: boolean
    allowSharing?: boolean
    createdAt?: boolean
    lastAccessed?: boolean
  }


  export type $AnonymousSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AnonymousSession"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      businessName: string
      displayBusinessName: string
      pin: string
      email: string | null
      planData: string
      shareableId: string | null
      allowSharing: boolean
      createdAt: Date
      lastAccessed: Date
    }, ExtArgs["result"]["anonymousSession"]>
    composites: {}
  }

  type AnonymousSessionGetPayload<S extends boolean | null | undefined | AnonymousSessionDefaultArgs> = $Result.GetResult<Prisma.$AnonymousSessionPayload, S>

  type AnonymousSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AnonymousSessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AnonymousSessionCountAggregateInputType | true
    }

  export interface AnonymousSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AnonymousSession'], meta: { name: 'AnonymousSession' } }
    /**
     * Find zero or one AnonymousSession that matches the filter.
     * @param {AnonymousSessionFindUniqueArgs} args - Arguments to find a AnonymousSession
     * @example
     * // Get one AnonymousSession
     * const anonymousSession = await prisma.anonymousSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnonymousSessionFindUniqueArgs>(args: SelectSubset<T, AnonymousSessionFindUniqueArgs<ExtArgs>>): Prisma__AnonymousSessionClient<$Result.GetResult<Prisma.$AnonymousSessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AnonymousSession that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AnonymousSessionFindUniqueOrThrowArgs} args - Arguments to find a AnonymousSession
     * @example
     * // Get one AnonymousSession
     * const anonymousSession = await prisma.anonymousSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnonymousSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, AnonymousSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnonymousSessionClient<$Result.GetResult<Prisma.$AnonymousSessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AnonymousSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnonymousSessionFindFirstArgs} args - Arguments to find a AnonymousSession
     * @example
     * // Get one AnonymousSession
     * const anonymousSession = await prisma.anonymousSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnonymousSessionFindFirstArgs>(args?: SelectSubset<T, AnonymousSessionFindFirstArgs<ExtArgs>>): Prisma__AnonymousSessionClient<$Result.GetResult<Prisma.$AnonymousSessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AnonymousSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnonymousSessionFindFirstOrThrowArgs} args - Arguments to find a AnonymousSession
     * @example
     * // Get one AnonymousSession
     * const anonymousSession = await prisma.anonymousSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnonymousSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, AnonymousSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnonymousSessionClient<$Result.GetResult<Prisma.$AnonymousSessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AnonymousSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnonymousSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AnonymousSessions
     * const anonymousSessions = await prisma.anonymousSession.findMany()
     * 
     * // Get first 10 AnonymousSessions
     * const anonymousSessions = await prisma.anonymousSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const anonymousSessionWithIdOnly = await prisma.anonymousSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnonymousSessionFindManyArgs>(args?: SelectSubset<T, AnonymousSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnonymousSessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AnonymousSession.
     * @param {AnonymousSessionCreateArgs} args - Arguments to create a AnonymousSession.
     * @example
     * // Create one AnonymousSession
     * const AnonymousSession = await prisma.anonymousSession.create({
     *   data: {
     *     // ... data to create a AnonymousSession
     *   }
     * })
     * 
     */
    create<T extends AnonymousSessionCreateArgs>(args: SelectSubset<T, AnonymousSessionCreateArgs<ExtArgs>>): Prisma__AnonymousSessionClient<$Result.GetResult<Prisma.$AnonymousSessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AnonymousSessions.
     * @param {AnonymousSessionCreateManyArgs} args - Arguments to create many AnonymousSessions.
     * @example
     * // Create many AnonymousSessions
     * const anonymousSession = await prisma.anonymousSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnonymousSessionCreateManyArgs>(args?: SelectSubset<T, AnonymousSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AnonymousSessions and returns the data saved in the database.
     * @param {AnonymousSessionCreateManyAndReturnArgs} args - Arguments to create many AnonymousSessions.
     * @example
     * // Create many AnonymousSessions
     * const anonymousSession = await prisma.anonymousSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AnonymousSessions and only return the `id`
     * const anonymousSessionWithIdOnly = await prisma.anonymousSession.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnonymousSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, AnonymousSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnonymousSessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AnonymousSession.
     * @param {AnonymousSessionDeleteArgs} args - Arguments to delete one AnonymousSession.
     * @example
     * // Delete one AnonymousSession
     * const AnonymousSession = await prisma.anonymousSession.delete({
     *   where: {
     *     // ... filter to delete one AnonymousSession
     *   }
     * })
     * 
     */
    delete<T extends AnonymousSessionDeleteArgs>(args: SelectSubset<T, AnonymousSessionDeleteArgs<ExtArgs>>): Prisma__AnonymousSessionClient<$Result.GetResult<Prisma.$AnonymousSessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AnonymousSession.
     * @param {AnonymousSessionUpdateArgs} args - Arguments to update one AnonymousSession.
     * @example
     * // Update one AnonymousSession
     * const anonymousSession = await prisma.anonymousSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnonymousSessionUpdateArgs>(args: SelectSubset<T, AnonymousSessionUpdateArgs<ExtArgs>>): Prisma__AnonymousSessionClient<$Result.GetResult<Prisma.$AnonymousSessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AnonymousSessions.
     * @param {AnonymousSessionDeleteManyArgs} args - Arguments to filter AnonymousSessions to delete.
     * @example
     * // Delete a few AnonymousSessions
     * const { count } = await prisma.anonymousSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnonymousSessionDeleteManyArgs>(args?: SelectSubset<T, AnonymousSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnonymousSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnonymousSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AnonymousSessions
     * const anonymousSession = await prisma.anonymousSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnonymousSessionUpdateManyArgs>(args: SelectSubset<T, AnonymousSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AnonymousSession.
     * @param {AnonymousSessionUpsertArgs} args - Arguments to update or create a AnonymousSession.
     * @example
     * // Update or create a AnonymousSession
     * const anonymousSession = await prisma.anonymousSession.upsert({
     *   create: {
     *     // ... data to create a AnonymousSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AnonymousSession we want to update
     *   }
     * })
     */
    upsert<T extends AnonymousSessionUpsertArgs>(args: SelectSubset<T, AnonymousSessionUpsertArgs<ExtArgs>>): Prisma__AnonymousSessionClient<$Result.GetResult<Prisma.$AnonymousSessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AnonymousSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnonymousSessionCountArgs} args - Arguments to filter AnonymousSessions to count.
     * @example
     * // Count the number of AnonymousSessions
     * const count = await prisma.anonymousSession.count({
     *   where: {
     *     // ... the filter for the AnonymousSessions we want to count
     *   }
     * })
    **/
    count<T extends AnonymousSessionCountArgs>(
      args?: Subset<T, AnonymousSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnonymousSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AnonymousSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnonymousSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnonymousSessionAggregateArgs>(args: Subset<T, AnonymousSessionAggregateArgs>): Prisma.PrismaPromise<GetAnonymousSessionAggregateType<T>>

    /**
     * Group by AnonymousSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnonymousSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnonymousSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnonymousSessionGroupByArgs['orderBy'] }
        : { orderBy?: AnonymousSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnonymousSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnonymousSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AnonymousSession model
   */
  readonly fields: AnonymousSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AnonymousSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnonymousSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AnonymousSession model
   */ 
  interface AnonymousSessionFieldRefs {
    readonly id: FieldRef<"AnonymousSession", 'String'>
    readonly sessionId: FieldRef<"AnonymousSession", 'String'>
    readonly businessName: FieldRef<"AnonymousSession", 'String'>
    readonly displayBusinessName: FieldRef<"AnonymousSession", 'String'>
    readonly pin: FieldRef<"AnonymousSession", 'String'>
    readonly email: FieldRef<"AnonymousSession", 'String'>
    readonly planData: FieldRef<"AnonymousSession", 'String'>
    readonly shareableId: FieldRef<"AnonymousSession", 'String'>
    readonly allowSharing: FieldRef<"AnonymousSession", 'Boolean'>
    readonly createdAt: FieldRef<"AnonymousSession", 'DateTime'>
    readonly lastAccessed: FieldRef<"AnonymousSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AnonymousSession findUnique
   */
  export type AnonymousSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnonymousSession
     */
    select?: AnonymousSessionSelect<ExtArgs> | null
    /**
     * Filter, which AnonymousSession to fetch.
     */
    where: AnonymousSessionWhereUniqueInput
  }

  /**
   * AnonymousSession findUniqueOrThrow
   */
  export type AnonymousSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnonymousSession
     */
    select?: AnonymousSessionSelect<ExtArgs> | null
    /**
     * Filter, which AnonymousSession to fetch.
     */
    where: AnonymousSessionWhereUniqueInput
  }

  /**
   * AnonymousSession findFirst
   */
  export type AnonymousSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnonymousSession
     */
    select?: AnonymousSessionSelect<ExtArgs> | null
    /**
     * Filter, which AnonymousSession to fetch.
     */
    where?: AnonymousSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnonymousSessions to fetch.
     */
    orderBy?: AnonymousSessionOrderByWithRelationInput | AnonymousSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnonymousSessions.
     */
    cursor?: AnonymousSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnonymousSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnonymousSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnonymousSessions.
     */
    distinct?: AnonymousSessionScalarFieldEnum | AnonymousSessionScalarFieldEnum[]
  }

  /**
   * AnonymousSession findFirstOrThrow
   */
  export type AnonymousSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnonymousSession
     */
    select?: AnonymousSessionSelect<ExtArgs> | null
    /**
     * Filter, which AnonymousSession to fetch.
     */
    where?: AnonymousSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnonymousSessions to fetch.
     */
    orderBy?: AnonymousSessionOrderByWithRelationInput | AnonymousSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnonymousSessions.
     */
    cursor?: AnonymousSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnonymousSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnonymousSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnonymousSessions.
     */
    distinct?: AnonymousSessionScalarFieldEnum | AnonymousSessionScalarFieldEnum[]
  }

  /**
   * AnonymousSession findMany
   */
  export type AnonymousSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnonymousSession
     */
    select?: AnonymousSessionSelect<ExtArgs> | null
    /**
     * Filter, which AnonymousSessions to fetch.
     */
    where?: AnonymousSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnonymousSessions to fetch.
     */
    orderBy?: AnonymousSessionOrderByWithRelationInput | AnonymousSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AnonymousSessions.
     */
    cursor?: AnonymousSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnonymousSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnonymousSessions.
     */
    skip?: number
    distinct?: AnonymousSessionScalarFieldEnum | AnonymousSessionScalarFieldEnum[]
  }

  /**
   * AnonymousSession create
   */
  export type AnonymousSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnonymousSession
     */
    select?: AnonymousSessionSelect<ExtArgs> | null
    /**
     * The data needed to create a AnonymousSession.
     */
    data: XOR<AnonymousSessionCreateInput, AnonymousSessionUncheckedCreateInput>
  }

  /**
   * AnonymousSession createMany
   */
  export type AnonymousSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AnonymousSessions.
     */
    data: AnonymousSessionCreateManyInput | AnonymousSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AnonymousSession createManyAndReturn
   */
  export type AnonymousSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnonymousSession
     */
    select?: AnonymousSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AnonymousSessions.
     */
    data: AnonymousSessionCreateManyInput | AnonymousSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AnonymousSession update
   */
  export type AnonymousSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnonymousSession
     */
    select?: AnonymousSessionSelect<ExtArgs> | null
    /**
     * The data needed to update a AnonymousSession.
     */
    data: XOR<AnonymousSessionUpdateInput, AnonymousSessionUncheckedUpdateInput>
    /**
     * Choose, which AnonymousSession to update.
     */
    where: AnonymousSessionWhereUniqueInput
  }

  /**
   * AnonymousSession updateMany
   */
  export type AnonymousSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AnonymousSessions.
     */
    data: XOR<AnonymousSessionUpdateManyMutationInput, AnonymousSessionUncheckedUpdateManyInput>
    /**
     * Filter which AnonymousSessions to update
     */
    where?: AnonymousSessionWhereInput
  }

  /**
   * AnonymousSession upsert
   */
  export type AnonymousSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnonymousSession
     */
    select?: AnonymousSessionSelect<ExtArgs> | null
    /**
     * The filter to search for the AnonymousSession to update in case it exists.
     */
    where: AnonymousSessionWhereUniqueInput
    /**
     * In case the AnonymousSession found by the `where` argument doesn't exist, create a new AnonymousSession with this data.
     */
    create: XOR<AnonymousSessionCreateInput, AnonymousSessionUncheckedCreateInput>
    /**
     * In case the AnonymousSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnonymousSessionUpdateInput, AnonymousSessionUncheckedUpdateInput>
  }

  /**
   * AnonymousSession delete
   */
  export type AnonymousSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnonymousSession
     */
    select?: AnonymousSessionSelect<ExtArgs> | null
    /**
     * Filter which AnonymousSession to delete.
     */
    where: AnonymousSessionWhereUniqueInput
  }

  /**
   * AnonymousSession deleteMany
   */
  export type AnonymousSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnonymousSessions to delete
     */
    where?: AnonymousSessionWhereInput
  }

  /**
   * AnonymousSession without action
   */
  export type AnonymousSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnonymousSession
     */
    select?: AnonymousSessionSelect<ExtArgs> | null
  }


  /**
   * Model AdminBusinessType
   */

  export type AggregateAdminBusinessType = {
    _count: AdminBusinessTypeCountAggregateOutputType | null
    _min: AdminBusinessTypeMinAggregateOutputType | null
    _max: AdminBusinessTypeMaxAggregateOutputType | null
  }

  export type AdminBusinessTypeMinAggregateOutputType = {
    id: string | null
    businessTypeId: string | null
    name: string | null
    localName: string | null
    category: string | null
    description: string | null
    typicalOperatingHours: string | null
    minimumStaff: string | null
    minimumEquipment: string | null
    minimumUtilities: string | null
    minimumSpace: string | null
    essentialFunctions: string | null
    criticalSuppliers: string | null
    exampleBusinessPurposes: string | null
    exampleProducts: string | null
    exampleKeyPersonnel: string | null
    exampleCustomerBase: string | null
    dependencies: string | null
    vulnerabilityMatrix: string | null
    operationalThresholds: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminBusinessTypeMaxAggregateOutputType = {
    id: string | null
    businessTypeId: string | null
    name: string | null
    localName: string | null
    category: string | null
    description: string | null
    typicalOperatingHours: string | null
    minimumStaff: string | null
    minimumEquipment: string | null
    minimumUtilities: string | null
    minimumSpace: string | null
    essentialFunctions: string | null
    criticalSuppliers: string | null
    exampleBusinessPurposes: string | null
    exampleProducts: string | null
    exampleKeyPersonnel: string | null
    exampleCustomerBase: string | null
    dependencies: string | null
    vulnerabilityMatrix: string | null
    operationalThresholds: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminBusinessTypeCountAggregateOutputType = {
    id: number
    businessTypeId: number
    name: number
    localName: number
    category: number
    description: number
    typicalOperatingHours: number
    minimumStaff: number
    minimumEquipment: number
    minimumUtilities: number
    minimumSpace: number
    essentialFunctions: number
    criticalSuppliers: number
    exampleBusinessPurposes: number
    exampleProducts: number
    exampleKeyPersonnel: number
    exampleCustomerBase: number
    dependencies: number
    vulnerabilityMatrix: number
    operationalThresholds: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdminBusinessTypeMinAggregateInputType = {
    id?: true
    businessTypeId?: true
    name?: true
    localName?: true
    category?: true
    description?: true
    typicalOperatingHours?: true
    minimumStaff?: true
    minimumEquipment?: true
    minimumUtilities?: true
    minimumSpace?: true
    essentialFunctions?: true
    criticalSuppliers?: true
    exampleBusinessPurposes?: true
    exampleProducts?: true
    exampleKeyPersonnel?: true
    exampleCustomerBase?: true
    dependencies?: true
    vulnerabilityMatrix?: true
    operationalThresholds?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminBusinessTypeMaxAggregateInputType = {
    id?: true
    businessTypeId?: true
    name?: true
    localName?: true
    category?: true
    description?: true
    typicalOperatingHours?: true
    minimumStaff?: true
    minimumEquipment?: true
    minimumUtilities?: true
    minimumSpace?: true
    essentialFunctions?: true
    criticalSuppliers?: true
    exampleBusinessPurposes?: true
    exampleProducts?: true
    exampleKeyPersonnel?: true
    exampleCustomerBase?: true
    dependencies?: true
    vulnerabilityMatrix?: true
    operationalThresholds?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminBusinessTypeCountAggregateInputType = {
    id?: true
    businessTypeId?: true
    name?: true
    localName?: true
    category?: true
    description?: true
    typicalOperatingHours?: true
    minimumStaff?: true
    minimumEquipment?: true
    minimumUtilities?: true
    minimumSpace?: true
    essentialFunctions?: true
    criticalSuppliers?: true
    exampleBusinessPurposes?: true
    exampleProducts?: true
    exampleKeyPersonnel?: true
    exampleCustomerBase?: true
    dependencies?: true
    vulnerabilityMatrix?: true
    operationalThresholds?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdminBusinessTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminBusinessType to aggregate.
     */
    where?: AdminBusinessTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminBusinessTypes to fetch.
     */
    orderBy?: AdminBusinessTypeOrderByWithRelationInput | AdminBusinessTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminBusinessTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminBusinessTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminBusinessTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminBusinessTypes
    **/
    _count?: true | AdminBusinessTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminBusinessTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminBusinessTypeMaxAggregateInputType
  }

  export type GetAdminBusinessTypeAggregateType<T extends AdminBusinessTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminBusinessType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminBusinessType[P]>
      : GetScalarType<T[P], AggregateAdminBusinessType[P]>
  }




  export type AdminBusinessTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminBusinessTypeWhereInput
    orderBy?: AdminBusinessTypeOrderByWithAggregationInput | AdminBusinessTypeOrderByWithAggregationInput[]
    by: AdminBusinessTypeScalarFieldEnum[] | AdminBusinessTypeScalarFieldEnum
    having?: AdminBusinessTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminBusinessTypeCountAggregateInputType | true
    _min?: AdminBusinessTypeMinAggregateInputType
    _max?: AdminBusinessTypeMaxAggregateInputType
  }

  export type AdminBusinessTypeGroupByOutputType = {
    id: string
    businessTypeId: string
    name: string
    localName: string
    category: string
    description: string | null
    typicalOperatingHours: string | null
    minimumStaff: string | null
    minimumEquipment: string | null
    minimumUtilities: string | null
    minimumSpace: string | null
    essentialFunctions: string | null
    criticalSuppliers: string | null
    exampleBusinessPurposes: string | null
    exampleProducts: string | null
    exampleKeyPersonnel: string | null
    exampleCustomerBase: string | null
    dependencies: string | null
    vulnerabilityMatrix: string | null
    operationalThresholds: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: AdminBusinessTypeCountAggregateOutputType | null
    _min: AdminBusinessTypeMinAggregateOutputType | null
    _max: AdminBusinessTypeMaxAggregateOutputType | null
  }

  type GetAdminBusinessTypeGroupByPayload<T extends AdminBusinessTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminBusinessTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminBusinessTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminBusinessTypeGroupByOutputType[P]>
            : GetScalarType<T[P], AdminBusinessTypeGroupByOutputType[P]>
        }
      >
    >


  export type AdminBusinessTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessTypeId?: boolean
    name?: boolean
    localName?: boolean
    category?: boolean
    description?: boolean
    typicalOperatingHours?: boolean
    minimumStaff?: boolean
    minimumEquipment?: boolean
    minimumUtilities?: boolean
    minimumSpace?: boolean
    essentialFunctions?: boolean
    criticalSuppliers?: boolean
    exampleBusinessPurposes?: boolean
    exampleProducts?: boolean
    exampleKeyPersonnel?: boolean
    exampleCustomerBase?: boolean
    dependencies?: boolean
    vulnerabilityMatrix?: boolean
    operationalThresholds?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    businessTypeHazards?: boolean | AdminBusinessType$businessTypeHazardsArgs<ExtArgs>
    riskProfiles?: boolean | AdminBusinessType$riskProfilesArgs<ExtArgs>
    _count?: boolean | AdminBusinessTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminBusinessType"]>

  export type AdminBusinessTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessTypeId?: boolean
    name?: boolean
    localName?: boolean
    category?: boolean
    description?: boolean
    typicalOperatingHours?: boolean
    minimumStaff?: boolean
    minimumEquipment?: boolean
    minimumUtilities?: boolean
    minimumSpace?: boolean
    essentialFunctions?: boolean
    criticalSuppliers?: boolean
    exampleBusinessPurposes?: boolean
    exampleProducts?: boolean
    exampleKeyPersonnel?: boolean
    exampleCustomerBase?: boolean
    dependencies?: boolean
    vulnerabilityMatrix?: boolean
    operationalThresholds?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["adminBusinessType"]>

  export type AdminBusinessTypeSelectScalar = {
    id?: boolean
    businessTypeId?: boolean
    name?: boolean
    localName?: boolean
    category?: boolean
    description?: boolean
    typicalOperatingHours?: boolean
    minimumStaff?: boolean
    minimumEquipment?: boolean
    minimumUtilities?: boolean
    minimumSpace?: boolean
    essentialFunctions?: boolean
    criticalSuppliers?: boolean
    exampleBusinessPurposes?: boolean
    exampleProducts?: boolean
    exampleKeyPersonnel?: boolean
    exampleCustomerBase?: boolean
    dependencies?: boolean
    vulnerabilityMatrix?: boolean
    operationalThresholds?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdminBusinessTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businessTypeHazards?: boolean | AdminBusinessType$businessTypeHazardsArgs<ExtArgs>
    riskProfiles?: boolean | AdminBusinessType$riskProfilesArgs<ExtArgs>
    _count?: boolean | AdminBusinessTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AdminBusinessTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AdminBusinessTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminBusinessType"
    objects: {
      businessTypeHazards: Prisma.$AdminBusinessTypeHazardPayload<ExtArgs>[]
      riskProfiles: Prisma.$AdminRiskProfilePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      businessTypeId: string
      name: string
      localName: string
      category: string
      description: string | null
      typicalOperatingHours: string | null
      minimumStaff: string | null
      minimumEquipment: string | null
      minimumUtilities: string | null
      minimumSpace: string | null
      essentialFunctions: string | null
      criticalSuppliers: string | null
      exampleBusinessPurposes: string | null
      exampleProducts: string | null
      exampleKeyPersonnel: string | null
      exampleCustomerBase: string | null
      dependencies: string | null
      vulnerabilityMatrix: string | null
      operationalThresholds: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["adminBusinessType"]>
    composites: {}
  }

  type AdminBusinessTypeGetPayload<S extends boolean | null | undefined | AdminBusinessTypeDefaultArgs> = $Result.GetResult<Prisma.$AdminBusinessTypePayload, S>

  type AdminBusinessTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdminBusinessTypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdminBusinessTypeCountAggregateInputType | true
    }

  export interface AdminBusinessTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminBusinessType'], meta: { name: 'AdminBusinessType' } }
    /**
     * Find zero or one AdminBusinessType that matches the filter.
     * @param {AdminBusinessTypeFindUniqueArgs} args - Arguments to find a AdminBusinessType
     * @example
     * // Get one AdminBusinessType
     * const adminBusinessType = await prisma.adminBusinessType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminBusinessTypeFindUniqueArgs>(args: SelectSubset<T, AdminBusinessTypeFindUniqueArgs<ExtArgs>>): Prisma__AdminBusinessTypeClient<$Result.GetResult<Prisma.$AdminBusinessTypePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AdminBusinessType that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdminBusinessTypeFindUniqueOrThrowArgs} args - Arguments to find a AdminBusinessType
     * @example
     * // Get one AdminBusinessType
     * const adminBusinessType = await prisma.adminBusinessType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminBusinessTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminBusinessTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminBusinessTypeClient<$Result.GetResult<Prisma.$AdminBusinessTypePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AdminBusinessType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminBusinessTypeFindFirstArgs} args - Arguments to find a AdminBusinessType
     * @example
     * // Get one AdminBusinessType
     * const adminBusinessType = await prisma.adminBusinessType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminBusinessTypeFindFirstArgs>(args?: SelectSubset<T, AdminBusinessTypeFindFirstArgs<ExtArgs>>): Prisma__AdminBusinessTypeClient<$Result.GetResult<Prisma.$AdminBusinessTypePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AdminBusinessType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminBusinessTypeFindFirstOrThrowArgs} args - Arguments to find a AdminBusinessType
     * @example
     * // Get one AdminBusinessType
     * const adminBusinessType = await prisma.adminBusinessType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminBusinessTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminBusinessTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminBusinessTypeClient<$Result.GetResult<Prisma.$AdminBusinessTypePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AdminBusinessTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminBusinessTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminBusinessTypes
     * const adminBusinessTypes = await prisma.adminBusinessType.findMany()
     * 
     * // Get first 10 AdminBusinessTypes
     * const adminBusinessTypes = await prisma.adminBusinessType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminBusinessTypeWithIdOnly = await prisma.adminBusinessType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminBusinessTypeFindManyArgs>(args?: SelectSubset<T, AdminBusinessTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminBusinessTypePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AdminBusinessType.
     * @param {AdminBusinessTypeCreateArgs} args - Arguments to create a AdminBusinessType.
     * @example
     * // Create one AdminBusinessType
     * const AdminBusinessType = await prisma.adminBusinessType.create({
     *   data: {
     *     // ... data to create a AdminBusinessType
     *   }
     * })
     * 
     */
    create<T extends AdminBusinessTypeCreateArgs>(args: SelectSubset<T, AdminBusinessTypeCreateArgs<ExtArgs>>): Prisma__AdminBusinessTypeClient<$Result.GetResult<Prisma.$AdminBusinessTypePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AdminBusinessTypes.
     * @param {AdminBusinessTypeCreateManyArgs} args - Arguments to create many AdminBusinessTypes.
     * @example
     * // Create many AdminBusinessTypes
     * const adminBusinessType = await prisma.adminBusinessType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminBusinessTypeCreateManyArgs>(args?: SelectSubset<T, AdminBusinessTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminBusinessTypes and returns the data saved in the database.
     * @param {AdminBusinessTypeCreateManyAndReturnArgs} args - Arguments to create many AdminBusinessTypes.
     * @example
     * // Create many AdminBusinessTypes
     * const adminBusinessType = await prisma.adminBusinessType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminBusinessTypes and only return the `id`
     * const adminBusinessTypeWithIdOnly = await prisma.adminBusinessType.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminBusinessTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminBusinessTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminBusinessTypePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AdminBusinessType.
     * @param {AdminBusinessTypeDeleteArgs} args - Arguments to delete one AdminBusinessType.
     * @example
     * // Delete one AdminBusinessType
     * const AdminBusinessType = await prisma.adminBusinessType.delete({
     *   where: {
     *     // ... filter to delete one AdminBusinessType
     *   }
     * })
     * 
     */
    delete<T extends AdminBusinessTypeDeleteArgs>(args: SelectSubset<T, AdminBusinessTypeDeleteArgs<ExtArgs>>): Prisma__AdminBusinessTypeClient<$Result.GetResult<Prisma.$AdminBusinessTypePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AdminBusinessType.
     * @param {AdminBusinessTypeUpdateArgs} args - Arguments to update one AdminBusinessType.
     * @example
     * // Update one AdminBusinessType
     * const adminBusinessType = await prisma.adminBusinessType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminBusinessTypeUpdateArgs>(args: SelectSubset<T, AdminBusinessTypeUpdateArgs<ExtArgs>>): Prisma__AdminBusinessTypeClient<$Result.GetResult<Prisma.$AdminBusinessTypePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AdminBusinessTypes.
     * @param {AdminBusinessTypeDeleteManyArgs} args - Arguments to filter AdminBusinessTypes to delete.
     * @example
     * // Delete a few AdminBusinessTypes
     * const { count } = await prisma.adminBusinessType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminBusinessTypeDeleteManyArgs>(args?: SelectSubset<T, AdminBusinessTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminBusinessTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminBusinessTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminBusinessTypes
     * const adminBusinessType = await prisma.adminBusinessType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminBusinessTypeUpdateManyArgs>(args: SelectSubset<T, AdminBusinessTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AdminBusinessType.
     * @param {AdminBusinessTypeUpsertArgs} args - Arguments to update or create a AdminBusinessType.
     * @example
     * // Update or create a AdminBusinessType
     * const adminBusinessType = await prisma.adminBusinessType.upsert({
     *   create: {
     *     // ... data to create a AdminBusinessType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminBusinessType we want to update
     *   }
     * })
     */
    upsert<T extends AdminBusinessTypeUpsertArgs>(args: SelectSubset<T, AdminBusinessTypeUpsertArgs<ExtArgs>>): Prisma__AdminBusinessTypeClient<$Result.GetResult<Prisma.$AdminBusinessTypePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AdminBusinessTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminBusinessTypeCountArgs} args - Arguments to filter AdminBusinessTypes to count.
     * @example
     * // Count the number of AdminBusinessTypes
     * const count = await prisma.adminBusinessType.count({
     *   where: {
     *     // ... the filter for the AdminBusinessTypes we want to count
     *   }
     * })
    **/
    count<T extends AdminBusinessTypeCountArgs>(
      args?: Subset<T, AdminBusinessTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminBusinessTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminBusinessType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminBusinessTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminBusinessTypeAggregateArgs>(args: Subset<T, AdminBusinessTypeAggregateArgs>): Prisma.PrismaPromise<GetAdminBusinessTypeAggregateType<T>>

    /**
     * Group by AdminBusinessType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminBusinessTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminBusinessTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminBusinessTypeGroupByArgs['orderBy'] }
        : { orderBy?: AdminBusinessTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminBusinessTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminBusinessTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminBusinessType model
   */
  readonly fields: AdminBusinessTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminBusinessType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminBusinessTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    businessTypeHazards<T extends AdminBusinessType$businessTypeHazardsArgs<ExtArgs> = {}>(args?: Subset<T, AdminBusinessType$businessTypeHazardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminBusinessTypeHazardPayload<ExtArgs>, T, "findMany"> | Null>
    riskProfiles<T extends AdminBusinessType$riskProfilesArgs<ExtArgs> = {}>(args?: Subset<T, AdminBusinessType$riskProfilesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminRiskProfilePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminBusinessType model
   */ 
  interface AdminBusinessTypeFieldRefs {
    readonly id: FieldRef<"AdminBusinessType", 'String'>
    readonly businessTypeId: FieldRef<"AdminBusinessType", 'String'>
    readonly name: FieldRef<"AdminBusinessType", 'String'>
    readonly localName: FieldRef<"AdminBusinessType", 'String'>
    readonly category: FieldRef<"AdminBusinessType", 'String'>
    readonly description: FieldRef<"AdminBusinessType", 'String'>
    readonly typicalOperatingHours: FieldRef<"AdminBusinessType", 'String'>
    readonly minimumStaff: FieldRef<"AdminBusinessType", 'String'>
    readonly minimumEquipment: FieldRef<"AdminBusinessType", 'String'>
    readonly minimumUtilities: FieldRef<"AdminBusinessType", 'String'>
    readonly minimumSpace: FieldRef<"AdminBusinessType", 'String'>
    readonly essentialFunctions: FieldRef<"AdminBusinessType", 'String'>
    readonly criticalSuppliers: FieldRef<"AdminBusinessType", 'String'>
    readonly exampleBusinessPurposes: FieldRef<"AdminBusinessType", 'String'>
    readonly exampleProducts: FieldRef<"AdminBusinessType", 'String'>
    readonly exampleKeyPersonnel: FieldRef<"AdminBusinessType", 'String'>
    readonly exampleCustomerBase: FieldRef<"AdminBusinessType", 'String'>
    readonly dependencies: FieldRef<"AdminBusinessType", 'String'>
    readonly vulnerabilityMatrix: FieldRef<"AdminBusinessType", 'String'>
    readonly operationalThresholds: FieldRef<"AdminBusinessType", 'String'>
    readonly isActive: FieldRef<"AdminBusinessType", 'Boolean'>
    readonly createdAt: FieldRef<"AdminBusinessType", 'DateTime'>
    readonly updatedAt: FieldRef<"AdminBusinessType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdminBusinessType findUnique
   */
  export type AdminBusinessTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminBusinessType
     */
    select?: AdminBusinessTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminBusinessTypeInclude<ExtArgs> | null
    /**
     * Filter, which AdminBusinessType to fetch.
     */
    where: AdminBusinessTypeWhereUniqueInput
  }

  /**
   * AdminBusinessType findUniqueOrThrow
   */
  export type AdminBusinessTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminBusinessType
     */
    select?: AdminBusinessTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminBusinessTypeInclude<ExtArgs> | null
    /**
     * Filter, which AdminBusinessType to fetch.
     */
    where: AdminBusinessTypeWhereUniqueInput
  }

  /**
   * AdminBusinessType findFirst
   */
  export type AdminBusinessTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminBusinessType
     */
    select?: AdminBusinessTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminBusinessTypeInclude<ExtArgs> | null
    /**
     * Filter, which AdminBusinessType to fetch.
     */
    where?: AdminBusinessTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminBusinessTypes to fetch.
     */
    orderBy?: AdminBusinessTypeOrderByWithRelationInput | AdminBusinessTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminBusinessTypes.
     */
    cursor?: AdminBusinessTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminBusinessTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminBusinessTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminBusinessTypes.
     */
    distinct?: AdminBusinessTypeScalarFieldEnum | AdminBusinessTypeScalarFieldEnum[]
  }

  /**
   * AdminBusinessType findFirstOrThrow
   */
  export type AdminBusinessTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminBusinessType
     */
    select?: AdminBusinessTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminBusinessTypeInclude<ExtArgs> | null
    /**
     * Filter, which AdminBusinessType to fetch.
     */
    where?: AdminBusinessTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminBusinessTypes to fetch.
     */
    orderBy?: AdminBusinessTypeOrderByWithRelationInput | AdminBusinessTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminBusinessTypes.
     */
    cursor?: AdminBusinessTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminBusinessTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminBusinessTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminBusinessTypes.
     */
    distinct?: AdminBusinessTypeScalarFieldEnum | AdminBusinessTypeScalarFieldEnum[]
  }

  /**
   * AdminBusinessType findMany
   */
  export type AdminBusinessTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminBusinessType
     */
    select?: AdminBusinessTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminBusinessTypeInclude<ExtArgs> | null
    /**
     * Filter, which AdminBusinessTypes to fetch.
     */
    where?: AdminBusinessTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminBusinessTypes to fetch.
     */
    orderBy?: AdminBusinessTypeOrderByWithRelationInput | AdminBusinessTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminBusinessTypes.
     */
    cursor?: AdminBusinessTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminBusinessTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminBusinessTypes.
     */
    skip?: number
    distinct?: AdminBusinessTypeScalarFieldEnum | AdminBusinessTypeScalarFieldEnum[]
  }

  /**
   * AdminBusinessType create
   */
  export type AdminBusinessTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminBusinessType
     */
    select?: AdminBusinessTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminBusinessTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminBusinessType.
     */
    data: XOR<AdminBusinessTypeCreateInput, AdminBusinessTypeUncheckedCreateInput>
  }

  /**
   * AdminBusinessType createMany
   */
  export type AdminBusinessTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminBusinessTypes.
     */
    data: AdminBusinessTypeCreateManyInput | AdminBusinessTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminBusinessType createManyAndReturn
   */
  export type AdminBusinessTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminBusinessType
     */
    select?: AdminBusinessTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AdminBusinessTypes.
     */
    data: AdminBusinessTypeCreateManyInput | AdminBusinessTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminBusinessType update
   */
  export type AdminBusinessTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminBusinessType
     */
    select?: AdminBusinessTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminBusinessTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminBusinessType.
     */
    data: XOR<AdminBusinessTypeUpdateInput, AdminBusinessTypeUncheckedUpdateInput>
    /**
     * Choose, which AdminBusinessType to update.
     */
    where: AdminBusinessTypeWhereUniqueInput
  }

  /**
   * AdminBusinessType updateMany
   */
  export type AdminBusinessTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminBusinessTypes.
     */
    data: XOR<AdminBusinessTypeUpdateManyMutationInput, AdminBusinessTypeUncheckedUpdateManyInput>
    /**
     * Filter which AdminBusinessTypes to update
     */
    where?: AdminBusinessTypeWhereInput
  }

  /**
   * AdminBusinessType upsert
   */
  export type AdminBusinessTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminBusinessType
     */
    select?: AdminBusinessTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminBusinessTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminBusinessType to update in case it exists.
     */
    where: AdminBusinessTypeWhereUniqueInput
    /**
     * In case the AdminBusinessType found by the `where` argument doesn't exist, create a new AdminBusinessType with this data.
     */
    create: XOR<AdminBusinessTypeCreateInput, AdminBusinessTypeUncheckedCreateInput>
    /**
     * In case the AdminBusinessType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminBusinessTypeUpdateInput, AdminBusinessTypeUncheckedUpdateInput>
  }

  /**
   * AdminBusinessType delete
   */
  export type AdminBusinessTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminBusinessType
     */
    select?: AdminBusinessTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminBusinessTypeInclude<ExtArgs> | null
    /**
     * Filter which AdminBusinessType to delete.
     */
    where: AdminBusinessTypeWhereUniqueInput
  }

  /**
   * AdminBusinessType deleteMany
   */
  export type AdminBusinessTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminBusinessTypes to delete
     */
    where?: AdminBusinessTypeWhereInput
  }

  /**
   * AdminBusinessType.businessTypeHazards
   */
  export type AdminBusinessType$businessTypeHazardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminBusinessTypeHazard
     */
    select?: AdminBusinessTypeHazardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminBusinessTypeHazardInclude<ExtArgs> | null
    where?: AdminBusinessTypeHazardWhereInput
    orderBy?: AdminBusinessTypeHazardOrderByWithRelationInput | AdminBusinessTypeHazardOrderByWithRelationInput[]
    cursor?: AdminBusinessTypeHazardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminBusinessTypeHazardScalarFieldEnum | AdminBusinessTypeHazardScalarFieldEnum[]
  }

  /**
   * AdminBusinessType.riskProfiles
   */
  export type AdminBusinessType$riskProfilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRiskProfile
     */
    select?: AdminRiskProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRiskProfileInclude<ExtArgs> | null
    where?: AdminRiskProfileWhereInput
    orderBy?: AdminRiskProfileOrderByWithRelationInput | AdminRiskProfileOrderByWithRelationInput[]
    cursor?: AdminRiskProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminRiskProfileScalarFieldEnum | AdminRiskProfileScalarFieldEnum[]
  }

  /**
   * AdminBusinessType without action
   */
  export type AdminBusinessTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminBusinessType
     */
    select?: AdminBusinessTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminBusinessTypeInclude<ExtArgs> | null
  }


  /**
   * Model AdminHazardType
   */

  export type AggregateAdminHazardType = {
    _count: AdminHazardTypeCountAggregateOutputType | null
    _min: AdminHazardTypeMinAggregateOutputType | null
    _max: AdminHazardTypeMaxAggregateOutputType | null
  }

  export type AdminHazardTypeMinAggregateOutputType = {
    id: string | null
    hazardId: string | null
    name: string | null
    category: string | null
    description: string | null
    defaultFrequency: string | null
    defaultImpact: string | null
    seasonalPattern: string | null
    peakMonths: string | null
    warningTime: string | null
    geographicScope: string | null
    cascadingRisks: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminHazardTypeMaxAggregateOutputType = {
    id: string | null
    hazardId: string | null
    name: string | null
    category: string | null
    description: string | null
    defaultFrequency: string | null
    defaultImpact: string | null
    seasonalPattern: string | null
    peakMonths: string | null
    warningTime: string | null
    geographicScope: string | null
    cascadingRisks: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminHazardTypeCountAggregateOutputType = {
    id: number
    hazardId: number
    name: number
    category: number
    description: number
    defaultFrequency: number
    defaultImpact: number
    seasonalPattern: number
    peakMonths: number
    warningTime: number
    geographicScope: number
    cascadingRisks: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdminHazardTypeMinAggregateInputType = {
    id?: true
    hazardId?: true
    name?: true
    category?: true
    description?: true
    defaultFrequency?: true
    defaultImpact?: true
    seasonalPattern?: true
    peakMonths?: true
    warningTime?: true
    geographicScope?: true
    cascadingRisks?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminHazardTypeMaxAggregateInputType = {
    id?: true
    hazardId?: true
    name?: true
    category?: true
    description?: true
    defaultFrequency?: true
    defaultImpact?: true
    seasonalPattern?: true
    peakMonths?: true
    warningTime?: true
    geographicScope?: true
    cascadingRisks?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminHazardTypeCountAggregateInputType = {
    id?: true
    hazardId?: true
    name?: true
    category?: true
    description?: true
    defaultFrequency?: true
    defaultImpact?: true
    seasonalPattern?: true
    peakMonths?: true
    warningTime?: true
    geographicScope?: true
    cascadingRisks?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdminHazardTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminHazardType to aggregate.
     */
    where?: AdminHazardTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminHazardTypes to fetch.
     */
    orderBy?: AdminHazardTypeOrderByWithRelationInput | AdminHazardTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminHazardTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminHazardTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminHazardTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminHazardTypes
    **/
    _count?: true | AdminHazardTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminHazardTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminHazardTypeMaxAggregateInputType
  }

  export type GetAdminHazardTypeAggregateType<T extends AdminHazardTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminHazardType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminHazardType[P]>
      : GetScalarType<T[P], AggregateAdminHazardType[P]>
  }




  export type AdminHazardTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminHazardTypeWhereInput
    orderBy?: AdminHazardTypeOrderByWithAggregationInput | AdminHazardTypeOrderByWithAggregationInput[]
    by: AdminHazardTypeScalarFieldEnum[] | AdminHazardTypeScalarFieldEnum
    having?: AdminHazardTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminHazardTypeCountAggregateInputType | true
    _min?: AdminHazardTypeMinAggregateInputType
    _max?: AdminHazardTypeMaxAggregateInputType
  }

  export type AdminHazardTypeGroupByOutputType = {
    id: string
    hazardId: string
    name: string
    category: string
    description: string | null
    defaultFrequency: string
    defaultImpact: string
    seasonalPattern: string | null
    peakMonths: string | null
    warningTime: string | null
    geographicScope: string | null
    cascadingRisks: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: AdminHazardTypeCountAggregateOutputType | null
    _min: AdminHazardTypeMinAggregateOutputType | null
    _max: AdminHazardTypeMaxAggregateOutputType | null
  }

  type GetAdminHazardTypeGroupByPayload<T extends AdminHazardTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminHazardTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminHazardTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminHazardTypeGroupByOutputType[P]>
            : GetScalarType<T[P], AdminHazardTypeGroupByOutputType[P]>
        }
      >
    >


  export type AdminHazardTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hazardId?: boolean
    name?: boolean
    category?: boolean
    description?: boolean
    defaultFrequency?: boolean
    defaultImpact?: boolean
    seasonalPattern?: boolean
    peakMonths?: boolean
    warningTime?: boolean
    geographicScope?: boolean
    cascadingRisks?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    businessTypeHazards?: boolean | AdminHazardType$businessTypeHazardsArgs<ExtArgs>
    locationHazards?: boolean | AdminHazardType$locationHazardsArgs<ExtArgs>
    hazardStrategies?: boolean | AdminHazardType$hazardStrategiesArgs<ExtArgs>
    hazardActionPlans?: boolean | AdminHazardType$hazardActionPlansArgs<ExtArgs>
    AdminActionPlan?: boolean | AdminHazardType$AdminActionPlanArgs<ExtArgs>
    translations?: boolean | AdminHazardType$translationsArgs<ExtArgs>
    _count?: boolean | AdminHazardTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminHazardType"]>

  export type AdminHazardTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hazardId?: boolean
    name?: boolean
    category?: boolean
    description?: boolean
    defaultFrequency?: boolean
    defaultImpact?: boolean
    seasonalPattern?: boolean
    peakMonths?: boolean
    warningTime?: boolean
    geographicScope?: boolean
    cascadingRisks?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["adminHazardType"]>

  export type AdminHazardTypeSelectScalar = {
    id?: boolean
    hazardId?: boolean
    name?: boolean
    category?: boolean
    description?: boolean
    defaultFrequency?: boolean
    defaultImpact?: boolean
    seasonalPattern?: boolean
    peakMonths?: boolean
    warningTime?: boolean
    geographicScope?: boolean
    cascadingRisks?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdminHazardTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businessTypeHazards?: boolean | AdminHazardType$businessTypeHazardsArgs<ExtArgs>
    locationHazards?: boolean | AdminHazardType$locationHazardsArgs<ExtArgs>
    hazardStrategies?: boolean | AdminHazardType$hazardStrategiesArgs<ExtArgs>
    hazardActionPlans?: boolean | AdminHazardType$hazardActionPlansArgs<ExtArgs>
    AdminActionPlan?: boolean | AdminHazardType$AdminActionPlanArgs<ExtArgs>
    translations?: boolean | AdminHazardType$translationsArgs<ExtArgs>
    _count?: boolean | AdminHazardTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AdminHazardTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AdminHazardTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminHazardType"
    objects: {
      businessTypeHazards: Prisma.$AdminBusinessTypeHazardPayload<ExtArgs>[]
      locationHazards: Prisma.$AdminLocationHazardPayload<ExtArgs>[]
      hazardStrategies: Prisma.$AdminHazardStrategyPayload<ExtArgs>[]
      hazardActionPlans: Prisma.$AdminHazardActionPlanPayload<ExtArgs>[]
      AdminActionPlan: Prisma.$AdminActionPlanPayload<ExtArgs> | null
      translations: Prisma.$HazardTranslationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      hazardId: string
      name: string
      category: string
      description: string | null
      defaultFrequency: string
      defaultImpact: string
      seasonalPattern: string | null
      peakMonths: string | null
      warningTime: string | null
      geographicScope: string | null
      cascadingRisks: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["adminHazardType"]>
    composites: {}
  }

  type AdminHazardTypeGetPayload<S extends boolean | null | undefined | AdminHazardTypeDefaultArgs> = $Result.GetResult<Prisma.$AdminHazardTypePayload, S>

  type AdminHazardTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdminHazardTypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdminHazardTypeCountAggregateInputType | true
    }

  export interface AdminHazardTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminHazardType'], meta: { name: 'AdminHazardType' } }
    /**
     * Find zero or one AdminHazardType that matches the filter.
     * @param {AdminHazardTypeFindUniqueArgs} args - Arguments to find a AdminHazardType
     * @example
     * // Get one AdminHazardType
     * const adminHazardType = await prisma.adminHazardType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminHazardTypeFindUniqueArgs>(args: SelectSubset<T, AdminHazardTypeFindUniqueArgs<ExtArgs>>): Prisma__AdminHazardTypeClient<$Result.GetResult<Prisma.$AdminHazardTypePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AdminHazardType that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdminHazardTypeFindUniqueOrThrowArgs} args - Arguments to find a AdminHazardType
     * @example
     * // Get one AdminHazardType
     * const adminHazardType = await prisma.adminHazardType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminHazardTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminHazardTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminHazardTypeClient<$Result.GetResult<Prisma.$AdminHazardTypePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AdminHazardType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminHazardTypeFindFirstArgs} args - Arguments to find a AdminHazardType
     * @example
     * // Get one AdminHazardType
     * const adminHazardType = await prisma.adminHazardType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminHazardTypeFindFirstArgs>(args?: SelectSubset<T, AdminHazardTypeFindFirstArgs<ExtArgs>>): Prisma__AdminHazardTypeClient<$Result.GetResult<Prisma.$AdminHazardTypePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AdminHazardType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminHazardTypeFindFirstOrThrowArgs} args - Arguments to find a AdminHazardType
     * @example
     * // Get one AdminHazardType
     * const adminHazardType = await prisma.adminHazardType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminHazardTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminHazardTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminHazardTypeClient<$Result.GetResult<Prisma.$AdminHazardTypePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AdminHazardTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminHazardTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminHazardTypes
     * const adminHazardTypes = await prisma.adminHazardType.findMany()
     * 
     * // Get first 10 AdminHazardTypes
     * const adminHazardTypes = await prisma.adminHazardType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminHazardTypeWithIdOnly = await prisma.adminHazardType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminHazardTypeFindManyArgs>(args?: SelectSubset<T, AdminHazardTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminHazardTypePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AdminHazardType.
     * @param {AdminHazardTypeCreateArgs} args - Arguments to create a AdminHazardType.
     * @example
     * // Create one AdminHazardType
     * const AdminHazardType = await prisma.adminHazardType.create({
     *   data: {
     *     // ... data to create a AdminHazardType
     *   }
     * })
     * 
     */
    create<T extends AdminHazardTypeCreateArgs>(args: SelectSubset<T, AdminHazardTypeCreateArgs<ExtArgs>>): Prisma__AdminHazardTypeClient<$Result.GetResult<Prisma.$AdminHazardTypePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AdminHazardTypes.
     * @param {AdminHazardTypeCreateManyArgs} args - Arguments to create many AdminHazardTypes.
     * @example
     * // Create many AdminHazardTypes
     * const adminHazardType = await prisma.adminHazardType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminHazardTypeCreateManyArgs>(args?: SelectSubset<T, AdminHazardTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminHazardTypes and returns the data saved in the database.
     * @param {AdminHazardTypeCreateManyAndReturnArgs} args - Arguments to create many AdminHazardTypes.
     * @example
     * // Create many AdminHazardTypes
     * const adminHazardType = await prisma.adminHazardType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminHazardTypes and only return the `id`
     * const adminHazardTypeWithIdOnly = await prisma.adminHazardType.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminHazardTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminHazardTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminHazardTypePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AdminHazardType.
     * @param {AdminHazardTypeDeleteArgs} args - Arguments to delete one AdminHazardType.
     * @example
     * // Delete one AdminHazardType
     * const AdminHazardType = await prisma.adminHazardType.delete({
     *   where: {
     *     // ... filter to delete one AdminHazardType
     *   }
     * })
     * 
     */
    delete<T extends AdminHazardTypeDeleteArgs>(args: SelectSubset<T, AdminHazardTypeDeleteArgs<ExtArgs>>): Prisma__AdminHazardTypeClient<$Result.GetResult<Prisma.$AdminHazardTypePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AdminHazardType.
     * @param {AdminHazardTypeUpdateArgs} args - Arguments to update one AdminHazardType.
     * @example
     * // Update one AdminHazardType
     * const adminHazardType = await prisma.adminHazardType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminHazardTypeUpdateArgs>(args: SelectSubset<T, AdminHazardTypeUpdateArgs<ExtArgs>>): Prisma__AdminHazardTypeClient<$Result.GetResult<Prisma.$AdminHazardTypePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AdminHazardTypes.
     * @param {AdminHazardTypeDeleteManyArgs} args - Arguments to filter AdminHazardTypes to delete.
     * @example
     * // Delete a few AdminHazardTypes
     * const { count } = await prisma.adminHazardType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminHazardTypeDeleteManyArgs>(args?: SelectSubset<T, AdminHazardTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminHazardTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminHazardTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminHazardTypes
     * const adminHazardType = await prisma.adminHazardType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminHazardTypeUpdateManyArgs>(args: SelectSubset<T, AdminHazardTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AdminHazardType.
     * @param {AdminHazardTypeUpsertArgs} args - Arguments to update or create a AdminHazardType.
     * @example
     * // Update or create a AdminHazardType
     * const adminHazardType = await prisma.adminHazardType.upsert({
     *   create: {
     *     // ... data to create a AdminHazardType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminHazardType we want to update
     *   }
     * })
     */
    upsert<T extends AdminHazardTypeUpsertArgs>(args: SelectSubset<T, AdminHazardTypeUpsertArgs<ExtArgs>>): Prisma__AdminHazardTypeClient<$Result.GetResult<Prisma.$AdminHazardTypePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AdminHazardTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminHazardTypeCountArgs} args - Arguments to filter AdminHazardTypes to count.
     * @example
     * // Count the number of AdminHazardTypes
     * const count = await prisma.adminHazardType.count({
     *   where: {
     *     // ... the filter for the AdminHazardTypes we want to count
     *   }
     * })
    **/
    count<T extends AdminHazardTypeCountArgs>(
      args?: Subset<T, AdminHazardTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminHazardTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminHazardType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminHazardTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminHazardTypeAggregateArgs>(args: Subset<T, AdminHazardTypeAggregateArgs>): Prisma.PrismaPromise<GetAdminHazardTypeAggregateType<T>>

    /**
     * Group by AdminHazardType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminHazardTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminHazardTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminHazardTypeGroupByArgs['orderBy'] }
        : { orderBy?: AdminHazardTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminHazardTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminHazardTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminHazardType model
   */
  readonly fields: AdminHazardTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminHazardType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminHazardTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    businessTypeHazards<T extends AdminHazardType$businessTypeHazardsArgs<ExtArgs> = {}>(args?: Subset<T, AdminHazardType$businessTypeHazardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminBusinessTypeHazardPayload<ExtArgs>, T, "findMany"> | Null>
    locationHazards<T extends AdminHazardType$locationHazardsArgs<ExtArgs> = {}>(args?: Subset<T, AdminHazardType$locationHazardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminLocationHazardPayload<ExtArgs>, T, "findMany"> | Null>
    hazardStrategies<T extends AdminHazardType$hazardStrategiesArgs<ExtArgs> = {}>(args?: Subset<T, AdminHazardType$hazardStrategiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminHazardStrategyPayload<ExtArgs>, T, "findMany"> | Null>
    hazardActionPlans<T extends AdminHazardType$hazardActionPlansArgs<ExtArgs> = {}>(args?: Subset<T, AdminHazardType$hazardActionPlansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminHazardActionPlanPayload<ExtArgs>, T, "findMany"> | Null>
    AdminActionPlan<T extends AdminHazardType$AdminActionPlanArgs<ExtArgs> = {}>(args?: Subset<T, AdminHazardType$AdminActionPlanArgs<ExtArgs>>): Prisma__AdminActionPlanClient<$Result.GetResult<Prisma.$AdminActionPlanPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    translations<T extends AdminHazardType$translationsArgs<ExtArgs> = {}>(args?: Subset<T, AdminHazardType$translationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HazardTranslationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminHazardType model
   */ 
  interface AdminHazardTypeFieldRefs {
    readonly id: FieldRef<"AdminHazardType", 'String'>
    readonly hazardId: FieldRef<"AdminHazardType", 'String'>
    readonly name: FieldRef<"AdminHazardType", 'String'>
    readonly category: FieldRef<"AdminHazardType", 'String'>
    readonly description: FieldRef<"AdminHazardType", 'String'>
    readonly defaultFrequency: FieldRef<"AdminHazardType", 'String'>
    readonly defaultImpact: FieldRef<"AdminHazardType", 'String'>
    readonly seasonalPattern: FieldRef<"AdminHazardType", 'String'>
    readonly peakMonths: FieldRef<"AdminHazardType", 'String'>
    readonly warningTime: FieldRef<"AdminHazardType", 'String'>
    readonly geographicScope: FieldRef<"AdminHazardType", 'String'>
    readonly cascadingRisks: FieldRef<"AdminHazardType", 'String'>
    readonly isActive: FieldRef<"AdminHazardType", 'Boolean'>
    readonly createdAt: FieldRef<"AdminHazardType", 'DateTime'>
    readonly updatedAt: FieldRef<"AdminHazardType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdminHazardType findUnique
   */
  export type AdminHazardTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminHazardType
     */
    select?: AdminHazardTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminHazardTypeInclude<ExtArgs> | null
    /**
     * Filter, which AdminHazardType to fetch.
     */
    where: AdminHazardTypeWhereUniqueInput
  }

  /**
   * AdminHazardType findUniqueOrThrow
   */
  export type AdminHazardTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminHazardType
     */
    select?: AdminHazardTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminHazardTypeInclude<ExtArgs> | null
    /**
     * Filter, which AdminHazardType to fetch.
     */
    where: AdminHazardTypeWhereUniqueInput
  }

  /**
   * AdminHazardType findFirst
   */
  export type AdminHazardTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminHazardType
     */
    select?: AdminHazardTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminHazardTypeInclude<ExtArgs> | null
    /**
     * Filter, which AdminHazardType to fetch.
     */
    where?: AdminHazardTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminHazardTypes to fetch.
     */
    orderBy?: AdminHazardTypeOrderByWithRelationInput | AdminHazardTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminHazardTypes.
     */
    cursor?: AdminHazardTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminHazardTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminHazardTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminHazardTypes.
     */
    distinct?: AdminHazardTypeScalarFieldEnum | AdminHazardTypeScalarFieldEnum[]
  }

  /**
   * AdminHazardType findFirstOrThrow
   */
  export type AdminHazardTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminHazardType
     */
    select?: AdminHazardTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminHazardTypeInclude<ExtArgs> | null
    /**
     * Filter, which AdminHazardType to fetch.
     */
    where?: AdminHazardTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminHazardTypes to fetch.
     */
    orderBy?: AdminHazardTypeOrderByWithRelationInput | AdminHazardTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminHazardTypes.
     */
    cursor?: AdminHazardTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminHazardTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminHazardTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminHazardTypes.
     */
    distinct?: AdminHazardTypeScalarFieldEnum | AdminHazardTypeScalarFieldEnum[]
  }

  /**
   * AdminHazardType findMany
   */
  export type AdminHazardTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminHazardType
     */
    select?: AdminHazardTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminHazardTypeInclude<ExtArgs> | null
    /**
     * Filter, which AdminHazardTypes to fetch.
     */
    where?: AdminHazardTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminHazardTypes to fetch.
     */
    orderBy?: AdminHazardTypeOrderByWithRelationInput | AdminHazardTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminHazardTypes.
     */
    cursor?: AdminHazardTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminHazardTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminHazardTypes.
     */
    skip?: number
    distinct?: AdminHazardTypeScalarFieldEnum | AdminHazardTypeScalarFieldEnum[]
  }

  /**
   * AdminHazardType create
   */
  export type AdminHazardTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminHazardType
     */
    select?: AdminHazardTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminHazardTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminHazardType.
     */
    data: XOR<AdminHazardTypeCreateInput, AdminHazardTypeUncheckedCreateInput>
  }

  /**
   * AdminHazardType createMany
   */
  export type AdminHazardTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminHazardTypes.
     */
    data: AdminHazardTypeCreateManyInput | AdminHazardTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminHazardType createManyAndReturn
   */
  export type AdminHazardTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminHazardType
     */
    select?: AdminHazardTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AdminHazardTypes.
     */
    data: AdminHazardTypeCreateManyInput | AdminHazardTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminHazardType update
   */
  export type AdminHazardTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminHazardType
     */
    select?: AdminHazardTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminHazardTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminHazardType.
     */
    data: XOR<AdminHazardTypeUpdateInput, AdminHazardTypeUncheckedUpdateInput>
    /**
     * Choose, which AdminHazardType to update.
     */
    where: AdminHazardTypeWhereUniqueInput
  }

  /**
   * AdminHazardType updateMany
   */
  export type AdminHazardTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminHazardTypes.
     */
    data: XOR<AdminHazardTypeUpdateManyMutationInput, AdminHazardTypeUncheckedUpdateManyInput>
    /**
     * Filter which AdminHazardTypes to update
     */
    where?: AdminHazardTypeWhereInput
  }

  /**
   * AdminHazardType upsert
   */
  export type AdminHazardTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminHazardType
     */
    select?: AdminHazardTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminHazardTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminHazardType to update in case it exists.
     */
    where: AdminHazardTypeWhereUniqueInput
    /**
     * In case the AdminHazardType found by the `where` argument doesn't exist, create a new AdminHazardType with this data.
     */
    create: XOR<AdminHazardTypeCreateInput, AdminHazardTypeUncheckedCreateInput>
    /**
     * In case the AdminHazardType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminHazardTypeUpdateInput, AdminHazardTypeUncheckedUpdateInput>
  }

  /**
   * AdminHazardType delete
   */
  export type AdminHazardTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminHazardType
     */
    select?: AdminHazardTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminHazardTypeInclude<ExtArgs> | null
    /**
     * Filter which AdminHazardType to delete.
     */
    where: AdminHazardTypeWhereUniqueInput
  }

  /**
   * AdminHazardType deleteMany
   */
  export type AdminHazardTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminHazardTypes to delete
     */
    where?: AdminHazardTypeWhereInput
  }

  /**
   * AdminHazardType.businessTypeHazards
   */
  export type AdminHazardType$businessTypeHazardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminBusinessTypeHazard
     */
    select?: AdminBusinessTypeHazardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminBusinessTypeHazardInclude<ExtArgs> | null
    where?: AdminBusinessTypeHazardWhereInput
    orderBy?: AdminBusinessTypeHazardOrderByWithRelationInput | AdminBusinessTypeHazardOrderByWithRelationInput[]
    cursor?: AdminBusinessTypeHazardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminBusinessTypeHazardScalarFieldEnum | AdminBusinessTypeHazardScalarFieldEnum[]
  }

  /**
   * AdminHazardType.locationHazards
   */
  export type AdminHazardType$locationHazardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminLocationHazard
     */
    select?: AdminLocationHazardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminLocationHazardInclude<ExtArgs> | null
    where?: AdminLocationHazardWhereInput
    orderBy?: AdminLocationHazardOrderByWithRelationInput | AdminLocationHazardOrderByWithRelationInput[]
    cursor?: AdminLocationHazardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminLocationHazardScalarFieldEnum | AdminLocationHazardScalarFieldEnum[]
  }

  /**
   * AdminHazardType.hazardStrategies
   */
  export type AdminHazardType$hazardStrategiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminHazardStrategy
     */
    select?: AdminHazardStrategySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminHazardStrategyInclude<ExtArgs> | null
    where?: AdminHazardStrategyWhereInput
    orderBy?: AdminHazardStrategyOrderByWithRelationInput | AdminHazardStrategyOrderByWithRelationInput[]
    cursor?: AdminHazardStrategyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminHazardStrategyScalarFieldEnum | AdminHazardStrategyScalarFieldEnum[]
  }

  /**
   * AdminHazardType.hazardActionPlans
   */
  export type AdminHazardType$hazardActionPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminHazardActionPlan
     */
    select?: AdminHazardActionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminHazardActionPlanInclude<ExtArgs> | null
    where?: AdminHazardActionPlanWhereInput
    orderBy?: AdminHazardActionPlanOrderByWithRelationInput | AdminHazardActionPlanOrderByWithRelationInput[]
    cursor?: AdminHazardActionPlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminHazardActionPlanScalarFieldEnum | AdminHazardActionPlanScalarFieldEnum[]
  }

  /**
   * AdminHazardType.AdminActionPlan
   */
  export type AdminHazardType$AdminActionPlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminActionPlan
     */
    select?: AdminActionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActionPlanInclude<ExtArgs> | null
    where?: AdminActionPlanWhereInput
  }

  /**
   * AdminHazardType.translations
   */
  export type AdminHazardType$translationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HazardTranslation
     */
    select?: HazardTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HazardTranslationInclude<ExtArgs> | null
    where?: HazardTranslationWhereInput
    orderBy?: HazardTranslationOrderByWithRelationInput | HazardTranslationOrderByWithRelationInput[]
    cursor?: HazardTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HazardTranslationScalarFieldEnum | HazardTranslationScalarFieldEnum[]
  }

  /**
   * AdminHazardType without action
   */
  export type AdminHazardTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminHazardType
     */
    select?: AdminHazardTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminHazardTypeInclude<ExtArgs> | null
  }


  /**
   * Model AdminLocation
   */

  export type AggregateAdminLocation = {
    _count: AdminLocationCountAggregateOutputType | null
    _min: AdminLocationMinAggregateOutputType | null
    _max: AdminLocationMaxAggregateOutputType | null
  }

  export type AdminLocationMinAggregateOutputType = {
    id: string | null
    country: string | null
    countryCode: string | null
    parish: string | null
    isCoastal: boolean | null
    isUrban: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminLocationMaxAggregateOutputType = {
    id: string | null
    country: string | null
    countryCode: string | null
    parish: string | null
    isCoastal: boolean | null
    isUrban: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminLocationCountAggregateOutputType = {
    id: number
    country: number
    countryCode: number
    parish: number
    isCoastal: number
    isUrban: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdminLocationMinAggregateInputType = {
    id?: true
    country?: true
    countryCode?: true
    parish?: true
    isCoastal?: true
    isUrban?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminLocationMaxAggregateInputType = {
    id?: true
    country?: true
    countryCode?: true
    parish?: true
    isCoastal?: true
    isUrban?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminLocationCountAggregateInputType = {
    id?: true
    country?: true
    countryCode?: true
    parish?: true
    isCoastal?: true
    isUrban?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdminLocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminLocation to aggregate.
     */
    where?: AdminLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminLocations to fetch.
     */
    orderBy?: AdminLocationOrderByWithRelationInput | AdminLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminLocations
    **/
    _count?: true | AdminLocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminLocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminLocationMaxAggregateInputType
  }

  export type GetAdminLocationAggregateType<T extends AdminLocationAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminLocation[P]>
      : GetScalarType<T[P], AggregateAdminLocation[P]>
  }




  export type AdminLocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminLocationWhereInput
    orderBy?: AdminLocationOrderByWithAggregationInput | AdminLocationOrderByWithAggregationInput[]
    by: AdminLocationScalarFieldEnum[] | AdminLocationScalarFieldEnum
    having?: AdminLocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminLocationCountAggregateInputType | true
    _min?: AdminLocationMinAggregateInputType
    _max?: AdminLocationMaxAggregateInputType
  }

  export type AdminLocationGroupByOutputType = {
    id: string
    country: string
    countryCode: string
    parish: string | null
    isCoastal: boolean
    isUrban: boolean
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: AdminLocationCountAggregateOutputType | null
    _min: AdminLocationMinAggregateOutputType | null
    _max: AdminLocationMaxAggregateOutputType | null
  }

  type GetAdminLocationGroupByPayload<T extends AdminLocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminLocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminLocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminLocationGroupByOutputType[P]>
            : GetScalarType<T[P], AdminLocationGroupByOutputType[P]>
        }
      >
    >


  export type AdminLocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    country?: boolean
    countryCode?: boolean
    parish?: boolean
    isCoastal?: boolean
    isUrban?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    locationHazards?: boolean | AdminLocation$locationHazardsArgs<ExtArgs>
    riskProfiles?: boolean | AdminLocation$riskProfilesArgs<ExtArgs>
    _count?: boolean | AdminLocationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminLocation"]>

  export type AdminLocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    country?: boolean
    countryCode?: boolean
    parish?: boolean
    isCoastal?: boolean
    isUrban?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["adminLocation"]>

  export type AdminLocationSelectScalar = {
    id?: boolean
    country?: boolean
    countryCode?: boolean
    parish?: boolean
    isCoastal?: boolean
    isUrban?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdminLocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    locationHazards?: boolean | AdminLocation$locationHazardsArgs<ExtArgs>
    riskProfiles?: boolean | AdminLocation$riskProfilesArgs<ExtArgs>
    _count?: boolean | AdminLocationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AdminLocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AdminLocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminLocation"
    objects: {
      locationHazards: Prisma.$AdminLocationHazardPayload<ExtArgs>[]
      riskProfiles: Prisma.$AdminRiskProfilePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      country: string
      countryCode: string
      parish: string | null
      isCoastal: boolean
      isUrban: boolean
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["adminLocation"]>
    composites: {}
  }

  type AdminLocationGetPayload<S extends boolean | null | undefined | AdminLocationDefaultArgs> = $Result.GetResult<Prisma.$AdminLocationPayload, S>

  type AdminLocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdminLocationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdminLocationCountAggregateInputType | true
    }

  export interface AdminLocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminLocation'], meta: { name: 'AdminLocation' } }
    /**
     * Find zero or one AdminLocation that matches the filter.
     * @param {AdminLocationFindUniqueArgs} args - Arguments to find a AdminLocation
     * @example
     * // Get one AdminLocation
     * const adminLocation = await prisma.adminLocation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminLocationFindUniqueArgs>(args: SelectSubset<T, AdminLocationFindUniqueArgs<ExtArgs>>): Prisma__AdminLocationClient<$Result.GetResult<Prisma.$AdminLocationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AdminLocation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdminLocationFindUniqueOrThrowArgs} args - Arguments to find a AdminLocation
     * @example
     * // Get one AdminLocation
     * const adminLocation = await prisma.adminLocation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminLocationFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminLocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminLocationClient<$Result.GetResult<Prisma.$AdminLocationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AdminLocation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminLocationFindFirstArgs} args - Arguments to find a AdminLocation
     * @example
     * // Get one AdminLocation
     * const adminLocation = await prisma.adminLocation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminLocationFindFirstArgs>(args?: SelectSubset<T, AdminLocationFindFirstArgs<ExtArgs>>): Prisma__AdminLocationClient<$Result.GetResult<Prisma.$AdminLocationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AdminLocation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminLocationFindFirstOrThrowArgs} args - Arguments to find a AdminLocation
     * @example
     * // Get one AdminLocation
     * const adminLocation = await prisma.adminLocation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminLocationFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminLocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminLocationClient<$Result.GetResult<Prisma.$AdminLocationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AdminLocations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminLocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminLocations
     * const adminLocations = await prisma.adminLocation.findMany()
     * 
     * // Get first 10 AdminLocations
     * const adminLocations = await prisma.adminLocation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminLocationWithIdOnly = await prisma.adminLocation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminLocationFindManyArgs>(args?: SelectSubset<T, AdminLocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminLocationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AdminLocation.
     * @param {AdminLocationCreateArgs} args - Arguments to create a AdminLocation.
     * @example
     * // Create one AdminLocation
     * const AdminLocation = await prisma.adminLocation.create({
     *   data: {
     *     // ... data to create a AdminLocation
     *   }
     * })
     * 
     */
    create<T extends AdminLocationCreateArgs>(args: SelectSubset<T, AdminLocationCreateArgs<ExtArgs>>): Prisma__AdminLocationClient<$Result.GetResult<Prisma.$AdminLocationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AdminLocations.
     * @param {AdminLocationCreateManyArgs} args - Arguments to create many AdminLocations.
     * @example
     * // Create many AdminLocations
     * const adminLocation = await prisma.adminLocation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminLocationCreateManyArgs>(args?: SelectSubset<T, AdminLocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminLocations and returns the data saved in the database.
     * @param {AdminLocationCreateManyAndReturnArgs} args - Arguments to create many AdminLocations.
     * @example
     * // Create many AdminLocations
     * const adminLocation = await prisma.adminLocation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminLocations and only return the `id`
     * const adminLocationWithIdOnly = await prisma.adminLocation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminLocationCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminLocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminLocationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AdminLocation.
     * @param {AdminLocationDeleteArgs} args - Arguments to delete one AdminLocation.
     * @example
     * // Delete one AdminLocation
     * const AdminLocation = await prisma.adminLocation.delete({
     *   where: {
     *     // ... filter to delete one AdminLocation
     *   }
     * })
     * 
     */
    delete<T extends AdminLocationDeleteArgs>(args: SelectSubset<T, AdminLocationDeleteArgs<ExtArgs>>): Prisma__AdminLocationClient<$Result.GetResult<Prisma.$AdminLocationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AdminLocation.
     * @param {AdminLocationUpdateArgs} args - Arguments to update one AdminLocation.
     * @example
     * // Update one AdminLocation
     * const adminLocation = await prisma.adminLocation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminLocationUpdateArgs>(args: SelectSubset<T, AdminLocationUpdateArgs<ExtArgs>>): Prisma__AdminLocationClient<$Result.GetResult<Prisma.$AdminLocationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AdminLocations.
     * @param {AdminLocationDeleteManyArgs} args - Arguments to filter AdminLocations to delete.
     * @example
     * // Delete a few AdminLocations
     * const { count } = await prisma.adminLocation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminLocationDeleteManyArgs>(args?: SelectSubset<T, AdminLocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminLocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminLocations
     * const adminLocation = await prisma.adminLocation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminLocationUpdateManyArgs>(args: SelectSubset<T, AdminLocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AdminLocation.
     * @param {AdminLocationUpsertArgs} args - Arguments to update or create a AdminLocation.
     * @example
     * // Update or create a AdminLocation
     * const adminLocation = await prisma.adminLocation.upsert({
     *   create: {
     *     // ... data to create a AdminLocation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminLocation we want to update
     *   }
     * })
     */
    upsert<T extends AdminLocationUpsertArgs>(args: SelectSubset<T, AdminLocationUpsertArgs<ExtArgs>>): Prisma__AdminLocationClient<$Result.GetResult<Prisma.$AdminLocationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AdminLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminLocationCountArgs} args - Arguments to filter AdminLocations to count.
     * @example
     * // Count the number of AdminLocations
     * const count = await prisma.adminLocation.count({
     *   where: {
     *     // ... the filter for the AdminLocations we want to count
     *   }
     * })
    **/
    count<T extends AdminLocationCountArgs>(
      args?: Subset<T, AdminLocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminLocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminLocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminLocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminLocationAggregateArgs>(args: Subset<T, AdminLocationAggregateArgs>): Prisma.PrismaPromise<GetAdminLocationAggregateType<T>>

    /**
     * Group by AdminLocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminLocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminLocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminLocationGroupByArgs['orderBy'] }
        : { orderBy?: AdminLocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminLocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminLocation model
   */
  readonly fields: AdminLocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminLocation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminLocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    locationHazards<T extends AdminLocation$locationHazardsArgs<ExtArgs> = {}>(args?: Subset<T, AdminLocation$locationHazardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminLocationHazardPayload<ExtArgs>, T, "findMany"> | Null>
    riskProfiles<T extends AdminLocation$riskProfilesArgs<ExtArgs> = {}>(args?: Subset<T, AdminLocation$riskProfilesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminRiskProfilePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminLocation model
   */ 
  interface AdminLocationFieldRefs {
    readonly id: FieldRef<"AdminLocation", 'String'>
    readonly country: FieldRef<"AdminLocation", 'String'>
    readonly countryCode: FieldRef<"AdminLocation", 'String'>
    readonly parish: FieldRef<"AdminLocation", 'String'>
    readonly isCoastal: FieldRef<"AdminLocation", 'Boolean'>
    readonly isUrban: FieldRef<"AdminLocation", 'Boolean'>
    readonly isActive: FieldRef<"AdminLocation", 'Boolean'>
    readonly createdAt: FieldRef<"AdminLocation", 'DateTime'>
    readonly updatedAt: FieldRef<"AdminLocation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdminLocation findUnique
   */
  export type AdminLocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminLocation
     */
    select?: AdminLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminLocationInclude<ExtArgs> | null
    /**
     * Filter, which AdminLocation to fetch.
     */
    where: AdminLocationWhereUniqueInput
  }

  /**
   * AdminLocation findUniqueOrThrow
   */
  export type AdminLocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminLocation
     */
    select?: AdminLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminLocationInclude<ExtArgs> | null
    /**
     * Filter, which AdminLocation to fetch.
     */
    where: AdminLocationWhereUniqueInput
  }

  /**
   * AdminLocation findFirst
   */
  export type AdminLocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminLocation
     */
    select?: AdminLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminLocationInclude<ExtArgs> | null
    /**
     * Filter, which AdminLocation to fetch.
     */
    where?: AdminLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminLocations to fetch.
     */
    orderBy?: AdminLocationOrderByWithRelationInput | AdminLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminLocations.
     */
    cursor?: AdminLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminLocations.
     */
    distinct?: AdminLocationScalarFieldEnum | AdminLocationScalarFieldEnum[]
  }

  /**
   * AdminLocation findFirstOrThrow
   */
  export type AdminLocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminLocation
     */
    select?: AdminLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminLocationInclude<ExtArgs> | null
    /**
     * Filter, which AdminLocation to fetch.
     */
    where?: AdminLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminLocations to fetch.
     */
    orderBy?: AdminLocationOrderByWithRelationInput | AdminLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminLocations.
     */
    cursor?: AdminLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminLocations.
     */
    distinct?: AdminLocationScalarFieldEnum | AdminLocationScalarFieldEnum[]
  }

  /**
   * AdminLocation findMany
   */
  export type AdminLocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminLocation
     */
    select?: AdminLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminLocationInclude<ExtArgs> | null
    /**
     * Filter, which AdminLocations to fetch.
     */
    where?: AdminLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminLocations to fetch.
     */
    orderBy?: AdminLocationOrderByWithRelationInput | AdminLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminLocations.
     */
    cursor?: AdminLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminLocations.
     */
    skip?: number
    distinct?: AdminLocationScalarFieldEnum | AdminLocationScalarFieldEnum[]
  }

  /**
   * AdminLocation create
   */
  export type AdminLocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminLocation
     */
    select?: AdminLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminLocationInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminLocation.
     */
    data: XOR<AdminLocationCreateInput, AdminLocationUncheckedCreateInput>
  }

  /**
   * AdminLocation createMany
   */
  export type AdminLocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminLocations.
     */
    data: AdminLocationCreateManyInput | AdminLocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminLocation createManyAndReturn
   */
  export type AdminLocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminLocation
     */
    select?: AdminLocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AdminLocations.
     */
    data: AdminLocationCreateManyInput | AdminLocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminLocation update
   */
  export type AdminLocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminLocation
     */
    select?: AdminLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminLocationInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminLocation.
     */
    data: XOR<AdminLocationUpdateInput, AdminLocationUncheckedUpdateInput>
    /**
     * Choose, which AdminLocation to update.
     */
    where: AdminLocationWhereUniqueInput
  }

  /**
   * AdminLocation updateMany
   */
  export type AdminLocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminLocations.
     */
    data: XOR<AdminLocationUpdateManyMutationInput, AdminLocationUncheckedUpdateManyInput>
    /**
     * Filter which AdminLocations to update
     */
    where?: AdminLocationWhereInput
  }

  /**
   * AdminLocation upsert
   */
  export type AdminLocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminLocation
     */
    select?: AdminLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminLocationInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminLocation to update in case it exists.
     */
    where: AdminLocationWhereUniqueInput
    /**
     * In case the AdminLocation found by the `where` argument doesn't exist, create a new AdminLocation with this data.
     */
    create: XOR<AdminLocationCreateInput, AdminLocationUncheckedCreateInput>
    /**
     * In case the AdminLocation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminLocationUpdateInput, AdminLocationUncheckedUpdateInput>
  }

  /**
   * AdminLocation delete
   */
  export type AdminLocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminLocation
     */
    select?: AdminLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminLocationInclude<ExtArgs> | null
    /**
     * Filter which AdminLocation to delete.
     */
    where: AdminLocationWhereUniqueInput
  }

  /**
   * AdminLocation deleteMany
   */
  export type AdminLocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminLocations to delete
     */
    where?: AdminLocationWhereInput
  }

  /**
   * AdminLocation.locationHazards
   */
  export type AdminLocation$locationHazardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminLocationHazard
     */
    select?: AdminLocationHazardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminLocationHazardInclude<ExtArgs> | null
    where?: AdminLocationHazardWhereInput
    orderBy?: AdminLocationHazardOrderByWithRelationInput | AdminLocationHazardOrderByWithRelationInput[]
    cursor?: AdminLocationHazardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminLocationHazardScalarFieldEnum | AdminLocationHazardScalarFieldEnum[]
  }

  /**
   * AdminLocation.riskProfiles
   */
  export type AdminLocation$riskProfilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRiskProfile
     */
    select?: AdminRiskProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRiskProfileInclude<ExtArgs> | null
    where?: AdminRiskProfileWhereInput
    orderBy?: AdminRiskProfileOrderByWithRelationInput | AdminRiskProfileOrderByWithRelationInput[]
    cursor?: AdminRiskProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminRiskProfileScalarFieldEnum | AdminRiskProfileScalarFieldEnum[]
  }

  /**
   * AdminLocation without action
   */
  export type AdminLocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminLocation
     */
    select?: AdminLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminLocationInclude<ExtArgs> | null
  }


  /**
   * Model AdminBusinessTypeHazard
   */

  export type AggregateAdminBusinessTypeHazard = {
    _count: AdminBusinessTypeHazardCountAggregateOutputType | null
    _min: AdminBusinessTypeHazardMinAggregateOutputType | null
    _max: AdminBusinessTypeHazardMaxAggregateOutputType | null
  }

  export type AdminBusinessTypeHazardMinAggregateOutputType = {
    id: string | null
    businessTypeId: string | null
    hazardId: string | null
    riskLevel: string | null
    frequency: string | null
    impact: string | null
    notes: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminBusinessTypeHazardMaxAggregateOutputType = {
    id: string | null
    businessTypeId: string | null
    hazardId: string | null
    riskLevel: string | null
    frequency: string | null
    impact: string | null
    notes: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminBusinessTypeHazardCountAggregateOutputType = {
    id: number
    businessTypeId: number
    hazardId: number
    riskLevel: number
    frequency: number
    impact: number
    notes: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdminBusinessTypeHazardMinAggregateInputType = {
    id?: true
    businessTypeId?: true
    hazardId?: true
    riskLevel?: true
    frequency?: true
    impact?: true
    notes?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminBusinessTypeHazardMaxAggregateInputType = {
    id?: true
    businessTypeId?: true
    hazardId?: true
    riskLevel?: true
    frequency?: true
    impact?: true
    notes?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminBusinessTypeHazardCountAggregateInputType = {
    id?: true
    businessTypeId?: true
    hazardId?: true
    riskLevel?: true
    frequency?: true
    impact?: true
    notes?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdminBusinessTypeHazardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminBusinessTypeHazard to aggregate.
     */
    where?: AdminBusinessTypeHazardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminBusinessTypeHazards to fetch.
     */
    orderBy?: AdminBusinessTypeHazardOrderByWithRelationInput | AdminBusinessTypeHazardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminBusinessTypeHazardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminBusinessTypeHazards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminBusinessTypeHazards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminBusinessTypeHazards
    **/
    _count?: true | AdminBusinessTypeHazardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminBusinessTypeHazardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminBusinessTypeHazardMaxAggregateInputType
  }

  export type GetAdminBusinessTypeHazardAggregateType<T extends AdminBusinessTypeHazardAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminBusinessTypeHazard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminBusinessTypeHazard[P]>
      : GetScalarType<T[P], AggregateAdminBusinessTypeHazard[P]>
  }




  export type AdminBusinessTypeHazardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminBusinessTypeHazardWhereInput
    orderBy?: AdminBusinessTypeHazardOrderByWithAggregationInput | AdminBusinessTypeHazardOrderByWithAggregationInput[]
    by: AdminBusinessTypeHazardScalarFieldEnum[] | AdminBusinessTypeHazardScalarFieldEnum
    having?: AdminBusinessTypeHazardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminBusinessTypeHazardCountAggregateInputType | true
    _min?: AdminBusinessTypeHazardMinAggregateInputType
    _max?: AdminBusinessTypeHazardMaxAggregateInputType
  }

  export type AdminBusinessTypeHazardGroupByOutputType = {
    id: string
    businessTypeId: string
    hazardId: string
    riskLevel: string
    frequency: string | null
    impact: string | null
    notes: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: AdminBusinessTypeHazardCountAggregateOutputType | null
    _min: AdminBusinessTypeHazardMinAggregateOutputType | null
    _max: AdminBusinessTypeHazardMaxAggregateOutputType | null
  }

  type GetAdminBusinessTypeHazardGroupByPayload<T extends AdminBusinessTypeHazardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminBusinessTypeHazardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminBusinessTypeHazardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminBusinessTypeHazardGroupByOutputType[P]>
            : GetScalarType<T[P], AdminBusinessTypeHazardGroupByOutputType[P]>
        }
      >
    >


  export type AdminBusinessTypeHazardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessTypeId?: boolean
    hazardId?: boolean
    riskLevel?: boolean
    frequency?: boolean
    impact?: boolean
    notes?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    businessType?: boolean | AdminBusinessTypeDefaultArgs<ExtArgs>
    hazard?: boolean | AdminHazardTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminBusinessTypeHazard"]>

  export type AdminBusinessTypeHazardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessTypeId?: boolean
    hazardId?: boolean
    riskLevel?: boolean
    frequency?: boolean
    impact?: boolean
    notes?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    businessType?: boolean | AdminBusinessTypeDefaultArgs<ExtArgs>
    hazard?: boolean | AdminHazardTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminBusinessTypeHazard"]>

  export type AdminBusinessTypeHazardSelectScalar = {
    id?: boolean
    businessTypeId?: boolean
    hazardId?: boolean
    riskLevel?: boolean
    frequency?: boolean
    impact?: boolean
    notes?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdminBusinessTypeHazardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businessType?: boolean | AdminBusinessTypeDefaultArgs<ExtArgs>
    hazard?: boolean | AdminHazardTypeDefaultArgs<ExtArgs>
  }
  export type AdminBusinessTypeHazardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businessType?: boolean | AdminBusinessTypeDefaultArgs<ExtArgs>
    hazard?: boolean | AdminHazardTypeDefaultArgs<ExtArgs>
  }

  export type $AdminBusinessTypeHazardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminBusinessTypeHazard"
    objects: {
      businessType: Prisma.$AdminBusinessTypePayload<ExtArgs>
      hazard: Prisma.$AdminHazardTypePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      businessTypeId: string
      hazardId: string
      riskLevel: string
      frequency: string | null
      impact: string | null
      notes: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["adminBusinessTypeHazard"]>
    composites: {}
  }

  type AdminBusinessTypeHazardGetPayload<S extends boolean | null | undefined | AdminBusinessTypeHazardDefaultArgs> = $Result.GetResult<Prisma.$AdminBusinessTypeHazardPayload, S>

  type AdminBusinessTypeHazardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdminBusinessTypeHazardFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdminBusinessTypeHazardCountAggregateInputType | true
    }

  export interface AdminBusinessTypeHazardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminBusinessTypeHazard'], meta: { name: 'AdminBusinessTypeHazard' } }
    /**
     * Find zero or one AdminBusinessTypeHazard that matches the filter.
     * @param {AdminBusinessTypeHazardFindUniqueArgs} args - Arguments to find a AdminBusinessTypeHazard
     * @example
     * // Get one AdminBusinessTypeHazard
     * const adminBusinessTypeHazard = await prisma.adminBusinessTypeHazard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminBusinessTypeHazardFindUniqueArgs>(args: SelectSubset<T, AdminBusinessTypeHazardFindUniqueArgs<ExtArgs>>): Prisma__AdminBusinessTypeHazardClient<$Result.GetResult<Prisma.$AdminBusinessTypeHazardPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AdminBusinessTypeHazard that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdminBusinessTypeHazardFindUniqueOrThrowArgs} args - Arguments to find a AdminBusinessTypeHazard
     * @example
     * // Get one AdminBusinessTypeHazard
     * const adminBusinessTypeHazard = await prisma.adminBusinessTypeHazard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminBusinessTypeHazardFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminBusinessTypeHazardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminBusinessTypeHazardClient<$Result.GetResult<Prisma.$AdminBusinessTypeHazardPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AdminBusinessTypeHazard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminBusinessTypeHazardFindFirstArgs} args - Arguments to find a AdminBusinessTypeHazard
     * @example
     * // Get one AdminBusinessTypeHazard
     * const adminBusinessTypeHazard = await prisma.adminBusinessTypeHazard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminBusinessTypeHazardFindFirstArgs>(args?: SelectSubset<T, AdminBusinessTypeHazardFindFirstArgs<ExtArgs>>): Prisma__AdminBusinessTypeHazardClient<$Result.GetResult<Prisma.$AdminBusinessTypeHazardPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AdminBusinessTypeHazard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminBusinessTypeHazardFindFirstOrThrowArgs} args - Arguments to find a AdminBusinessTypeHazard
     * @example
     * // Get one AdminBusinessTypeHazard
     * const adminBusinessTypeHazard = await prisma.adminBusinessTypeHazard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminBusinessTypeHazardFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminBusinessTypeHazardFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminBusinessTypeHazardClient<$Result.GetResult<Prisma.$AdminBusinessTypeHazardPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AdminBusinessTypeHazards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminBusinessTypeHazardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminBusinessTypeHazards
     * const adminBusinessTypeHazards = await prisma.adminBusinessTypeHazard.findMany()
     * 
     * // Get first 10 AdminBusinessTypeHazards
     * const adminBusinessTypeHazards = await prisma.adminBusinessTypeHazard.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminBusinessTypeHazardWithIdOnly = await prisma.adminBusinessTypeHazard.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminBusinessTypeHazardFindManyArgs>(args?: SelectSubset<T, AdminBusinessTypeHazardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminBusinessTypeHazardPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AdminBusinessTypeHazard.
     * @param {AdminBusinessTypeHazardCreateArgs} args - Arguments to create a AdminBusinessTypeHazard.
     * @example
     * // Create one AdminBusinessTypeHazard
     * const AdminBusinessTypeHazard = await prisma.adminBusinessTypeHazard.create({
     *   data: {
     *     // ... data to create a AdminBusinessTypeHazard
     *   }
     * })
     * 
     */
    create<T extends AdminBusinessTypeHazardCreateArgs>(args: SelectSubset<T, AdminBusinessTypeHazardCreateArgs<ExtArgs>>): Prisma__AdminBusinessTypeHazardClient<$Result.GetResult<Prisma.$AdminBusinessTypeHazardPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AdminBusinessTypeHazards.
     * @param {AdminBusinessTypeHazardCreateManyArgs} args - Arguments to create many AdminBusinessTypeHazards.
     * @example
     * // Create many AdminBusinessTypeHazards
     * const adminBusinessTypeHazard = await prisma.adminBusinessTypeHazard.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminBusinessTypeHazardCreateManyArgs>(args?: SelectSubset<T, AdminBusinessTypeHazardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminBusinessTypeHazards and returns the data saved in the database.
     * @param {AdminBusinessTypeHazardCreateManyAndReturnArgs} args - Arguments to create many AdminBusinessTypeHazards.
     * @example
     * // Create many AdminBusinessTypeHazards
     * const adminBusinessTypeHazard = await prisma.adminBusinessTypeHazard.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminBusinessTypeHazards and only return the `id`
     * const adminBusinessTypeHazardWithIdOnly = await prisma.adminBusinessTypeHazard.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminBusinessTypeHazardCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminBusinessTypeHazardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminBusinessTypeHazardPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AdminBusinessTypeHazard.
     * @param {AdminBusinessTypeHazardDeleteArgs} args - Arguments to delete one AdminBusinessTypeHazard.
     * @example
     * // Delete one AdminBusinessTypeHazard
     * const AdminBusinessTypeHazard = await prisma.adminBusinessTypeHazard.delete({
     *   where: {
     *     // ... filter to delete one AdminBusinessTypeHazard
     *   }
     * })
     * 
     */
    delete<T extends AdminBusinessTypeHazardDeleteArgs>(args: SelectSubset<T, AdminBusinessTypeHazardDeleteArgs<ExtArgs>>): Prisma__AdminBusinessTypeHazardClient<$Result.GetResult<Prisma.$AdminBusinessTypeHazardPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AdminBusinessTypeHazard.
     * @param {AdminBusinessTypeHazardUpdateArgs} args - Arguments to update one AdminBusinessTypeHazard.
     * @example
     * // Update one AdminBusinessTypeHazard
     * const adminBusinessTypeHazard = await prisma.adminBusinessTypeHazard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminBusinessTypeHazardUpdateArgs>(args: SelectSubset<T, AdminBusinessTypeHazardUpdateArgs<ExtArgs>>): Prisma__AdminBusinessTypeHazardClient<$Result.GetResult<Prisma.$AdminBusinessTypeHazardPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AdminBusinessTypeHazards.
     * @param {AdminBusinessTypeHazardDeleteManyArgs} args - Arguments to filter AdminBusinessTypeHazards to delete.
     * @example
     * // Delete a few AdminBusinessTypeHazards
     * const { count } = await prisma.adminBusinessTypeHazard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminBusinessTypeHazardDeleteManyArgs>(args?: SelectSubset<T, AdminBusinessTypeHazardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminBusinessTypeHazards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminBusinessTypeHazardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminBusinessTypeHazards
     * const adminBusinessTypeHazard = await prisma.adminBusinessTypeHazard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminBusinessTypeHazardUpdateManyArgs>(args: SelectSubset<T, AdminBusinessTypeHazardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AdminBusinessTypeHazard.
     * @param {AdminBusinessTypeHazardUpsertArgs} args - Arguments to update or create a AdminBusinessTypeHazard.
     * @example
     * // Update or create a AdminBusinessTypeHazard
     * const adminBusinessTypeHazard = await prisma.adminBusinessTypeHazard.upsert({
     *   create: {
     *     // ... data to create a AdminBusinessTypeHazard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminBusinessTypeHazard we want to update
     *   }
     * })
     */
    upsert<T extends AdminBusinessTypeHazardUpsertArgs>(args: SelectSubset<T, AdminBusinessTypeHazardUpsertArgs<ExtArgs>>): Prisma__AdminBusinessTypeHazardClient<$Result.GetResult<Prisma.$AdminBusinessTypeHazardPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AdminBusinessTypeHazards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminBusinessTypeHazardCountArgs} args - Arguments to filter AdminBusinessTypeHazards to count.
     * @example
     * // Count the number of AdminBusinessTypeHazards
     * const count = await prisma.adminBusinessTypeHazard.count({
     *   where: {
     *     // ... the filter for the AdminBusinessTypeHazards we want to count
     *   }
     * })
    **/
    count<T extends AdminBusinessTypeHazardCountArgs>(
      args?: Subset<T, AdminBusinessTypeHazardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminBusinessTypeHazardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminBusinessTypeHazard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminBusinessTypeHazardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminBusinessTypeHazardAggregateArgs>(args: Subset<T, AdminBusinessTypeHazardAggregateArgs>): Prisma.PrismaPromise<GetAdminBusinessTypeHazardAggregateType<T>>

    /**
     * Group by AdminBusinessTypeHazard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminBusinessTypeHazardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminBusinessTypeHazardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminBusinessTypeHazardGroupByArgs['orderBy'] }
        : { orderBy?: AdminBusinessTypeHazardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminBusinessTypeHazardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminBusinessTypeHazardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminBusinessTypeHazard model
   */
  readonly fields: AdminBusinessTypeHazardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminBusinessTypeHazard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminBusinessTypeHazardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    businessType<T extends AdminBusinessTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminBusinessTypeDefaultArgs<ExtArgs>>): Prisma__AdminBusinessTypeClient<$Result.GetResult<Prisma.$AdminBusinessTypePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    hazard<T extends AdminHazardTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminHazardTypeDefaultArgs<ExtArgs>>): Prisma__AdminHazardTypeClient<$Result.GetResult<Prisma.$AdminHazardTypePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminBusinessTypeHazard model
   */ 
  interface AdminBusinessTypeHazardFieldRefs {
    readonly id: FieldRef<"AdminBusinessTypeHazard", 'String'>
    readonly businessTypeId: FieldRef<"AdminBusinessTypeHazard", 'String'>
    readonly hazardId: FieldRef<"AdminBusinessTypeHazard", 'String'>
    readonly riskLevel: FieldRef<"AdminBusinessTypeHazard", 'String'>
    readonly frequency: FieldRef<"AdminBusinessTypeHazard", 'String'>
    readonly impact: FieldRef<"AdminBusinessTypeHazard", 'String'>
    readonly notes: FieldRef<"AdminBusinessTypeHazard", 'String'>
    readonly isActive: FieldRef<"AdminBusinessTypeHazard", 'Boolean'>
    readonly createdAt: FieldRef<"AdminBusinessTypeHazard", 'DateTime'>
    readonly updatedAt: FieldRef<"AdminBusinessTypeHazard", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdminBusinessTypeHazard findUnique
   */
  export type AdminBusinessTypeHazardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminBusinessTypeHazard
     */
    select?: AdminBusinessTypeHazardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminBusinessTypeHazardInclude<ExtArgs> | null
    /**
     * Filter, which AdminBusinessTypeHazard to fetch.
     */
    where: AdminBusinessTypeHazardWhereUniqueInput
  }

  /**
   * AdminBusinessTypeHazard findUniqueOrThrow
   */
  export type AdminBusinessTypeHazardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminBusinessTypeHazard
     */
    select?: AdminBusinessTypeHazardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminBusinessTypeHazardInclude<ExtArgs> | null
    /**
     * Filter, which AdminBusinessTypeHazard to fetch.
     */
    where: AdminBusinessTypeHazardWhereUniqueInput
  }

  /**
   * AdminBusinessTypeHazard findFirst
   */
  export type AdminBusinessTypeHazardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminBusinessTypeHazard
     */
    select?: AdminBusinessTypeHazardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminBusinessTypeHazardInclude<ExtArgs> | null
    /**
     * Filter, which AdminBusinessTypeHazard to fetch.
     */
    where?: AdminBusinessTypeHazardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminBusinessTypeHazards to fetch.
     */
    orderBy?: AdminBusinessTypeHazardOrderByWithRelationInput | AdminBusinessTypeHazardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminBusinessTypeHazards.
     */
    cursor?: AdminBusinessTypeHazardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminBusinessTypeHazards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminBusinessTypeHazards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminBusinessTypeHazards.
     */
    distinct?: AdminBusinessTypeHazardScalarFieldEnum | AdminBusinessTypeHazardScalarFieldEnum[]
  }

  /**
   * AdminBusinessTypeHazard findFirstOrThrow
   */
  export type AdminBusinessTypeHazardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminBusinessTypeHazard
     */
    select?: AdminBusinessTypeHazardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminBusinessTypeHazardInclude<ExtArgs> | null
    /**
     * Filter, which AdminBusinessTypeHazard to fetch.
     */
    where?: AdminBusinessTypeHazardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminBusinessTypeHazards to fetch.
     */
    orderBy?: AdminBusinessTypeHazardOrderByWithRelationInput | AdminBusinessTypeHazardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminBusinessTypeHazards.
     */
    cursor?: AdminBusinessTypeHazardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminBusinessTypeHazards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminBusinessTypeHazards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminBusinessTypeHazards.
     */
    distinct?: AdminBusinessTypeHazardScalarFieldEnum | AdminBusinessTypeHazardScalarFieldEnum[]
  }

  /**
   * AdminBusinessTypeHazard findMany
   */
  export type AdminBusinessTypeHazardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminBusinessTypeHazard
     */
    select?: AdminBusinessTypeHazardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminBusinessTypeHazardInclude<ExtArgs> | null
    /**
     * Filter, which AdminBusinessTypeHazards to fetch.
     */
    where?: AdminBusinessTypeHazardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminBusinessTypeHazards to fetch.
     */
    orderBy?: AdminBusinessTypeHazardOrderByWithRelationInput | AdminBusinessTypeHazardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminBusinessTypeHazards.
     */
    cursor?: AdminBusinessTypeHazardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminBusinessTypeHazards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminBusinessTypeHazards.
     */
    skip?: number
    distinct?: AdminBusinessTypeHazardScalarFieldEnum | AdminBusinessTypeHazardScalarFieldEnum[]
  }

  /**
   * AdminBusinessTypeHazard create
   */
  export type AdminBusinessTypeHazardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminBusinessTypeHazard
     */
    select?: AdminBusinessTypeHazardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminBusinessTypeHazardInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminBusinessTypeHazard.
     */
    data: XOR<AdminBusinessTypeHazardCreateInput, AdminBusinessTypeHazardUncheckedCreateInput>
  }

  /**
   * AdminBusinessTypeHazard createMany
   */
  export type AdminBusinessTypeHazardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminBusinessTypeHazards.
     */
    data: AdminBusinessTypeHazardCreateManyInput | AdminBusinessTypeHazardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminBusinessTypeHazard createManyAndReturn
   */
  export type AdminBusinessTypeHazardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminBusinessTypeHazard
     */
    select?: AdminBusinessTypeHazardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AdminBusinessTypeHazards.
     */
    data: AdminBusinessTypeHazardCreateManyInput | AdminBusinessTypeHazardCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminBusinessTypeHazardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminBusinessTypeHazard update
   */
  export type AdminBusinessTypeHazardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminBusinessTypeHazard
     */
    select?: AdminBusinessTypeHazardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminBusinessTypeHazardInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminBusinessTypeHazard.
     */
    data: XOR<AdminBusinessTypeHazardUpdateInput, AdminBusinessTypeHazardUncheckedUpdateInput>
    /**
     * Choose, which AdminBusinessTypeHazard to update.
     */
    where: AdminBusinessTypeHazardWhereUniqueInput
  }

  /**
   * AdminBusinessTypeHazard updateMany
   */
  export type AdminBusinessTypeHazardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminBusinessTypeHazards.
     */
    data: XOR<AdminBusinessTypeHazardUpdateManyMutationInput, AdminBusinessTypeHazardUncheckedUpdateManyInput>
    /**
     * Filter which AdminBusinessTypeHazards to update
     */
    where?: AdminBusinessTypeHazardWhereInput
  }

  /**
   * AdminBusinessTypeHazard upsert
   */
  export type AdminBusinessTypeHazardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminBusinessTypeHazard
     */
    select?: AdminBusinessTypeHazardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminBusinessTypeHazardInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminBusinessTypeHazard to update in case it exists.
     */
    where: AdminBusinessTypeHazardWhereUniqueInput
    /**
     * In case the AdminBusinessTypeHazard found by the `where` argument doesn't exist, create a new AdminBusinessTypeHazard with this data.
     */
    create: XOR<AdminBusinessTypeHazardCreateInput, AdminBusinessTypeHazardUncheckedCreateInput>
    /**
     * In case the AdminBusinessTypeHazard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminBusinessTypeHazardUpdateInput, AdminBusinessTypeHazardUncheckedUpdateInput>
  }

  /**
   * AdminBusinessTypeHazard delete
   */
  export type AdminBusinessTypeHazardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminBusinessTypeHazard
     */
    select?: AdminBusinessTypeHazardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminBusinessTypeHazardInclude<ExtArgs> | null
    /**
     * Filter which AdminBusinessTypeHazard to delete.
     */
    where: AdminBusinessTypeHazardWhereUniqueInput
  }

  /**
   * AdminBusinessTypeHazard deleteMany
   */
  export type AdminBusinessTypeHazardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminBusinessTypeHazards to delete
     */
    where?: AdminBusinessTypeHazardWhereInput
  }

  /**
   * AdminBusinessTypeHazard without action
   */
  export type AdminBusinessTypeHazardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminBusinessTypeHazard
     */
    select?: AdminBusinessTypeHazardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminBusinessTypeHazardInclude<ExtArgs> | null
  }


  /**
   * Model AdminLocationHazard
   */

  export type AggregateAdminLocationHazard = {
    _count: AdminLocationHazardCountAggregateOutputType | null
    _min: AdminLocationHazardMinAggregateOutputType | null
    _max: AdminLocationHazardMaxAggregateOutputType | null
  }

  export type AdminLocationHazardMinAggregateOutputType = {
    id: string | null
    locationId: string | null
    hazardId: string | null
    riskLevel: string | null
    frequency: string | null
    impact: string | null
    notes: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminLocationHazardMaxAggregateOutputType = {
    id: string | null
    locationId: string | null
    hazardId: string | null
    riskLevel: string | null
    frequency: string | null
    impact: string | null
    notes: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminLocationHazardCountAggregateOutputType = {
    id: number
    locationId: number
    hazardId: number
    riskLevel: number
    frequency: number
    impact: number
    notes: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdminLocationHazardMinAggregateInputType = {
    id?: true
    locationId?: true
    hazardId?: true
    riskLevel?: true
    frequency?: true
    impact?: true
    notes?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminLocationHazardMaxAggregateInputType = {
    id?: true
    locationId?: true
    hazardId?: true
    riskLevel?: true
    frequency?: true
    impact?: true
    notes?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminLocationHazardCountAggregateInputType = {
    id?: true
    locationId?: true
    hazardId?: true
    riskLevel?: true
    frequency?: true
    impact?: true
    notes?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdminLocationHazardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminLocationHazard to aggregate.
     */
    where?: AdminLocationHazardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminLocationHazards to fetch.
     */
    orderBy?: AdminLocationHazardOrderByWithRelationInput | AdminLocationHazardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminLocationHazardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminLocationHazards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminLocationHazards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminLocationHazards
    **/
    _count?: true | AdminLocationHazardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminLocationHazardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminLocationHazardMaxAggregateInputType
  }

  export type GetAdminLocationHazardAggregateType<T extends AdminLocationHazardAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminLocationHazard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminLocationHazard[P]>
      : GetScalarType<T[P], AggregateAdminLocationHazard[P]>
  }




  export type AdminLocationHazardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminLocationHazardWhereInput
    orderBy?: AdminLocationHazardOrderByWithAggregationInput | AdminLocationHazardOrderByWithAggregationInput[]
    by: AdminLocationHazardScalarFieldEnum[] | AdminLocationHazardScalarFieldEnum
    having?: AdminLocationHazardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminLocationHazardCountAggregateInputType | true
    _min?: AdminLocationHazardMinAggregateInputType
    _max?: AdminLocationHazardMaxAggregateInputType
  }

  export type AdminLocationHazardGroupByOutputType = {
    id: string
    locationId: string
    hazardId: string
    riskLevel: string
    frequency: string | null
    impact: string | null
    notes: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: AdminLocationHazardCountAggregateOutputType | null
    _min: AdminLocationHazardMinAggregateOutputType | null
    _max: AdminLocationHazardMaxAggregateOutputType | null
  }

  type GetAdminLocationHazardGroupByPayload<T extends AdminLocationHazardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminLocationHazardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminLocationHazardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminLocationHazardGroupByOutputType[P]>
            : GetScalarType<T[P], AdminLocationHazardGroupByOutputType[P]>
        }
      >
    >


  export type AdminLocationHazardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationId?: boolean
    hazardId?: boolean
    riskLevel?: boolean
    frequency?: boolean
    impact?: boolean
    notes?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean | AdminLocationDefaultArgs<ExtArgs>
    hazard?: boolean | AdminHazardTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminLocationHazard"]>

  export type AdminLocationHazardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationId?: boolean
    hazardId?: boolean
    riskLevel?: boolean
    frequency?: boolean
    impact?: boolean
    notes?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean | AdminLocationDefaultArgs<ExtArgs>
    hazard?: boolean | AdminHazardTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminLocationHazard"]>

  export type AdminLocationHazardSelectScalar = {
    id?: boolean
    locationId?: boolean
    hazardId?: boolean
    riskLevel?: boolean
    frequency?: boolean
    impact?: boolean
    notes?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdminLocationHazardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | AdminLocationDefaultArgs<ExtArgs>
    hazard?: boolean | AdminHazardTypeDefaultArgs<ExtArgs>
  }
  export type AdminLocationHazardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | AdminLocationDefaultArgs<ExtArgs>
    hazard?: boolean | AdminHazardTypeDefaultArgs<ExtArgs>
  }

  export type $AdminLocationHazardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminLocationHazard"
    objects: {
      location: Prisma.$AdminLocationPayload<ExtArgs>
      hazard: Prisma.$AdminHazardTypePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      locationId: string
      hazardId: string
      riskLevel: string
      frequency: string | null
      impact: string | null
      notes: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["adminLocationHazard"]>
    composites: {}
  }

  type AdminLocationHazardGetPayload<S extends boolean | null | undefined | AdminLocationHazardDefaultArgs> = $Result.GetResult<Prisma.$AdminLocationHazardPayload, S>

  type AdminLocationHazardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdminLocationHazardFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdminLocationHazardCountAggregateInputType | true
    }

  export interface AdminLocationHazardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminLocationHazard'], meta: { name: 'AdminLocationHazard' } }
    /**
     * Find zero or one AdminLocationHazard that matches the filter.
     * @param {AdminLocationHazardFindUniqueArgs} args - Arguments to find a AdminLocationHazard
     * @example
     * // Get one AdminLocationHazard
     * const adminLocationHazard = await prisma.adminLocationHazard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminLocationHazardFindUniqueArgs>(args: SelectSubset<T, AdminLocationHazardFindUniqueArgs<ExtArgs>>): Prisma__AdminLocationHazardClient<$Result.GetResult<Prisma.$AdminLocationHazardPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AdminLocationHazard that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdminLocationHazardFindUniqueOrThrowArgs} args - Arguments to find a AdminLocationHazard
     * @example
     * // Get one AdminLocationHazard
     * const adminLocationHazard = await prisma.adminLocationHazard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminLocationHazardFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminLocationHazardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminLocationHazardClient<$Result.GetResult<Prisma.$AdminLocationHazardPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AdminLocationHazard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminLocationHazardFindFirstArgs} args - Arguments to find a AdminLocationHazard
     * @example
     * // Get one AdminLocationHazard
     * const adminLocationHazard = await prisma.adminLocationHazard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminLocationHazardFindFirstArgs>(args?: SelectSubset<T, AdminLocationHazardFindFirstArgs<ExtArgs>>): Prisma__AdminLocationHazardClient<$Result.GetResult<Prisma.$AdminLocationHazardPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AdminLocationHazard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminLocationHazardFindFirstOrThrowArgs} args - Arguments to find a AdminLocationHazard
     * @example
     * // Get one AdminLocationHazard
     * const adminLocationHazard = await prisma.adminLocationHazard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminLocationHazardFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminLocationHazardFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminLocationHazardClient<$Result.GetResult<Prisma.$AdminLocationHazardPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AdminLocationHazards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminLocationHazardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminLocationHazards
     * const adminLocationHazards = await prisma.adminLocationHazard.findMany()
     * 
     * // Get first 10 AdminLocationHazards
     * const adminLocationHazards = await prisma.adminLocationHazard.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminLocationHazardWithIdOnly = await prisma.adminLocationHazard.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminLocationHazardFindManyArgs>(args?: SelectSubset<T, AdminLocationHazardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminLocationHazardPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AdminLocationHazard.
     * @param {AdminLocationHazardCreateArgs} args - Arguments to create a AdminLocationHazard.
     * @example
     * // Create one AdminLocationHazard
     * const AdminLocationHazard = await prisma.adminLocationHazard.create({
     *   data: {
     *     // ... data to create a AdminLocationHazard
     *   }
     * })
     * 
     */
    create<T extends AdminLocationHazardCreateArgs>(args: SelectSubset<T, AdminLocationHazardCreateArgs<ExtArgs>>): Prisma__AdminLocationHazardClient<$Result.GetResult<Prisma.$AdminLocationHazardPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AdminLocationHazards.
     * @param {AdminLocationHazardCreateManyArgs} args - Arguments to create many AdminLocationHazards.
     * @example
     * // Create many AdminLocationHazards
     * const adminLocationHazard = await prisma.adminLocationHazard.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminLocationHazardCreateManyArgs>(args?: SelectSubset<T, AdminLocationHazardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminLocationHazards and returns the data saved in the database.
     * @param {AdminLocationHazardCreateManyAndReturnArgs} args - Arguments to create many AdminLocationHazards.
     * @example
     * // Create many AdminLocationHazards
     * const adminLocationHazard = await prisma.adminLocationHazard.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminLocationHazards and only return the `id`
     * const adminLocationHazardWithIdOnly = await prisma.adminLocationHazard.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminLocationHazardCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminLocationHazardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminLocationHazardPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AdminLocationHazard.
     * @param {AdminLocationHazardDeleteArgs} args - Arguments to delete one AdminLocationHazard.
     * @example
     * // Delete one AdminLocationHazard
     * const AdminLocationHazard = await prisma.adminLocationHazard.delete({
     *   where: {
     *     // ... filter to delete one AdminLocationHazard
     *   }
     * })
     * 
     */
    delete<T extends AdminLocationHazardDeleteArgs>(args: SelectSubset<T, AdminLocationHazardDeleteArgs<ExtArgs>>): Prisma__AdminLocationHazardClient<$Result.GetResult<Prisma.$AdminLocationHazardPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AdminLocationHazard.
     * @param {AdminLocationHazardUpdateArgs} args - Arguments to update one AdminLocationHazard.
     * @example
     * // Update one AdminLocationHazard
     * const adminLocationHazard = await prisma.adminLocationHazard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminLocationHazardUpdateArgs>(args: SelectSubset<T, AdminLocationHazardUpdateArgs<ExtArgs>>): Prisma__AdminLocationHazardClient<$Result.GetResult<Prisma.$AdminLocationHazardPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AdminLocationHazards.
     * @param {AdminLocationHazardDeleteManyArgs} args - Arguments to filter AdminLocationHazards to delete.
     * @example
     * // Delete a few AdminLocationHazards
     * const { count } = await prisma.adminLocationHazard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminLocationHazardDeleteManyArgs>(args?: SelectSubset<T, AdminLocationHazardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminLocationHazards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminLocationHazardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminLocationHazards
     * const adminLocationHazard = await prisma.adminLocationHazard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminLocationHazardUpdateManyArgs>(args: SelectSubset<T, AdminLocationHazardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AdminLocationHazard.
     * @param {AdminLocationHazardUpsertArgs} args - Arguments to update or create a AdminLocationHazard.
     * @example
     * // Update or create a AdminLocationHazard
     * const adminLocationHazard = await prisma.adminLocationHazard.upsert({
     *   create: {
     *     // ... data to create a AdminLocationHazard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminLocationHazard we want to update
     *   }
     * })
     */
    upsert<T extends AdminLocationHazardUpsertArgs>(args: SelectSubset<T, AdminLocationHazardUpsertArgs<ExtArgs>>): Prisma__AdminLocationHazardClient<$Result.GetResult<Prisma.$AdminLocationHazardPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AdminLocationHazards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminLocationHazardCountArgs} args - Arguments to filter AdminLocationHazards to count.
     * @example
     * // Count the number of AdminLocationHazards
     * const count = await prisma.adminLocationHazard.count({
     *   where: {
     *     // ... the filter for the AdminLocationHazards we want to count
     *   }
     * })
    **/
    count<T extends AdminLocationHazardCountArgs>(
      args?: Subset<T, AdminLocationHazardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminLocationHazardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminLocationHazard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminLocationHazardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminLocationHazardAggregateArgs>(args: Subset<T, AdminLocationHazardAggregateArgs>): Prisma.PrismaPromise<GetAdminLocationHazardAggregateType<T>>

    /**
     * Group by AdminLocationHazard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminLocationHazardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminLocationHazardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminLocationHazardGroupByArgs['orderBy'] }
        : { orderBy?: AdminLocationHazardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminLocationHazardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminLocationHazardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminLocationHazard model
   */
  readonly fields: AdminLocationHazardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminLocationHazard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminLocationHazardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    location<T extends AdminLocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminLocationDefaultArgs<ExtArgs>>): Prisma__AdminLocationClient<$Result.GetResult<Prisma.$AdminLocationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    hazard<T extends AdminHazardTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminHazardTypeDefaultArgs<ExtArgs>>): Prisma__AdminHazardTypeClient<$Result.GetResult<Prisma.$AdminHazardTypePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminLocationHazard model
   */ 
  interface AdminLocationHazardFieldRefs {
    readonly id: FieldRef<"AdminLocationHazard", 'String'>
    readonly locationId: FieldRef<"AdminLocationHazard", 'String'>
    readonly hazardId: FieldRef<"AdminLocationHazard", 'String'>
    readonly riskLevel: FieldRef<"AdminLocationHazard", 'String'>
    readonly frequency: FieldRef<"AdminLocationHazard", 'String'>
    readonly impact: FieldRef<"AdminLocationHazard", 'String'>
    readonly notes: FieldRef<"AdminLocationHazard", 'String'>
    readonly isActive: FieldRef<"AdminLocationHazard", 'Boolean'>
    readonly createdAt: FieldRef<"AdminLocationHazard", 'DateTime'>
    readonly updatedAt: FieldRef<"AdminLocationHazard", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdminLocationHazard findUnique
   */
  export type AdminLocationHazardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminLocationHazard
     */
    select?: AdminLocationHazardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminLocationHazardInclude<ExtArgs> | null
    /**
     * Filter, which AdminLocationHazard to fetch.
     */
    where: AdminLocationHazardWhereUniqueInput
  }

  /**
   * AdminLocationHazard findUniqueOrThrow
   */
  export type AdminLocationHazardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminLocationHazard
     */
    select?: AdminLocationHazardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminLocationHazardInclude<ExtArgs> | null
    /**
     * Filter, which AdminLocationHazard to fetch.
     */
    where: AdminLocationHazardWhereUniqueInput
  }

  /**
   * AdminLocationHazard findFirst
   */
  export type AdminLocationHazardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminLocationHazard
     */
    select?: AdminLocationHazardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminLocationHazardInclude<ExtArgs> | null
    /**
     * Filter, which AdminLocationHazard to fetch.
     */
    where?: AdminLocationHazardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminLocationHazards to fetch.
     */
    orderBy?: AdminLocationHazardOrderByWithRelationInput | AdminLocationHazardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminLocationHazards.
     */
    cursor?: AdminLocationHazardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminLocationHazards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminLocationHazards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminLocationHazards.
     */
    distinct?: AdminLocationHazardScalarFieldEnum | AdminLocationHazardScalarFieldEnum[]
  }

  /**
   * AdminLocationHazard findFirstOrThrow
   */
  export type AdminLocationHazardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminLocationHazard
     */
    select?: AdminLocationHazardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminLocationHazardInclude<ExtArgs> | null
    /**
     * Filter, which AdminLocationHazard to fetch.
     */
    where?: AdminLocationHazardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminLocationHazards to fetch.
     */
    orderBy?: AdminLocationHazardOrderByWithRelationInput | AdminLocationHazardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminLocationHazards.
     */
    cursor?: AdminLocationHazardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminLocationHazards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminLocationHazards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminLocationHazards.
     */
    distinct?: AdminLocationHazardScalarFieldEnum | AdminLocationHazardScalarFieldEnum[]
  }

  /**
   * AdminLocationHazard findMany
   */
  export type AdminLocationHazardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminLocationHazard
     */
    select?: AdminLocationHazardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminLocationHazardInclude<ExtArgs> | null
    /**
     * Filter, which AdminLocationHazards to fetch.
     */
    where?: AdminLocationHazardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminLocationHazards to fetch.
     */
    orderBy?: AdminLocationHazardOrderByWithRelationInput | AdminLocationHazardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminLocationHazards.
     */
    cursor?: AdminLocationHazardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminLocationHazards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminLocationHazards.
     */
    skip?: number
    distinct?: AdminLocationHazardScalarFieldEnum | AdminLocationHazardScalarFieldEnum[]
  }

  /**
   * AdminLocationHazard create
   */
  export type AdminLocationHazardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminLocationHazard
     */
    select?: AdminLocationHazardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminLocationHazardInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminLocationHazard.
     */
    data: XOR<AdminLocationHazardCreateInput, AdminLocationHazardUncheckedCreateInput>
  }

  /**
   * AdminLocationHazard createMany
   */
  export type AdminLocationHazardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminLocationHazards.
     */
    data: AdminLocationHazardCreateManyInput | AdminLocationHazardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminLocationHazard createManyAndReturn
   */
  export type AdminLocationHazardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminLocationHazard
     */
    select?: AdminLocationHazardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AdminLocationHazards.
     */
    data: AdminLocationHazardCreateManyInput | AdminLocationHazardCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminLocationHazardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminLocationHazard update
   */
  export type AdminLocationHazardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminLocationHazard
     */
    select?: AdminLocationHazardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminLocationHazardInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminLocationHazard.
     */
    data: XOR<AdminLocationHazardUpdateInput, AdminLocationHazardUncheckedUpdateInput>
    /**
     * Choose, which AdminLocationHazard to update.
     */
    where: AdminLocationHazardWhereUniqueInput
  }

  /**
   * AdminLocationHazard updateMany
   */
  export type AdminLocationHazardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminLocationHazards.
     */
    data: XOR<AdminLocationHazardUpdateManyMutationInput, AdminLocationHazardUncheckedUpdateManyInput>
    /**
     * Filter which AdminLocationHazards to update
     */
    where?: AdminLocationHazardWhereInput
  }

  /**
   * AdminLocationHazard upsert
   */
  export type AdminLocationHazardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminLocationHazard
     */
    select?: AdminLocationHazardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminLocationHazardInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminLocationHazard to update in case it exists.
     */
    where: AdminLocationHazardWhereUniqueInput
    /**
     * In case the AdminLocationHazard found by the `where` argument doesn't exist, create a new AdminLocationHazard with this data.
     */
    create: XOR<AdminLocationHazardCreateInput, AdminLocationHazardUncheckedCreateInput>
    /**
     * In case the AdminLocationHazard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminLocationHazardUpdateInput, AdminLocationHazardUncheckedUpdateInput>
  }

  /**
   * AdminLocationHazard delete
   */
  export type AdminLocationHazardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminLocationHazard
     */
    select?: AdminLocationHazardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminLocationHazardInclude<ExtArgs> | null
    /**
     * Filter which AdminLocationHazard to delete.
     */
    where: AdminLocationHazardWhereUniqueInput
  }

  /**
   * AdminLocationHazard deleteMany
   */
  export type AdminLocationHazardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminLocationHazards to delete
     */
    where?: AdminLocationHazardWhereInput
  }

  /**
   * AdminLocationHazard without action
   */
  export type AdminLocationHazardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminLocationHazard
     */
    select?: AdminLocationHazardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminLocationHazardInclude<ExtArgs> | null
  }


  /**
   * Model AdminStrategy
   */

  export type AggregateAdminStrategy = {
    _count: AdminStrategyCountAggregateOutputType | null
    _min: AdminStrategyMinAggregateOutputType | null
    _max: AdminStrategyMaxAggregateOutputType | null
  }

  export type AdminStrategyMinAggregateOutputType = {
    id: string | null
    strategyId: string | null
    title: string | null
    description: string | null
    category: string | null
    reasoning: string | null
    icon: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminStrategyMaxAggregateOutputType = {
    id: string | null
    strategyId: string | null
    title: string | null
    description: string | null
    category: string | null
    reasoning: string | null
    icon: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminStrategyCountAggregateOutputType = {
    id: number
    strategyId: number
    title: number
    description: number
    category: number
    reasoning: number
    icon: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdminStrategyMinAggregateInputType = {
    id?: true
    strategyId?: true
    title?: true
    description?: true
    category?: true
    reasoning?: true
    icon?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminStrategyMaxAggregateInputType = {
    id?: true
    strategyId?: true
    title?: true
    description?: true
    category?: true
    reasoning?: true
    icon?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminStrategyCountAggregateInputType = {
    id?: true
    strategyId?: true
    title?: true
    description?: true
    category?: true
    reasoning?: true
    icon?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdminStrategyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminStrategy to aggregate.
     */
    where?: AdminStrategyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminStrategies to fetch.
     */
    orderBy?: AdminStrategyOrderByWithRelationInput | AdminStrategyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminStrategyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminStrategies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminStrategies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminStrategies
    **/
    _count?: true | AdminStrategyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminStrategyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminStrategyMaxAggregateInputType
  }

  export type GetAdminStrategyAggregateType<T extends AdminStrategyAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminStrategy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminStrategy[P]>
      : GetScalarType<T[P], AggregateAdminStrategy[P]>
  }




  export type AdminStrategyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminStrategyWhereInput
    orderBy?: AdminStrategyOrderByWithAggregationInput | AdminStrategyOrderByWithAggregationInput[]
    by: AdminStrategyScalarFieldEnum[] | AdminStrategyScalarFieldEnum
    having?: AdminStrategyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminStrategyCountAggregateInputType | true
    _min?: AdminStrategyMinAggregateInputType
    _max?: AdminStrategyMaxAggregateInputType
  }

  export type AdminStrategyGroupByOutputType = {
    id: string
    strategyId: string
    title: string
    description: string
    category: string
    reasoning: string | null
    icon: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: AdminStrategyCountAggregateOutputType | null
    _min: AdminStrategyMinAggregateOutputType | null
    _max: AdminStrategyMaxAggregateOutputType | null
  }

  type GetAdminStrategyGroupByPayload<T extends AdminStrategyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminStrategyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminStrategyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminStrategyGroupByOutputType[P]>
            : GetScalarType<T[P], AdminStrategyGroupByOutputType[P]>
        }
      >
    >


  export type AdminStrategySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    strategyId?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    reasoning?: boolean
    icon?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hazardStrategies?: boolean | AdminStrategy$hazardStrategiesArgs<ExtArgs>
    _count?: boolean | AdminStrategyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminStrategy"]>

  export type AdminStrategySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    strategyId?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    reasoning?: boolean
    icon?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["adminStrategy"]>

  export type AdminStrategySelectScalar = {
    id?: boolean
    strategyId?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    reasoning?: boolean
    icon?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdminStrategyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hazardStrategies?: boolean | AdminStrategy$hazardStrategiesArgs<ExtArgs>
    _count?: boolean | AdminStrategyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AdminStrategyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AdminStrategyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminStrategy"
    objects: {
      hazardStrategies: Prisma.$AdminHazardStrategyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      strategyId: string
      title: string
      description: string
      category: string
      reasoning: string | null
      icon: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["adminStrategy"]>
    composites: {}
  }

  type AdminStrategyGetPayload<S extends boolean | null | undefined | AdminStrategyDefaultArgs> = $Result.GetResult<Prisma.$AdminStrategyPayload, S>

  type AdminStrategyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdminStrategyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdminStrategyCountAggregateInputType | true
    }

  export interface AdminStrategyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminStrategy'], meta: { name: 'AdminStrategy' } }
    /**
     * Find zero or one AdminStrategy that matches the filter.
     * @param {AdminStrategyFindUniqueArgs} args - Arguments to find a AdminStrategy
     * @example
     * // Get one AdminStrategy
     * const adminStrategy = await prisma.adminStrategy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminStrategyFindUniqueArgs>(args: SelectSubset<T, AdminStrategyFindUniqueArgs<ExtArgs>>): Prisma__AdminStrategyClient<$Result.GetResult<Prisma.$AdminStrategyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AdminStrategy that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdminStrategyFindUniqueOrThrowArgs} args - Arguments to find a AdminStrategy
     * @example
     * // Get one AdminStrategy
     * const adminStrategy = await prisma.adminStrategy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminStrategyFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminStrategyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminStrategyClient<$Result.GetResult<Prisma.$AdminStrategyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AdminStrategy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminStrategyFindFirstArgs} args - Arguments to find a AdminStrategy
     * @example
     * // Get one AdminStrategy
     * const adminStrategy = await prisma.adminStrategy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminStrategyFindFirstArgs>(args?: SelectSubset<T, AdminStrategyFindFirstArgs<ExtArgs>>): Prisma__AdminStrategyClient<$Result.GetResult<Prisma.$AdminStrategyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AdminStrategy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminStrategyFindFirstOrThrowArgs} args - Arguments to find a AdminStrategy
     * @example
     * // Get one AdminStrategy
     * const adminStrategy = await prisma.adminStrategy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminStrategyFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminStrategyFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminStrategyClient<$Result.GetResult<Prisma.$AdminStrategyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AdminStrategies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminStrategyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminStrategies
     * const adminStrategies = await prisma.adminStrategy.findMany()
     * 
     * // Get first 10 AdminStrategies
     * const adminStrategies = await prisma.adminStrategy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminStrategyWithIdOnly = await prisma.adminStrategy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminStrategyFindManyArgs>(args?: SelectSubset<T, AdminStrategyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminStrategyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AdminStrategy.
     * @param {AdminStrategyCreateArgs} args - Arguments to create a AdminStrategy.
     * @example
     * // Create one AdminStrategy
     * const AdminStrategy = await prisma.adminStrategy.create({
     *   data: {
     *     // ... data to create a AdminStrategy
     *   }
     * })
     * 
     */
    create<T extends AdminStrategyCreateArgs>(args: SelectSubset<T, AdminStrategyCreateArgs<ExtArgs>>): Prisma__AdminStrategyClient<$Result.GetResult<Prisma.$AdminStrategyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AdminStrategies.
     * @param {AdminStrategyCreateManyArgs} args - Arguments to create many AdminStrategies.
     * @example
     * // Create many AdminStrategies
     * const adminStrategy = await prisma.adminStrategy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminStrategyCreateManyArgs>(args?: SelectSubset<T, AdminStrategyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminStrategies and returns the data saved in the database.
     * @param {AdminStrategyCreateManyAndReturnArgs} args - Arguments to create many AdminStrategies.
     * @example
     * // Create many AdminStrategies
     * const adminStrategy = await prisma.adminStrategy.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminStrategies and only return the `id`
     * const adminStrategyWithIdOnly = await prisma.adminStrategy.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminStrategyCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminStrategyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminStrategyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AdminStrategy.
     * @param {AdminStrategyDeleteArgs} args - Arguments to delete one AdminStrategy.
     * @example
     * // Delete one AdminStrategy
     * const AdminStrategy = await prisma.adminStrategy.delete({
     *   where: {
     *     // ... filter to delete one AdminStrategy
     *   }
     * })
     * 
     */
    delete<T extends AdminStrategyDeleteArgs>(args: SelectSubset<T, AdminStrategyDeleteArgs<ExtArgs>>): Prisma__AdminStrategyClient<$Result.GetResult<Prisma.$AdminStrategyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AdminStrategy.
     * @param {AdminStrategyUpdateArgs} args - Arguments to update one AdminStrategy.
     * @example
     * // Update one AdminStrategy
     * const adminStrategy = await prisma.adminStrategy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminStrategyUpdateArgs>(args: SelectSubset<T, AdminStrategyUpdateArgs<ExtArgs>>): Prisma__AdminStrategyClient<$Result.GetResult<Prisma.$AdminStrategyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AdminStrategies.
     * @param {AdminStrategyDeleteManyArgs} args - Arguments to filter AdminStrategies to delete.
     * @example
     * // Delete a few AdminStrategies
     * const { count } = await prisma.adminStrategy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminStrategyDeleteManyArgs>(args?: SelectSubset<T, AdminStrategyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminStrategies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminStrategyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminStrategies
     * const adminStrategy = await prisma.adminStrategy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminStrategyUpdateManyArgs>(args: SelectSubset<T, AdminStrategyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AdminStrategy.
     * @param {AdminStrategyUpsertArgs} args - Arguments to update or create a AdminStrategy.
     * @example
     * // Update or create a AdminStrategy
     * const adminStrategy = await prisma.adminStrategy.upsert({
     *   create: {
     *     // ... data to create a AdminStrategy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminStrategy we want to update
     *   }
     * })
     */
    upsert<T extends AdminStrategyUpsertArgs>(args: SelectSubset<T, AdminStrategyUpsertArgs<ExtArgs>>): Prisma__AdminStrategyClient<$Result.GetResult<Prisma.$AdminStrategyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AdminStrategies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminStrategyCountArgs} args - Arguments to filter AdminStrategies to count.
     * @example
     * // Count the number of AdminStrategies
     * const count = await prisma.adminStrategy.count({
     *   where: {
     *     // ... the filter for the AdminStrategies we want to count
     *   }
     * })
    **/
    count<T extends AdminStrategyCountArgs>(
      args?: Subset<T, AdminStrategyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminStrategyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminStrategy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminStrategyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminStrategyAggregateArgs>(args: Subset<T, AdminStrategyAggregateArgs>): Prisma.PrismaPromise<GetAdminStrategyAggregateType<T>>

    /**
     * Group by AdminStrategy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminStrategyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminStrategyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminStrategyGroupByArgs['orderBy'] }
        : { orderBy?: AdminStrategyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminStrategyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminStrategyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminStrategy model
   */
  readonly fields: AdminStrategyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminStrategy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminStrategyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    hazardStrategies<T extends AdminStrategy$hazardStrategiesArgs<ExtArgs> = {}>(args?: Subset<T, AdminStrategy$hazardStrategiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminHazardStrategyPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminStrategy model
   */ 
  interface AdminStrategyFieldRefs {
    readonly id: FieldRef<"AdminStrategy", 'String'>
    readonly strategyId: FieldRef<"AdminStrategy", 'String'>
    readonly title: FieldRef<"AdminStrategy", 'String'>
    readonly description: FieldRef<"AdminStrategy", 'String'>
    readonly category: FieldRef<"AdminStrategy", 'String'>
    readonly reasoning: FieldRef<"AdminStrategy", 'String'>
    readonly icon: FieldRef<"AdminStrategy", 'String'>
    readonly isActive: FieldRef<"AdminStrategy", 'Boolean'>
    readonly createdAt: FieldRef<"AdminStrategy", 'DateTime'>
    readonly updatedAt: FieldRef<"AdminStrategy", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdminStrategy findUnique
   */
  export type AdminStrategyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminStrategy
     */
    select?: AdminStrategySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminStrategyInclude<ExtArgs> | null
    /**
     * Filter, which AdminStrategy to fetch.
     */
    where: AdminStrategyWhereUniqueInput
  }

  /**
   * AdminStrategy findUniqueOrThrow
   */
  export type AdminStrategyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminStrategy
     */
    select?: AdminStrategySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminStrategyInclude<ExtArgs> | null
    /**
     * Filter, which AdminStrategy to fetch.
     */
    where: AdminStrategyWhereUniqueInput
  }

  /**
   * AdminStrategy findFirst
   */
  export type AdminStrategyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminStrategy
     */
    select?: AdminStrategySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminStrategyInclude<ExtArgs> | null
    /**
     * Filter, which AdminStrategy to fetch.
     */
    where?: AdminStrategyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminStrategies to fetch.
     */
    orderBy?: AdminStrategyOrderByWithRelationInput | AdminStrategyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminStrategies.
     */
    cursor?: AdminStrategyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminStrategies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminStrategies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminStrategies.
     */
    distinct?: AdminStrategyScalarFieldEnum | AdminStrategyScalarFieldEnum[]
  }

  /**
   * AdminStrategy findFirstOrThrow
   */
  export type AdminStrategyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminStrategy
     */
    select?: AdminStrategySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminStrategyInclude<ExtArgs> | null
    /**
     * Filter, which AdminStrategy to fetch.
     */
    where?: AdminStrategyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminStrategies to fetch.
     */
    orderBy?: AdminStrategyOrderByWithRelationInput | AdminStrategyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminStrategies.
     */
    cursor?: AdminStrategyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminStrategies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminStrategies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminStrategies.
     */
    distinct?: AdminStrategyScalarFieldEnum | AdminStrategyScalarFieldEnum[]
  }

  /**
   * AdminStrategy findMany
   */
  export type AdminStrategyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminStrategy
     */
    select?: AdminStrategySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminStrategyInclude<ExtArgs> | null
    /**
     * Filter, which AdminStrategies to fetch.
     */
    where?: AdminStrategyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminStrategies to fetch.
     */
    orderBy?: AdminStrategyOrderByWithRelationInput | AdminStrategyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminStrategies.
     */
    cursor?: AdminStrategyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminStrategies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminStrategies.
     */
    skip?: number
    distinct?: AdminStrategyScalarFieldEnum | AdminStrategyScalarFieldEnum[]
  }

  /**
   * AdminStrategy create
   */
  export type AdminStrategyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminStrategy
     */
    select?: AdminStrategySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminStrategyInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminStrategy.
     */
    data: XOR<AdminStrategyCreateInput, AdminStrategyUncheckedCreateInput>
  }

  /**
   * AdminStrategy createMany
   */
  export type AdminStrategyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminStrategies.
     */
    data: AdminStrategyCreateManyInput | AdminStrategyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminStrategy createManyAndReturn
   */
  export type AdminStrategyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminStrategy
     */
    select?: AdminStrategySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AdminStrategies.
     */
    data: AdminStrategyCreateManyInput | AdminStrategyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminStrategy update
   */
  export type AdminStrategyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminStrategy
     */
    select?: AdminStrategySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminStrategyInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminStrategy.
     */
    data: XOR<AdminStrategyUpdateInput, AdminStrategyUncheckedUpdateInput>
    /**
     * Choose, which AdminStrategy to update.
     */
    where: AdminStrategyWhereUniqueInput
  }

  /**
   * AdminStrategy updateMany
   */
  export type AdminStrategyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminStrategies.
     */
    data: XOR<AdminStrategyUpdateManyMutationInput, AdminStrategyUncheckedUpdateManyInput>
    /**
     * Filter which AdminStrategies to update
     */
    where?: AdminStrategyWhereInput
  }

  /**
   * AdminStrategy upsert
   */
  export type AdminStrategyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminStrategy
     */
    select?: AdminStrategySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminStrategyInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminStrategy to update in case it exists.
     */
    where: AdminStrategyWhereUniqueInput
    /**
     * In case the AdminStrategy found by the `where` argument doesn't exist, create a new AdminStrategy with this data.
     */
    create: XOR<AdminStrategyCreateInput, AdminStrategyUncheckedCreateInput>
    /**
     * In case the AdminStrategy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminStrategyUpdateInput, AdminStrategyUncheckedUpdateInput>
  }

  /**
   * AdminStrategy delete
   */
  export type AdminStrategyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminStrategy
     */
    select?: AdminStrategySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminStrategyInclude<ExtArgs> | null
    /**
     * Filter which AdminStrategy to delete.
     */
    where: AdminStrategyWhereUniqueInput
  }

  /**
   * AdminStrategy deleteMany
   */
  export type AdminStrategyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminStrategies to delete
     */
    where?: AdminStrategyWhereInput
  }

  /**
   * AdminStrategy.hazardStrategies
   */
  export type AdminStrategy$hazardStrategiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminHazardStrategy
     */
    select?: AdminHazardStrategySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminHazardStrategyInclude<ExtArgs> | null
    where?: AdminHazardStrategyWhereInput
    orderBy?: AdminHazardStrategyOrderByWithRelationInput | AdminHazardStrategyOrderByWithRelationInput[]
    cursor?: AdminHazardStrategyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminHazardStrategyScalarFieldEnum | AdminHazardStrategyScalarFieldEnum[]
  }

  /**
   * AdminStrategy without action
   */
  export type AdminStrategyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminStrategy
     */
    select?: AdminStrategySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminStrategyInclude<ExtArgs> | null
  }


  /**
   * Model AdminHazardStrategy
   */

  export type AggregateAdminHazardStrategy = {
    _count: AdminHazardStrategyCountAggregateOutputType | null
    _min: AdminHazardStrategyMinAggregateOutputType | null
    _max: AdminHazardStrategyMaxAggregateOutputType | null
  }

  export type AdminHazardStrategyMinAggregateOutputType = {
    id: string | null
    hazardId: string | null
    strategyId: string | null
    businessTypes: string | null
    priority: string | null
    isRecommended: boolean | null
    notes: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminHazardStrategyMaxAggregateOutputType = {
    id: string | null
    hazardId: string | null
    strategyId: string | null
    businessTypes: string | null
    priority: string | null
    isRecommended: boolean | null
    notes: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminHazardStrategyCountAggregateOutputType = {
    id: number
    hazardId: number
    strategyId: number
    businessTypes: number
    priority: number
    isRecommended: number
    notes: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdminHazardStrategyMinAggregateInputType = {
    id?: true
    hazardId?: true
    strategyId?: true
    businessTypes?: true
    priority?: true
    isRecommended?: true
    notes?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminHazardStrategyMaxAggregateInputType = {
    id?: true
    hazardId?: true
    strategyId?: true
    businessTypes?: true
    priority?: true
    isRecommended?: true
    notes?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminHazardStrategyCountAggregateInputType = {
    id?: true
    hazardId?: true
    strategyId?: true
    businessTypes?: true
    priority?: true
    isRecommended?: true
    notes?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdminHazardStrategyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminHazardStrategy to aggregate.
     */
    where?: AdminHazardStrategyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminHazardStrategies to fetch.
     */
    orderBy?: AdminHazardStrategyOrderByWithRelationInput | AdminHazardStrategyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminHazardStrategyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminHazardStrategies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminHazardStrategies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminHazardStrategies
    **/
    _count?: true | AdminHazardStrategyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminHazardStrategyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminHazardStrategyMaxAggregateInputType
  }

  export type GetAdminHazardStrategyAggregateType<T extends AdminHazardStrategyAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminHazardStrategy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminHazardStrategy[P]>
      : GetScalarType<T[P], AggregateAdminHazardStrategy[P]>
  }




  export type AdminHazardStrategyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminHazardStrategyWhereInput
    orderBy?: AdminHazardStrategyOrderByWithAggregationInput | AdminHazardStrategyOrderByWithAggregationInput[]
    by: AdminHazardStrategyScalarFieldEnum[] | AdminHazardStrategyScalarFieldEnum
    having?: AdminHazardStrategyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminHazardStrategyCountAggregateInputType | true
    _min?: AdminHazardStrategyMinAggregateInputType
    _max?: AdminHazardStrategyMaxAggregateInputType
  }

  export type AdminHazardStrategyGroupByOutputType = {
    id: string
    hazardId: string
    strategyId: string
    businessTypes: string | null
    priority: string
    isRecommended: boolean
    notes: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: AdminHazardStrategyCountAggregateOutputType | null
    _min: AdminHazardStrategyMinAggregateOutputType | null
    _max: AdminHazardStrategyMaxAggregateOutputType | null
  }

  type GetAdminHazardStrategyGroupByPayload<T extends AdminHazardStrategyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminHazardStrategyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminHazardStrategyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminHazardStrategyGroupByOutputType[P]>
            : GetScalarType<T[P], AdminHazardStrategyGroupByOutputType[P]>
        }
      >
    >


  export type AdminHazardStrategySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hazardId?: boolean
    strategyId?: boolean
    businessTypes?: boolean
    priority?: boolean
    isRecommended?: boolean
    notes?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hazard?: boolean | AdminHazardTypeDefaultArgs<ExtArgs>
    strategy?: boolean | AdminStrategyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminHazardStrategy"]>

  export type AdminHazardStrategySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hazardId?: boolean
    strategyId?: boolean
    businessTypes?: boolean
    priority?: boolean
    isRecommended?: boolean
    notes?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hazard?: boolean | AdminHazardTypeDefaultArgs<ExtArgs>
    strategy?: boolean | AdminStrategyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminHazardStrategy"]>

  export type AdminHazardStrategySelectScalar = {
    id?: boolean
    hazardId?: boolean
    strategyId?: boolean
    businessTypes?: boolean
    priority?: boolean
    isRecommended?: boolean
    notes?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdminHazardStrategyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hazard?: boolean | AdminHazardTypeDefaultArgs<ExtArgs>
    strategy?: boolean | AdminStrategyDefaultArgs<ExtArgs>
  }
  export type AdminHazardStrategyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hazard?: boolean | AdminHazardTypeDefaultArgs<ExtArgs>
    strategy?: boolean | AdminStrategyDefaultArgs<ExtArgs>
  }

  export type $AdminHazardStrategyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminHazardStrategy"
    objects: {
      hazard: Prisma.$AdminHazardTypePayload<ExtArgs>
      strategy: Prisma.$AdminStrategyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      hazardId: string
      strategyId: string
      businessTypes: string | null
      priority: string
      isRecommended: boolean
      notes: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["adminHazardStrategy"]>
    composites: {}
  }

  type AdminHazardStrategyGetPayload<S extends boolean | null | undefined | AdminHazardStrategyDefaultArgs> = $Result.GetResult<Prisma.$AdminHazardStrategyPayload, S>

  type AdminHazardStrategyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdminHazardStrategyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdminHazardStrategyCountAggregateInputType | true
    }

  export interface AdminHazardStrategyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminHazardStrategy'], meta: { name: 'AdminHazardStrategy' } }
    /**
     * Find zero or one AdminHazardStrategy that matches the filter.
     * @param {AdminHazardStrategyFindUniqueArgs} args - Arguments to find a AdminHazardStrategy
     * @example
     * // Get one AdminHazardStrategy
     * const adminHazardStrategy = await prisma.adminHazardStrategy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminHazardStrategyFindUniqueArgs>(args: SelectSubset<T, AdminHazardStrategyFindUniqueArgs<ExtArgs>>): Prisma__AdminHazardStrategyClient<$Result.GetResult<Prisma.$AdminHazardStrategyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AdminHazardStrategy that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdminHazardStrategyFindUniqueOrThrowArgs} args - Arguments to find a AdminHazardStrategy
     * @example
     * // Get one AdminHazardStrategy
     * const adminHazardStrategy = await prisma.adminHazardStrategy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminHazardStrategyFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminHazardStrategyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminHazardStrategyClient<$Result.GetResult<Prisma.$AdminHazardStrategyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AdminHazardStrategy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminHazardStrategyFindFirstArgs} args - Arguments to find a AdminHazardStrategy
     * @example
     * // Get one AdminHazardStrategy
     * const adminHazardStrategy = await prisma.adminHazardStrategy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminHazardStrategyFindFirstArgs>(args?: SelectSubset<T, AdminHazardStrategyFindFirstArgs<ExtArgs>>): Prisma__AdminHazardStrategyClient<$Result.GetResult<Prisma.$AdminHazardStrategyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AdminHazardStrategy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminHazardStrategyFindFirstOrThrowArgs} args - Arguments to find a AdminHazardStrategy
     * @example
     * // Get one AdminHazardStrategy
     * const adminHazardStrategy = await prisma.adminHazardStrategy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminHazardStrategyFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminHazardStrategyFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminHazardStrategyClient<$Result.GetResult<Prisma.$AdminHazardStrategyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AdminHazardStrategies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminHazardStrategyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminHazardStrategies
     * const adminHazardStrategies = await prisma.adminHazardStrategy.findMany()
     * 
     * // Get first 10 AdminHazardStrategies
     * const adminHazardStrategies = await prisma.adminHazardStrategy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminHazardStrategyWithIdOnly = await prisma.adminHazardStrategy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminHazardStrategyFindManyArgs>(args?: SelectSubset<T, AdminHazardStrategyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminHazardStrategyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AdminHazardStrategy.
     * @param {AdminHazardStrategyCreateArgs} args - Arguments to create a AdminHazardStrategy.
     * @example
     * // Create one AdminHazardStrategy
     * const AdminHazardStrategy = await prisma.adminHazardStrategy.create({
     *   data: {
     *     // ... data to create a AdminHazardStrategy
     *   }
     * })
     * 
     */
    create<T extends AdminHazardStrategyCreateArgs>(args: SelectSubset<T, AdminHazardStrategyCreateArgs<ExtArgs>>): Prisma__AdminHazardStrategyClient<$Result.GetResult<Prisma.$AdminHazardStrategyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AdminHazardStrategies.
     * @param {AdminHazardStrategyCreateManyArgs} args - Arguments to create many AdminHazardStrategies.
     * @example
     * // Create many AdminHazardStrategies
     * const adminHazardStrategy = await prisma.adminHazardStrategy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminHazardStrategyCreateManyArgs>(args?: SelectSubset<T, AdminHazardStrategyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminHazardStrategies and returns the data saved in the database.
     * @param {AdminHazardStrategyCreateManyAndReturnArgs} args - Arguments to create many AdminHazardStrategies.
     * @example
     * // Create many AdminHazardStrategies
     * const adminHazardStrategy = await prisma.adminHazardStrategy.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminHazardStrategies and only return the `id`
     * const adminHazardStrategyWithIdOnly = await prisma.adminHazardStrategy.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminHazardStrategyCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminHazardStrategyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminHazardStrategyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AdminHazardStrategy.
     * @param {AdminHazardStrategyDeleteArgs} args - Arguments to delete one AdminHazardStrategy.
     * @example
     * // Delete one AdminHazardStrategy
     * const AdminHazardStrategy = await prisma.adminHazardStrategy.delete({
     *   where: {
     *     // ... filter to delete one AdminHazardStrategy
     *   }
     * })
     * 
     */
    delete<T extends AdminHazardStrategyDeleteArgs>(args: SelectSubset<T, AdminHazardStrategyDeleteArgs<ExtArgs>>): Prisma__AdminHazardStrategyClient<$Result.GetResult<Prisma.$AdminHazardStrategyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AdminHazardStrategy.
     * @param {AdminHazardStrategyUpdateArgs} args - Arguments to update one AdminHazardStrategy.
     * @example
     * // Update one AdminHazardStrategy
     * const adminHazardStrategy = await prisma.adminHazardStrategy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminHazardStrategyUpdateArgs>(args: SelectSubset<T, AdminHazardStrategyUpdateArgs<ExtArgs>>): Prisma__AdminHazardStrategyClient<$Result.GetResult<Prisma.$AdminHazardStrategyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AdminHazardStrategies.
     * @param {AdminHazardStrategyDeleteManyArgs} args - Arguments to filter AdminHazardStrategies to delete.
     * @example
     * // Delete a few AdminHazardStrategies
     * const { count } = await prisma.adminHazardStrategy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminHazardStrategyDeleteManyArgs>(args?: SelectSubset<T, AdminHazardStrategyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminHazardStrategies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminHazardStrategyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminHazardStrategies
     * const adminHazardStrategy = await prisma.adminHazardStrategy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminHazardStrategyUpdateManyArgs>(args: SelectSubset<T, AdminHazardStrategyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AdminHazardStrategy.
     * @param {AdminHazardStrategyUpsertArgs} args - Arguments to update or create a AdminHazardStrategy.
     * @example
     * // Update or create a AdminHazardStrategy
     * const adminHazardStrategy = await prisma.adminHazardStrategy.upsert({
     *   create: {
     *     // ... data to create a AdminHazardStrategy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminHazardStrategy we want to update
     *   }
     * })
     */
    upsert<T extends AdminHazardStrategyUpsertArgs>(args: SelectSubset<T, AdminHazardStrategyUpsertArgs<ExtArgs>>): Prisma__AdminHazardStrategyClient<$Result.GetResult<Prisma.$AdminHazardStrategyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AdminHazardStrategies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminHazardStrategyCountArgs} args - Arguments to filter AdminHazardStrategies to count.
     * @example
     * // Count the number of AdminHazardStrategies
     * const count = await prisma.adminHazardStrategy.count({
     *   where: {
     *     // ... the filter for the AdminHazardStrategies we want to count
     *   }
     * })
    **/
    count<T extends AdminHazardStrategyCountArgs>(
      args?: Subset<T, AdminHazardStrategyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminHazardStrategyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminHazardStrategy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminHazardStrategyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminHazardStrategyAggregateArgs>(args: Subset<T, AdminHazardStrategyAggregateArgs>): Prisma.PrismaPromise<GetAdminHazardStrategyAggregateType<T>>

    /**
     * Group by AdminHazardStrategy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminHazardStrategyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminHazardStrategyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminHazardStrategyGroupByArgs['orderBy'] }
        : { orderBy?: AdminHazardStrategyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminHazardStrategyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminHazardStrategyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminHazardStrategy model
   */
  readonly fields: AdminHazardStrategyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminHazardStrategy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminHazardStrategyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    hazard<T extends AdminHazardTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminHazardTypeDefaultArgs<ExtArgs>>): Prisma__AdminHazardTypeClient<$Result.GetResult<Prisma.$AdminHazardTypePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    strategy<T extends AdminStrategyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminStrategyDefaultArgs<ExtArgs>>): Prisma__AdminStrategyClient<$Result.GetResult<Prisma.$AdminStrategyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminHazardStrategy model
   */ 
  interface AdminHazardStrategyFieldRefs {
    readonly id: FieldRef<"AdminHazardStrategy", 'String'>
    readonly hazardId: FieldRef<"AdminHazardStrategy", 'String'>
    readonly strategyId: FieldRef<"AdminHazardStrategy", 'String'>
    readonly businessTypes: FieldRef<"AdminHazardStrategy", 'String'>
    readonly priority: FieldRef<"AdminHazardStrategy", 'String'>
    readonly isRecommended: FieldRef<"AdminHazardStrategy", 'Boolean'>
    readonly notes: FieldRef<"AdminHazardStrategy", 'String'>
    readonly isActive: FieldRef<"AdminHazardStrategy", 'Boolean'>
    readonly createdAt: FieldRef<"AdminHazardStrategy", 'DateTime'>
    readonly updatedAt: FieldRef<"AdminHazardStrategy", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdminHazardStrategy findUnique
   */
  export type AdminHazardStrategyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminHazardStrategy
     */
    select?: AdminHazardStrategySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminHazardStrategyInclude<ExtArgs> | null
    /**
     * Filter, which AdminHazardStrategy to fetch.
     */
    where: AdminHazardStrategyWhereUniqueInput
  }

  /**
   * AdminHazardStrategy findUniqueOrThrow
   */
  export type AdminHazardStrategyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminHazardStrategy
     */
    select?: AdminHazardStrategySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminHazardStrategyInclude<ExtArgs> | null
    /**
     * Filter, which AdminHazardStrategy to fetch.
     */
    where: AdminHazardStrategyWhereUniqueInput
  }

  /**
   * AdminHazardStrategy findFirst
   */
  export type AdminHazardStrategyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminHazardStrategy
     */
    select?: AdminHazardStrategySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminHazardStrategyInclude<ExtArgs> | null
    /**
     * Filter, which AdminHazardStrategy to fetch.
     */
    where?: AdminHazardStrategyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminHazardStrategies to fetch.
     */
    orderBy?: AdminHazardStrategyOrderByWithRelationInput | AdminHazardStrategyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminHazardStrategies.
     */
    cursor?: AdminHazardStrategyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminHazardStrategies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminHazardStrategies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminHazardStrategies.
     */
    distinct?: AdminHazardStrategyScalarFieldEnum | AdminHazardStrategyScalarFieldEnum[]
  }

  /**
   * AdminHazardStrategy findFirstOrThrow
   */
  export type AdminHazardStrategyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminHazardStrategy
     */
    select?: AdminHazardStrategySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminHazardStrategyInclude<ExtArgs> | null
    /**
     * Filter, which AdminHazardStrategy to fetch.
     */
    where?: AdminHazardStrategyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminHazardStrategies to fetch.
     */
    orderBy?: AdminHazardStrategyOrderByWithRelationInput | AdminHazardStrategyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminHazardStrategies.
     */
    cursor?: AdminHazardStrategyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminHazardStrategies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminHazardStrategies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminHazardStrategies.
     */
    distinct?: AdminHazardStrategyScalarFieldEnum | AdminHazardStrategyScalarFieldEnum[]
  }

  /**
   * AdminHazardStrategy findMany
   */
  export type AdminHazardStrategyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminHazardStrategy
     */
    select?: AdminHazardStrategySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminHazardStrategyInclude<ExtArgs> | null
    /**
     * Filter, which AdminHazardStrategies to fetch.
     */
    where?: AdminHazardStrategyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminHazardStrategies to fetch.
     */
    orderBy?: AdminHazardStrategyOrderByWithRelationInput | AdminHazardStrategyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminHazardStrategies.
     */
    cursor?: AdminHazardStrategyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminHazardStrategies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminHazardStrategies.
     */
    skip?: number
    distinct?: AdminHazardStrategyScalarFieldEnum | AdminHazardStrategyScalarFieldEnum[]
  }

  /**
   * AdminHazardStrategy create
   */
  export type AdminHazardStrategyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminHazardStrategy
     */
    select?: AdminHazardStrategySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminHazardStrategyInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminHazardStrategy.
     */
    data: XOR<AdminHazardStrategyCreateInput, AdminHazardStrategyUncheckedCreateInput>
  }

  /**
   * AdminHazardStrategy createMany
   */
  export type AdminHazardStrategyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminHazardStrategies.
     */
    data: AdminHazardStrategyCreateManyInput | AdminHazardStrategyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminHazardStrategy createManyAndReturn
   */
  export type AdminHazardStrategyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminHazardStrategy
     */
    select?: AdminHazardStrategySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AdminHazardStrategies.
     */
    data: AdminHazardStrategyCreateManyInput | AdminHazardStrategyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminHazardStrategyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminHazardStrategy update
   */
  export type AdminHazardStrategyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminHazardStrategy
     */
    select?: AdminHazardStrategySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminHazardStrategyInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminHazardStrategy.
     */
    data: XOR<AdminHazardStrategyUpdateInput, AdminHazardStrategyUncheckedUpdateInput>
    /**
     * Choose, which AdminHazardStrategy to update.
     */
    where: AdminHazardStrategyWhereUniqueInput
  }

  /**
   * AdminHazardStrategy updateMany
   */
  export type AdminHazardStrategyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminHazardStrategies.
     */
    data: XOR<AdminHazardStrategyUpdateManyMutationInput, AdminHazardStrategyUncheckedUpdateManyInput>
    /**
     * Filter which AdminHazardStrategies to update
     */
    where?: AdminHazardStrategyWhereInput
  }

  /**
   * AdminHazardStrategy upsert
   */
  export type AdminHazardStrategyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminHazardStrategy
     */
    select?: AdminHazardStrategySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminHazardStrategyInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminHazardStrategy to update in case it exists.
     */
    where: AdminHazardStrategyWhereUniqueInput
    /**
     * In case the AdminHazardStrategy found by the `where` argument doesn't exist, create a new AdminHazardStrategy with this data.
     */
    create: XOR<AdminHazardStrategyCreateInput, AdminHazardStrategyUncheckedCreateInput>
    /**
     * In case the AdminHazardStrategy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminHazardStrategyUpdateInput, AdminHazardStrategyUncheckedUpdateInput>
  }

  /**
   * AdminHazardStrategy delete
   */
  export type AdminHazardStrategyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminHazardStrategy
     */
    select?: AdminHazardStrategySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminHazardStrategyInclude<ExtArgs> | null
    /**
     * Filter which AdminHazardStrategy to delete.
     */
    where: AdminHazardStrategyWhereUniqueInput
  }

  /**
   * AdminHazardStrategy deleteMany
   */
  export type AdminHazardStrategyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminHazardStrategies to delete
     */
    where?: AdminHazardStrategyWhereInput
  }

  /**
   * AdminHazardStrategy without action
   */
  export type AdminHazardStrategyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminHazardStrategy
     */
    select?: AdminHazardStrategySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminHazardStrategyInclude<ExtArgs> | null
  }


  /**
   * Model AdminActionPlan
   */

  export type AggregateAdminActionPlan = {
    _count: AdminActionPlanCountAggregateOutputType | null
    _min: AdminActionPlanMinAggregateOutputType | null
    _max: AdminActionPlanMaxAggregateOutputType | null
  }

  export type AdminActionPlanMinAggregateOutputType = {
    id: string | null
    hazardId: string | null
    resourcesNeeded: string | null
    immediateActions: string | null
    shortTermActions: string | null
    mediumTermActions: string | null
    longTermReduction: string | null
    businessTypeModifiers: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminActionPlanMaxAggregateOutputType = {
    id: string | null
    hazardId: string | null
    resourcesNeeded: string | null
    immediateActions: string | null
    shortTermActions: string | null
    mediumTermActions: string | null
    longTermReduction: string | null
    businessTypeModifiers: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminActionPlanCountAggregateOutputType = {
    id: number
    hazardId: number
    resourcesNeeded: number
    immediateActions: number
    shortTermActions: number
    mediumTermActions: number
    longTermReduction: number
    businessTypeModifiers: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdminActionPlanMinAggregateInputType = {
    id?: true
    hazardId?: true
    resourcesNeeded?: true
    immediateActions?: true
    shortTermActions?: true
    mediumTermActions?: true
    longTermReduction?: true
    businessTypeModifiers?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminActionPlanMaxAggregateInputType = {
    id?: true
    hazardId?: true
    resourcesNeeded?: true
    immediateActions?: true
    shortTermActions?: true
    mediumTermActions?: true
    longTermReduction?: true
    businessTypeModifiers?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminActionPlanCountAggregateInputType = {
    id?: true
    hazardId?: true
    resourcesNeeded?: true
    immediateActions?: true
    shortTermActions?: true
    mediumTermActions?: true
    longTermReduction?: true
    businessTypeModifiers?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdminActionPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminActionPlan to aggregate.
     */
    where?: AdminActionPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminActionPlans to fetch.
     */
    orderBy?: AdminActionPlanOrderByWithRelationInput | AdminActionPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminActionPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminActionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminActionPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminActionPlans
    **/
    _count?: true | AdminActionPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminActionPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminActionPlanMaxAggregateInputType
  }

  export type GetAdminActionPlanAggregateType<T extends AdminActionPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminActionPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminActionPlan[P]>
      : GetScalarType<T[P], AggregateAdminActionPlan[P]>
  }




  export type AdminActionPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminActionPlanWhereInput
    orderBy?: AdminActionPlanOrderByWithAggregationInput | AdminActionPlanOrderByWithAggregationInput[]
    by: AdminActionPlanScalarFieldEnum[] | AdminActionPlanScalarFieldEnum
    having?: AdminActionPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminActionPlanCountAggregateInputType | true
    _min?: AdminActionPlanMinAggregateInputType
    _max?: AdminActionPlanMaxAggregateInputType
  }

  export type AdminActionPlanGroupByOutputType = {
    id: string
    hazardId: string
    resourcesNeeded: string
    immediateActions: string
    shortTermActions: string
    mediumTermActions: string
    longTermReduction: string
    businessTypeModifiers: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: AdminActionPlanCountAggregateOutputType | null
    _min: AdminActionPlanMinAggregateOutputType | null
    _max: AdminActionPlanMaxAggregateOutputType | null
  }

  type GetAdminActionPlanGroupByPayload<T extends AdminActionPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminActionPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminActionPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminActionPlanGroupByOutputType[P]>
            : GetScalarType<T[P], AdminActionPlanGroupByOutputType[P]>
        }
      >
    >


  export type AdminActionPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hazardId?: boolean
    resourcesNeeded?: boolean
    immediateActions?: boolean
    shortTermActions?: boolean
    mediumTermActions?: boolean
    longTermReduction?: boolean
    businessTypeModifiers?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hazard?: boolean | AdminHazardTypeDefaultArgs<ExtArgs>
    AdminHazardActionPlan?: boolean | AdminActionPlan$AdminHazardActionPlanArgs<ExtArgs>
    _count?: boolean | AdminActionPlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminActionPlan"]>

  export type AdminActionPlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hazardId?: boolean
    resourcesNeeded?: boolean
    immediateActions?: boolean
    shortTermActions?: boolean
    mediumTermActions?: boolean
    longTermReduction?: boolean
    businessTypeModifiers?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hazard?: boolean | AdminHazardTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminActionPlan"]>

  export type AdminActionPlanSelectScalar = {
    id?: boolean
    hazardId?: boolean
    resourcesNeeded?: boolean
    immediateActions?: boolean
    shortTermActions?: boolean
    mediumTermActions?: boolean
    longTermReduction?: boolean
    businessTypeModifiers?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdminActionPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hazard?: boolean | AdminHazardTypeDefaultArgs<ExtArgs>
    AdminHazardActionPlan?: boolean | AdminActionPlan$AdminHazardActionPlanArgs<ExtArgs>
    _count?: boolean | AdminActionPlanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AdminActionPlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hazard?: boolean | AdminHazardTypeDefaultArgs<ExtArgs>
  }

  export type $AdminActionPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminActionPlan"
    objects: {
      hazard: Prisma.$AdminHazardTypePayload<ExtArgs>
      AdminHazardActionPlan: Prisma.$AdminHazardActionPlanPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      hazardId: string
      resourcesNeeded: string
      immediateActions: string
      shortTermActions: string
      mediumTermActions: string
      longTermReduction: string
      businessTypeModifiers: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["adminActionPlan"]>
    composites: {}
  }

  type AdminActionPlanGetPayload<S extends boolean | null | undefined | AdminActionPlanDefaultArgs> = $Result.GetResult<Prisma.$AdminActionPlanPayload, S>

  type AdminActionPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdminActionPlanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdminActionPlanCountAggregateInputType | true
    }

  export interface AdminActionPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminActionPlan'], meta: { name: 'AdminActionPlan' } }
    /**
     * Find zero or one AdminActionPlan that matches the filter.
     * @param {AdminActionPlanFindUniqueArgs} args - Arguments to find a AdminActionPlan
     * @example
     * // Get one AdminActionPlan
     * const adminActionPlan = await prisma.adminActionPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminActionPlanFindUniqueArgs>(args: SelectSubset<T, AdminActionPlanFindUniqueArgs<ExtArgs>>): Prisma__AdminActionPlanClient<$Result.GetResult<Prisma.$AdminActionPlanPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AdminActionPlan that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdminActionPlanFindUniqueOrThrowArgs} args - Arguments to find a AdminActionPlan
     * @example
     * // Get one AdminActionPlan
     * const adminActionPlan = await prisma.adminActionPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminActionPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminActionPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminActionPlanClient<$Result.GetResult<Prisma.$AdminActionPlanPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AdminActionPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminActionPlanFindFirstArgs} args - Arguments to find a AdminActionPlan
     * @example
     * // Get one AdminActionPlan
     * const adminActionPlan = await prisma.adminActionPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminActionPlanFindFirstArgs>(args?: SelectSubset<T, AdminActionPlanFindFirstArgs<ExtArgs>>): Prisma__AdminActionPlanClient<$Result.GetResult<Prisma.$AdminActionPlanPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AdminActionPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminActionPlanFindFirstOrThrowArgs} args - Arguments to find a AdminActionPlan
     * @example
     * // Get one AdminActionPlan
     * const adminActionPlan = await prisma.adminActionPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminActionPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminActionPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminActionPlanClient<$Result.GetResult<Prisma.$AdminActionPlanPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AdminActionPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminActionPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminActionPlans
     * const adminActionPlans = await prisma.adminActionPlan.findMany()
     * 
     * // Get first 10 AdminActionPlans
     * const adminActionPlans = await prisma.adminActionPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminActionPlanWithIdOnly = await prisma.adminActionPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminActionPlanFindManyArgs>(args?: SelectSubset<T, AdminActionPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminActionPlanPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AdminActionPlan.
     * @param {AdminActionPlanCreateArgs} args - Arguments to create a AdminActionPlan.
     * @example
     * // Create one AdminActionPlan
     * const AdminActionPlan = await prisma.adminActionPlan.create({
     *   data: {
     *     // ... data to create a AdminActionPlan
     *   }
     * })
     * 
     */
    create<T extends AdminActionPlanCreateArgs>(args: SelectSubset<T, AdminActionPlanCreateArgs<ExtArgs>>): Prisma__AdminActionPlanClient<$Result.GetResult<Prisma.$AdminActionPlanPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AdminActionPlans.
     * @param {AdminActionPlanCreateManyArgs} args - Arguments to create many AdminActionPlans.
     * @example
     * // Create many AdminActionPlans
     * const adminActionPlan = await prisma.adminActionPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminActionPlanCreateManyArgs>(args?: SelectSubset<T, AdminActionPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminActionPlans and returns the data saved in the database.
     * @param {AdminActionPlanCreateManyAndReturnArgs} args - Arguments to create many AdminActionPlans.
     * @example
     * // Create many AdminActionPlans
     * const adminActionPlan = await prisma.adminActionPlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminActionPlans and only return the `id`
     * const adminActionPlanWithIdOnly = await prisma.adminActionPlan.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminActionPlanCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminActionPlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminActionPlanPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AdminActionPlan.
     * @param {AdminActionPlanDeleteArgs} args - Arguments to delete one AdminActionPlan.
     * @example
     * // Delete one AdminActionPlan
     * const AdminActionPlan = await prisma.adminActionPlan.delete({
     *   where: {
     *     // ... filter to delete one AdminActionPlan
     *   }
     * })
     * 
     */
    delete<T extends AdminActionPlanDeleteArgs>(args: SelectSubset<T, AdminActionPlanDeleteArgs<ExtArgs>>): Prisma__AdminActionPlanClient<$Result.GetResult<Prisma.$AdminActionPlanPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AdminActionPlan.
     * @param {AdminActionPlanUpdateArgs} args - Arguments to update one AdminActionPlan.
     * @example
     * // Update one AdminActionPlan
     * const adminActionPlan = await prisma.adminActionPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminActionPlanUpdateArgs>(args: SelectSubset<T, AdminActionPlanUpdateArgs<ExtArgs>>): Prisma__AdminActionPlanClient<$Result.GetResult<Prisma.$AdminActionPlanPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AdminActionPlans.
     * @param {AdminActionPlanDeleteManyArgs} args - Arguments to filter AdminActionPlans to delete.
     * @example
     * // Delete a few AdminActionPlans
     * const { count } = await prisma.adminActionPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminActionPlanDeleteManyArgs>(args?: SelectSubset<T, AdminActionPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminActionPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminActionPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminActionPlans
     * const adminActionPlan = await prisma.adminActionPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminActionPlanUpdateManyArgs>(args: SelectSubset<T, AdminActionPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AdminActionPlan.
     * @param {AdminActionPlanUpsertArgs} args - Arguments to update or create a AdminActionPlan.
     * @example
     * // Update or create a AdminActionPlan
     * const adminActionPlan = await prisma.adminActionPlan.upsert({
     *   create: {
     *     // ... data to create a AdminActionPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminActionPlan we want to update
     *   }
     * })
     */
    upsert<T extends AdminActionPlanUpsertArgs>(args: SelectSubset<T, AdminActionPlanUpsertArgs<ExtArgs>>): Prisma__AdminActionPlanClient<$Result.GetResult<Prisma.$AdminActionPlanPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AdminActionPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminActionPlanCountArgs} args - Arguments to filter AdminActionPlans to count.
     * @example
     * // Count the number of AdminActionPlans
     * const count = await prisma.adminActionPlan.count({
     *   where: {
     *     // ... the filter for the AdminActionPlans we want to count
     *   }
     * })
    **/
    count<T extends AdminActionPlanCountArgs>(
      args?: Subset<T, AdminActionPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminActionPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminActionPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminActionPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminActionPlanAggregateArgs>(args: Subset<T, AdminActionPlanAggregateArgs>): Prisma.PrismaPromise<GetAdminActionPlanAggregateType<T>>

    /**
     * Group by AdminActionPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminActionPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminActionPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminActionPlanGroupByArgs['orderBy'] }
        : { orderBy?: AdminActionPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminActionPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminActionPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminActionPlan model
   */
  readonly fields: AdminActionPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminActionPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminActionPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    hazard<T extends AdminHazardTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminHazardTypeDefaultArgs<ExtArgs>>): Prisma__AdminHazardTypeClient<$Result.GetResult<Prisma.$AdminHazardTypePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    AdminHazardActionPlan<T extends AdminActionPlan$AdminHazardActionPlanArgs<ExtArgs> = {}>(args?: Subset<T, AdminActionPlan$AdminHazardActionPlanArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminHazardActionPlanPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminActionPlan model
   */ 
  interface AdminActionPlanFieldRefs {
    readonly id: FieldRef<"AdminActionPlan", 'String'>
    readonly hazardId: FieldRef<"AdminActionPlan", 'String'>
    readonly resourcesNeeded: FieldRef<"AdminActionPlan", 'String'>
    readonly immediateActions: FieldRef<"AdminActionPlan", 'String'>
    readonly shortTermActions: FieldRef<"AdminActionPlan", 'String'>
    readonly mediumTermActions: FieldRef<"AdminActionPlan", 'String'>
    readonly longTermReduction: FieldRef<"AdminActionPlan", 'String'>
    readonly businessTypeModifiers: FieldRef<"AdminActionPlan", 'String'>
    readonly isActive: FieldRef<"AdminActionPlan", 'Boolean'>
    readonly createdAt: FieldRef<"AdminActionPlan", 'DateTime'>
    readonly updatedAt: FieldRef<"AdminActionPlan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdminActionPlan findUnique
   */
  export type AdminActionPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminActionPlan
     */
    select?: AdminActionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActionPlanInclude<ExtArgs> | null
    /**
     * Filter, which AdminActionPlan to fetch.
     */
    where: AdminActionPlanWhereUniqueInput
  }

  /**
   * AdminActionPlan findUniqueOrThrow
   */
  export type AdminActionPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminActionPlan
     */
    select?: AdminActionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActionPlanInclude<ExtArgs> | null
    /**
     * Filter, which AdminActionPlan to fetch.
     */
    where: AdminActionPlanWhereUniqueInput
  }

  /**
   * AdminActionPlan findFirst
   */
  export type AdminActionPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminActionPlan
     */
    select?: AdminActionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActionPlanInclude<ExtArgs> | null
    /**
     * Filter, which AdminActionPlan to fetch.
     */
    where?: AdminActionPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminActionPlans to fetch.
     */
    orderBy?: AdminActionPlanOrderByWithRelationInput | AdminActionPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminActionPlans.
     */
    cursor?: AdminActionPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminActionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminActionPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminActionPlans.
     */
    distinct?: AdminActionPlanScalarFieldEnum | AdminActionPlanScalarFieldEnum[]
  }

  /**
   * AdminActionPlan findFirstOrThrow
   */
  export type AdminActionPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminActionPlan
     */
    select?: AdminActionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActionPlanInclude<ExtArgs> | null
    /**
     * Filter, which AdminActionPlan to fetch.
     */
    where?: AdminActionPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminActionPlans to fetch.
     */
    orderBy?: AdminActionPlanOrderByWithRelationInput | AdminActionPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminActionPlans.
     */
    cursor?: AdminActionPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminActionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminActionPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminActionPlans.
     */
    distinct?: AdminActionPlanScalarFieldEnum | AdminActionPlanScalarFieldEnum[]
  }

  /**
   * AdminActionPlan findMany
   */
  export type AdminActionPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminActionPlan
     */
    select?: AdminActionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActionPlanInclude<ExtArgs> | null
    /**
     * Filter, which AdminActionPlans to fetch.
     */
    where?: AdminActionPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminActionPlans to fetch.
     */
    orderBy?: AdminActionPlanOrderByWithRelationInput | AdminActionPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminActionPlans.
     */
    cursor?: AdminActionPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminActionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminActionPlans.
     */
    skip?: number
    distinct?: AdminActionPlanScalarFieldEnum | AdminActionPlanScalarFieldEnum[]
  }

  /**
   * AdminActionPlan create
   */
  export type AdminActionPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminActionPlan
     */
    select?: AdminActionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActionPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminActionPlan.
     */
    data: XOR<AdminActionPlanCreateInput, AdminActionPlanUncheckedCreateInput>
  }

  /**
   * AdminActionPlan createMany
   */
  export type AdminActionPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminActionPlans.
     */
    data: AdminActionPlanCreateManyInput | AdminActionPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminActionPlan createManyAndReturn
   */
  export type AdminActionPlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminActionPlan
     */
    select?: AdminActionPlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AdminActionPlans.
     */
    data: AdminActionPlanCreateManyInput | AdminActionPlanCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActionPlanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminActionPlan update
   */
  export type AdminActionPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminActionPlan
     */
    select?: AdminActionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActionPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminActionPlan.
     */
    data: XOR<AdminActionPlanUpdateInput, AdminActionPlanUncheckedUpdateInput>
    /**
     * Choose, which AdminActionPlan to update.
     */
    where: AdminActionPlanWhereUniqueInput
  }

  /**
   * AdminActionPlan updateMany
   */
  export type AdminActionPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminActionPlans.
     */
    data: XOR<AdminActionPlanUpdateManyMutationInput, AdminActionPlanUncheckedUpdateManyInput>
    /**
     * Filter which AdminActionPlans to update
     */
    where?: AdminActionPlanWhereInput
  }

  /**
   * AdminActionPlan upsert
   */
  export type AdminActionPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminActionPlan
     */
    select?: AdminActionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActionPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminActionPlan to update in case it exists.
     */
    where: AdminActionPlanWhereUniqueInput
    /**
     * In case the AdminActionPlan found by the `where` argument doesn't exist, create a new AdminActionPlan with this data.
     */
    create: XOR<AdminActionPlanCreateInput, AdminActionPlanUncheckedCreateInput>
    /**
     * In case the AdminActionPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminActionPlanUpdateInput, AdminActionPlanUncheckedUpdateInput>
  }

  /**
   * AdminActionPlan delete
   */
  export type AdminActionPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminActionPlan
     */
    select?: AdminActionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActionPlanInclude<ExtArgs> | null
    /**
     * Filter which AdminActionPlan to delete.
     */
    where: AdminActionPlanWhereUniqueInput
  }

  /**
   * AdminActionPlan deleteMany
   */
  export type AdminActionPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminActionPlans to delete
     */
    where?: AdminActionPlanWhereInput
  }

  /**
   * AdminActionPlan.AdminHazardActionPlan
   */
  export type AdminActionPlan$AdminHazardActionPlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminHazardActionPlan
     */
    select?: AdminHazardActionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminHazardActionPlanInclude<ExtArgs> | null
    where?: AdminHazardActionPlanWhereInput
    orderBy?: AdminHazardActionPlanOrderByWithRelationInput | AdminHazardActionPlanOrderByWithRelationInput[]
    cursor?: AdminHazardActionPlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminHazardActionPlanScalarFieldEnum | AdminHazardActionPlanScalarFieldEnum[]
  }

  /**
   * AdminActionPlan without action
   */
  export type AdminActionPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminActionPlan
     */
    select?: AdminActionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActionPlanInclude<ExtArgs> | null
  }


  /**
   * Model AdminHazardActionPlan
   */

  export type AggregateAdminHazardActionPlan = {
    _count: AdminHazardActionPlanCountAggregateOutputType | null
    _min: AdminHazardActionPlanMinAggregateOutputType | null
    _max: AdminHazardActionPlanMaxAggregateOutputType | null
  }

  export type AdminHazardActionPlanMinAggregateOutputType = {
    id: string | null
    hazardId: string | null
    actionPlanId: string | null
    businessTypes: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminHazardActionPlanMaxAggregateOutputType = {
    id: string | null
    hazardId: string | null
    actionPlanId: string | null
    businessTypes: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminHazardActionPlanCountAggregateOutputType = {
    id: number
    hazardId: number
    actionPlanId: number
    businessTypes: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdminHazardActionPlanMinAggregateInputType = {
    id?: true
    hazardId?: true
    actionPlanId?: true
    businessTypes?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminHazardActionPlanMaxAggregateInputType = {
    id?: true
    hazardId?: true
    actionPlanId?: true
    businessTypes?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminHazardActionPlanCountAggregateInputType = {
    id?: true
    hazardId?: true
    actionPlanId?: true
    businessTypes?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdminHazardActionPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminHazardActionPlan to aggregate.
     */
    where?: AdminHazardActionPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminHazardActionPlans to fetch.
     */
    orderBy?: AdminHazardActionPlanOrderByWithRelationInput | AdminHazardActionPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminHazardActionPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminHazardActionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminHazardActionPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminHazardActionPlans
    **/
    _count?: true | AdminHazardActionPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminHazardActionPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminHazardActionPlanMaxAggregateInputType
  }

  export type GetAdminHazardActionPlanAggregateType<T extends AdminHazardActionPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminHazardActionPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminHazardActionPlan[P]>
      : GetScalarType<T[P], AggregateAdminHazardActionPlan[P]>
  }




  export type AdminHazardActionPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminHazardActionPlanWhereInput
    orderBy?: AdminHazardActionPlanOrderByWithAggregationInput | AdminHazardActionPlanOrderByWithAggregationInput[]
    by: AdminHazardActionPlanScalarFieldEnum[] | AdminHazardActionPlanScalarFieldEnum
    having?: AdminHazardActionPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminHazardActionPlanCountAggregateInputType | true
    _min?: AdminHazardActionPlanMinAggregateInputType
    _max?: AdminHazardActionPlanMaxAggregateInputType
  }

  export type AdminHazardActionPlanGroupByOutputType = {
    id: string
    hazardId: string
    actionPlanId: string
    businessTypes: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: AdminHazardActionPlanCountAggregateOutputType | null
    _min: AdminHazardActionPlanMinAggregateOutputType | null
    _max: AdminHazardActionPlanMaxAggregateOutputType | null
  }

  type GetAdminHazardActionPlanGroupByPayload<T extends AdminHazardActionPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminHazardActionPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminHazardActionPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminHazardActionPlanGroupByOutputType[P]>
            : GetScalarType<T[P], AdminHazardActionPlanGroupByOutputType[P]>
        }
      >
    >


  export type AdminHazardActionPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hazardId?: boolean
    actionPlanId?: boolean
    businessTypes?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hazard?: boolean | AdminHazardTypeDefaultArgs<ExtArgs>
    actionPlan?: boolean | AdminActionPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminHazardActionPlan"]>

  export type AdminHazardActionPlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hazardId?: boolean
    actionPlanId?: boolean
    businessTypes?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hazard?: boolean | AdminHazardTypeDefaultArgs<ExtArgs>
    actionPlan?: boolean | AdminActionPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminHazardActionPlan"]>

  export type AdminHazardActionPlanSelectScalar = {
    id?: boolean
    hazardId?: boolean
    actionPlanId?: boolean
    businessTypes?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdminHazardActionPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hazard?: boolean | AdminHazardTypeDefaultArgs<ExtArgs>
    actionPlan?: boolean | AdminActionPlanDefaultArgs<ExtArgs>
  }
  export type AdminHazardActionPlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hazard?: boolean | AdminHazardTypeDefaultArgs<ExtArgs>
    actionPlan?: boolean | AdminActionPlanDefaultArgs<ExtArgs>
  }

  export type $AdminHazardActionPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminHazardActionPlan"
    objects: {
      hazard: Prisma.$AdminHazardTypePayload<ExtArgs>
      actionPlan: Prisma.$AdminActionPlanPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      hazardId: string
      actionPlanId: string
      businessTypes: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["adminHazardActionPlan"]>
    composites: {}
  }

  type AdminHazardActionPlanGetPayload<S extends boolean | null | undefined | AdminHazardActionPlanDefaultArgs> = $Result.GetResult<Prisma.$AdminHazardActionPlanPayload, S>

  type AdminHazardActionPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdminHazardActionPlanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdminHazardActionPlanCountAggregateInputType | true
    }

  export interface AdminHazardActionPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminHazardActionPlan'], meta: { name: 'AdminHazardActionPlan' } }
    /**
     * Find zero or one AdminHazardActionPlan that matches the filter.
     * @param {AdminHazardActionPlanFindUniqueArgs} args - Arguments to find a AdminHazardActionPlan
     * @example
     * // Get one AdminHazardActionPlan
     * const adminHazardActionPlan = await prisma.adminHazardActionPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminHazardActionPlanFindUniqueArgs>(args: SelectSubset<T, AdminHazardActionPlanFindUniqueArgs<ExtArgs>>): Prisma__AdminHazardActionPlanClient<$Result.GetResult<Prisma.$AdminHazardActionPlanPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AdminHazardActionPlan that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdminHazardActionPlanFindUniqueOrThrowArgs} args - Arguments to find a AdminHazardActionPlan
     * @example
     * // Get one AdminHazardActionPlan
     * const adminHazardActionPlan = await prisma.adminHazardActionPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminHazardActionPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminHazardActionPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminHazardActionPlanClient<$Result.GetResult<Prisma.$AdminHazardActionPlanPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AdminHazardActionPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminHazardActionPlanFindFirstArgs} args - Arguments to find a AdminHazardActionPlan
     * @example
     * // Get one AdminHazardActionPlan
     * const adminHazardActionPlan = await prisma.adminHazardActionPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminHazardActionPlanFindFirstArgs>(args?: SelectSubset<T, AdminHazardActionPlanFindFirstArgs<ExtArgs>>): Prisma__AdminHazardActionPlanClient<$Result.GetResult<Prisma.$AdminHazardActionPlanPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AdminHazardActionPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminHazardActionPlanFindFirstOrThrowArgs} args - Arguments to find a AdminHazardActionPlan
     * @example
     * // Get one AdminHazardActionPlan
     * const adminHazardActionPlan = await prisma.adminHazardActionPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminHazardActionPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminHazardActionPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminHazardActionPlanClient<$Result.GetResult<Prisma.$AdminHazardActionPlanPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AdminHazardActionPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminHazardActionPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminHazardActionPlans
     * const adminHazardActionPlans = await prisma.adminHazardActionPlan.findMany()
     * 
     * // Get first 10 AdminHazardActionPlans
     * const adminHazardActionPlans = await prisma.adminHazardActionPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminHazardActionPlanWithIdOnly = await prisma.adminHazardActionPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminHazardActionPlanFindManyArgs>(args?: SelectSubset<T, AdminHazardActionPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminHazardActionPlanPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AdminHazardActionPlan.
     * @param {AdminHazardActionPlanCreateArgs} args - Arguments to create a AdminHazardActionPlan.
     * @example
     * // Create one AdminHazardActionPlan
     * const AdminHazardActionPlan = await prisma.adminHazardActionPlan.create({
     *   data: {
     *     // ... data to create a AdminHazardActionPlan
     *   }
     * })
     * 
     */
    create<T extends AdminHazardActionPlanCreateArgs>(args: SelectSubset<T, AdminHazardActionPlanCreateArgs<ExtArgs>>): Prisma__AdminHazardActionPlanClient<$Result.GetResult<Prisma.$AdminHazardActionPlanPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AdminHazardActionPlans.
     * @param {AdminHazardActionPlanCreateManyArgs} args - Arguments to create many AdminHazardActionPlans.
     * @example
     * // Create many AdminHazardActionPlans
     * const adminHazardActionPlan = await prisma.adminHazardActionPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminHazardActionPlanCreateManyArgs>(args?: SelectSubset<T, AdminHazardActionPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminHazardActionPlans and returns the data saved in the database.
     * @param {AdminHazardActionPlanCreateManyAndReturnArgs} args - Arguments to create many AdminHazardActionPlans.
     * @example
     * // Create many AdminHazardActionPlans
     * const adminHazardActionPlan = await prisma.adminHazardActionPlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminHazardActionPlans and only return the `id`
     * const adminHazardActionPlanWithIdOnly = await prisma.adminHazardActionPlan.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminHazardActionPlanCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminHazardActionPlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminHazardActionPlanPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AdminHazardActionPlan.
     * @param {AdminHazardActionPlanDeleteArgs} args - Arguments to delete one AdminHazardActionPlan.
     * @example
     * // Delete one AdminHazardActionPlan
     * const AdminHazardActionPlan = await prisma.adminHazardActionPlan.delete({
     *   where: {
     *     // ... filter to delete one AdminHazardActionPlan
     *   }
     * })
     * 
     */
    delete<T extends AdminHazardActionPlanDeleteArgs>(args: SelectSubset<T, AdminHazardActionPlanDeleteArgs<ExtArgs>>): Prisma__AdminHazardActionPlanClient<$Result.GetResult<Prisma.$AdminHazardActionPlanPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AdminHazardActionPlan.
     * @param {AdminHazardActionPlanUpdateArgs} args - Arguments to update one AdminHazardActionPlan.
     * @example
     * // Update one AdminHazardActionPlan
     * const adminHazardActionPlan = await prisma.adminHazardActionPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminHazardActionPlanUpdateArgs>(args: SelectSubset<T, AdminHazardActionPlanUpdateArgs<ExtArgs>>): Prisma__AdminHazardActionPlanClient<$Result.GetResult<Prisma.$AdminHazardActionPlanPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AdminHazardActionPlans.
     * @param {AdminHazardActionPlanDeleteManyArgs} args - Arguments to filter AdminHazardActionPlans to delete.
     * @example
     * // Delete a few AdminHazardActionPlans
     * const { count } = await prisma.adminHazardActionPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminHazardActionPlanDeleteManyArgs>(args?: SelectSubset<T, AdminHazardActionPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminHazardActionPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminHazardActionPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminHazardActionPlans
     * const adminHazardActionPlan = await prisma.adminHazardActionPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminHazardActionPlanUpdateManyArgs>(args: SelectSubset<T, AdminHazardActionPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AdminHazardActionPlan.
     * @param {AdminHazardActionPlanUpsertArgs} args - Arguments to update or create a AdminHazardActionPlan.
     * @example
     * // Update or create a AdminHazardActionPlan
     * const adminHazardActionPlan = await prisma.adminHazardActionPlan.upsert({
     *   create: {
     *     // ... data to create a AdminHazardActionPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminHazardActionPlan we want to update
     *   }
     * })
     */
    upsert<T extends AdminHazardActionPlanUpsertArgs>(args: SelectSubset<T, AdminHazardActionPlanUpsertArgs<ExtArgs>>): Prisma__AdminHazardActionPlanClient<$Result.GetResult<Prisma.$AdminHazardActionPlanPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AdminHazardActionPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminHazardActionPlanCountArgs} args - Arguments to filter AdminHazardActionPlans to count.
     * @example
     * // Count the number of AdminHazardActionPlans
     * const count = await prisma.adminHazardActionPlan.count({
     *   where: {
     *     // ... the filter for the AdminHazardActionPlans we want to count
     *   }
     * })
    **/
    count<T extends AdminHazardActionPlanCountArgs>(
      args?: Subset<T, AdminHazardActionPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminHazardActionPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminHazardActionPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminHazardActionPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminHazardActionPlanAggregateArgs>(args: Subset<T, AdminHazardActionPlanAggregateArgs>): Prisma.PrismaPromise<GetAdminHazardActionPlanAggregateType<T>>

    /**
     * Group by AdminHazardActionPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminHazardActionPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminHazardActionPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminHazardActionPlanGroupByArgs['orderBy'] }
        : { orderBy?: AdminHazardActionPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminHazardActionPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminHazardActionPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminHazardActionPlan model
   */
  readonly fields: AdminHazardActionPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminHazardActionPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminHazardActionPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    hazard<T extends AdminHazardTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminHazardTypeDefaultArgs<ExtArgs>>): Prisma__AdminHazardTypeClient<$Result.GetResult<Prisma.$AdminHazardTypePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    actionPlan<T extends AdminActionPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminActionPlanDefaultArgs<ExtArgs>>): Prisma__AdminActionPlanClient<$Result.GetResult<Prisma.$AdminActionPlanPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminHazardActionPlan model
   */ 
  interface AdminHazardActionPlanFieldRefs {
    readonly id: FieldRef<"AdminHazardActionPlan", 'String'>
    readonly hazardId: FieldRef<"AdminHazardActionPlan", 'String'>
    readonly actionPlanId: FieldRef<"AdminHazardActionPlan", 'String'>
    readonly businessTypes: FieldRef<"AdminHazardActionPlan", 'String'>
    readonly isActive: FieldRef<"AdminHazardActionPlan", 'Boolean'>
    readonly createdAt: FieldRef<"AdminHazardActionPlan", 'DateTime'>
    readonly updatedAt: FieldRef<"AdminHazardActionPlan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdminHazardActionPlan findUnique
   */
  export type AdminHazardActionPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminHazardActionPlan
     */
    select?: AdminHazardActionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminHazardActionPlanInclude<ExtArgs> | null
    /**
     * Filter, which AdminHazardActionPlan to fetch.
     */
    where: AdminHazardActionPlanWhereUniqueInput
  }

  /**
   * AdminHazardActionPlan findUniqueOrThrow
   */
  export type AdminHazardActionPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminHazardActionPlan
     */
    select?: AdminHazardActionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminHazardActionPlanInclude<ExtArgs> | null
    /**
     * Filter, which AdminHazardActionPlan to fetch.
     */
    where: AdminHazardActionPlanWhereUniqueInput
  }

  /**
   * AdminHazardActionPlan findFirst
   */
  export type AdminHazardActionPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminHazardActionPlan
     */
    select?: AdminHazardActionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminHazardActionPlanInclude<ExtArgs> | null
    /**
     * Filter, which AdminHazardActionPlan to fetch.
     */
    where?: AdminHazardActionPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminHazardActionPlans to fetch.
     */
    orderBy?: AdminHazardActionPlanOrderByWithRelationInput | AdminHazardActionPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminHazardActionPlans.
     */
    cursor?: AdminHazardActionPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminHazardActionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminHazardActionPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminHazardActionPlans.
     */
    distinct?: AdminHazardActionPlanScalarFieldEnum | AdminHazardActionPlanScalarFieldEnum[]
  }

  /**
   * AdminHazardActionPlan findFirstOrThrow
   */
  export type AdminHazardActionPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminHazardActionPlan
     */
    select?: AdminHazardActionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminHazardActionPlanInclude<ExtArgs> | null
    /**
     * Filter, which AdminHazardActionPlan to fetch.
     */
    where?: AdminHazardActionPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminHazardActionPlans to fetch.
     */
    orderBy?: AdminHazardActionPlanOrderByWithRelationInput | AdminHazardActionPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminHazardActionPlans.
     */
    cursor?: AdminHazardActionPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminHazardActionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminHazardActionPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminHazardActionPlans.
     */
    distinct?: AdminHazardActionPlanScalarFieldEnum | AdminHazardActionPlanScalarFieldEnum[]
  }

  /**
   * AdminHazardActionPlan findMany
   */
  export type AdminHazardActionPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminHazardActionPlan
     */
    select?: AdminHazardActionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminHazardActionPlanInclude<ExtArgs> | null
    /**
     * Filter, which AdminHazardActionPlans to fetch.
     */
    where?: AdminHazardActionPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminHazardActionPlans to fetch.
     */
    orderBy?: AdminHazardActionPlanOrderByWithRelationInput | AdminHazardActionPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminHazardActionPlans.
     */
    cursor?: AdminHazardActionPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminHazardActionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminHazardActionPlans.
     */
    skip?: number
    distinct?: AdminHazardActionPlanScalarFieldEnum | AdminHazardActionPlanScalarFieldEnum[]
  }

  /**
   * AdminHazardActionPlan create
   */
  export type AdminHazardActionPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminHazardActionPlan
     */
    select?: AdminHazardActionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminHazardActionPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminHazardActionPlan.
     */
    data: XOR<AdminHazardActionPlanCreateInput, AdminHazardActionPlanUncheckedCreateInput>
  }

  /**
   * AdminHazardActionPlan createMany
   */
  export type AdminHazardActionPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminHazardActionPlans.
     */
    data: AdminHazardActionPlanCreateManyInput | AdminHazardActionPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminHazardActionPlan createManyAndReturn
   */
  export type AdminHazardActionPlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminHazardActionPlan
     */
    select?: AdminHazardActionPlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AdminHazardActionPlans.
     */
    data: AdminHazardActionPlanCreateManyInput | AdminHazardActionPlanCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminHazardActionPlanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminHazardActionPlan update
   */
  export type AdminHazardActionPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminHazardActionPlan
     */
    select?: AdminHazardActionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminHazardActionPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminHazardActionPlan.
     */
    data: XOR<AdminHazardActionPlanUpdateInput, AdminHazardActionPlanUncheckedUpdateInput>
    /**
     * Choose, which AdminHazardActionPlan to update.
     */
    where: AdminHazardActionPlanWhereUniqueInput
  }

  /**
   * AdminHazardActionPlan updateMany
   */
  export type AdminHazardActionPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminHazardActionPlans.
     */
    data: XOR<AdminHazardActionPlanUpdateManyMutationInput, AdminHazardActionPlanUncheckedUpdateManyInput>
    /**
     * Filter which AdminHazardActionPlans to update
     */
    where?: AdminHazardActionPlanWhereInput
  }

  /**
   * AdminHazardActionPlan upsert
   */
  export type AdminHazardActionPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminHazardActionPlan
     */
    select?: AdminHazardActionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminHazardActionPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminHazardActionPlan to update in case it exists.
     */
    where: AdminHazardActionPlanWhereUniqueInput
    /**
     * In case the AdminHazardActionPlan found by the `where` argument doesn't exist, create a new AdminHazardActionPlan with this data.
     */
    create: XOR<AdminHazardActionPlanCreateInput, AdminHazardActionPlanUncheckedCreateInput>
    /**
     * In case the AdminHazardActionPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminHazardActionPlanUpdateInput, AdminHazardActionPlanUncheckedUpdateInput>
  }

  /**
   * AdminHazardActionPlan delete
   */
  export type AdminHazardActionPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminHazardActionPlan
     */
    select?: AdminHazardActionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminHazardActionPlanInclude<ExtArgs> | null
    /**
     * Filter which AdminHazardActionPlan to delete.
     */
    where: AdminHazardActionPlanWhereUniqueInput
  }

  /**
   * AdminHazardActionPlan deleteMany
   */
  export type AdminHazardActionPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminHazardActionPlans to delete
     */
    where?: AdminHazardActionPlanWhereInput
  }

  /**
   * AdminHazardActionPlan without action
   */
  export type AdminHazardActionPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminHazardActionPlan
     */
    select?: AdminHazardActionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminHazardActionPlanInclude<ExtArgs> | null
  }


  /**
   * Model AdminRiskProfile
   */

  export type AggregateAdminRiskProfile = {
    _count: AdminRiskProfileCountAggregateOutputType | null
    _avg: AdminRiskProfileAvgAggregateOutputType | null
    _sum: AdminRiskProfileSumAggregateOutputType | null
    _min: AdminRiskProfileMinAggregateOutputType | null
    _max: AdminRiskProfileMaxAggregateOutputType | null
  }

  export type AdminRiskProfileAvgAggregateOutputType = {
    riskScore: number | null
  }

  export type AdminRiskProfileSumAggregateOutputType = {
    riskScore: number | null
  }

  export type AdminRiskProfileMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    businessTypeId: string | null
    locationId: string | null
    calculatedRisks: string | null
    recommendedStrategies: string | null
    lastCalculated: Date | null
    riskScore: number | null
  }

  export type AdminRiskProfileMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    businessTypeId: string | null
    locationId: string | null
    calculatedRisks: string | null
    recommendedStrategies: string | null
    lastCalculated: Date | null
    riskScore: number | null
  }

  export type AdminRiskProfileCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    businessTypeId: number
    locationId: number
    calculatedRisks: number
    recommendedStrategies: number
    lastCalculated: number
    riskScore: number
    _all: number
  }


  export type AdminRiskProfileAvgAggregateInputType = {
    riskScore?: true
  }

  export type AdminRiskProfileSumAggregateInputType = {
    riskScore?: true
  }

  export type AdminRiskProfileMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    businessTypeId?: true
    locationId?: true
    calculatedRisks?: true
    recommendedStrategies?: true
    lastCalculated?: true
    riskScore?: true
  }

  export type AdminRiskProfileMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    businessTypeId?: true
    locationId?: true
    calculatedRisks?: true
    recommendedStrategies?: true
    lastCalculated?: true
    riskScore?: true
  }

  export type AdminRiskProfileCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    businessTypeId?: true
    locationId?: true
    calculatedRisks?: true
    recommendedStrategies?: true
    lastCalculated?: true
    riskScore?: true
    _all?: true
  }

  export type AdminRiskProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminRiskProfile to aggregate.
     */
    where?: AdminRiskProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminRiskProfiles to fetch.
     */
    orderBy?: AdminRiskProfileOrderByWithRelationInput | AdminRiskProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminRiskProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminRiskProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminRiskProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminRiskProfiles
    **/
    _count?: true | AdminRiskProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminRiskProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminRiskProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminRiskProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminRiskProfileMaxAggregateInputType
  }

  export type GetAdminRiskProfileAggregateType<T extends AdminRiskProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminRiskProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminRiskProfile[P]>
      : GetScalarType<T[P], AggregateAdminRiskProfile[P]>
  }




  export type AdminRiskProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminRiskProfileWhereInput
    orderBy?: AdminRiskProfileOrderByWithAggregationInput | AdminRiskProfileOrderByWithAggregationInput[]
    by: AdminRiskProfileScalarFieldEnum[] | AdminRiskProfileScalarFieldEnum
    having?: AdminRiskProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminRiskProfileCountAggregateInputType | true
    _avg?: AdminRiskProfileAvgAggregateInputType
    _sum?: AdminRiskProfileSumAggregateInputType
    _min?: AdminRiskProfileMinAggregateInputType
    _max?: AdminRiskProfileMaxAggregateInputType
  }

  export type AdminRiskProfileGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    businessTypeId: string
    locationId: string
    calculatedRisks: string
    recommendedStrategies: string
    lastCalculated: Date
    riskScore: number
    _count: AdminRiskProfileCountAggregateOutputType | null
    _avg: AdminRiskProfileAvgAggregateOutputType | null
    _sum: AdminRiskProfileSumAggregateOutputType | null
    _min: AdminRiskProfileMinAggregateOutputType | null
    _max: AdminRiskProfileMaxAggregateOutputType | null
  }

  type GetAdminRiskProfileGroupByPayload<T extends AdminRiskProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminRiskProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminRiskProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminRiskProfileGroupByOutputType[P]>
            : GetScalarType<T[P], AdminRiskProfileGroupByOutputType[P]>
        }
      >
    >


  export type AdminRiskProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    businessTypeId?: boolean
    locationId?: boolean
    calculatedRisks?: boolean
    recommendedStrategies?: boolean
    lastCalculated?: boolean
    riskScore?: boolean
    businessType?: boolean | AdminBusinessTypeDefaultArgs<ExtArgs>
    location?: boolean | AdminLocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminRiskProfile"]>

  export type AdminRiskProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    businessTypeId?: boolean
    locationId?: boolean
    calculatedRisks?: boolean
    recommendedStrategies?: boolean
    lastCalculated?: boolean
    riskScore?: boolean
    businessType?: boolean | AdminBusinessTypeDefaultArgs<ExtArgs>
    location?: boolean | AdminLocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminRiskProfile"]>

  export type AdminRiskProfileSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    businessTypeId?: boolean
    locationId?: boolean
    calculatedRisks?: boolean
    recommendedStrategies?: boolean
    lastCalculated?: boolean
    riskScore?: boolean
  }

  export type AdminRiskProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businessType?: boolean | AdminBusinessTypeDefaultArgs<ExtArgs>
    location?: boolean | AdminLocationDefaultArgs<ExtArgs>
  }
  export type AdminRiskProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businessType?: boolean | AdminBusinessTypeDefaultArgs<ExtArgs>
    location?: boolean | AdminLocationDefaultArgs<ExtArgs>
  }

  export type $AdminRiskProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminRiskProfile"
    objects: {
      businessType: Prisma.$AdminBusinessTypePayload<ExtArgs>
      location: Prisma.$AdminLocationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      businessTypeId: string
      locationId: string
      calculatedRisks: string
      recommendedStrategies: string
      lastCalculated: Date
      riskScore: number
    }, ExtArgs["result"]["adminRiskProfile"]>
    composites: {}
  }

  type AdminRiskProfileGetPayload<S extends boolean | null | undefined | AdminRiskProfileDefaultArgs> = $Result.GetResult<Prisma.$AdminRiskProfilePayload, S>

  type AdminRiskProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdminRiskProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdminRiskProfileCountAggregateInputType | true
    }

  export interface AdminRiskProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminRiskProfile'], meta: { name: 'AdminRiskProfile' } }
    /**
     * Find zero or one AdminRiskProfile that matches the filter.
     * @param {AdminRiskProfileFindUniqueArgs} args - Arguments to find a AdminRiskProfile
     * @example
     * // Get one AdminRiskProfile
     * const adminRiskProfile = await prisma.adminRiskProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminRiskProfileFindUniqueArgs>(args: SelectSubset<T, AdminRiskProfileFindUniqueArgs<ExtArgs>>): Prisma__AdminRiskProfileClient<$Result.GetResult<Prisma.$AdminRiskProfilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AdminRiskProfile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdminRiskProfileFindUniqueOrThrowArgs} args - Arguments to find a AdminRiskProfile
     * @example
     * // Get one AdminRiskProfile
     * const adminRiskProfile = await prisma.adminRiskProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminRiskProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminRiskProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminRiskProfileClient<$Result.GetResult<Prisma.$AdminRiskProfilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AdminRiskProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminRiskProfileFindFirstArgs} args - Arguments to find a AdminRiskProfile
     * @example
     * // Get one AdminRiskProfile
     * const adminRiskProfile = await prisma.adminRiskProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminRiskProfileFindFirstArgs>(args?: SelectSubset<T, AdminRiskProfileFindFirstArgs<ExtArgs>>): Prisma__AdminRiskProfileClient<$Result.GetResult<Prisma.$AdminRiskProfilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AdminRiskProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminRiskProfileFindFirstOrThrowArgs} args - Arguments to find a AdminRiskProfile
     * @example
     * // Get one AdminRiskProfile
     * const adminRiskProfile = await prisma.adminRiskProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminRiskProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminRiskProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminRiskProfileClient<$Result.GetResult<Prisma.$AdminRiskProfilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AdminRiskProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminRiskProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminRiskProfiles
     * const adminRiskProfiles = await prisma.adminRiskProfile.findMany()
     * 
     * // Get first 10 AdminRiskProfiles
     * const adminRiskProfiles = await prisma.adminRiskProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminRiskProfileWithIdOnly = await prisma.adminRiskProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminRiskProfileFindManyArgs>(args?: SelectSubset<T, AdminRiskProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminRiskProfilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AdminRiskProfile.
     * @param {AdminRiskProfileCreateArgs} args - Arguments to create a AdminRiskProfile.
     * @example
     * // Create one AdminRiskProfile
     * const AdminRiskProfile = await prisma.adminRiskProfile.create({
     *   data: {
     *     // ... data to create a AdminRiskProfile
     *   }
     * })
     * 
     */
    create<T extends AdminRiskProfileCreateArgs>(args: SelectSubset<T, AdminRiskProfileCreateArgs<ExtArgs>>): Prisma__AdminRiskProfileClient<$Result.GetResult<Prisma.$AdminRiskProfilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AdminRiskProfiles.
     * @param {AdminRiskProfileCreateManyArgs} args - Arguments to create many AdminRiskProfiles.
     * @example
     * // Create many AdminRiskProfiles
     * const adminRiskProfile = await prisma.adminRiskProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminRiskProfileCreateManyArgs>(args?: SelectSubset<T, AdminRiskProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminRiskProfiles and returns the data saved in the database.
     * @param {AdminRiskProfileCreateManyAndReturnArgs} args - Arguments to create many AdminRiskProfiles.
     * @example
     * // Create many AdminRiskProfiles
     * const adminRiskProfile = await prisma.adminRiskProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminRiskProfiles and only return the `id`
     * const adminRiskProfileWithIdOnly = await prisma.adminRiskProfile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminRiskProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminRiskProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminRiskProfilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AdminRiskProfile.
     * @param {AdminRiskProfileDeleteArgs} args - Arguments to delete one AdminRiskProfile.
     * @example
     * // Delete one AdminRiskProfile
     * const AdminRiskProfile = await prisma.adminRiskProfile.delete({
     *   where: {
     *     // ... filter to delete one AdminRiskProfile
     *   }
     * })
     * 
     */
    delete<T extends AdminRiskProfileDeleteArgs>(args: SelectSubset<T, AdminRiskProfileDeleteArgs<ExtArgs>>): Prisma__AdminRiskProfileClient<$Result.GetResult<Prisma.$AdminRiskProfilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AdminRiskProfile.
     * @param {AdminRiskProfileUpdateArgs} args - Arguments to update one AdminRiskProfile.
     * @example
     * // Update one AdminRiskProfile
     * const adminRiskProfile = await prisma.adminRiskProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminRiskProfileUpdateArgs>(args: SelectSubset<T, AdminRiskProfileUpdateArgs<ExtArgs>>): Prisma__AdminRiskProfileClient<$Result.GetResult<Prisma.$AdminRiskProfilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AdminRiskProfiles.
     * @param {AdminRiskProfileDeleteManyArgs} args - Arguments to filter AdminRiskProfiles to delete.
     * @example
     * // Delete a few AdminRiskProfiles
     * const { count } = await prisma.adminRiskProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminRiskProfileDeleteManyArgs>(args?: SelectSubset<T, AdminRiskProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminRiskProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminRiskProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminRiskProfiles
     * const adminRiskProfile = await prisma.adminRiskProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminRiskProfileUpdateManyArgs>(args: SelectSubset<T, AdminRiskProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AdminRiskProfile.
     * @param {AdminRiskProfileUpsertArgs} args - Arguments to update or create a AdminRiskProfile.
     * @example
     * // Update or create a AdminRiskProfile
     * const adminRiskProfile = await prisma.adminRiskProfile.upsert({
     *   create: {
     *     // ... data to create a AdminRiskProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminRiskProfile we want to update
     *   }
     * })
     */
    upsert<T extends AdminRiskProfileUpsertArgs>(args: SelectSubset<T, AdminRiskProfileUpsertArgs<ExtArgs>>): Prisma__AdminRiskProfileClient<$Result.GetResult<Prisma.$AdminRiskProfilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AdminRiskProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminRiskProfileCountArgs} args - Arguments to filter AdminRiskProfiles to count.
     * @example
     * // Count the number of AdminRiskProfiles
     * const count = await prisma.adminRiskProfile.count({
     *   where: {
     *     // ... the filter for the AdminRiskProfiles we want to count
     *   }
     * })
    **/
    count<T extends AdminRiskProfileCountArgs>(
      args?: Subset<T, AdminRiskProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminRiskProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminRiskProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminRiskProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminRiskProfileAggregateArgs>(args: Subset<T, AdminRiskProfileAggregateArgs>): Prisma.PrismaPromise<GetAdminRiskProfileAggregateType<T>>

    /**
     * Group by AdminRiskProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminRiskProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminRiskProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminRiskProfileGroupByArgs['orderBy'] }
        : { orderBy?: AdminRiskProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminRiskProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminRiskProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminRiskProfile model
   */
  readonly fields: AdminRiskProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminRiskProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminRiskProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    businessType<T extends AdminBusinessTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminBusinessTypeDefaultArgs<ExtArgs>>): Prisma__AdminBusinessTypeClient<$Result.GetResult<Prisma.$AdminBusinessTypePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    location<T extends AdminLocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminLocationDefaultArgs<ExtArgs>>): Prisma__AdminLocationClient<$Result.GetResult<Prisma.$AdminLocationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminRiskProfile model
   */ 
  interface AdminRiskProfileFieldRefs {
    readonly id: FieldRef<"AdminRiskProfile", 'String'>
    readonly createdAt: FieldRef<"AdminRiskProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"AdminRiskProfile", 'DateTime'>
    readonly businessTypeId: FieldRef<"AdminRiskProfile", 'String'>
    readonly locationId: FieldRef<"AdminRiskProfile", 'String'>
    readonly calculatedRisks: FieldRef<"AdminRiskProfile", 'String'>
    readonly recommendedStrategies: FieldRef<"AdminRiskProfile", 'String'>
    readonly lastCalculated: FieldRef<"AdminRiskProfile", 'DateTime'>
    readonly riskScore: FieldRef<"AdminRiskProfile", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * AdminRiskProfile findUnique
   */
  export type AdminRiskProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRiskProfile
     */
    select?: AdminRiskProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRiskProfileInclude<ExtArgs> | null
    /**
     * Filter, which AdminRiskProfile to fetch.
     */
    where: AdminRiskProfileWhereUniqueInput
  }

  /**
   * AdminRiskProfile findUniqueOrThrow
   */
  export type AdminRiskProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRiskProfile
     */
    select?: AdminRiskProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRiskProfileInclude<ExtArgs> | null
    /**
     * Filter, which AdminRiskProfile to fetch.
     */
    where: AdminRiskProfileWhereUniqueInput
  }

  /**
   * AdminRiskProfile findFirst
   */
  export type AdminRiskProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRiskProfile
     */
    select?: AdminRiskProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRiskProfileInclude<ExtArgs> | null
    /**
     * Filter, which AdminRiskProfile to fetch.
     */
    where?: AdminRiskProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminRiskProfiles to fetch.
     */
    orderBy?: AdminRiskProfileOrderByWithRelationInput | AdminRiskProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminRiskProfiles.
     */
    cursor?: AdminRiskProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminRiskProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminRiskProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminRiskProfiles.
     */
    distinct?: AdminRiskProfileScalarFieldEnum | AdminRiskProfileScalarFieldEnum[]
  }

  /**
   * AdminRiskProfile findFirstOrThrow
   */
  export type AdminRiskProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRiskProfile
     */
    select?: AdminRiskProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRiskProfileInclude<ExtArgs> | null
    /**
     * Filter, which AdminRiskProfile to fetch.
     */
    where?: AdminRiskProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminRiskProfiles to fetch.
     */
    orderBy?: AdminRiskProfileOrderByWithRelationInput | AdminRiskProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminRiskProfiles.
     */
    cursor?: AdminRiskProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminRiskProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminRiskProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminRiskProfiles.
     */
    distinct?: AdminRiskProfileScalarFieldEnum | AdminRiskProfileScalarFieldEnum[]
  }

  /**
   * AdminRiskProfile findMany
   */
  export type AdminRiskProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRiskProfile
     */
    select?: AdminRiskProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRiskProfileInclude<ExtArgs> | null
    /**
     * Filter, which AdminRiskProfiles to fetch.
     */
    where?: AdminRiskProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminRiskProfiles to fetch.
     */
    orderBy?: AdminRiskProfileOrderByWithRelationInput | AdminRiskProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminRiskProfiles.
     */
    cursor?: AdminRiskProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminRiskProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminRiskProfiles.
     */
    skip?: number
    distinct?: AdminRiskProfileScalarFieldEnum | AdminRiskProfileScalarFieldEnum[]
  }

  /**
   * AdminRiskProfile create
   */
  export type AdminRiskProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRiskProfile
     */
    select?: AdminRiskProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRiskProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminRiskProfile.
     */
    data: XOR<AdminRiskProfileCreateInput, AdminRiskProfileUncheckedCreateInput>
  }

  /**
   * AdminRiskProfile createMany
   */
  export type AdminRiskProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminRiskProfiles.
     */
    data: AdminRiskProfileCreateManyInput | AdminRiskProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminRiskProfile createManyAndReturn
   */
  export type AdminRiskProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRiskProfile
     */
    select?: AdminRiskProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AdminRiskProfiles.
     */
    data: AdminRiskProfileCreateManyInput | AdminRiskProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRiskProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminRiskProfile update
   */
  export type AdminRiskProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRiskProfile
     */
    select?: AdminRiskProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRiskProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminRiskProfile.
     */
    data: XOR<AdminRiskProfileUpdateInput, AdminRiskProfileUncheckedUpdateInput>
    /**
     * Choose, which AdminRiskProfile to update.
     */
    where: AdminRiskProfileWhereUniqueInput
  }

  /**
   * AdminRiskProfile updateMany
   */
  export type AdminRiskProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminRiskProfiles.
     */
    data: XOR<AdminRiskProfileUpdateManyMutationInput, AdminRiskProfileUncheckedUpdateManyInput>
    /**
     * Filter which AdminRiskProfiles to update
     */
    where?: AdminRiskProfileWhereInput
  }

  /**
   * AdminRiskProfile upsert
   */
  export type AdminRiskProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRiskProfile
     */
    select?: AdminRiskProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRiskProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminRiskProfile to update in case it exists.
     */
    where: AdminRiskProfileWhereUniqueInput
    /**
     * In case the AdminRiskProfile found by the `where` argument doesn't exist, create a new AdminRiskProfile with this data.
     */
    create: XOR<AdminRiskProfileCreateInput, AdminRiskProfileUncheckedCreateInput>
    /**
     * In case the AdminRiskProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminRiskProfileUpdateInput, AdminRiskProfileUncheckedUpdateInput>
  }

  /**
   * AdminRiskProfile delete
   */
  export type AdminRiskProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRiskProfile
     */
    select?: AdminRiskProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRiskProfileInclude<ExtArgs> | null
    /**
     * Filter which AdminRiskProfile to delete.
     */
    where: AdminRiskProfileWhereUniqueInput
  }

  /**
   * AdminRiskProfile deleteMany
   */
  export type AdminRiskProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminRiskProfiles to delete
     */
    where?: AdminRiskProfileWhereInput
  }

  /**
   * AdminRiskProfile without action
   */
  export type AdminRiskProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRiskProfile
     */
    select?: AdminRiskProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRiskProfileInclude<ExtArgs> | null
  }


  /**
   * Model Country
   */

  export type AggregateCountry = {
    _count: CountryCountAggregateOutputType | null
    _min: CountryMinAggregateOutputType | null
    _max: CountryMaxAggregateOutputType | null
  }

  export type CountryMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    region: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CountryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    region: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CountryCountAggregateOutputType = {
    id: number
    name: number
    code: number
    region: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CountryMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    region?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CountryMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    region?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CountryCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    region?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CountryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Country to aggregate.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Countries
    **/
    _count?: true | CountryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CountryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CountryMaxAggregateInputType
  }

  export type GetCountryAggregateType<T extends CountryAggregateArgs> = {
        [P in keyof T & keyof AggregateCountry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCountry[P]>
      : GetScalarType<T[P], AggregateCountry[P]>
  }




  export type CountryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CountryWhereInput
    orderBy?: CountryOrderByWithAggregationInput | CountryOrderByWithAggregationInput[]
    by: CountryScalarFieldEnum[] | CountryScalarFieldEnum
    having?: CountryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CountryCountAggregateInputType | true
    _min?: CountryMinAggregateInputType
    _max?: CountryMaxAggregateInputType
  }

  export type CountryGroupByOutputType = {
    id: string
    name: string
    code: string
    region: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: CountryCountAggregateOutputType | null
    _min: CountryMinAggregateOutputType | null
    _max: CountryMaxAggregateOutputType | null
  }

  type GetCountryGroupByPayload<T extends CountryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CountryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CountryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CountryGroupByOutputType[P]>
            : GetScalarType<T[P], CountryGroupByOutputType[P]>
        }
      >
    >


  export type CountrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    region?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    adminUnits?: boolean | Country$adminUnitsArgs<ExtArgs>
    _count?: boolean | CountryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["country"]>

  export type CountrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    region?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["country"]>

  export type CountrySelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    region?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CountryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    adminUnits?: boolean | Country$adminUnitsArgs<ExtArgs>
    _count?: boolean | CountryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CountryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CountryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Country"
    objects: {
      adminUnits: Prisma.$AdminUnitPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string
      region: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["country"]>
    composites: {}
  }

  type CountryGetPayload<S extends boolean | null | undefined | CountryDefaultArgs> = $Result.GetResult<Prisma.$CountryPayload, S>

  type CountryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CountryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CountryCountAggregateInputType | true
    }

  export interface CountryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Country'], meta: { name: 'Country' } }
    /**
     * Find zero or one Country that matches the filter.
     * @param {CountryFindUniqueArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CountryFindUniqueArgs>(args: SelectSubset<T, CountryFindUniqueArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Country that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CountryFindUniqueOrThrowArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CountryFindUniqueOrThrowArgs>(args: SelectSubset<T, CountryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Country that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindFirstArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CountryFindFirstArgs>(args?: SelectSubset<T, CountryFindFirstArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Country that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindFirstOrThrowArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CountryFindFirstOrThrowArgs>(args?: SelectSubset<T, CountryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Countries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Countries
     * const countries = await prisma.country.findMany()
     * 
     * // Get first 10 Countries
     * const countries = await prisma.country.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const countryWithIdOnly = await prisma.country.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CountryFindManyArgs>(args?: SelectSubset<T, CountryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Country.
     * @param {CountryCreateArgs} args - Arguments to create a Country.
     * @example
     * // Create one Country
     * const Country = await prisma.country.create({
     *   data: {
     *     // ... data to create a Country
     *   }
     * })
     * 
     */
    create<T extends CountryCreateArgs>(args: SelectSubset<T, CountryCreateArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Countries.
     * @param {CountryCreateManyArgs} args - Arguments to create many Countries.
     * @example
     * // Create many Countries
     * const country = await prisma.country.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CountryCreateManyArgs>(args?: SelectSubset<T, CountryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Countries and returns the data saved in the database.
     * @param {CountryCreateManyAndReturnArgs} args - Arguments to create many Countries.
     * @example
     * // Create many Countries
     * const country = await prisma.country.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Countries and only return the `id`
     * const countryWithIdOnly = await prisma.country.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CountryCreateManyAndReturnArgs>(args?: SelectSubset<T, CountryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Country.
     * @param {CountryDeleteArgs} args - Arguments to delete one Country.
     * @example
     * // Delete one Country
     * const Country = await prisma.country.delete({
     *   where: {
     *     // ... filter to delete one Country
     *   }
     * })
     * 
     */
    delete<T extends CountryDeleteArgs>(args: SelectSubset<T, CountryDeleteArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Country.
     * @param {CountryUpdateArgs} args - Arguments to update one Country.
     * @example
     * // Update one Country
     * const country = await prisma.country.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CountryUpdateArgs>(args: SelectSubset<T, CountryUpdateArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Countries.
     * @param {CountryDeleteManyArgs} args - Arguments to filter Countries to delete.
     * @example
     * // Delete a few Countries
     * const { count } = await prisma.country.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CountryDeleteManyArgs>(args?: SelectSubset<T, CountryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Countries
     * const country = await prisma.country.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CountryUpdateManyArgs>(args: SelectSubset<T, CountryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Country.
     * @param {CountryUpsertArgs} args - Arguments to update or create a Country.
     * @example
     * // Update or create a Country
     * const country = await prisma.country.upsert({
     *   create: {
     *     // ... data to create a Country
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Country we want to update
     *   }
     * })
     */
    upsert<T extends CountryUpsertArgs>(args: SelectSubset<T, CountryUpsertArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryCountArgs} args - Arguments to filter Countries to count.
     * @example
     * // Count the number of Countries
     * const count = await prisma.country.count({
     *   where: {
     *     // ... the filter for the Countries we want to count
     *   }
     * })
    **/
    count<T extends CountryCountArgs>(
      args?: Subset<T, CountryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CountryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CountryAggregateArgs>(args: Subset<T, CountryAggregateArgs>): Prisma.PrismaPromise<GetCountryAggregateType<T>>

    /**
     * Group by Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CountryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CountryGroupByArgs['orderBy'] }
        : { orderBy?: CountryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CountryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCountryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Country model
   */
  readonly fields: CountryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Country.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CountryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    adminUnits<T extends Country$adminUnitsArgs<ExtArgs> = {}>(args?: Subset<T, Country$adminUnitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminUnitPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Country model
   */ 
  interface CountryFieldRefs {
    readonly id: FieldRef<"Country", 'String'>
    readonly name: FieldRef<"Country", 'String'>
    readonly code: FieldRef<"Country", 'String'>
    readonly region: FieldRef<"Country", 'String'>
    readonly isActive: FieldRef<"Country", 'Boolean'>
    readonly createdAt: FieldRef<"Country", 'DateTime'>
    readonly updatedAt: FieldRef<"Country", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Country findUnique
   */
  export type CountryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country findUniqueOrThrow
   */
  export type CountryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country findFirst
   */
  export type CountryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Countries.
     */
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }

  /**
   * Country findFirstOrThrow
   */
  export type CountryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Countries.
     */
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }

  /**
   * Country findMany
   */
  export type CountryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Countries to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }

  /**
   * Country create
   */
  export type CountryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * The data needed to create a Country.
     */
    data: XOR<CountryCreateInput, CountryUncheckedCreateInput>
  }

  /**
   * Country createMany
   */
  export type CountryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Countries.
     */
    data: CountryCreateManyInput | CountryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Country createManyAndReturn
   */
  export type CountryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Countries.
     */
    data: CountryCreateManyInput | CountryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Country update
   */
  export type CountryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * The data needed to update a Country.
     */
    data: XOR<CountryUpdateInput, CountryUncheckedUpdateInput>
    /**
     * Choose, which Country to update.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country updateMany
   */
  export type CountryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Countries.
     */
    data: XOR<CountryUpdateManyMutationInput, CountryUncheckedUpdateManyInput>
    /**
     * Filter which Countries to update
     */
    where?: CountryWhereInput
  }

  /**
   * Country upsert
   */
  export type CountryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * The filter to search for the Country to update in case it exists.
     */
    where: CountryWhereUniqueInput
    /**
     * In case the Country found by the `where` argument doesn't exist, create a new Country with this data.
     */
    create: XOR<CountryCreateInput, CountryUncheckedCreateInput>
    /**
     * In case the Country was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CountryUpdateInput, CountryUncheckedUpdateInput>
  }

  /**
   * Country delete
   */
  export type CountryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter which Country to delete.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country deleteMany
   */
  export type CountryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Countries to delete
     */
    where?: CountryWhereInput
  }

  /**
   * Country.adminUnits
   */
  export type Country$adminUnitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUnit
     */
    select?: AdminUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUnitInclude<ExtArgs> | null
    where?: AdminUnitWhereInput
    orderBy?: AdminUnitOrderByWithRelationInput | AdminUnitOrderByWithRelationInput[]
    cursor?: AdminUnitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminUnitScalarFieldEnum | AdminUnitScalarFieldEnum[]
  }

  /**
   * Country without action
   */
  export type CountryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
  }


  /**
   * Model AdminUnit
   */

  export type AggregateAdminUnit = {
    _count: AdminUnitCountAggregateOutputType | null
    _avg: AdminUnitAvgAggregateOutputType | null
    _sum: AdminUnitSumAggregateOutputType | null
    _min: AdminUnitMinAggregateOutputType | null
    _max: AdminUnitMaxAggregateOutputType | null
  }

  export type AdminUnitAvgAggregateOutputType = {
    population: number | null
    area: number | null
    elevation: number | null
  }

  export type AdminUnitSumAggregateOutputType = {
    population: number | null
    area: number | null
    elevation: number | null
  }

  export type AdminUnitMinAggregateOutputType = {
    id: string | null
    name: string | null
    localName: string | null
    type: string | null
    region: string | null
    countryId: string | null
    population: number | null
    area: number | null
    elevation: number | null
    coordinates: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isActive: boolean | null
  }

  export type AdminUnitMaxAggregateOutputType = {
    id: string | null
    name: string | null
    localName: string | null
    type: string | null
    region: string | null
    countryId: string | null
    population: number | null
    area: number | null
    elevation: number | null
    coordinates: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isActive: boolean | null
  }

  export type AdminUnitCountAggregateOutputType = {
    id: number
    name: number
    localName: number
    type: number
    region: number
    countryId: number
    population: number
    area: number
    elevation: number
    coordinates: number
    createdAt: number
    updatedAt: number
    isActive: number
    _all: number
  }


  export type AdminUnitAvgAggregateInputType = {
    population?: true
    area?: true
    elevation?: true
  }

  export type AdminUnitSumAggregateInputType = {
    population?: true
    area?: true
    elevation?: true
  }

  export type AdminUnitMinAggregateInputType = {
    id?: true
    name?: true
    localName?: true
    type?: true
    region?: true
    countryId?: true
    population?: true
    area?: true
    elevation?: true
    coordinates?: true
    createdAt?: true
    updatedAt?: true
    isActive?: true
  }

  export type AdminUnitMaxAggregateInputType = {
    id?: true
    name?: true
    localName?: true
    type?: true
    region?: true
    countryId?: true
    population?: true
    area?: true
    elevation?: true
    coordinates?: true
    createdAt?: true
    updatedAt?: true
    isActive?: true
  }

  export type AdminUnitCountAggregateInputType = {
    id?: true
    name?: true
    localName?: true
    type?: true
    region?: true
    countryId?: true
    population?: true
    area?: true
    elevation?: true
    coordinates?: true
    createdAt?: true
    updatedAt?: true
    isActive?: true
    _all?: true
  }

  export type AdminUnitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminUnit to aggregate.
     */
    where?: AdminUnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminUnits to fetch.
     */
    orderBy?: AdminUnitOrderByWithRelationInput | AdminUnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminUnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminUnits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminUnits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminUnits
    **/
    _count?: true | AdminUnitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminUnitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminUnitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminUnitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminUnitMaxAggregateInputType
  }

  export type GetAdminUnitAggregateType<T extends AdminUnitAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminUnit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminUnit[P]>
      : GetScalarType<T[P], AggregateAdminUnit[P]>
  }




  export type AdminUnitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminUnitWhereInput
    orderBy?: AdminUnitOrderByWithAggregationInput | AdminUnitOrderByWithAggregationInput[]
    by: AdminUnitScalarFieldEnum[] | AdminUnitScalarFieldEnum
    having?: AdminUnitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminUnitCountAggregateInputType | true
    _avg?: AdminUnitAvgAggregateInputType
    _sum?: AdminUnitSumAggregateInputType
    _min?: AdminUnitMinAggregateInputType
    _max?: AdminUnitMaxAggregateInputType
  }

  export type AdminUnitGroupByOutputType = {
    id: string
    name: string
    localName: string | null
    type: string
    region: string | null
    countryId: string
    population: number
    area: number | null
    elevation: number | null
    coordinates: string | null
    createdAt: Date
    updatedAt: Date
    isActive: boolean
    _count: AdminUnitCountAggregateOutputType | null
    _avg: AdminUnitAvgAggregateOutputType | null
    _sum: AdminUnitSumAggregateOutputType | null
    _min: AdminUnitMinAggregateOutputType | null
    _max: AdminUnitMaxAggregateOutputType | null
  }

  type GetAdminUnitGroupByPayload<T extends AdminUnitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminUnitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminUnitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminUnitGroupByOutputType[P]>
            : GetScalarType<T[P], AdminUnitGroupByOutputType[P]>
        }
      >
    >


  export type AdminUnitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    localName?: boolean
    type?: boolean
    region?: boolean
    countryId?: boolean
    population?: boolean
    area?: boolean
    elevation?: boolean
    coordinates?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isActive?: boolean
    country?: boolean | CountryDefaultArgs<ExtArgs>
    adminUnitRisk?: boolean | AdminUnit$adminUnitRiskArgs<ExtArgs>
  }, ExtArgs["result"]["adminUnit"]>

  export type AdminUnitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    localName?: boolean
    type?: boolean
    region?: boolean
    countryId?: boolean
    population?: boolean
    area?: boolean
    elevation?: boolean
    coordinates?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isActive?: boolean
    country?: boolean | CountryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminUnit"]>

  export type AdminUnitSelectScalar = {
    id?: boolean
    name?: boolean
    localName?: boolean
    type?: boolean
    region?: boolean
    countryId?: boolean
    population?: boolean
    area?: boolean
    elevation?: boolean
    coordinates?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isActive?: boolean
  }

  export type AdminUnitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | CountryDefaultArgs<ExtArgs>
    adminUnitRisk?: boolean | AdminUnit$adminUnitRiskArgs<ExtArgs>
  }
  export type AdminUnitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | CountryDefaultArgs<ExtArgs>
  }

  export type $AdminUnitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminUnit"
    objects: {
      country: Prisma.$CountryPayload<ExtArgs>
      adminUnitRisk: Prisma.$AdminUnitRiskPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      localName: string | null
      type: string
      region: string | null
      countryId: string
      population: number
      area: number | null
      elevation: number | null
      coordinates: string | null
      createdAt: Date
      updatedAt: Date
      isActive: boolean
    }, ExtArgs["result"]["adminUnit"]>
    composites: {}
  }

  type AdminUnitGetPayload<S extends boolean | null | undefined | AdminUnitDefaultArgs> = $Result.GetResult<Prisma.$AdminUnitPayload, S>

  type AdminUnitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdminUnitFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdminUnitCountAggregateInputType | true
    }

  export interface AdminUnitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminUnit'], meta: { name: 'AdminUnit' } }
    /**
     * Find zero or one AdminUnit that matches the filter.
     * @param {AdminUnitFindUniqueArgs} args - Arguments to find a AdminUnit
     * @example
     * // Get one AdminUnit
     * const adminUnit = await prisma.adminUnit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminUnitFindUniqueArgs>(args: SelectSubset<T, AdminUnitFindUniqueArgs<ExtArgs>>): Prisma__AdminUnitClient<$Result.GetResult<Prisma.$AdminUnitPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AdminUnit that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdminUnitFindUniqueOrThrowArgs} args - Arguments to find a AdminUnit
     * @example
     * // Get one AdminUnit
     * const adminUnit = await prisma.adminUnit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminUnitFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminUnitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminUnitClient<$Result.GetResult<Prisma.$AdminUnitPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AdminUnit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUnitFindFirstArgs} args - Arguments to find a AdminUnit
     * @example
     * // Get one AdminUnit
     * const adminUnit = await prisma.adminUnit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminUnitFindFirstArgs>(args?: SelectSubset<T, AdminUnitFindFirstArgs<ExtArgs>>): Prisma__AdminUnitClient<$Result.GetResult<Prisma.$AdminUnitPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AdminUnit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUnitFindFirstOrThrowArgs} args - Arguments to find a AdminUnit
     * @example
     * // Get one AdminUnit
     * const adminUnit = await prisma.adminUnit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminUnitFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminUnitFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminUnitClient<$Result.GetResult<Prisma.$AdminUnitPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AdminUnits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUnitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminUnits
     * const adminUnits = await prisma.adminUnit.findMany()
     * 
     * // Get first 10 AdminUnits
     * const adminUnits = await prisma.adminUnit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminUnitWithIdOnly = await prisma.adminUnit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminUnitFindManyArgs>(args?: SelectSubset<T, AdminUnitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminUnitPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AdminUnit.
     * @param {AdminUnitCreateArgs} args - Arguments to create a AdminUnit.
     * @example
     * // Create one AdminUnit
     * const AdminUnit = await prisma.adminUnit.create({
     *   data: {
     *     // ... data to create a AdminUnit
     *   }
     * })
     * 
     */
    create<T extends AdminUnitCreateArgs>(args: SelectSubset<T, AdminUnitCreateArgs<ExtArgs>>): Prisma__AdminUnitClient<$Result.GetResult<Prisma.$AdminUnitPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AdminUnits.
     * @param {AdminUnitCreateManyArgs} args - Arguments to create many AdminUnits.
     * @example
     * // Create many AdminUnits
     * const adminUnit = await prisma.adminUnit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminUnitCreateManyArgs>(args?: SelectSubset<T, AdminUnitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminUnits and returns the data saved in the database.
     * @param {AdminUnitCreateManyAndReturnArgs} args - Arguments to create many AdminUnits.
     * @example
     * // Create many AdminUnits
     * const adminUnit = await prisma.adminUnit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminUnits and only return the `id`
     * const adminUnitWithIdOnly = await prisma.adminUnit.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminUnitCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminUnitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminUnitPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AdminUnit.
     * @param {AdminUnitDeleteArgs} args - Arguments to delete one AdminUnit.
     * @example
     * // Delete one AdminUnit
     * const AdminUnit = await prisma.adminUnit.delete({
     *   where: {
     *     // ... filter to delete one AdminUnit
     *   }
     * })
     * 
     */
    delete<T extends AdminUnitDeleteArgs>(args: SelectSubset<T, AdminUnitDeleteArgs<ExtArgs>>): Prisma__AdminUnitClient<$Result.GetResult<Prisma.$AdminUnitPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AdminUnit.
     * @param {AdminUnitUpdateArgs} args - Arguments to update one AdminUnit.
     * @example
     * // Update one AdminUnit
     * const adminUnit = await prisma.adminUnit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminUnitUpdateArgs>(args: SelectSubset<T, AdminUnitUpdateArgs<ExtArgs>>): Prisma__AdminUnitClient<$Result.GetResult<Prisma.$AdminUnitPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AdminUnits.
     * @param {AdminUnitDeleteManyArgs} args - Arguments to filter AdminUnits to delete.
     * @example
     * // Delete a few AdminUnits
     * const { count } = await prisma.adminUnit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminUnitDeleteManyArgs>(args?: SelectSubset<T, AdminUnitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminUnits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUnitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminUnits
     * const adminUnit = await prisma.adminUnit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminUnitUpdateManyArgs>(args: SelectSubset<T, AdminUnitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AdminUnit.
     * @param {AdminUnitUpsertArgs} args - Arguments to update or create a AdminUnit.
     * @example
     * // Update or create a AdminUnit
     * const adminUnit = await prisma.adminUnit.upsert({
     *   create: {
     *     // ... data to create a AdminUnit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminUnit we want to update
     *   }
     * })
     */
    upsert<T extends AdminUnitUpsertArgs>(args: SelectSubset<T, AdminUnitUpsertArgs<ExtArgs>>): Prisma__AdminUnitClient<$Result.GetResult<Prisma.$AdminUnitPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AdminUnits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUnitCountArgs} args - Arguments to filter AdminUnits to count.
     * @example
     * // Count the number of AdminUnits
     * const count = await prisma.adminUnit.count({
     *   where: {
     *     // ... the filter for the AdminUnits we want to count
     *   }
     * })
    **/
    count<T extends AdminUnitCountArgs>(
      args?: Subset<T, AdminUnitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminUnitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminUnit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUnitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminUnitAggregateArgs>(args: Subset<T, AdminUnitAggregateArgs>): Prisma.PrismaPromise<GetAdminUnitAggregateType<T>>

    /**
     * Group by AdminUnit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUnitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminUnitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminUnitGroupByArgs['orderBy'] }
        : { orderBy?: AdminUnitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminUnitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminUnitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminUnit model
   */
  readonly fields: AdminUnitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminUnit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminUnitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    country<T extends CountryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CountryDefaultArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    adminUnitRisk<T extends AdminUnit$adminUnitRiskArgs<ExtArgs> = {}>(args?: Subset<T, AdminUnit$adminUnitRiskArgs<ExtArgs>>): Prisma__AdminUnitRiskClient<$Result.GetResult<Prisma.$AdminUnitRiskPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminUnit model
   */ 
  interface AdminUnitFieldRefs {
    readonly id: FieldRef<"AdminUnit", 'String'>
    readonly name: FieldRef<"AdminUnit", 'String'>
    readonly localName: FieldRef<"AdminUnit", 'String'>
    readonly type: FieldRef<"AdminUnit", 'String'>
    readonly region: FieldRef<"AdminUnit", 'String'>
    readonly countryId: FieldRef<"AdminUnit", 'String'>
    readonly population: FieldRef<"AdminUnit", 'Int'>
    readonly area: FieldRef<"AdminUnit", 'Float'>
    readonly elevation: FieldRef<"AdminUnit", 'Float'>
    readonly coordinates: FieldRef<"AdminUnit", 'String'>
    readonly createdAt: FieldRef<"AdminUnit", 'DateTime'>
    readonly updatedAt: FieldRef<"AdminUnit", 'DateTime'>
    readonly isActive: FieldRef<"AdminUnit", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * AdminUnit findUnique
   */
  export type AdminUnitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUnit
     */
    select?: AdminUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUnitInclude<ExtArgs> | null
    /**
     * Filter, which AdminUnit to fetch.
     */
    where: AdminUnitWhereUniqueInput
  }

  /**
   * AdminUnit findUniqueOrThrow
   */
  export type AdminUnitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUnit
     */
    select?: AdminUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUnitInclude<ExtArgs> | null
    /**
     * Filter, which AdminUnit to fetch.
     */
    where: AdminUnitWhereUniqueInput
  }

  /**
   * AdminUnit findFirst
   */
  export type AdminUnitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUnit
     */
    select?: AdminUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUnitInclude<ExtArgs> | null
    /**
     * Filter, which AdminUnit to fetch.
     */
    where?: AdminUnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminUnits to fetch.
     */
    orderBy?: AdminUnitOrderByWithRelationInput | AdminUnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminUnits.
     */
    cursor?: AdminUnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminUnits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminUnits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminUnits.
     */
    distinct?: AdminUnitScalarFieldEnum | AdminUnitScalarFieldEnum[]
  }

  /**
   * AdminUnit findFirstOrThrow
   */
  export type AdminUnitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUnit
     */
    select?: AdminUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUnitInclude<ExtArgs> | null
    /**
     * Filter, which AdminUnit to fetch.
     */
    where?: AdminUnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminUnits to fetch.
     */
    orderBy?: AdminUnitOrderByWithRelationInput | AdminUnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminUnits.
     */
    cursor?: AdminUnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminUnits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminUnits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminUnits.
     */
    distinct?: AdminUnitScalarFieldEnum | AdminUnitScalarFieldEnum[]
  }

  /**
   * AdminUnit findMany
   */
  export type AdminUnitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUnit
     */
    select?: AdminUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUnitInclude<ExtArgs> | null
    /**
     * Filter, which AdminUnits to fetch.
     */
    where?: AdminUnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminUnits to fetch.
     */
    orderBy?: AdminUnitOrderByWithRelationInput | AdminUnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminUnits.
     */
    cursor?: AdminUnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminUnits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminUnits.
     */
    skip?: number
    distinct?: AdminUnitScalarFieldEnum | AdminUnitScalarFieldEnum[]
  }

  /**
   * AdminUnit create
   */
  export type AdminUnitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUnit
     */
    select?: AdminUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUnitInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminUnit.
     */
    data: XOR<AdminUnitCreateInput, AdminUnitUncheckedCreateInput>
  }

  /**
   * AdminUnit createMany
   */
  export type AdminUnitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminUnits.
     */
    data: AdminUnitCreateManyInput | AdminUnitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminUnit createManyAndReturn
   */
  export type AdminUnitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUnit
     */
    select?: AdminUnitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AdminUnits.
     */
    data: AdminUnitCreateManyInput | AdminUnitCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUnitIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminUnit update
   */
  export type AdminUnitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUnit
     */
    select?: AdminUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUnitInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminUnit.
     */
    data: XOR<AdminUnitUpdateInput, AdminUnitUncheckedUpdateInput>
    /**
     * Choose, which AdminUnit to update.
     */
    where: AdminUnitWhereUniqueInput
  }

  /**
   * AdminUnit updateMany
   */
  export type AdminUnitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminUnits.
     */
    data: XOR<AdminUnitUpdateManyMutationInput, AdminUnitUncheckedUpdateManyInput>
    /**
     * Filter which AdminUnits to update
     */
    where?: AdminUnitWhereInput
  }

  /**
   * AdminUnit upsert
   */
  export type AdminUnitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUnit
     */
    select?: AdminUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUnitInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminUnit to update in case it exists.
     */
    where: AdminUnitWhereUniqueInput
    /**
     * In case the AdminUnit found by the `where` argument doesn't exist, create a new AdminUnit with this data.
     */
    create: XOR<AdminUnitCreateInput, AdminUnitUncheckedCreateInput>
    /**
     * In case the AdminUnit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUnitUpdateInput, AdminUnitUncheckedUpdateInput>
  }

  /**
   * AdminUnit delete
   */
  export type AdminUnitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUnit
     */
    select?: AdminUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUnitInclude<ExtArgs> | null
    /**
     * Filter which AdminUnit to delete.
     */
    where: AdminUnitWhereUniqueInput
  }

  /**
   * AdminUnit deleteMany
   */
  export type AdminUnitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminUnits to delete
     */
    where?: AdminUnitWhereInput
  }

  /**
   * AdminUnit.adminUnitRisk
   */
  export type AdminUnit$adminUnitRiskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUnitRisk
     */
    select?: AdminUnitRiskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUnitRiskInclude<ExtArgs> | null
    where?: AdminUnitRiskWhereInput
  }

  /**
   * AdminUnit without action
   */
  export type AdminUnitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUnit
     */
    select?: AdminUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUnitInclude<ExtArgs> | null
  }


  /**
   * Model Parish
   */

  export type AggregateParish = {
    _count: ParishCountAggregateOutputType | null
    _avg: ParishAvgAggregateOutputType | null
    _sum: ParishSumAggregateOutputType | null
    _min: ParishMinAggregateOutputType | null
    _max: ParishMaxAggregateOutputType | null
  }

  export type ParishAvgAggregateOutputType = {
    population: number | null
    area: number | null
    elevation: number | null
  }

  export type ParishSumAggregateOutputType = {
    population: number | null
    area: number | null
    elevation: number | null
  }

  export type ParishMinAggregateOutputType = {
    id: string | null
    name: string | null
    region: string | null
    countryCode: string | null
    population: number | null
    area: number | null
    elevation: number | null
    coordinates: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isActive: boolean | null
  }

  export type ParishMaxAggregateOutputType = {
    id: string | null
    name: string | null
    region: string | null
    countryCode: string | null
    population: number | null
    area: number | null
    elevation: number | null
    coordinates: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isActive: boolean | null
  }

  export type ParishCountAggregateOutputType = {
    id: number
    name: number
    region: number
    countryCode: number
    population: number
    area: number
    elevation: number
    coordinates: number
    createdAt: number
    updatedAt: number
    isActive: number
    _all: number
  }


  export type ParishAvgAggregateInputType = {
    population?: true
    area?: true
    elevation?: true
  }

  export type ParishSumAggregateInputType = {
    population?: true
    area?: true
    elevation?: true
  }

  export type ParishMinAggregateInputType = {
    id?: true
    name?: true
    region?: true
    countryCode?: true
    population?: true
    area?: true
    elevation?: true
    coordinates?: true
    createdAt?: true
    updatedAt?: true
    isActive?: true
  }

  export type ParishMaxAggregateInputType = {
    id?: true
    name?: true
    region?: true
    countryCode?: true
    population?: true
    area?: true
    elevation?: true
    coordinates?: true
    createdAt?: true
    updatedAt?: true
    isActive?: true
  }

  export type ParishCountAggregateInputType = {
    id?: true
    name?: true
    region?: true
    countryCode?: true
    population?: true
    area?: true
    elevation?: true
    coordinates?: true
    createdAt?: true
    updatedAt?: true
    isActive?: true
    _all?: true
  }

  export type ParishAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Parish to aggregate.
     */
    where?: ParishWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parishes to fetch.
     */
    orderBy?: ParishOrderByWithRelationInput | ParishOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ParishWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parishes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parishes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Parishes
    **/
    _count?: true | ParishCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ParishAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ParishSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParishMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParishMaxAggregateInputType
  }

  export type GetParishAggregateType<T extends ParishAggregateArgs> = {
        [P in keyof T & keyof AggregateParish]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParish[P]>
      : GetScalarType<T[P], AggregateParish[P]>
  }




  export type ParishGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParishWhereInput
    orderBy?: ParishOrderByWithAggregationInput | ParishOrderByWithAggregationInput[]
    by: ParishScalarFieldEnum[] | ParishScalarFieldEnum
    having?: ParishScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParishCountAggregateInputType | true
    _avg?: ParishAvgAggregateInputType
    _sum?: ParishSumAggregateInputType
    _min?: ParishMinAggregateInputType
    _max?: ParishMaxAggregateInputType
  }

  export type ParishGroupByOutputType = {
    id: string
    name: string
    region: string
    countryCode: string
    population: number
    area: number | null
    elevation: number | null
    coordinates: string | null
    createdAt: Date
    updatedAt: Date
    isActive: boolean
    _count: ParishCountAggregateOutputType | null
    _avg: ParishAvgAggregateOutputType | null
    _sum: ParishSumAggregateOutputType | null
    _min: ParishMinAggregateOutputType | null
    _max: ParishMaxAggregateOutputType | null
  }

  type GetParishGroupByPayload<T extends ParishGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParishGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParishGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParishGroupByOutputType[P]>
            : GetScalarType<T[P], ParishGroupByOutputType[P]>
        }
      >
    >


  export type ParishSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    region?: boolean
    countryCode?: boolean
    population?: boolean
    area?: boolean
    elevation?: boolean
    coordinates?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isActive?: boolean
    parishRisk?: boolean | Parish$parishRiskArgs<ExtArgs>
    businessRiskProfiles?: boolean | Parish$businessRiskProfilesArgs<ExtArgs>
    _count?: boolean | ParishCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parish"]>

  export type ParishSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    region?: boolean
    countryCode?: boolean
    population?: boolean
    area?: boolean
    elevation?: boolean
    coordinates?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["parish"]>

  export type ParishSelectScalar = {
    id?: boolean
    name?: boolean
    region?: boolean
    countryCode?: boolean
    population?: boolean
    area?: boolean
    elevation?: boolean
    coordinates?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isActive?: boolean
  }

  export type ParishInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parishRisk?: boolean | Parish$parishRiskArgs<ExtArgs>
    businessRiskProfiles?: boolean | Parish$businessRiskProfilesArgs<ExtArgs>
    _count?: boolean | ParishCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ParishIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ParishPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Parish"
    objects: {
      parishRisk: Prisma.$ParishRiskPayload<ExtArgs> | null
      businessRiskProfiles: Prisma.$BusinessRiskProfilePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      region: string
      countryCode: string
      population: number
      area: number | null
      elevation: number | null
      coordinates: string | null
      createdAt: Date
      updatedAt: Date
      isActive: boolean
    }, ExtArgs["result"]["parish"]>
    composites: {}
  }

  type ParishGetPayload<S extends boolean | null | undefined | ParishDefaultArgs> = $Result.GetResult<Prisma.$ParishPayload, S>

  type ParishCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ParishFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ParishCountAggregateInputType | true
    }

  export interface ParishDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Parish'], meta: { name: 'Parish' } }
    /**
     * Find zero or one Parish that matches the filter.
     * @param {ParishFindUniqueArgs} args - Arguments to find a Parish
     * @example
     * // Get one Parish
     * const parish = await prisma.parish.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ParishFindUniqueArgs>(args: SelectSubset<T, ParishFindUniqueArgs<ExtArgs>>): Prisma__ParishClient<$Result.GetResult<Prisma.$ParishPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Parish that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ParishFindUniqueOrThrowArgs} args - Arguments to find a Parish
     * @example
     * // Get one Parish
     * const parish = await prisma.parish.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ParishFindUniqueOrThrowArgs>(args: SelectSubset<T, ParishFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ParishClient<$Result.GetResult<Prisma.$ParishPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Parish that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParishFindFirstArgs} args - Arguments to find a Parish
     * @example
     * // Get one Parish
     * const parish = await prisma.parish.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ParishFindFirstArgs>(args?: SelectSubset<T, ParishFindFirstArgs<ExtArgs>>): Prisma__ParishClient<$Result.GetResult<Prisma.$ParishPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Parish that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParishFindFirstOrThrowArgs} args - Arguments to find a Parish
     * @example
     * // Get one Parish
     * const parish = await prisma.parish.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ParishFindFirstOrThrowArgs>(args?: SelectSubset<T, ParishFindFirstOrThrowArgs<ExtArgs>>): Prisma__ParishClient<$Result.GetResult<Prisma.$ParishPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Parishes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParishFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Parishes
     * const parishes = await prisma.parish.findMany()
     * 
     * // Get first 10 Parishes
     * const parishes = await prisma.parish.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const parishWithIdOnly = await prisma.parish.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ParishFindManyArgs>(args?: SelectSubset<T, ParishFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParishPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Parish.
     * @param {ParishCreateArgs} args - Arguments to create a Parish.
     * @example
     * // Create one Parish
     * const Parish = await prisma.parish.create({
     *   data: {
     *     // ... data to create a Parish
     *   }
     * })
     * 
     */
    create<T extends ParishCreateArgs>(args: SelectSubset<T, ParishCreateArgs<ExtArgs>>): Prisma__ParishClient<$Result.GetResult<Prisma.$ParishPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Parishes.
     * @param {ParishCreateManyArgs} args - Arguments to create many Parishes.
     * @example
     * // Create many Parishes
     * const parish = await prisma.parish.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ParishCreateManyArgs>(args?: SelectSubset<T, ParishCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Parishes and returns the data saved in the database.
     * @param {ParishCreateManyAndReturnArgs} args - Arguments to create many Parishes.
     * @example
     * // Create many Parishes
     * const parish = await prisma.parish.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Parishes and only return the `id`
     * const parishWithIdOnly = await prisma.parish.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ParishCreateManyAndReturnArgs>(args?: SelectSubset<T, ParishCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParishPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Parish.
     * @param {ParishDeleteArgs} args - Arguments to delete one Parish.
     * @example
     * // Delete one Parish
     * const Parish = await prisma.parish.delete({
     *   where: {
     *     // ... filter to delete one Parish
     *   }
     * })
     * 
     */
    delete<T extends ParishDeleteArgs>(args: SelectSubset<T, ParishDeleteArgs<ExtArgs>>): Prisma__ParishClient<$Result.GetResult<Prisma.$ParishPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Parish.
     * @param {ParishUpdateArgs} args - Arguments to update one Parish.
     * @example
     * // Update one Parish
     * const parish = await prisma.parish.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ParishUpdateArgs>(args: SelectSubset<T, ParishUpdateArgs<ExtArgs>>): Prisma__ParishClient<$Result.GetResult<Prisma.$ParishPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Parishes.
     * @param {ParishDeleteManyArgs} args - Arguments to filter Parishes to delete.
     * @example
     * // Delete a few Parishes
     * const { count } = await prisma.parish.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ParishDeleteManyArgs>(args?: SelectSubset<T, ParishDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parishes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParishUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Parishes
     * const parish = await prisma.parish.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ParishUpdateManyArgs>(args: SelectSubset<T, ParishUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Parish.
     * @param {ParishUpsertArgs} args - Arguments to update or create a Parish.
     * @example
     * // Update or create a Parish
     * const parish = await prisma.parish.upsert({
     *   create: {
     *     // ... data to create a Parish
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Parish we want to update
     *   }
     * })
     */
    upsert<T extends ParishUpsertArgs>(args: SelectSubset<T, ParishUpsertArgs<ExtArgs>>): Prisma__ParishClient<$Result.GetResult<Prisma.$ParishPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Parishes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParishCountArgs} args - Arguments to filter Parishes to count.
     * @example
     * // Count the number of Parishes
     * const count = await prisma.parish.count({
     *   where: {
     *     // ... the filter for the Parishes we want to count
     *   }
     * })
    **/
    count<T extends ParishCountArgs>(
      args?: Subset<T, ParishCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParishCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Parish.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParishAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParishAggregateArgs>(args: Subset<T, ParishAggregateArgs>): Prisma.PrismaPromise<GetParishAggregateType<T>>

    /**
     * Group by Parish.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParishGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParishGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParishGroupByArgs['orderBy'] }
        : { orderBy?: ParishGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParishGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParishGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Parish model
   */
  readonly fields: ParishFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Parish.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ParishClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parishRisk<T extends Parish$parishRiskArgs<ExtArgs> = {}>(args?: Subset<T, Parish$parishRiskArgs<ExtArgs>>): Prisma__ParishRiskClient<$Result.GetResult<Prisma.$ParishRiskPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    businessRiskProfiles<T extends Parish$businessRiskProfilesArgs<ExtArgs> = {}>(args?: Subset<T, Parish$businessRiskProfilesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessRiskProfilePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Parish model
   */ 
  interface ParishFieldRefs {
    readonly id: FieldRef<"Parish", 'String'>
    readonly name: FieldRef<"Parish", 'String'>
    readonly region: FieldRef<"Parish", 'String'>
    readonly countryCode: FieldRef<"Parish", 'String'>
    readonly population: FieldRef<"Parish", 'Int'>
    readonly area: FieldRef<"Parish", 'Float'>
    readonly elevation: FieldRef<"Parish", 'Float'>
    readonly coordinates: FieldRef<"Parish", 'String'>
    readonly createdAt: FieldRef<"Parish", 'DateTime'>
    readonly updatedAt: FieldRef<"Parish", 'DateTime'>
    readonly isActive: FieldRef<"Parish", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Parish findUnique
   */
  export type ParishFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parish
     */
    select?: ParishSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParishInclude<ExtArgs> | null
    /**
     * Filter, which Parish to fetch.
     */
    where: ParishWhereUniqueInput
  }

  /**
   * Parish findUniqueOrThrow
   */
  export type ParishFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parish
     */
    select?: ParishSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParishInclude<ExtArgs> | null
    /**
     * Filter, which Parish to fetch.
     */
    where: ParishWhereUniqueInput
  }

  /**
   * Parish findFirst
   */
  export type ParishFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parish
     */
    select?: ParishSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParishInclude<ExtArgs> | null
    /**
     * Filter, which Parish to fetch.
     */
    where?: ParishWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parishes to fetch.
     */
    orderBy?: ParishOrderByWithRelationInput | ParishOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parishes.
     */
    cursor?: ParishWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parishes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parishes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parishes.
     */
    distinct?: ParishScalarFieldEnum | ParishScalarFieldEnum[]
  }

  /**
   * Parish findFirstOrThrow
   */
  export type ParishFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parish
     */
    select?: ParishSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParishInclude<ExtArgs> | null
    /**
     * Filter, which Parish to fetch.
     */
    where?: ParishWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parishes to fetch.
     */
    orderBy?: ParishOrderByWithRelationInput | ParishOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parishes.
     */
    cursor?: ParishWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parishes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parishes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parishes.
     */
    distinct?: ParishScalarFieldEnum | ParishScalarFieldEnum[]
  }

  /**
   * Parish findMany
   */
  export type ParishFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parish
     */
    select?: ParishSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParishInclude<ExtArgs> | null
    /**
     * Filter, which Parishes to fetch.
     */
    where?: ParishWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parishes to fetch.
     */
    orderBy?: ParishOrderByWithRelationInput | ParishOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Parishes.
     */
    cursor?: ParishWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parishes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parishes.
     */
    skip?: number
    distinct?: ParishScalarFieldEnum | ParishScalarFieldEnum[]
  }

  /**
   * Parish create
   */
  export type ParishCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parish
     */
    select?: ParishSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParishInclude<ExtArgs> | null
    /**
     * The data needed to create a Parish.
     */
    data: XOR<ParishCreateInput, ParishUncheckedCreateInput>
  }

  /**
   * Parish createMany
   */
  export type ParishCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Parishes.
     */
    data: ParishCreateManyInput | ParishCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Parish createManyAndReturn
   */
  export type ParishCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parish
     */
    select?: ParishSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Parishes.
     */
    data: ParishCreateManyInput | ParishCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Parish update
   */
  export type ParishUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parish
     */
    select?: ParishSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParishInclude<ExtArgs> | null
    /**
     * The data needed to update a Parish.
     */
    data: XOR<ParishUpdateInput, ParishUncheckedUpdateInput>
    /**
     * Choose, which Parish to update.
     */
    where: ParishWhereUniqueInput
  }

  /**
   * Parish updateMany
   */
  export type ParishUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Parishes.
     */
    data: XOR<ParishUpdateManyMutationInput, ParishUncheckedUpdateManyInput>
    /**
     * Filter which Parishes to update
     */
    where?: ParishWhereInput
  }

  /**
   * Parish upsert
   */
  export type ParishUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parish
     */
    select?: ParishSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParishInclude<ExtArgs> | null
    /**
     * The filter to search for the Parish to update in case it exists.
     */
    where: ParishWhereUniqueInput
    /**
     * In case the Parish found by the `where` argument doesn't exist, create a new Parish with this data.
     */
    create: XOR<ParishCreateInput, ParishUncheckedCreateInput>
    /**
     * In case the Parish was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ParishUpdateInput, ParishUncheckedUpdateInput>
  }

  /**
   * Parish delete
   */
  export type ParishDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parish
     */
    select?: ParishSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParishInclude<ExtArgs> | null
    /**
     * Filter which Parish to delete.
     */
    where: ParishWhereUniqueInput
  }

  /**
   * Parish deleteMany
   */
  export type ParishDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Parishes to delete
     */
    where?: ParishWhereInput
  }

  /**
   * Parish.parishRisk
   */
  export type Parish$parishRiskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParishRisk
     */
    select?: ParishRiskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParishRiskInclude<ExtArgs> | null
    where?: ParishRiskWhereInput
  }

  /**
   * Parish.businessRiskProfiles
   */
  export type Parish$businessRiskProfilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessRiskProfile
     */
    select?: BusinessRiskProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessRiskProfileInclude<ExtArgs> | null
    where?: BusinessRiskProfileWhereInput
    orderBy?: BusinessRiskProfileOrderByWithRelationInput | BusinessRiskProfileOrderByWithRelationInput[]
    cursor?: BusinessRiskProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BusinessRiskProfileScalarFieldEnum | BusinessRiskProfileScalarFieldEnum[]
  }

  /**
   * Parish without action
   */
  export type ParishDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parish
     */
    select?: ParishSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParishInclude<ExtArgs> | null
  }


  /**
   * Model AdminUnitRisk
   */

  export type AggregateAdminUnitRisk = {
    _count: AdminUnitRiskCountAggregateOutputType | null
    _avg: AdminUnitRiskAvgAggregateOutputType | null
    _sum: AdminUnitRiskSumAggregateOutputType | null
    _min: AdminUnitRiskMinAggregateOutputType | null
    _max: AdminUnitRiskMaxAggregateOutputType | null
  }

  export type AdminUnitRiskAvgAggregateOutputType = {
    hurricaneLevel: number | null
    floodLevel: number | null
    earthquakeLevel: number | null
    droughtLevel: number | null
    landslideLevel: number | null
    powerOutageLevel: number | null
  }

  export type AdminUnitRiskSumAggregateOutputType = {
    hurricaneLevel: number | null
    floodLevel: number | null
    earthquakeLevel: number | null
    droughtLevel: number | null
    landslideLevel: number | null
    powerOutageLevel: number | null
  }

  export type AdminUnitRiskMinAggregateOutputType = {
    id: string | null
    adminUnitId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lastUpdated: Date | null
    updatedBy: string | null
    hurricaneLevel: number | null
    hurricaneNotes: string | null
    floodLevel: number | null
    floodNotes: string | null
    earthquakeLevel: number | null
    earthquakeNotes: string | null
    droughtLevel: number | null
    droughtNotes: string | null
    landslideLevel: number | null
    landslideNotes: string | null
    powerOutageLevel: number | null
    powerOutageNotes: string | null
    riskProfileJson: string | null
    isActive: boolean | null
  }

  export type AdminUnitRiskMaxAggregateOutputType = {
    id: string | null
    adminUnitId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lastUpdated: Date | null
    updatedBy: string | null
    hurricaneLevel: number | null
    hurricaneNotes: string | null
    floodLevel: number | null
    floodNotes: string | null
    earthquakeLevel: number | null
    earthquakeNotes: string | null
    droughtLevel: number | null
    droughtNotes: string | null
    landslideLevel: number | null
    landslideNotes: string | null
    powerOutageLevel: number | null
    powerOutageNotes: string | null
    riskProfileJson: string | null
    isActive: boolean | null
  }

  export type AdminUnitRiskCountAggregateOutputType = {
    id: number
    adminUnitId: number
    createdAt: number
    updatedAt: number
    lastUpdated: number
    updatedBy: number
    hurricaneLevel: number
    hurricaneNotes: number
    floodLevel: number
    floodNotes: number
    earthquakeLevel: number
    earthquakeNotes: number
    droughtLevel: number
    droughtNotes: number
    landslideLevel: number
    landslideNotes: number
    powerOutageLevel: number
    powerOutageNotes: number
    riskProfileJson: number
    isActive: number
    _all: number
  }


  export type AdminUnitRiskAvgAggregateInputType = {
    hurricaneLevel?: true
    floodLevel?: true
    earthquakeLevel?: true
    droughtLevel?: true
    landslideLevel?: true
    powerOutageLevel?: true
  }

  export type AdminUnitRiskSumAggregateInputType = {
    hurricaneLevel?: true
    floodLevel?: true
    earthquakeLevel?: true
    droughtLevel?: true
    landslideLevel?: true
    powerOutageLevel?: true
  }

  export type AdminUnitRiskMinAggregateInputType = {
    id?: true
    adminUnitId?: true
    createdAt?: true
    updatedAt?: true
    lastUpdated?: true
    updatedBy?: true
    hurricaneLevel?: true
    hurricaneNotes?: true
    floodLevel?: true
    floodNotes?: true
    earthquakeLevel?: true
    earthquakeNotes?: true
    droughtLevel?: true
    droughtNotes?: true
    landslideLevel?: true
    landslideNotes?: true
    powerOutageLevel?: true
    powerOutageNotes?: true
    riskProfileJson?: true
    isActive?: true
  }

  export type AdminUnitRiskMaxAggregateInputType = {
    id?: true
    adminUnitId?: true
    createdAt?: true
    updatedAt?: true
    lastUpdated?: true
    updatedBy?: true
    hurricaneLevel?: true
    hurricaneNotes?: true
    floodLevel?: true
    floodNotes?: true
    earthquakeLevel?: true
    earthquakeNotes?: true
    droughtLevel?: true
    droughtNotes?: true
    landslideLevel?: true
    landslideNotes?: true
    powerOutageLevel?: true
    powerOutageNotes?: true
    riskProfileJson?: true
    isActive?: true
  }

  export type AdminUnitRiskCountAggregateInputType = {
    id?: true
    adminUnitId?: true
    createdAt?: true
    updatedAt?: true
    lastUpdated?: true
    updatedBy?: true
    hurricaneLevel?: true
    hurricaneNotes?: true
    floodLevel?: true
    floodNotes?: true
    earthquakeLevel?: true
    earthquakeNotes?: true
    droughtLevel?: true
    droughtNotes?: true
    landslideLevel?: true
    landslideNotes?: true
    powerOutageLevel?: true
    powerOutageNotes?: true
    riskProfileJson?: true
    isActive?: true
    _all?: true
  }

  export type AdminUnitRiskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminUnitRisk to aggregate.
     */
    where?: AdminUnitRiskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminUnitRisks to fetch.
     */
    orderBy?: AdminUnitRiskOrderByWithRelationInput | AdminUnitRiskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminUnitRiskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminUnitRisks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminUnitRisks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminUnitRisks
    **/
    _count?: true | AdminUnitRiskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminUnitRiskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminUnitRiskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminUnitRiskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminUnitRiskMaxAggregateInputType
  }

  export type GetAdminUnitRiskAggregateType<T extends AdminUnitRiskAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminUnitRisk]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminUnitRisk[P]>
      : GetScalarType<T[P], AggregateAdminUnitRisk[P]>
  }




  export type AdminUnitRiskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminUnitRiskWhereInput
    orderBy?: AdminUnitRiskOrderByWithAggregationInput | AdminUnitRiskOrderByWithAggregationInput[]
    by: AdminUnitRiskScalarFieldEnum[] | AdminUnitRiskScalarFieldEnum
    having?: AdminUnitRiskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminUnitRiskCountAggregateInputType | true
    _avg?: AdminUnitRiskAvgAggregateInputType
    _sum?: AdminUnitRiskSumAggregateInputType
    _min?: AdminUnitRiskMinAggregateInputType
    _max?: AdminUnitRiskMaxAggregateInputType
  }

  export type AdminUnitRiskGroupByOutputType = {
    id: string
    adminUnitId: string
    createdAt: Date
    updatedAt: Date
    lastUpdated: Date
    updatedBy: string
    hurricaneLevel: number
    hurricaneNotes: string
    floodLevel: number
    floodNotes: string
    earthquakeLevel: number
    earthquakeNotes: string
    droughtLevel: number
    droughtNotes: string
    landslideLevel: number
    landslideNotes: string
    powerOutageLevel: number
    powerOutageNotes: string
    riskProfileJson: string
    isActive: boolean
    _count: AdminUnitRiskCountAggregateOutputType | null
    _avg: AdminUnitRiskAvgAggregateOutputType | null
    _sum: AdminUnitRiskSumAggregateOutputType | null
    _min: AdminUnitRiskMinAggregateOutputType | null
    _max: AdminUnitRiskMaxAggregateOutputType | null
  }

  type GetAdminUnitRiskGroupByPayload<T extends AdminUnitRiskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminUnitRiskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminUnitRiskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminUnitRiskGroupByOutputType[P]>
            : GetScalarType<T[P], AdminUnitRiskGroupByOutputType[P]>
        }
      >
    >


  export type AdminUnitRiskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminUnitId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastUpdated?: boolean
    updatedBy?: boolean
    hurricaneLevel?: boolean
    hurricaneNotes?: boolean
    floodLevel?: boolean
    floodNotes?: boolean
    earthquakeLevel?: boolean
    earthquakeNotes?: boolean
    droughtLevel?: boolean
    droughtNotes?: boolean
    landslideLevel?: boolean
    landslideNotes?: boolean
    powerOutageLevel?: boolean
    powerOutageNotes?: boolean
    riskProfileJson?: boolean
    isActive?: boolean
    adminUnit?: boolean | AdminUnitDefaultArgs<ExtArgs>
    changeLogs?: boolean | AdminUnitRisk$changeLogsArgs<ExtArgs>
    _count?: boolean | AdminUnitRiskCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminUnitRisk"]>

  export type AdminUnitRiskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminUnitId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastUpdated?: boolean
    updatedBy?: boolean
    hurricaneLevel?: boolean
    hurricaneNotes?: boolean
    floodLevel?: boolean
    floodNotes?: boolean
    earthquakeLevel?: boolean
    earthquakeNotes?: boolean
    droughtLevel?: boolean
    droughtNotes?: boolean
    landslideLevel?: boolean
    landslideNotes?: boolean
    powerOutageLevel?: boolean
    powerOutageNotes?: boolean
    riskProfileJson?: boolean
    isActive?: boolean
    adminUnit?: boolean | AdminUnitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminUnitRisk"]>

  export type AdminUnitRiskSelectScalar = {
    id?: boolean
    adminUnitId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastUpdated?: boolean
    updatedBy?: boolean
    hurricaneLevel?: boolean
    hurricaneNotes?: boolean
    floodLevel?: boolean
    floodNotes?: boolean
    earthquakeLevel?: boolean
    earthquakeNotes?: boolean
    droughtLevel?: boolean
    droughtNotes?: boolean
    landslideLevel?: boolean
    landslideNotes?: boolean
    powerOutageLevel?: boolean
    powerOutageNotes?: boolean
    riskProfileJson?: boolean
    isActive?: boolean
  }

  export type AdminUnitRiskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    adminUnit?: boolean | AdminUnitDefaultArgs<ExtArgs>
    changeLogs?: boolean | AdminUnitRisk$changeLogsArgs<ExtArgs>
    _count?: boolean | AdminUnitRiskCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AdminUnitRiskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    adminUnit?: boolean | AdminUnitDefaultArgs<ExtArgs>
  }

  export type $AdminUnitRiskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminUnitRisk"
    objects: {
      adminUnit: Prisma.$AdminUnitPayload<ExtArgs>
      changeLogs: Prisma.$AdminUnitRiskChangeLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      adminUnitId: string
      createdAt: Date
      updatedAt: Date
      lastUpdated: Date
      updatedBy: string
      hurricaneLevel: number
      hurricaneNotes: string
      floodLevel: number
      floodNotes: string
      earthquakeLevel: number
      earthquakeNotes: string
      droughtLevel: number
      droughtNotes: string
      landslideLevel: number
      landslideNotes: string
      powerOutageLevel: number
      powerOutageNotes: string
      riskProfileJson: string
      isActive: boolean
    }, ExtArgs["result"]["adminUnitRisk"]>
    composites: {}
  }

  type AdminUnitRiskGetPayload<S extends boolean | null | undefined | AdminUnitRiskDefaultArgs> = $Result.GetResult<Prisma.$AdminUnitRiskPayload, S>

  type AdminUnitRiskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdminUnitRiskFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdminUnitRiskCountAggregateInputType | true
    }

  export interface AdminUnitRiskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminUnitRisk'], meta: { name: 'AdminUnitRisk' } }
    /**
     * Find zero or one AdminUnitRisk that matches the filter.
     * @param {AdminUnitRiskFindUniqueArgs} args - Arguments to find a AdminUnitRisk
     * @example
     * // Get one AdminUnitRisk
     * const adminUnitRisk = await prisma.adminUnitRisk.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminUnitRiskFindUniqueArgs>(args: SelectSubset<T, AdminUnitRiskFindUniqueArgs<ExtArgs>>): Prisma__AdminUnitRiskClient<$Result.GetResult<Prisma.$AdminUnitRiskPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AdminUnitRisk that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdminUnitRiskFindUniqueOrThrowArgs} args - Arguments to find a AdminUnitRisk
     * @example
     * // Get one AdminUnitRisk
     * const adminUnitRisk = await prisma.adminUnitRisk.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminUnitRiskFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminUnitRiskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminUnitRiskClient<$Result.GetResult<Prisma.$AdminUnitRiskPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AdminUnitRisk that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUnitRiskFindFirstArgs} args - Arguments to find a AdminUnitRisk
     * @example
     * // Get one AdminUnitRisk
     * const adminUnitRisk = await prisma.adminUnitRisk.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminUnitRiskFindFirstArgs>(args?: SelectSubset<T, AdminUnitRiskFindFirstArgs<ExtArgs>>): Prisma__AdminUnitRiskClient<$Result.GetResult<Prisma.$AdminUnitRiskPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AdminUnitRisk that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUnitRiskFindFirstOrThrowArgs} args - Arguments to find a AdminUnitRisk
     * @example
     * // Get one AdminUnitRisk
     * const adminUnitRisk = await prisma.adminUnitRisk.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminUnitRiskFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminUnitRiskFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminUnitRiskClient<$Result.GetResult<Prisma.$AdminUnitRiskPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AdminUnitRisks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUnitRiskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminUnitRisks
     * const adminUnitRisks = await prisma.adminUnitRisk.findMany()
     * 
     * // Get first 10 AdminUnitRisks
     * const adminUnitRisks = await prisma.adminUnitRisk.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminUnitRiskWithIdOnly = await prisma.adminUnitRisk.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminUnitRiskFindManyArgs>(args?: SelectSubset<T, AdminUnitRiskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminUnitRiskPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AdminUnitRisk.
     * @param {AdminUnitRiskCreateArgs} args - Arguments to create a AdminUnitRisk.
     * @example
     * // Create one AdminUnitRisk
     * const AdminUnitRisk = await prisma.adminUnitRisk.create({
     *   data: {
     *     // ... data to create a AdminUnitRisk
     *   }
     * })
     * 
     */
    create<T extends AdminUnitRiskCreateArgs>(args: SelectSubset<T, AdminUnitRiskCreateArgs<ExtArgs>>): Prisma__AdminUnitRiskClient<$Result.GetResult<Prisma.$AdminUnitRiskPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AdminUnitRisks.
     * @param {AdminUnitRiskCreateManyArgs} args - Arguments to create many AdminUnitRisks.
     * @example
     * // Create many AdminUnitRisks
     * const adminUnitRisk = await prisma.adminUnitRisk.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminUnitRiskCreateManyArgs>(args?: SelectSubset<T, AdminUnitRiskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminUnitRisks and returns the data saved in the database.
     * @param {AdminUnitRiskCreateManyAndReturnArgs} args - Arguments to create many AdminUnitRisks.
     * @example
     * // Create many AdminUnitRisks
     * const adminUnitRisk = await prisma.adminUnitRisk.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminUnitRisks and only return the `id`
     * const adminUnitRiskWithIdOnly = await prisma.adminUnitRisk.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminUnitRiskCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminUnitRiskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminUnitRiskPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AdminUnitRisk.
     * @param {AdminUnitRiskDeleteArgs} args - Arguments to delete one AdminUnitRisk.
     * @example
     * // Delete one AdminUnitRisk
     * const AdminUnitRisk = await prisma.adminUnitRisk.delete({
     *   where: {
     *     // ... filter to delete one AdminUnitRisk
     *   }
     * })
     * 
     */
    delete<T extends AdminUnitRiskDeleteArgs>(args: SelectSubset<T, AdminUnitRiskDeleteArgs<ExtArgs>>): Prisma__AdminUnitRiskClient<$Result.GetResult<Prisma.$AdminUnitRiskPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AdminUnitRisk.
     * @param {AdminUnitRiskUpdateArgs} args - Arguments to update one AdminUnitRisk.
     * @example
     * // Update one AdminUnitRisk
     * const adminUnitRisk = await prisma.adminUnitRisk.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminUnitRiskUpdateArgs>(args: SelectSubset<T, AdminUnitRiskUpdateArgs<ExtArgs>>): Prisma__AdminUnitRiskClient<$Result.GetResult<Prisma.$AdminUnitRiskPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AdminUnitRisks.
     * @param {AdminUnitRiskDeleteManyArgs} args - Arguments to filter AdminUnitRisks to delete.
     * @example
     * // Delete a few AdminUnitRisks
     * const { count } = await prisma.adminUnitRisk.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminUnitRiskDeleteManyArgs>(args?: SelectSubset<T, AdminUnitRiskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminUnitRisks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUnitRiskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminUnitRisks
     * const adminUnitRisk = await prisma.adminUnitRisk.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminUnitRiskUpdateManyArgs>(args: SelectSubset<T, AdminUnitRiskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AdminUnitRisk.
     * @param {AdminUnitRiskUpsertArgs} args - Arguments to update or create a AdminUnitRisk.
     * @example
     * // Update or create a AdminUnitRisk
     * const adminUnitRisk = await prisma.adminUnitRisk.upsert({
     *   create: {
     *     // ... data to create a AdminUnitRisk
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminUnitRisk we want to update
     *   }
     * })
     */
    upsert<T extends AdminUnitRiskUpsertArgs>(args: SelectSubset<T, AdminUnitRiskUpsertArgs<ExtArgs>>): Prisma__AdminUnitRiskClient<$Result.GetResult<Prisma.$AdminUnitRiskPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AdminUnitRisks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUnitRiskCountArgs} args - Arguments to filter AdminUnitRisks to count.
     * @example
     * // Count the number of AdminUnitRisks
     * const count = await prisma.adminUnitRisk.count({
     *   where: {
     *     // ... the filter for the AdminUnitRisks we want to count
     *   }
     * })
    **/
    count<T extends AdminUnitRiskCountArgs>(
      args?: Subset<T, AdminUnitRiskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminUnitRiskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminUnitRisk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUnitRiskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminUnitRiskAggregateArgs>(args: Subset<T, AdminUnitRiskAggregateArgs>): Prisma.PrismaPromise<GetAdminUnitRiskAggregateType<T>>

    /**
     * Group by AdminUnitRisk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUnitRiskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminUnitRiskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminUnitRiskGroupByArgs['orderBy'] }
        : { orderBy?: AdminUnitRiskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminUnitRiskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminUnitRiskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminUnitRisk model
   */
  readonly fields: AdminUnitRiskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminUnitRisk.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminUnitRiskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    adminUnit<T extends AdminUnitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminUnitDefaultArgs<ExtArgs>>): Prisma__AdminUnitClient<$Result.GetResult<Prisma.$AdminUnitPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    changeLogs<T extends AdminUnitRisk$changeLogsArgs<ExtArgs> = {}>(args?: Subset<T, AdminUnitRisk$changeLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminUnitRiskChangeLogPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminUnitRisk model
   */ 
  interface AdminUnitRiskFieldRefs {
    readonly id: FieldRef<"AdminUnitRisk", 'String'>
    readonly adminUnitId: FieldRef<"AdminUnitRisk", 'String'>
    readonly createdAt: FieldRef<"AdminUnitRisk", 'DateTime'>
    readonly updatedAt: FieldRef<"AdminUnitRisk", 'DateTime'>
    readonly lastUpdated: FieldRef<"AdminUnitRisk", 'DateTime'>
    readonly updatedBy: FieldRef<"AdminUnitRisk", 'String'>
    readonly hurricaneLevel: FieldRef<"AdminUnitRisk", 'Int'>
    readonly hurricaneNotes: FieldRef<"AdminUnitRisk", 'String'>
    readonly floodLevel: FieldRef<"AdminUnitRisk", 'Int'>
    readonly floodNotes: FieldRef<"AdminUnitRisk", 'String'>
    readonly earthquakeLevel: FieldRef<"AdminUnitRisk", 'Int'>
    readonly earthquakeNotes: FieldRef<"AdminUnitRisk", 'String'>
    readonly droughtLevel: FieldRef<"AdminUnitRisk", 'Int'>
    readonly droughtNotes: FieldRef<"AdminUnitRisk", 'String'>
    readonly landslideLevel: FieldRef<"AdminUnitRisk", 'Int'>
    readonly landslideNotes: FieldRef<"AdminUnitRisk", 'String'>
    readonly powerOutageLevel: FieldRef<"AdminUnitRisk", 'Int'>
    readonly powerOutageNotes: FieldRef<"AdminUnitRisk", 'String'>
    readonly riskProfileJson: FieldRef<"AdminUnitRisk", 'String'>
    readonly isActive: FieldRef<"AdminUnitRisk", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * AdminUnitRisk findUnique
   */
  export type AdminUnitRiskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUnitRisk
     */
    select?: AdminUnitRiskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUnitRiskInclude<ExtArgs> | null
    /**
     * Filter, which AdminUnitRisk to fetch.
     */
    where: AdminUnitRiskWhereUniqueInput
  }

  /**
   * AdminUnitRisk findUniqueOrThrow
   */
  export type AdminUnitRiskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUnitRisk
     */
    select?: AdminUnitRiskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUnitRiskInclude<ExtArgs> | null
    /**
     * Filter, which AdminUnitRisk to fetch.
     */
    where: AdminUnitRiskWhereUniqueInput
  }

  /**
   * AdminUnitRisk findFirst
   */
  export type AdminUnitRiskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUnitRisk
     */
    select?: AdminUnitRiskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUnitRiskInclude<ExtArgs> | null
    /**
     * Filter, which AdminUnitRisk to fetch.
     */
    where?: AdminUnitRiskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminUnitRisks to fetch.
     */
    orderBy?: AdminUnitRiskOrderByWithRelationInput | AdminUnitRiskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminUnitRisks.
     */
    cursor?: AdminUnitRiskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminUnitRisks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminUnitRisks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminUnitRisks.
     */
    distinct?: AdminUnitRiskScalarFieldEnum | AdminUnitRiskScalarFieldEnum[]
  }

  /**
   * AdminUnitRisk findFirstOrThrow
   */
  export type AdminUnitRiskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUnitRisk
     */
    select?: AdminUnitRiskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUnitRiskInclude<ExtArgs> | null
    /**
     * Filter, which AdminUnitRisk to fetch.
     */
    where?: AdminUnitRiskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminUnitRisks to fetch.
     */
    orderBy?: AdminUnitRiskOrderByWithRelationInput | AdminUnitRiskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminUnitRisks.
     */
    cursor?: AdminUnitRiskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminUnitRisks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminUnitRisks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminUnitRisks.
     */
    distinct?: AdminUnitRiskScalarFieldEnum | AdminUnitRiskScalarFieldEnum[]
  }

  /**
   * AdminUnitRisk findMany
   */
  export type AdminUnitRiskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUnitRisk
     */
    select?: AdminUnitRiskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUnitRiskInclude<ExtArgs> | null
    /**
     * Filter, which AdminUnitRisks to fetch.
     */
    where?: AdminUnitRiskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminUnitRisks to fetch.
     */
    orderBy?: AdminUnitRiskOrderByWithRelationInput | AdminUnitRiskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminUnitRisks.
     */
    cursor?: AdminUnitRiskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminUnitRisks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminUnitRisks.
     */
    skip?: number
    distinct?: AdminUnitRiskScalarFieldEnum | AdminUnitRiskScalarFieldEnum[]
  }

  /**
   * AdminUnitRisk create
   */
  export type AdminUnitRiskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUnitRisk
     */
    select?: AdminUnitRiskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUnitRiskInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminUnitRisk.
     */
    data: XOR<AdminUnitRiskCreateInput, AdminUnitRiskUncheckedCreateInput>
  }

  /**
   * AdminUnitRisk createMany
   */
  export type AdminUnitRiskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminUnitRisks.
     */
    data: AdminUnitRiskCreateManyInput | AdminUnitRiskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminUnitRisk createManyAndReturn
   */
  export type AdminUnitRiskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUnitRisk
     */
    select?: AdminUnitRiskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AdminUnitRisks.
     */
    data: AdminUnitRiskCreateManyInput | AdminUnitRiskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUnitRiskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminUnitRisk update
   */
  export type AdminUnitRiskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUnitRisk
     */
    select?: AdminUnitRiskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUnitRiskInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminUnitRisk.
     */
    data: XOR<AdminUnitRiskUpdateInput, AdminUnitRiskUncheckedUpdateInput>
    /**
     * Choose, which AdminUnitRisk to update.
     */
    where: AdminUnitRiskWhereUniqueInput
  }

  /**
   * AdminUnitRisk updateMany
   */
  export type AdminUnitRiskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminUnitRisks.
     */
    data: XOR<AdminUnitRiskUpdateManyMutationInput, AdminUnitRiskUncheckedUpdateManyInput>
    /**
     * Filter which AdminUnitRisks to update
     */
    where?: AdminUnitRiskWhereInput
  }

  /**
   * AdminUnitRisk upsert
   */
  export type AdminUnitRiskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUnitRisk
     */
    select?: AdminUnitRiskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUnitRiskInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminUnitRisk to update in case it exists.
     */
    where: AdminUnitRiskWhereUniqueInput
    /**
     * In case the AdminUnitRisk found by the `where` argument doesn't exist, create a new AdminUnitRisk with this data.
     */
    create: XOR<AdminUnitRiskCreateInput, AdminUnitRiskUncheckedCreateInput>
    /**
     * In case the AdminUnitRisk was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUnitRiskUpdateInput, AdminUnitRiskUncheckedUpdateInput>
  }

  /**
   * AdminUnitRisk delete
   */
  export type AdminUnitRiskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUnitRisk
     */
    select?: AdminUnitRiskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUnitRiskInclude<ExtArgs> | null
    /**
     * Filter which AdminUnitRisk to delete.
     */
    where: AdminUnitRiskWhereUniqueInput
  }

  /**
   * AdminUnitRisk deleteMany
   */
  export type AdminUnitRiskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminUnitRisks to delete
     */
    where?: AdminUnitRiskWhereInput
  }

  /**
   * AdminUnitRisk.changeLogs
   */
  export type AdminUnitRisk$changeLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUnitRiskChangeLog
     */
    select?: AdminUnitRiskChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUnitRiskChangeLogInclude<ExtArgs> | null
    where?: AdminUnitRiskChangeLogWhereInput
    orderBy?: AdminUnitRiskChangeLogOrderByWithRelationInput | AdminUnitRiskChangeLogOrderByWithRelationInput[]
    cursor?: AdminUnitRiskChangeLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminUnitRiskChangeLogScalarFieldEnum | AdminUnitRiskChangeLogScalarFieldEnum[]
  }

  /**
   * AdminUnitRisk without action
   */
  export type AdminUnitRiskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUnitRisk
     */
    select?: AdminUnitRiskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUnitRiskInclude<ExtArgs> | null
  }


  /**
   * Model AdminUnitRiskChangeLog
   */

  export type AggregateAdminUnitRiskChangeLog = {
    _count: AdminUnitRiskChangeLogCountAggregateOutputType | null
    _avg: AdminUnitRiskChangeLogAvgAggregateOutputType | null
    _sum: AdminUnitRiskChangeLogSumAggregateOutputType | null
    _min: AdminUnitRiskChangeLogMinAggregateOutputType | null
    _max: AdminUnitRiskChangeLogMaxAggregateOutputType | null
  }

  export type AdminUnitRiskChangeLogAvgAggregateOutputType = {
    oldLevel: number | null
    newLevel: number | null
  }

  export type AdminUnitRiskChangeLogSumAggregateOutputType = {
    oldLevel: number | null
    newLevel: number | null
  }

  export type AdminUnitRiskChangeLogMinAggregateOutputType = {
    id: string | null
    adminUnitRiskId: string | null
    riskType: string | null
    oldLevel: number | null
    newLevel: number | null
    oldNotes: string | null
    newNotes: string | null
    changedBy: string | null
    changeReason: string | null
    createdAt: Date | null
  }

  export type AdminUnitRiskChangeLogMaxAggregateOutputType = {
    id: string | null
    adminUnitRiskId: string | null
    riskType: string | null
    oldLevel: number | null
    newLevel: number | null
    oldNotes: string | null
    newNotes: string | null
    changedBy: string | null
    changeReason: string | null
    createdAt: Date | null
  }

  export type AdminUnitRiskChangeLogCountAggregateOutputType = {
    id: number
    adminUnitRiskId: number
    riskType: number
    oldLevel: number
    newLevel: number
    oldNotes: number
    newNotes: number
    changedBy: number
    changeReason: number
    createdAt: number
    _all: number
  }


  export type AdminUnitRiskChangeLogAvgAggregateInputType = {
    oldLevel?: true
    newLevel?: true
  }

  export type AdminUnitRiskChangeLogSumAggregateInputType = {
    oldLevel?: true
    newLevel?: true
  }

  export type AdminUnitRiskChangeLogMinAggregateInputType = {
    id?: true
    adminUnitRiskId?: true
    riskType?: true
    oldLevel?: true
    newLevel?: true
    oldNotes?: true
    newNotes?: true
    changedBy?: true
    changeReason?: true
    createdAt?: true
  }

  export type AdminUnitRiskChangeLogMaxAggregateInputType = {
    id?: true
    adminUnitRiskId?: true
    riskType?: true
    oldLevel?: true
    newLevel?: true
    oldNotes?: true
    newNotes?: true
    changedBy?: true
    changeReason?: true
    createdAt?: true
  }

  export type AdminUnitRiskChangeLogCountAggregateInputType = {
    id?: true
    adminUnitRiskId?: true
    riskType?: true
    oldLevel?: true
    newLevel?: true
    oldNotes?: true
    newNotes?: true
    changedBy?: true
    changeReason?: true
    createdAt?: true
    _all?: true
  }

  export type AdminUnitRiskChangeLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminUnitRiskChangeLog to aggregate.
     */
    where?: AdminUnitRiskChangeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminUnitRiskChangeLogs to fetch.
     */
    orderBy?: AdminUnitRiskChangeLogOrderByWithRelationInput | AdminUnitRiskChangeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminUnitRiskChangeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminUnitRiskChangeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminUnitRiskChangeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminUnitRiskChangeLogs
    **/
    _count?: true | AdminUnitRiskChangeLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminUnitRiskChangeLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminUnitRiskChangeLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminUnitRiskChangeLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminUnitRiskChangeLogMaxAggregateInputType
  }

  export type GetAdminUnitRiskChangeLogAggregateType<T extends AdminUnitRiskChangeLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminUnitRiskChangeLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminUnitRiskChangeLog[P]>
      : GetScalarType<T[P], AggregateAdminUnitRiskChangeLog[P]>
  }




  export type AdminUnitRiskChangeLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminUnitRiskChangeLogWhereInput
    orderBy?: AdminUnitRiskChangeLogOrderByWithAggregationInput | AdminUnitRiskChangeLogOrderByWithAggregationInput[]
    by: AdminUnitRiskChangeLogScalarFieldEnum[] | AdminUnitRiskChangeLogScalarFieldEnum
    having?: AdminUnitRiskChangeLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminUnitRiskChangeLogCountAggregateInputType | true
    _avg?: AdminUnitRiskChangeLogAvgAggregateInputType
    _sum?: AdminUnitRiskChangeLogSumAggregateInputType
    _min?: AdminUnitRiskChangeLogMinAggregateInputType
    _max?: AdminUnitRiskChangeLogMaxAggregateInputType
  }

  export type AdminUnitRiskChangeLogGroupByOutputType = {
    id: string
    adminUnitRiskId: string
    riskType: string
    oldLevel: number
    newLevel: number
    oldNotes: string
    newNotes: string
    changedBy: string
    changeReason: string | null
    createdAt: Date
    _count: AdminUnitRiskChangeLogCountAggregateOutputType | null
    _avg: AdminUnitRiskChangeLogAvgAggregateOutputType | null
    _sum: AdminUnitRiskChangeLogSumAggregateOutputType | null
    _min: AdminUnitRiskChangeLogMinAggregateOutputType | null
    _max: AdminUnitRiskChangeLogMaxAggregateOutputType | null
  }

  type GetAdminUnitRiskChangeLogGroupByPayload<T extends AdminUnitRiskChangeLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminUnitRiskChangeLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminUnitRiskChangeLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminUnitRiskChangeLogGroupByOutputType[P]>
            : GetScalarType<T[P], AdminUnitRiskChangeLogGroupByOutputType[P]>
        }
      >
    >


  export type AdminUnitRiskChangeLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminUnitRiskId?: boolean
    riskType?: boolean
    oldLevel?: boolean
    newLevel?: boolean
    oldNotes?: boolean
    newNotes?: boolean
    changedBy?: boolean
    changeReason?: boolean
    createdAt?: boolean
    adminUnitRisk?: boolean | AdminUnitRiskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminUnitRiskChangeLog"]>

  export type AdminUnitRiskChangeLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminUnitRiskId?: boolean
    riskType?: boolean
    oldLevel?: boolean
    newLevel?: boolean
    oldNotes?: boolean
    newNotes?: boolean
    changedBy?: boolean
    changeReason?: boolean
    createdAt?: boolean
    adminUnitRisk?: boolean | AdminUnitRiskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminUnitRiskChangeLog"]>

  export type AdminUnitRiskChangeLogSelectScalar = {
    id?: boolean
    adminUnitRiskId?: boolean
    riskType?: boolean
    oldLevel?: boolean
    newLevel?: boolean
    oldNotes?: boolean
    newNotes?: boolean
    changedBy?: boolean
    changeReason?: boolean
    createdAt?: boolean
  }

  export type AdminUnitRiskChangeLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    adminUnitRisk?: boolean | AdminUnitRiskDefaultArgs<ExtArgs>
  }
  export type AdminUnitRiskChangeLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    adminUnitRisk?: boolean | AdminUnitRiskDefaultArgs<ExtArgs>
  }

  export type $AdminUnitRiskChangeLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminUnitRiskChangeLog"
    objects: {
      adminUnitRisk: Prisma.$AdminUnitRiskPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      adminUnitRiskId: string
      riskType: string
      oldLevel: number
      newLevel: number
      oldNotes: string
      newNotes: string
      changedBy: string
      changeReason: string | null
      createdAt: Date
    }, ExtArgs["result"]["adminUnitRiskChangeLog"]>
    composites: {}
  }

  type AdminUnitRiskChangeLogGetPayload<S extends boolean | null | undefined | AdminUnitRiskChangeLogDefaultArgs> = $Result.GetResult<Prisma.$AdminUnitRiskChangeLogPayload, S>

  type AdminUnitRiskChangeLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdminUnitRiskChangeLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdminUnitRiskChangeLogCountAggregateInputType | true
    }

  export interface AdminUnitRiskChangeLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminUnitRiskChangeLog'], meta: { name: 'AdminUnitRiskChangeLog' } }
    /**
     * Find zero or one AdminUnitRiskChangeLog that matches the filter.
     * @param {AdminUnitRiskChangeLogFindUniqueArgs} args - Arguments to find a AdminUnitRiskChangeLog
     * @example
     * // Get one AdminUnitRiskChangeLog
     * const adminUnitRiskChangeLog = await prisma.adminUnitRiskChangeLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminUnitRiskChangeLogFindUniqueArgs>(args: SelectSubset<T, AdminUnitRiskChangeLogFindUniqueArgs<ExtArgs>>): Prisma__AdminUnitRiskChangeLogClient<$Result.GetResult<Prisma.$AdminUnitRiskChangeLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AdminUnitRiskChangeLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdminUnitRiskChangeLogFindUniqueOrThrowArgs} args - Arguments to find a AdminUnitRiskChangeLog
     * @example
     * // Get one AdminUnitRiskChangeLog
     * const adminUnitRiskChangeLog = await prisma.adminUnitRiskChangeLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminUnitRiskChangeLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminUnitRiskChangeLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminUnitRiskChangeLogClient<$Result.GetResult<Prisma.$AdminUnitRiskChangeLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AdminUnitRiskChangeLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUnitRiskChangeLogFindFirstArgs} args - Arguments to find a AdminUnitRiskChangeLog
     * @example
     * // Get one AdminUnitRiskChangeLog
     * const adminUnitRiskChangeLog = await prisma.adminUnitRiskChangeLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminUnitRiskChangeLogFindFirstArgs>(args?: SelectSubset<T, AdminUnitRiskChangeLogFindFirstArgs<ExtArgs>>): Prisma__AdminUnitRiskChangeLogClient<$Result.GetResult<Prisma.$AdminUnitRiskChangeLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AdminUnitRiskChangeLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUnitRiskChangeLogFindFirstOrThrowArgs} args - Arguments to find a AdminUnitRiskChangeLog
     * @example
     * // Get one AdminUnitRiskChangeLog
     * const adminUnitRiskChangeLog = await prisma.adminUnitRiskChangeLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminUnitRiskChangeLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminUnitRiskChangeLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminUnitRiskChangeLogClient<$Result.GetResult<Prisma.$AdminUnitRiskChangeLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AdminUnitRiskChangeLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUnitRiskChangeLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminUnitRiskChangeLogs
     * const adminUnitRiskChangeLogs = await prisma.adminUnitRiskChangeLog.findMany()
     * 
     * // Get first 10 AdminUnitRiskChangeLogs
     * const adminUnitRiskChangeLogs = await prisma.adminUnitRiskChangeLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminUnitRiskChangeLogWithIdOnly = await prisma.adminUnitRiskChangeLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminUnitRiskChangeLogFindManyArgs>(args?: SelectSubset<T, AdminUnitRiskChangeLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminUnitRiskChangeLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AdminUnitRiskChangeLog.
     * @param {AdminUnitRiskChangeLogCreateArgs} args - Arguments to create a AdminUnitRiskChangeLog.
     * @example
     * // Create one AdminUnitRiskChangeLog
     * const AdminUnitRiskChangeLog = await prisma.adminUnitRiskChangeLog.create({
     *   data: {
     *     // ... data to create a AdminUnitRiskChangeLog
     *   }
     * })
     * 
     */
    create<T extends AdminUnitRiskChangeLogCreateArgs>(args: SelectSubset<T, AdminUnitRiskChangeLogCreateArgs<ExtArgs>>): Prisma__AdminUnitRiskChangeLogClient<$Result.GetResult<Prisma.$AdminUnitRiskChangeLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AdminUnitRiskChangeLogs.
     * @param {AdminUnitRiskChangeLogCreateManyArgs} args - Arguments to create many AdminUnitRiskChangeLogs.
     * @example
     * // Create many AdminUnitRiskChangeLogs
     * const adminUnitRiskChangeLog = await prisma.adminUnitRiskChangeLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminUnitRiskChangeLogCreateManyArgs>(args?: SelectSubset<T, AdminUnitRiskChangeLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminUnitRiskChangeLogs and returns the data saved in the database.
     * @param {AdminUnitRiskChangeLogCreateManyAndReturnArgs} args - Arguments to create many AdminUnitRiskChangeLogs.
     * @example
     * // Create many AdminUnitRiskChangeLogs
     * const adminUnitRiskChangeLog = await prisma.adminUnitRiskChangeLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminUnitRiskChangeLogs and only return the `id`
     * const adminUnitRiskChangeLogWithIdOnly = await prisma.adminUnitRiskChangeLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminUnitRiskChangeLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminUnitRiskChangeLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminUnitRiskChangeLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AdminUnitRiskChangeLog.
     * @param {AdminUnitRiskChangeLogDeleteArgs} args - Arguments to delete one AdminUnitRiskChangeLog.
     * @example
     * // Delete one AdminUnitRiskChangeLog
     * const AdminUnitRiskChangeLog = await prisma.adminUnitRiskChangeLog.delete({
     *   where: {
     *     // ... filter to delete one AdminUnitRiskChangeLog
     *   }
     * })
     * 
     */
    delete<T extends AdminUnitRiskChangeLogDeleteArgs>(args: SelectSubset<T, AdminUnitRiskChangeLogDeleteArgs<ExtArgs>>): Prisma__AdminUnitRiskChangeLogClient<$Result.GetResult<Prisma.$AdminUnitRiskChangeLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AdminUnitRiskChangeLog.
     * @param {AdminUnitRiskChangeLogUpdateArgs} args - Arguments to update one AdminUnitRiskChangeLog.
     * @example
     * // Update one AdminUnitRiskChangeLog
     * const adminUnitRiskChangeLog = await prisma.adminUnitRiskChangeLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminUnitRiskChangeLogUpdateArgs>(args: SelectSubset<T, AdminUnitRiskChangeLogUpdateArgs<ExtArgs>>): Prisma__AdminUnitRiskChangeLogClient<$Result.GetResult<Prisma.$AdminUnitRiskChangeLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AdminUnitRiskChangeLogs.
     * @param {AdminUnitRiskChangeLogDeleteManyArgs} args - Arguments to filter AdminUnitRiskChangeLogs to delete.
     * @example
     * // Delete a few AdminUnitRiskChangeLogs
     * const { count } = await prisma.adminUnitRiskChangeLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminUnitRiskChangeLogDeleteManyArgs>(args?: SelectSubset<T, AdminUnitRiskChangeLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminUnitRiskChangeLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUnitRiskChangeLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminUnitRiskChangeLogs
     * const adminUnitRiskChangeLog = await prisma.adminUnitRiskChangeLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminUnitRiskChangeLogUpdateManyArgs>(args: SelectSubset<T, AdminUnitRiskChangeLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AdminUnitRiskChangeLog.
     * @param {AdminUnitRiskChangeLogUpsertArgs} args - Arguments to update or create a AdminUnitRiskChangeLog.
     * @example
     * // Update or create a AdminUnitRiskChangeLog
     * const adminUnitRiskChangeLog = await prisma.adminUnitRiskChangeLog.upsert({
     *   create: {
     *     // ... data to create a AdminUnitRiskChangeLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminUnitRiskChangeLog we want to update
     *   }
     * })
     */
    upsert<T extends AdminUnitRiskChangeLogUpsertArgs>(args: SelectSubset<T, AdminUnitRiskChangeLogUpsertArgs<ExtArgs>>): Prisma__AdminUnitRiskChangeLogClient<$Result.GetResult<Prisma.$AdminUnitRiskChangeLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AdminUnitRiskChangeLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUnitRiskChangeLogCountArgs} args - Arguments to filter AdminUnitRiskChangeLogs to count.
     * @example
     * // Count the number of AdminUnitRiskChangeLogs
     * const count = await prisma.adminUnitRiskChangeLog.count({
     *   where: {
     *     // ... the filter for the AdminUnitRiskChangeLogs we want to count
     *   }
     * })
    **/
    count<T extends AdminUnitRiskChangeLogCountArgs>(
      args?: Subset<T, AdminUnitRiskChangeLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminUnitRiskChangeLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminUnitRiskChangeLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUnitRiskChangeLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminUnitRiskChangeLogAggregateArgs>(args: Subset<T, AdminUnitRiskChangeLogAggregateArgs>): Prisma.PrismaPromise<GetAdminUnitRiskChangeLogAggregateType<T>>

    /**
     * Group by AdminUnitRiskChangeLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUnitRiskChangeLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminUnitRiskChangeLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminUnitRiskChangeLogGroupByArgs['orderBy'] }
        : { orderBy?: AdminUnitRiskChangeLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminUnitRiskChangeLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminUnitRiskChangeLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminUnitRiskChangeLog model
   */
  readonly fields: AdminUnitRiskChangeLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminUnitRiskChangeLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminUnitRiskChangeLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    adminUnitRisk<T extends AdminUnitRiskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminUnitRiskDefaultArgs<ExtArgs>>): Prisma__AdminUnitRiskClient<$Result.GetResult<Prisma.$AdminUnitRiskPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminUnitRiskChangeLog model
   */ 
  interface AdminUnitRiskChangeLogFieldRefs {
    readonly id: FieldRef<"AdminUnitRiskChangeLog", 'String'>
    readonly adminUnitRiskId: FieldRef<"AdminUnitRiskChangeLog", 'String'>
    readonly riskType: FieldRef<"AdminUnitRiskChangeLog", 'String'>
    readonly oldLevel: FieldRef<"AdminUnitRiskChangeLog", 'Int'>
    readonly newLevel: FieldRef<"AdminUnitRiskChangeLog", 'Int'>
    readonly oldNotes: FieldRef<"AdminUnitRiskChangeLog", 'String'>
    readonly newNotes: FieldRef<"AdminUnitRiskChangeLog", 'String'>
    readonly changedBy: FieldRef<"AdminUnitRiskChangeLog", 'String'>
    readonly changeReason: FieldRef<"AdminUnitRiskChangeLog", 'String'>
    readonly createdAt: FieldRef<"AdminUnitRiskChangeLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdminUnitRiskChangeLog findUnique
   */
  export type AdminUnitRiskChangeLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUnitRiskChangeLog
     */
    select?: AdminUnitRiskChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUnitRiskChangeLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminUnitRiskChangeLog to fetch.
     */
    where: AdminUnitRiskChangeLogWhereUniqueInput
  }

  /**
   * AdminUnitRiskChangeLog findUniqueOrThrow
   */
  export type AdminUnitRiskChangeLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUnitRiskChangeLog
     */
    select?: AdminUnitRiskChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUnitRiskChangeLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminUnitRiskChangeLog to fetch.
     */
    where: AdminUnitRiskChangeLogWhereUniqueInput
  }

  /**
   * AdminUnitRiskChangeLog findFirst
   */
  export type AdminUnitRiskChangeLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUnitRiskChangeLog
     */
    select?: AdminUnitRiskChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUnitRiskChangeLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminUnitRiskChangeLog to fetch.
     */
    where?: AdminUnitRiskChangeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminUnitRiskChangeLogs to fetch.
     */
    orderBy?: AdminUnitRiskChangeLogOrderByWithRelationInput | AdminUnitRiskChangeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminUnitRiskChangeLogs.
     */
    cursor?: AdminUnitRiskChangeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminUnitRiskChangeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminUnitRiskChangeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminUnitRiskChangeLogs.
     */
    distinct?: AdminUnitRiskChangeLogScalarFieldEnum | AdminUnitRiskChangeLogScalarFieldEnum[]
  }

  /**
   * AdminUnitRiskChangeLog findFirstOrThrow
   */
  export type AdminUnitRiskChangeLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUnitRiskChangeLog
     */
    select?: AdminUnitRiskChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUnitRiskChangeLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminUnitRiskChangeLog to fetch.
     */
    where?: AdminUnitRiskChangeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminUnitRiskChangeLogs to fetch.
     */
    orderBy?: AdminUnitRiskChangeLogOrderByWithRelationInput | AdminUnitRiskChangeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminUnitRiskChangeLogs.
     */
    cursor?: AdminUnitRiskChangeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminUnitRiskChangeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminUnitRiskChangeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminUnitRiskChangeLogs.
     */
    distinct?: AdminUnitRiskChangeLogScalarFieldEnum | AdminUnitRiskChangeLogScalarFieldEnum[]
  }

  /**
   * AdminUnitRiskChangeLog findMany
   */
  export type AdminUnitRiskChangeLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUnitRiskChangeLog
     */
    select?: AdminUnitRiskChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUnitRiskChangeLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminUnitRiskChangeLogs to fetch.
     */
    where?: AdminUnitRiskChangeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminUnitRiskChangeLogs to fetch.
     */
    orderBy?: AdminUnitRiskChangeLogOrderByWithRelationInput | AdminUnitRiskChangeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminUnitRiskChangeLogs.
     */
    cursor?: AdminUnitRiskChangeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminUnitRiskChangeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminUnitRiskChangeLogs.
     */
    skip?: number
    distinct?: AdminUnitRiskChangeLogScalarFieldEnum | AdminUnitRiskChangeLogScalarFieldEnum[]
  }

  /**
   * AdminUnitRiskChangeLog create
   */
  export type AdminUnitRiskChangeLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUnitRiskChangeLog
     */
    select?: AdminUnitRiskChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUnitRiskChangeLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminUnitRiskChangeLog.
     */
    data: XOR<AdminUnitRiskChangeLogCreateInput, AdminUnitRiskChangeLogUncheckedCreateInput>
  }

  /**
   * AdminUnitRiskChangeLog createMany
   */
  export type AdminUnitRiskChangeLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminUnitRiskChangeLogs.
     */
    data: AdminUnitRiskChangeLogCreateManyInput | AdminUnitRiskChangeLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminUnitRiskChangeLog createManyAndReturn
   */
  export type AdminUnitRiskChangeLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUnitRiskChangeLog
     */
    select?: AdminUnitRiskChangeLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AdminUnitRiskChangeLogs.
     */
    data: AdminUnitRiskChangeLogCreateManyInput | AdminUnitRiskChangeLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUnitRiskChangeLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminUnitRiskChangeLog update
   */
  export type AdminUnitRiskChangeLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUnitRiskChangeLog
     */
    select?: AdminUnitRiskChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUnitRiskChangeLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminUnitRiskChangeLog.
     */
    data: XOR<AdminUnitRiskChangeLogUpdateInput, AdminUnitRiskChangeLogUncheckedUpdateInput>
    /**
     * Choose, which AdminUnitRiskChangeLog to update.
     */
    where: AdminUnitRiskChangeLogWhereUniqueInput
  }

  /**
   * AdminUnitRiskChangeLog updateMany
   */
  export type AdminUnitRiskChangeLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminUnitRiskChangeLogs.
     */
    data: XOR<AdminUnitRiskChangeLogUpdateManyMutationInput, AdminUnitRiskChangeLogUncheckedUpdateManyInput>
    /**
     * Filter which AdminUnitRiskChangeLogs to update
     */
    where?: AdminUnitRiskChangeLogWhereInput
  }

  /**
   * AdminUnitRiskChangeLog upsert
   */
  export type AdminUnitRiskChangeLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUnitRiskChangeLog
     */
    select?: AdminUnitRiskChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUnitRiskChangeLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminUnitRiskChangeLog to update in case it exists.
     */
    where: AdminUnitRiskChangeLogWhereUniqueInput
    /**
     * In case the AdminUnitRiskChangeLog found by the `where` argument doesn't exist, create a new AdminUnitRiskChangeLog with this data.
     */
    create: XOR<AdminUnitRiskChangeLogCreateInput, AdminUnitRiskChangeLogUncheckedCreateInput>
    /**
     * In case the AdminUnitRiskChangeLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUnitRiskChangeLogUpdateInput, AdminUnitRiskChangeLogUncheckedUpdateInput>
  }

  /**
   * AdminUnitRiskChangeLog delete
   */
  export type AdminUnitRiskChangeLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUnitRiskChangeLog
     */
    select?: AdminUnitRiskChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUnitRiskChangeLogInclude<ExtArgs> | null
    /**
     * Filter which AdminUnitRiskChangeLog to delete.
     */
    where: AdminUnitRiskChangeLogWhereUniqueInput
  }

  /**
   * AdminUnitRiskChangeLog deleteMany
   */
  export type AdminUnitRiskChangeLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminUnitRiskChangeLogs to delete
     */
    where?: AdminUnitRiskChangeLogWhereInput
  }

  /**
   * AdminUnitRiskChangeLog without action
   */
  export type AdminUnitRiskChangeLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUnitRiskChangeLog
     */
    select?: AdminUnitRiskChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUnitRiskChangeLogInclude<ExtArgs> | null
  }


  /**
   * Model ParishRisk
   */

  export type AggregateParishRisk = {
    _count: ParishRiskCountAggregateOutputType | null
    _avg: ParishRiskAvgAggregateOutputType | null
    _sum: ParishRiskSumAggregateOutputType | null
    _min: ParishRiskMinAggregateOutputType | null
    _max: ParishRiskMaxAggregateOutputType | null
  }

  export type ParishRiskAvgAggregateOutputType = {
    hurricaneLevel: number | null
    floodLevel: number | null
    earthquakeLevel: number | null
    droughtLevel: number | null
    landslideLevel: number | null
    powerOutageLevel: number | null
  }

  export type ParishRiskSumAggregateOutputType = {
    hurricaneLevel: number | null
    floodLevel: number | null
    earthquakeLevel: number | null
    droughtLevel: number | null
    landslideLevel: number | null
    powerOutageLevel: number | null
  }

  export type ParishRiskMinAggregateOutputType = {
    id: string | null
    parishId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lastUpdated: Date | null
    updatedBy: string | null
    hurricaneLevel: number | null
    hurricaneNotes: string | null
    floodLevel: number | null
    floodNotes: string | null
    earthquakeLevel: number | null
    earthquakeNotes: string | null
    droughtLevel: number | null
    droughtNotes: string | null
    landslideLevel: number | null
    landslideNotes: string | null
    powerOutageLevel: number | null
    powerOutageNotes: string | null
    riskProfileJson: string | null
    isActive: boolean | null
  }

  export type ParishRiskMaxAggregateOutputType = {
    id: string | null
    parishId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lastUpdated: Date | null
    updatedBy: string | null
    hurricaneLevel: number | null
    hurricaneNotes: string | null
    floodLevel: number | null
    floodNotes: string | null
    earthquakeLevel: number | null
    earthquakeNotes: string | null
    droughtLevel: number | null
    droughtNotes: string | null
    landslideLevel: number | null
    landslideNotes: string | null
    powerOutageLevel: number | null
    powerOutageNotes: string | null
    riskProfileJson: string | null
    isActive: boolean | null
  }

  export type ParishRiskCountAggregateOutputType = {
    id: number
    parishId: number
    createdAt: number
    updatedAt: number
    lastUpdated: number
    updatedBy: number
    hurricaneLevel: number
    hurricaneNotes: number
    floodLevel: number
    floodNotes: number
    earthquakeLevel: number
    earthquakeNotes: number
    droughtLevel: number
    droughtNotes: number
    landslideLevel: number
    landslideNotes: number
    powerOutageLevel: number
    powerOutageNotes: number
    riskProfileJson: number
    isActive: number
    _all: number
  }


  export type ParishRiskAvgAggregateInputType = {
    hurricaneLevel?: true
    floodLevel?: true
    earthquakeLevel?: true
    droughtLevel?: true
    landslideLevel?: true
    powerOutageLevel?: true
  }

  export type ParishRiskSumAggregateInputType = {
    hurricaneLevel?: true
    floodLevel?: true
    earthquakeLevel?: true
    droughtLevel?: true
    landslideLevel?: true
    powerOutageLevel?: true
  }

  export type ParishRiskMinAggregateInputType = {
    id?: true
    parishId?: true
    createdAt?: true
    updatedAt?: true
    lastUpdated?: true
    updatedBy?: true
    hurricaneLevel?: true
    hurricaneNotes?: true
    floodLevel?: true
    floodNotes?: true
    earthquakeLevel?: true
    earthquakeNotes?: true
    droughtLevel?: true
    droughtNotes?: true
    landslideLevel?: true
    landslideNotes?: true
    powerOutageLevel?: true
    powerOutageNotes?: true
    riskProfileJson?: true
    isActive?: true
  }

  export type ParishRiskMaxAggregateInputType = {
    id?: true
    parishId?: true
    createdAt?: true
    updatedAt?: true
    lastUpdated?: true
    updatedBy?: true
    hurricaneLevel?: true
    hurricaneNotes?: true
    floodLevel?: true
    floodNotes?: true
    earthquakeLevel?: true
    earthquakeNotes?: true
    droughtLevel?: true
    droughtNotes?: true
    landslideLevel?: true
    landslideNotes?: true
    powerOutageLevel?: true
    powerOutageNotes?: true
    riskProfileJson?: true
    isActive?: true
  }

  export type ParishRiskCountAggregateInputType = {
    id?: true
    parishId?: true
    createdAt?: true
    updatedAt?: true
    lastUpdated?: true
    updatedBy?: true
    hurricaneLevel?: true
    hurricaneNotes?: true
    floodLevel?: true
    floodNotes?: true
    earthquakeLevel?: true
    earthquakeNotes?: true
    droughtLevel?: true
    droughtNotes?: true
    landslideLevel?: true
    landslideNotes?: true
    powerOutageLevel?: true
    powerOutageNotes?: true
    riskProfileJson?: true
    isActive?: true
    _all?: true
  }

  export type ParishRiskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ParishRisk to aggregate.
     */
    where?: ParishRiskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParishRisks to fetch.
     */
    orderBy?: ParishRiskOrderByWithRelationInput | ParishRiskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ParishRiskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParishRisks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParishRisks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ParishRisks
    **/
    _count?: true | ParishRiskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ParishRiskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ParishRiskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParishRiskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParishRiskMaxAggregateInputType
  }

  export type GetParishRiskAggregateType<T extends ParishRiskAggregateArgs> = {
        [P in keyof T & keyof AggregateParishRisk]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParishRisk[P]>
      : GetScalarType<T[P], AggregateParishRisk[P]>
  }




  export type ParishRiskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParishRiskWhereInput
    orderBy?: ParishRiskOrderByWithAggregationInput | ParishRiskOrderByWithAggregationInput[]
    by: ParishRiskScalarFieldEnum[] | ParishRiskScalarFieldEnum
    having?: ParishRiskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParishRiskCountAggregateInputType | true
    _avg?: ParishRiskAvgAggregateInputType
    _sum?: ParishRiskSumAggregateInputType
    _min?: ParishRiskMinAggregateInputType
    _max?: ParishRiskMaxAggregateInputType
  }

  export type ParishRiskGroupByOutputType = {
    id: string
    parishId: string
    createdAt: Date
    updatedAt: Date
    lastUpdated: Date
    updatedBy: string
    hurricaneLevel: number
    hurricaneNotes: string
    floodLevel: number
    floodNotes: string
    earthquakeLevel: number
    earthquakeNotes: string
    droughtLevel: number
    droughtNotes: string
    landslideLevel: number
    landslideNotes: string
    powerOutageLevel: number
    powerOutageNotes: string
    riskProfileJson: string
    isActive: boolean
    _count: ParishRiskCountAggregateOutputType | null
    _avg: ParishRiskAvgAggregateOutputType | null
    _sum: ParishRiskSumAggregateOutputType | null
    _min: ParishRiskMinAggregateOutputType | null
    _max: ParishRiskMaxAggregateOutputType | null
  }

  type GetParishRiskGroupByPayload<T extends ParishRiskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParishRiskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParishRiskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParishRiskGroupByOutputType[P]>
            : GetScalarType<T[P], ParishRiskGroupByOutputType[P]>
        }
      >
    >


  export type ParishRiskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    parishId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastUpdated?: boolean
    updatedBy?: boolean
    hurricaneLevel?: boolean
    hurricaneNotes?: boolean
    floodLevel?: boolean
    floodNotes?: boolean
    earthquakeLevel?: boolean
    earthquakeNotes?: boolean
    droughtLevel?: boolean
    droughtNotes?: boolean
    landslideLevel?: boolean
    landslideNotes?: boolean
    powerOutageLevel?: boolean
    powerOutageNotes?: boolean
    riskProfileJson?: boolean
    isActive?: boolean
    parish?: boolean | ParishDefaultArgs<ExtArgs>
    changeLogs?: boolean | ParishRisk$changeLogsArgs<ExtArgs>
    _count?: boolean | ParishRiskCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parishRisk"]>

  export type ParishRiskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    parishId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastUpdated?: boolean
    updatedBy?: boolean
    hurricaneLevel?: boolean
    hurricaneNotes?: boolean
    floodLevel?: boolean
    floodNotes?: boolean
    earthquakeLevel?: boolean
    earthquakeNotes?: boolean
    droughtLevel?: boolean
    droughtNotes?: boolean
    landslideLevel?: boolean
    landslideNotes?: boolean
    powerOutageLevel?: boolean
    powerOutageNotes?: boolean
    riskProfileJson?: boolean
    isActive?: boolean
    parish?: boolean | ParishDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parishRisk"]>

  export type ParishRiskSelectScalar = {
    id?: boolean
    parishId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastUpdated?: boolean
    updatedBy?: boolean
    hurricaneLevel?: boolean
    hurricaneNotes?: boolean
    floodLevel?: boolean
    floodNotes?: boolean
    earthquakeLevel?: boolean
    earthquakeNotes?: boolean
    droughtLevel?: boolean
    droughtNotes?: boolean
    landslideLevel?: boolean
    landslideNotes?: boolean
    powerOutageLevel?: boolean
    powerOutageNotes?: boolean
    riskProfileJson?: boolean
    isActive?: boolean
  }

  export type ParishRiskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parish?: boolean | ParishDefaultArgs<ExtArgs>
    changeLogs?: boolean | ParishRisk$changeLogsArgs<ExtArgs>
    _count?: boolean | ParishRiskCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ParishRiskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parish?: boolean | ParishDefaultArgs<ExtArgs>
  }

  export type $ParishRiskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ParishRisk"
    objects: {
      parish: Prisma.$ParishPayload<ExtArgs>
      changeLogs: Prisma.$RiskChangeLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      parishId: string
      createdAt: Date
      updatedAt: Date
      lastUpdated: Date
      updatedBy: string
      hurricaneLevel: number
      hurricaneNotes: string
      floodLevel: number
      floodNotes: string
      earthquakeLevel: number
      earthquakeNotes: string
      droughtLevel: number
      droughtNotes: string
      landslideLevel: number
      landslideNotes: string
      powerOutageLevel: number
      powerOutageNotes: string
      riskProfileJson: string
      isActive: boolean
    }, ExtArgs["result"]["parishRisk"]>
    composites: {}
  }

  type ParishRiskGetPayload<S extends boolean | null | undefined | ParishRiskDefaultArgs> = $Result.GetResult<Prisma.$ParishRiskPayload, S>

  type ParishRiskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ParishRiskFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ParishRiskCountAggregateInputType | true
    }

  export interface ParishRiskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ParishRisk'], meta: { name: 'ParishRisk' } }
    /**
     * Find zero or one ParishRisk that matches the filter.
     * @param {ParishRiskFindUniqueArgs} args - Arguments to find a ParishRisk
     * @example
     * // Get one ParishRisk
     * const parishRisk = await prisma.parishRisk.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ParishRiskFindUniqueArgs>(args: SelectSubset<T, ParishRiskFindUniqueArgs<ExtArgs>>): Prisma__ParishRiskClient<$Result.GetResult<Prisma.$ParishRiskPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ParishRisk that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ParishRiskFindUniqueOrThrowArgs} args - Arguments to find a ParishRisk
     * @example
     * // Get one ParishRisk
     * const parishRisk = await prisma.parishRisk.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ParishRiskFindUniqueOrThrowArgs>(args: SelectSubset<T, ParishRiskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ParishRiskClient<$Result.GetResult<Prisma.$ParishRiskPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ParishRisk that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParishRiskFindFirstArgs} args - Arguments to find a ParishRisk
     * @example
     * // Get one ParishRisk
     * const parishRisk = await prisma.parishRisk.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ParishRiskFindFirstArgs>(args?: SelectSubset<T, ParishRiskFindFirstArgs<ExtArgs>>): Prisma__ParishRiskClient<$Result.GetResult<Prisma.$ParishRiskPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ParishRisk that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParishRiskFindFirstOrThrowArgs} args - Arguments to find a ParishRisk
     * @example
     * // Get one ParishRisk
     * const parishRisk = await prisma.parishRisk.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ParishRiskFindFirstOrThrowArgs>(args?: SelectSubset<T, ParishRiskFindFirstOrThrowArgs<ExtArgs>>): Prisma__ParishRiskClient<$Result.GetResult<Prisma.$ParishRiskPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ParishRisks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParishRiskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ParishRisks
     * const parishRisks = await prisma.parishRisk.findMany()
     * 
     * // Get first 10 ParishRisks
     * const parishRisks = await prisma.parishRisk.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const parishRiskWithIdOnly = await prisma.parishRisk.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ParishRiskFindManyArgs>(args?: SelectSubset<T, ParishRiskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParishRiskPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ParishRisk.
     * @param {ParishRiskCreateArgs} args - Arguments to create a ParishRisk.
     * @example
     * // Create one ParishRisk
     * const ParishRisk = await prisma.parishRisk.create({
     *   data: {
     *     // ... data to create a ParishRisk
     *   }
     * })
     * 
     */
    create<T extends ParishRiskCreateArgs>(args: SelectSubset<T, ParishRiskCreateArgs<ExtArgs>>): Prisma__ParishRiskClient<$Result.GetResult<Prisma.$ParishRiskPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ParishRisks.
     * @param {ParishRiskCreateManyArgs} args - Arguments to create many ParishRisks.
     * @example
     * // Create many ParishRisks
     * const parishRisk = await prisma.parishRisk.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ParishRiskCreateManyArgs>(args?: SelectSubset<T, ParishRiskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ParishRisks and returns the data saved in the database.
     * @param {ParishRiskCreateManyAndReturnArgs} args - Arguments to create many ParishRisks.
     * @example
     * // Create many ParishRisks
     * const parishRisk = await prisma.parishRisk.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ParishRisks and only return the `id`
     * const parishRiskWithIdOnly = await prisma.parishRisk.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ParishRiskCreateManyAndReturnArgs>(args?: SelectSubset<T, ParishRiskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParishRiskPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ParishRisk.
     * @param {ParishRiskDeleteArgs} args - Arguments to delete one ParishRisk.
     * @example
     * // Delete one ParishRisk
     * const ParishRisk = await prisma.parishRisk.delete({
     *   where: {
     *     // ... filter to delete one ParishRisk
     *   }
     * })
     * 
     */
    delete<T extends ParishRiskDeleteArgs>(args: SelectSubset<T, ParishRiskDeleteArgs<ExtArgs>>): Prisma__ParishRiskClient<$Result.GetResult<Prisma.$ParishRiskPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ParishRisk.
     * @param {ParishRiskUpdateArgs} args - Arguments to update one ParishRisk.
     * @example
     * // Update one ParishRisk
     * const parishRisk = await prisma.parishRisk.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ParishRiskUpdateArgs>(args: SelectSubset<T, ParishRiskUpdateArgs<ExtArgs>>): Prisma__ParishRiskClient<$Result.GetResult<Prisma.$ParishRiskPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ParishRisks.
     * @param {ParishRiskDeleteManyArgs} args - Arguments to filter ParishRisks to delete.
     * @example
     * // Delete a few ParishRisks
     * const { count } = await prisma.parishRisk.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ParishRiskDeleteManyArgs>(args?: SelectSubset<T, ParishRiskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ParishRisks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParishRiskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ParishRisks
     * const parishRisk = await prisma.parishRisk.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ParishRiskUpdateManyArgs>(args: SelectSubset<T, ParishRiskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ParishRisk.
     * @param {ParishRiskUpsertArgs} args - Arguments to update or create a ParishRisk.
     * @example
     * // Update or create a ParishRisk
     * const parishRisk = await prisma.parishRisk.upsert({
     *   create: {
     *     // ... data to create a ParishRisk
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ParishRisk we want to update
     *   }
     * })
     */
    upsert<T extends ParishRiskUpsertArgs>(args: SelectSubset<T, ParishRiskUpsertArgs<ExtArgs>>): Prisma__ParishRiskClient<$Result.GetResult<Prisma.$ParishRiskPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ParishRisks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParishRiskCountArgs} args - Arguments to filter ParishRisks to count.
     * @example
     * // Count the number of ParishRisks
     * const count = await prisma.parishRisk.count({
     *   where: {
     *     // ... the filter for the ParishRisks we want to count
     *   }
     * })
    **/
    count<T extends ParishRiskCountArgs>(
      args?: Subset<T, ParishRiskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParishRiskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ParishRisk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParishRiskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParishRiskAggregateArgs>(args: Subset<T, ParishRiskAggregateArgs>): Prisma.PrismaPromise<GetParishRiskAggregateType<T>>

    /**
     * Group by ParishRisk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParishRiskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParishRiskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParishRiskGroupByArgs['orderBy'] }
        : { orderBy?: ParishRiskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParishRiskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParishRiskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ParishRisk model
   */
  readonly fields: ParishRiskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ParishRisk.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ParishRiskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parish<T extends ParishDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ParishDefaultArgs<ExtArgs>>): Prisma__ParishClient<$Result.GetResult<Prisma.$ParishPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    changeLogs<T extends ParishRisk$changeLogsArgs<ExtArgs> = {}>(args?: Subset<T, ParishRisk$changeLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RiskChangeLogPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ParishRisk model
   */ 
  interface ParishRiskFieldRefs {
    readonly id: FieldRef<"ParishRisk", 'String'>
    readonly parishId: FieldRef<"ParishRisk", 'String'>
    readonly createdAt: FieldRef<"ParishRisk", 'DateTime'>
    readonly updatedAt: FieldRef<"ParishRisk", 'DateTime'>
    readonly lastUpdated: FieldRef<"ParishRisk", 'DateTime'>
    readonly updatedBy: FieldRef<"ParishRisk", 'String'>
    readonly hurricaneLevel: FieldRef<"ParishRisk", 'Int'>
    readonly hurricaneNotes: FieldRef<"ParishRisk", 'String'>
    readonly floodLevel: FieldRef<"ParishRisk", 'Int'>
    readonly floodNotes: FieldRef<"ParishRisk", 'String'>
    readonly earthquakeLevel: FieldRef<"ParishRisk", 'Int'>
    readonly earthquakeNotes: FieldRef<"ParishRisk", 'String'>
    readonly droughtLevel: FieldRef<"ParishRisk", 'Int'>
    readonly droughtNotes: FieldRef<"ParishRisk", 'String'>
    readonly landslideLevel: FieldRef<"ParishRisk", 'Int'>
    readonly landslideNotes: FieldRef<"ParishRisk", 'String'>
    readonly powerOutageLevel: FieldRef<"ParishRisk", 'Int'>
    readonly powerOutageNotes: FieldRef<"ParishRisk", 'String'>
    readonly riskProfileJson: FieldRef<"ParishRisk", 'String'>
    readonly isActive: FieldRef<"ParishRisk", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * ParishRisk findUnique
   */
  export type ParishRiskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParishRisk
     */
    select?: ParishRiskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParishRiskInclude<ExtArgs> | null
    /**
     * Filter, which ParishRisk to fetch.
     */
    where: ParishRiskWhereUniqueInput
  }

  /**
   * ParishRisk findUniqueOrThrow
   */
  export type ParishRiskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParishRisk
     */
    select?: ParishRiskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParishRiskInclude<ExtArgs> | null
    /**
     * Filter, which ParishRisk to fetch.
     */
    where: ParishRiskWhereUniqueInput
  }

  /**
   * ParishRisk findFirst
   */
  export type ParishRiskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParishRisk
     */
    select?: ParishRiskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParishRiskInclude<ExtArgs> | null
    /**
     * Filter, which ParishRisk to fetch.
     */
    where?: ParishRiskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParishRisks to fetch.
     */
    orderBy?: ParishRiskOrderByWithRelationInput | ParishRiskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ParishRisks.
     */
    cursor?: ParishRiskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParishRisks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParishRisks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ParishRisks.
     */
    distinct?: ParishRiskScalarFieldEnum | ParishRiskScalarFieldEnum[]
  }

  /**
   * ParishRisk findFirstOrThrow
   */
  export type ParishRiskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParishRisk
     */
    select?: ParishRiskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParishRiskInclude<ExtArgs> | null
    /**
     * Filter, which ParishRisk to fetch.
     */
    where?: ParishRiskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParishRisks to fetch.
     */
    orderBy?: ParishRiskOrderByWithRelationInput | ParishRiskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ParishRisks.
     */
    cursor?: ParishRiskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParishRisks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParishRisks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ParishRisks.
     */
    distinct?: ParishRiskScalarFieldEnum | ParishRiskScalarFieldEnum[]
  }

  /**
   * ParishRisk findMany
   */
  export type ParishRiskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParishRisk
     */
    select?: ParishRiskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParishRiskInclude<ExtArgs> | null
    /**
     * Filter, which ParishRisks to fetch.
     */
    where?: ParishRiskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParishRisks to fetch.
     */
    orderBy?: ParishRiskOrderByWithRelationInput | ParishRiskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ParishRisks.
     */
    cursor?: ParishRiskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParishRisks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParishRisks.
     */
    skip?: number
    distinct?: ParishRiskScalarFieldEnum | ParishRiskScalarFieldEnum[]
  }

  /**
   * ParishRisk create
   */
  export type ParishRiskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParishRisk
     */
    select?: ParishRiskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParishRiskInclude<ExtArgs> | null
    /**
     * The data needed to create a ParishRisk.
     */
    data: XOR<ParishRiskCreateInput, ParishRiskUncheckedCreateInput>
  }

  /**
   * ParishRisk createMany
   */
  export type ParishRiskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ParishRisks.
     */
    data: ParishRiskCreateManyInput | ParishRiskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ParishRisk createManyAndReturn
   */
  export type ParishRiskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParishRisk
     */
    select?: ParishRiskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ParishRisks.
     */
    data: ParishRiskCreateManyInput | ParishRiskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParishRiskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ParishRisk update
   */
  export type ParishRiskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParishRisk
     */
    select?: ParishRiskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParishRiskInclude<ExtArgs> | null
    /**
     * The data needed to update a ParishRisk.
     */
    data: XOR<ParishRiskUpdateInput, ParishRiskUncheckedUpdateInput>
    /**
     * Choose, which ParishRisk to update.
     */
    where: ParishRiskWhereUniqueInput
  }

  /**
   * ParishRisk updateMany
   */
  export type ParishRiskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ParishRisks.
     */
    data: XOR<ParishRiskUpdateManyMutationInput, ParishRiskUncheckedUpdateManyInput>
    /**
     * Filter which ParishRisks to update
     */
    where?: ParishRiskWhereInput
  }

  /**
   * ParishRisk upsert
   */
  export type ParishRiskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParishRisk
     */
    select?: ParishRiskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParishRiskInclude<ExtArgs> | null
    /**
     * The filter to search for the ParishRisk to update in case it exists.
     */
    where: ParishRiskWhereUniqueInput
    /**
     * In case the ParishRisk found by the `where` argument doesn't exist, create a new ParishRisk with this data.
     */
    create: XOR<ParishRiskCreateInput, ParishRiskUncheckedCreateInput>
    /**
     * In case the ParishRisk was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ParishRiskUpdateInput, ParishRiskUncheckedUpdateInput>
  }

  /**
   * ParishRisk delete
   */
  export type ParishRiskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParishRisk
     */
    select?: ParishRiskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParishRiskInclude<ExtArgs> | null
    /**
     * Filter which ParishRisk to delete.
     */
    where: ParishRiskWhereUniqueInput
  }

  /**
   * ParishRisk deleteMany
   */
  export type ParishRiskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ParishRisks to delete
     */
    where?: ParishRiskWhereInput
  }

  /**
   * ParishRisk.changeLogs
   */
  export type ParishRisk$changeLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskChangeLog
     */
    select?: RiskChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskChangeLogInclude<ExtArgs> | null
    where?: RiskChangeLogWhereInput
    orderBy?: RiskChangeLogOrderByWithRelationInput | RiskChangeLogOrderByWithRelationInput[]
    cursor?: RiskChangeLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RiskChangeLogScalarFieldEnum | RiskChangeLogScalarFieldEnum[]
  }

  /**
   * ParishRisk without action
   */
  export type ParishRiskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParishRisk
     */
    select?: ParishRiskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParishRiskInclude<ExtArgs> | null
  }


  /**
   * Model RiskChangeLog
   */

  export type AggregateRiskChangeLog = {
    _count: RiskChangeLogCountAggregateOutputType | null
    _avg: RiskChangeLogAvgAggregateOutputType | null
    _sum: RiskChangeLogSumAggregateOutputType | null
    _min: RiskChangeLogMinAggregateOutputType | null
    _max: RiskChangeLogMaxAggregateOutputType | null
  }

  export type RiskChangeLogAvgAggregateOutputType = {
    oldLevel: number | null
    newLevel: number | null
  }

  export type RiskChangeLogSumAggregateOutputType = {
    oldLevel: number | null
    newLevel: number | null
  }

  export type RiskChangeLogMinAggregateOutputType = {
    id: string | null
    parishRiskId: string | null
    riskType: string | null
    oldLevel: number | null
    newLevel: number | null
    oldNotes: string | null
    newNotes: string | null
    changedBy: string | null
    changeReason: string | null
    createdAt: Date | null
  }

  export type RiskChangeLogMaxAggregateOutputType = {
    id: string | null
    parishRiskId: string | null
    riskType: string | null
    oldLevel: number | null
    newLevel: number | null
    oldNotes: string | null
    newNotes: string | null
    changedBy: string | null
    changeReason: string | null
    createdAt: Date | null
  }

  export type RiskChangeLogCountAggregateOutputType = {
    id: number
    parishRiskId: number
    riskType: number
    oldLevel: number
    newLevel: number
    oldNotes: number
    newNotes: number
    changedBy: number
    changeReason: number
    createdAt: number
    _all: number
  }


  export type RiskChangeLogAvgAggregateInputType = {
    oldLevel?: true
    newLevel?: true
  }

  export type RiskChangeLogSumAggregateInputType = {
    oldLevel?: true
    newLevel?: true
  }

  export type RiskChangeLogMinAggregateInputType = {
    id?: true
    parishRiskId?: true
    riskType?: true
    oldLevel?: true
    newLevel?: true
    oldNotes?: true
    newNotes?: true
    changedBy?: true
    changeReason?: true
    createdAt?: true
  }

  export type RiskChangeLogMaxAggregateInputType = {
    id?: true
    parishRiskId?: true
    riskType?: true
    oldLevel?: true
    newLevel?: true
    oldNotes?: true
    newNotes?: true
    changedBy?: true
    changeReason?: true
    createdAt?: true
  }

  export type RiskChangeLogCountAggregateInputType = {
    id?: true
    parishRiskId?: true
    riskType?: true
    oldLevel?: true
    newLevel?: true
    oldNotes?: true
    newNotes?: true
    changedBy?: true
    changeReason?: true
    createdAt?: true
    _all?: true
  }

  export type RiskChangeLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RiskChangeLog to aggregate.
     */
    where?: RiskChangeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskChangeLogs to fetch.
     */
    orderBy?: RiskChangeLogOrderByWithRelationInput | RiskChangeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RiskChangeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskChangeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskChangeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RiskChangeLogs
    **/
    _count?: true | RiskChangeLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RiskChangeLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RiskChangeLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RiskChangeLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RiskChangeLogMaxAggregateInputType
  }

  export type GetRiskChangeLogAggregateType<T extends RiskChangeLogAggregateArgs> = {
        [P in keyof T & keyof AggregateRiskChangeLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRiskChangeLog[P]>
      : GetScalarType<T[P], AggregateRiskChangeLog[P]>
  }




  export type RiskChangeLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RiskChangeLogWhereInput
    orderBy?: RiskChangeLogOrderByWithAggregationInput | RiskChangeLogOrderByWithAggregationInput[]
    by: RiskChangeLogScalarFieldEnum[] | RiskChangeLogScalarFieldEnum
    having?: RiskChangeLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RiskChangeLogCountAggregateInputType | true
    _avg?: RiskChangeLogAvgAggregateInputType
    _sum?: RiskChangeLogSumAggregateInputType
    _min?: RiskChangeLogMinAggregateInputType
    _max?: RiskChangeLogMaxAggregateInputType
  }

  export type RiskChangeLogGroupByOutputType = {
    id: string
    parishRiskId: string
    riskType: string
    oldLevel: number
    newLevel: number
    oldNotes: string
    newNotes: string
    changedBy: string
    changeReason: string | null
    createdAt: Date
    _count: RiskChangeLogCountAggregateOutputType | null
    _avg: RiskChangeLogAvgAggregateOutputType | null
    _sum: RiskChangeLogSumAggregateOutputType | null
    _min: RiskChangeLogMinAggregateOutputType | null
    _max: RiskChangeLogMaxAggregateOutputType | null
  }

  type GetRiskChangeLogGroupByPayload<T extends RiskChangeLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RiskChangeLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RiskChangeLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RiskChangeLogGroupByOutputType[P]>
            : GetScalarType<T[P], RiskChangeLogGroupByOutputType[P]>
        }
      >
    >


  export type RiskChangeLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    parishRiskId?: boolean
    riskType?: boolean
    oldLevel?: boolean
    newLevel?: boolean
    oldNotes?: boolean
    newNotes?: boolean
    changedBy?: boolean
    changeReason?: boolean
    createdAt?: boolean
    parishRisk?: boolean | ParishRiskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["riskChangeLog"]>

  export type RiskChangeLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    parishRiskId?: boolean
    riskType?: boolean
    oldLevel?: boolean
    newLevel?: boolean
    oldNotes?: boolean
    newNotes?: boolean
    changedBy?: boolean
    changeReason?: boolean
    createdAt?: boolean
    parishRisk?: boolean | ParishRiskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["riskChangeLog"]>

  export type RiskChangeLogSelectScalar = {
    id?: boolean
    parishRiskId?: boolean
    riskType?: boolean
    oldLevel?: boolean
    newLevel?: boolean
    oldNotes?: boolean
    newNotes?: boolean
    changedBy?: boolean
    changeReason?: boolean
    createdAt?: boolean
  }

  export type RiskChangeLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parishRisk?: boolean | ParishRiskDefaultArgs<ExtArgs>
  }
  export type RiskChangeLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parishRisk?: boolean | ParishRiskDefaultArgs<ExtArgs>
  }

  export type $RiskChangeLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RiskChangeLog"
    objects: {
      parishRisk: Prisma.$ParishRiskPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      parishRiskId: string
      riskType: string
      oldLevel: number
      newLevel: number
      oldNotes: string
      newNotes: string
      changedBy: string
      changeReason: string | null
      createdAt: Date
    }, ExtArgs["result"]["riskChangeLog"]>
    composites: {}
  }

  type RiskChangeLogGetPayload<S extends boolean | null | undefined | RiskChangeLogDefaultArgs> = $Result.GetResult<Prisma.$RiskChangeLogPayload, S>

  type RiskChangeLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RiskChangeLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RiskChangeLogCountAggregateInputType | true
    }

  export interface RiskChangeLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RiskChangeLog'], meta: { name: 'RiskChangeLog' } }
    /**
     * Find zero or one RiskChangeLog that matches the filter.
     * @param {RiskChangeLogFindUniqueArgs} args - Arguments to find a RiskChangeLog
     * @example
     * // Get one RiskChangeLog
     * const riskChangeLog = await prisma.riskChangeLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RiskChangeLogFindUniqueArgs>(args: SelectSubset<T, RiskChangeLogFindUniqueArgs<ExtArgs>>): Prisma__RiskChangeLogClient<$Result.GetResult<Prisma.$RiskChangeLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RiskChangeLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RiskChangeLogFindUniqueOrThrowArgs} args - Arguments to find a RiskChangeLog
     * @example
     * // Get one RiskChangeLog
     * const riskChangeLog = await prisma.riskChangeLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RiskChangeLogFindUniqueOrThrowArgs>(args: SelectSubset<T, RiskChangeLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RiskChangeLogClient<$Result.GetResult<Prisma.$RiskChangeLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RiskChangeLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskChangeLogFindFirstArgs} args - Arguments to find a RiskChangeLog
     * @example
     * // Get one RiskChangeLog
     * const riskChangeLog = await prisma.riskChangeLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RiskChangeLogFindFirstArgs>(args?: SelectSubset<T, RiskChangeLogFindFirstArgs<ExtArgs>>): Prisma__RiskChangeLogClient<$Result.GetResult<Prisma.$RiskChangeLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RiskChangeLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskChangeLogFindFirstOrThrowArgs} args - Arguments to find a RiskChangeLog
     * @example
     * // Get one RiskChangeLog
     * const riskChangeLog = await prisma.riskChangeLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RiskChangeLogFindFirstOrThrowArgs>(args?: SelectSubset<T, RiskChangeLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__RiskChangeLogClient<$Result.GetResult<Prisma.$RiskChangeLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RiskChangeLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskChangeLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RiskChangeLogs
     * const riskChangeLogs = await prisma.riskChangeLog.findMany()
     * 
     * // Get first 10 RiskChangeLogs
     * const riskChangeLogs = await prisma.riskChangeLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const riskChangeLogWithIdOnly = await prisma.riskChangeLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RiskChangeLogFindManyArgs>(args?: SelectSubset<T, RiskChangeLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RiskChangeLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RiskChangeLog.
     * @param {RiskChangeLogCreateArgs} args - Arguments to create a RiskChangeLog.
     * @example
     * // Create one RiskChangeLog
     * const RiskChangeLog = await prisma.riskChangeLog.create({
     *   data: {
     *     // ... data to create a RiskChangeLog
     *   }
     * })
     * 
     */
    create<T extends RiskChangeLogCreateArgs>(args: SelectSubset<T, RiskChangeLogCreateArgs<ExtArgs>>): Prisma__RiskChangeLogClient<$Result.GetResult<Prisma.$RiskChangeLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RiskChangeLogs.
     * @param {RiskChangeLogCreateManyArgs} args - Arguments to create many RiskChangeLogs.
     * @example
     * // Create many RiskChangeLogs
     * const riskChangeLog = await prisma.riskChangeLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RiskChangeLogCreateManyArgs>(args?: SelectSubset<T, RiskChangeLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RiskChangeLogs and returns the data saved in the database.
     * @param {RiskChangeLogCreateManyAndReturnArgs} args - Arguments to create many RiskChangeLogs.
     * @example
     * // Create many RiskChangeLogs
     * const riskChangeLog = await prisma.riskChangeLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RiskChangeLogs and only return the `id`
     * const riskChangeLogWithIdOnly = await prisma.riskChangeLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RiskChangeLogCreateManyAndReturnArgs>(args?: SelectSubset<T, RiskChangeLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RiskChangeLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RiskChangeLog.
     * @param {RiskChangeLogDeleteArgs} args - Arguments to delete one RiskChangeLog.
     * @example
     * // Delete one RiskChangeLog
     * const RiskChangeLog = await prisma.riskChangeLog.delete({
     *   where: {
     *     // ... filter to delete one RiskChangeLog
     *   }
     * })
     * 
     */
    delete<T extends RiskChangeLogDeleteArgs>(args: SelectSubset<T, RiskChangeLogDeleteArgs<ExtArgs>>): Prisma__RiskChangeLogClient<$Result.GetResult<Prisma.$RiskChangeLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RiskChangeLog.
     * @param {RiskChangeLogUpdateArgs} args - Arguments to update one RiskChangeLog.
     * @example
     * // Update one RiskChangeLog
     * const riskChangeLog = await prisma.riskChangeLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RiskChangeLogUpdateArgs>(args: SelectSubset<T, RiskChangeLogUpdateArgs<ExtArgs>>): Prisma__RiskChangeLogClient<$Result.GetResult<Prisma.$RiskChangeLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RiskChangeLogs.
     * @param {RiskChangeLogDeleteManyArgs} args - Arguments to filter RiskChangeLogs to delete.
     * @example
     * // Delete a few RiskChangeLogs
     * const { count } = await prisma.riskChangeLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RiskChangeLogDeleteManyArgs>(args?: SelectSubset<T, RiskChangeLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RiskChangeLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskChangeLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RiskChangeLogs
     * const riskChangeLog = await prisma.riskChangeLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RiskChangeLogUpdateManyArgs>(args: SelectSubset<T, RiskChangeLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RiskChangeLog.
     * @param {RiskChangeLogUpsertArgs} args - Arguments to update or create a RiskChangeLog.
     * @example
     * // Update or create a RiskChangeLog
     * const riskChangeLog = await prisma.riskChangeLog.upsert({
     *   create: {
     *     // ... data to create a RiskChangeLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RiskChangeLog we want to update
     *   }
     * })
     */
    upsert<T extends RiskChangeLogUpsertArgs>(args: SelectSubset<T, RiskChangeLogUpsertArgs<ExtArgs>>): Prisma__RiskChangeLogClient<$Result.GetResult<Prisma.$RiskChangeLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RiskChangeLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskChangeLogCountArgs} args - Arguments to filter RiskChangeLogs to count.
     * @example
     * // Count the number of RiskChangeLogs
     * const count = await prisma.riskChangeLog.count({
     *   where: {
     *     // ... the filter for the RiskChangeLogs we want to count
     *   }
     * })
    **/
    count<T extends RiskChangeLogCountArgs>(
      args?: Subset<T, RiskChangeLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RiskChangeLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RiskChangeLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskChangeLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RiskChangeLogAggregateArgs>(args: Subset<T, RiskChangeLogAggregateArgs>): Prisma.PrismaPromise<GetRiskChangeLogAggregateType<T>>

    /**
     * Group by RiskChangeLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskChangeLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RiskChangeLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RiskChangeLogGroupByArgs['orderBy'] }
        : { orderBy?: RiskChangeLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RiskChangeLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRiskChangeLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RiskChangeLog model
   */
  readonly fields: RiskChangeLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RiskChangeLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RiskChangeLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parishRisk<T extends ParishRiskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ParishRiskDefaultArgs<ExtArgs>>): Prisma__ParishRiskClient<$Result.GetResult<Prisma.$ParishRiskPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RiskChangeLog model
   */ 
  interface RiskChangeLogFieldRefs {
    readonly id: FieldRef<"RiskChangeLog", 'String'>
    readonly parishRiskId: FieldRef<"RiskChangeLog", 'String'>
    readonly riskType: FieldRef<"RiskChangeLog", 'String'>
    readonly oldLevel: FieldRef<"RiskChangeLog", 'Int'>
    readonly newLevel: FieldRef<"RiskChangeLog", 'Int'>
    readonly oldNotes: FieldRef<"RiskChangeLog", 'String'>
    readonly newNotes: FieldRef<"RiskChangeLog", 'String'>
    readonly changedBy: FieldRef<"RiskChangeLog", 'String'>
    readonly changeReason: FieldRef<"RiskChangeLog", 'String'>
    readonly createdAt: FieldRef<"RiskChangeLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RiskChangeLog findUnique
   */
  export type RiskChangeLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskChangeLog
     */
    select?: RiskChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskChangeLogInclude<ExtArgs> | null
    /**
     * Filter, which RiskChangeLog to fetch.
     */
    where: RiskChangeLogWhereUniqueInput
  }

  /**
   * RiskChangeLog findUniqueOrThrow
   */
  export type RiskChangeLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskChangeLog
     */
    select?: RiskChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskChangeLogInclude<ExtArgs> | null
    /**
     * Filter, which RiskChangeLog to fetch.
     */
    where: RiskChangeLogWhereUniqueInput
  }

  /**
   * RiskChangeLog findFirst
   */
  export type RiskChangeLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskChangeLog
     */
    select?: RiskChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskChangeLogInclude<ExtArgs> | null
    /**
     * Filter, which RiskChangeLog to fetch.
     */
    where?: RiskChangeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskChangeLogs to fetch.
     */
    orderBy?: RiskChangeLogOrderByWithRelationInput | RiskChangeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RiskChangeLogs.
     */
    cursor?: RiskChangeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskChangeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskChangeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RiskChangeLogs.
     */
    distinct?: RiskChangeLogScalarFieldEnum | RiskChangeLogScalarFieldEnum[]
  }

  /**
   * RiskChangeLog findFirstOrThrow
   */
  export type RiskChangeLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskChangeLog
     */
    select?: RiskChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskChangeLogInclude<ExtArgs> | null
    /**
     * Filter, which RiskChangeLog to fetch.
     */
    where?: RiskChangeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskChangeLogs to fetch.
     */
    orderBy?: RiskChangeLogOrderByWithRelationInput | RiskChangeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RiskChangeLogs.
     */
    cursor?: RiskChangeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskChangeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskChangeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RiskChangeLogs.
     */
    distinct?: RiskChangeLogScalarFieldEnum | RiskChangeLogScalarFieldEnum[]
  }

  /**
   * RiskChangeLog findMany
   */
  export type RiskChangeLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskChangeLog
     */
    select?: RiskChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskChangeLogInclude<ExtArgs> | null
    /**
     * Filter, which RiskChangeLogs to fetch.
     */
    where?: RiskChangeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskChangeLogs to fetch.
     */
    orderBy?: RiskChangeLogOrderByWithRelationInput | RiskChangeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RiskChangeLogs.
     */
    cursor?: RiskChangeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskChangeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskChangeLogs.
     */
    skip?: number
    distinct?: RiskChangeLogScalarFieldEnum | RiskChangeLogScalarFieldEnum[]
  }

  /**
   * RiskChangeLog create
   */
  export type RiskChangeLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskChangeLog
     */
    select?: RiskChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskChangeLogInclude<ExtArgs> | null
    /**
     * The data needed to create a RiskChangeLog.
     */
    data: XOR<RiskChangeLogCreateInput, RiskChangeLogUncheckedCreateInput>
  }

  /**
   * RiskChangeLog createMany
   */
  export type RiskChangeLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RiskChangeLogs.
     */
    data: RiskChangeLogCreateManyInput | RiskChangeLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RiskChangeLog createManyAndReturn
   */
  export type RiskChangeLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskChangeLog
     */
    select?: RiskChangeLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RiskChangeLogs.
     */
    data: RiskChangeLogCreateManyInput | RiskChangeLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskChangeLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RiskChangeLog update
   */
  export type RiskChangeLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskChangeLog
     */
    select?: RiskChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskChangeLogInclude<ExtArgs> | null
    /**
     * The data needed to update a RiskChangeLog.
     */
    data: XOR<RiskChangeLogUpdateInput, RiskChangeLogUncheckedUpdateInput>
    /**
     * Choose, which RiskChangeLog to update.
     */
    where: RiskChangeLogWhereUniqueInput
  }

  /**
   * RiskChangeLog updateMany
   */
  export type RiskChangeLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RiskChangeLogs.
     */
    data: XOR<RiskChangeLogUpdateManyMutationInput, RiskChangeLogUncheckedUpdateManyInput>
    /**
     * Filter which RiskChangeLogs to update
     */
    where?: RiskChangeLogWhereInput
  }

  /**
   * RiskChangeLog upsert
   */
  export type RiskChangeLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskChangeLog
     */
    select?: RiskChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskChangeLogInclude<ExtArgs> | null
    /**
     * The filter to search for the RiskChangeLog to update in case it exists.
     */
    where: RiskChangeLogWhereUniqueInput
    /**
     * In case the RiskChangeLog found by the `where` argument doesn't exist, create a new RiskChangeLog with this data.
     */
    create: XOR<RiskChangeLogCreateInput, RiskChangeLogUncheckedCreateInput>
    /**
     * In case the RiskChangeLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RiskChangeLogUpdateInput, RiskChangeLogUncheckedUpdateInput>
  }

  /**
   * RiskChangeLog delete
   */
  export type RiskChangeLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskChangeLog
     */
    select?: RiskChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskChangeLogInclude<ExtArgs> | null
    /**
     * Filter which RiskChangeLog to delete.
     */
    where: RiskChangeLogWhereUniqueInput
  }

  /**
   * RiskChangeLog deleteMany
   */
  export type RiskChangeLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RiskChangeLogs to delete
     */
    where?: RiskChangeLogWhereInput
  }

  /**
   * RiskChangeLog without action
   */
  export type RiskChangeLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskChangeLog
     */
    select?: RiskChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskChangeLogInclude<ExtArgs> | null
  }


  /**
   * Model BusinessType
   */

  export type AggregateBusinessType = {
    _count: BusinessTypeCountAggregateOutputType | null
    _min: BusinessTypeMinAggregateOutputType | null
    _max: BusinessTypeMaxAggregateOutputType | null
  }

  export type BusinessTypeMinAggregateOutputType = {
    id: string | null
    businessTypeId: string | null
    name: string | null
    category: string | null
    subcategory: string | null
    description: string | null
    exampleBusinessPurposes: string | null
    exampleProducts: string | null
    exampleKeyPersonnel: string | null
    exampleCustomerBase: string | null
    minimumEquipment: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BusinessTypeMaxAggregateOutputType = {
    id: string | null
    businessTypeId: string | null
    name: string | null
    category: string | null
    subcategory: string | null
    description: string | null
    exampleBusinessPurposes: string | null
    exampleProducts: string | null
    exampleKeyPersonnel: string | null
    exampleCustomerBase: string | null
    minimumEquipment: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BusinessTypeCountAggregateOutputType = {
    id: number
    businessTypeId: number
    name: number
    category: number
    subcategory: number
    description: number
    exampleBusinessPurposes: number
    exampleProducts: number
    exampleKeyPersonnel: number
    exampleCustomerBase: number
    minimumEquipment: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BusinessTypeMinAggregateInputType = {
    id?: true
    businessTypeId?: true
    name?: true
    category?: true
    subcategory?: true
    description?: true
    exampleBusinessPurposes?: true
    exampleProducts?: true
    exampleKeyPersonnel?: true
    exampleCustomerBase?: true
    minimumEquipment?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BusinessTypeMaxAggregateInputType = {
    id?: true
    businessTypeId?: true
    name?: true
    category?: true
    subcategory?: true
    description?: true
    exampleBusinessPurposes?: true
    exampleProducts?: true
    exampleKeyPersonnel?: true
    exampleCustomerBase?: true
    minimumEquipment?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BusinessTypeCountAggregateInputType = {
    id?: true
    businessTypeId?: true
    name?: true
    category?: true
    subcategory?: true
    description?: true
    exampleBusinessPurposes?: true
    exampleProducts?: true
    exampleKeyPersonnel?: true
    exampleCustomerBase?: true
    minimumEquipment?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BusinessTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessType to aggregate.
     */
    where?: BusinessTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessTypes to fetch.
     */
    orderBy?: BusinessTypeOrderByWithRelationInput | BusinessTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BusinessTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BusinessTypes
    **/
    _count?: true | BusinessTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BusinessTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BusinessTypeMaxAggregateInputType
  }

  export type GetBusinessTypeAggregateType<T extends BusinessTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateBusinessType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBusinessType[P]>
      : GetScalarType<T[P], AggregateBusinessType[P]>
  }




  export type BusinessTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessTypeWhereInput
    orderBy?: BusinessTypeOrderByWithAggregationInput | BusinessTypeOrderByWithAggregationInput[]
    by: BusinessTypeScalarFieldEnum[] | BusinessTypeScalarFieldEnum
    having?: BusinessTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BusinessTypeCountAggregateInputType | true
    _min?: BusinessTypeMinAggregateInputType
    _max?: BusinessTypeMaxAggregateInputType
  }

  export type BusinessTypeGroupByOutputType = {
    id: string
    businessTypeId: string
    name: string
    category: string
    subcategory: string | null
    description: string | null
    exampleBusinessPurposes: string | null
    exampleProducts: string | null
    exampleKeyPersonnel: string | null
    exampleCustomerBase: string | null
    minimumEquipment: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: BusinessTypeCountAggregateOutputType | null
    _min: BusinessTypeMinAggregateOutputType | null
    _max: BusinessTypeMaxAggregateOutputType | null
  }

  type GetBusinessTypeGroupByPayload<T extends BusinessTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BusinessTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BusinessTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BusinessTypeGroupByOutputType[P]>
            : GetScalarType<T[P], BusinessTypeGroupByOutputType[P]>
        }
      >
    >


  export type BusinessTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessTypeId?: boolean
    name?: boolean
    category?: boolean
    subcategory?: boolean
    description?: boolean
    exampleBusinessPurposes?: boolean
    exampleProducts?: boolean
    exampleKeyPersonnel?: boolean
    exampleCustomerBase?: boolean
    minimumEquipment?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    riskVulnerabilities?: boolean | BusinessType$riskVulnerabilitiesArgs<ExtArgs>
    businessTypeStrategies?: boolean | BusinessType$businessTypeStrategiesArgs<ExtArgs>
    businessRiskProfiles?: boolean | BusinessType$businessRiskProfilesArgs<ExtArgs>
    translations?: boolean | BusinessType$translationsArgs<ExtArgs>
    _count?: boolean | BusinessTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["businessType"]>

  export type BusinessTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessTypeId?: boolean
    name?: boolean
    category?: boolean
    subcategory?: boolean
    description?: boolean
    exampleBusinessPurposes?: boolean
    exampleProducts?: boolean
    exampleKeyPersonnel?: boolean
    exampleCustomerBase?: boolean
    minimumEquipment?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["businessType"]>

  export type BusinessTypeSelectScalar = {
    id?: boolean
    businessTypeId?: boolean
    name?: boolean
    category?: boolean
    subcategory?: boolean
    description?: boolean
    exampleBusinessPurposes?: boolean
    exampleProducts?: boolean
    exampleKeyPersonnel?: boolean
    exampleCustomerBase?: boolean
    minimumEquipment?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BusinessTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    riskVulnerabilities?: boolean | BusinessType$riskVulnerabilitiesArgs<ExtArgs>
    businessTypeStrategies?: boolean | BusinessType$businessTypeStrategiesArgs<ExtArgs>
    businessRiskProfiles?: boolean | BusinessType$businessRiskProfilesArgs<ExtArgs>
    translations?: boolean | BusinessType$translationsArgs<ExtArgs>
    _count?: boolean | BusinessTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BusinessTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BusinessTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BusinessType"
    objects: {
      riskVulnerabilities: Prisma.$BusinessRiskVulnerabilityPayload<ExtArgs>[]
      businessTypeStrategies: Prisma.$BusinessTypeStrategyPayload<ExtArgs>[]
      businessRiskProfiles: Prisma.$BusinessRiskProfilePayload<ExtArgs>[]
      translations: Prisma.$BusinessTypeTranslationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      businessTypeId: string
      name: string
      category: string
      subcategory: string | null
      description: string | null
      exampleBusinessPurposes: string | null
      exampleProducts: string | null
      exampleKeyPersonnel: string | null
      exampleCustomerBase: string | null
      minimumEquipment: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["businessType"]>
    composites: {}
  }

  type BusinessTypeGetPayload<S extends boolean | null | undefined | BusinessTypeDefaultArgs> = $Result.GetResult<Prisma.$BusinessTypePayload, S>

  type BusinessTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BusinessTypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BusinessTypeCountAggregateInputType | true
    }

  export interface BusinessTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BusinessType'], meta: { name: 'BusinessType' } }
    /**
     * Find zero or one BusinessType that matches the filter.
     * @param {BusinessTypeFindUniqueArgs} args - Arguments to find a BusinessType
     * @example
     * // Get one BusinessType
     * const businessType = await prisma.businessType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BusinessTypeFindUniqueArgs>(args: SelectSubset<T, BusinessTypeFindUniqueArgs<ExtArgs>>): Prisma__BusinessTypeClient<$Result.GetResult<Prisma.$BusinessTypePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BusinessType that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BusinessTypeFindUniqueOrThrowArgs} args - Arguments to find a BusinessType
     * @example
     * // Get one BusinessType
     * const businessType = await prisma.businessType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BusinessTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, BusinessTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BusinessTypeClient<$Result.GetResult<Prisma.$BusinessTypePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BusinessType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessTypeFindFirstArgs} args - Arguments to find a BusinessType
     * @example
     * // Get one BusinessType
     * const businessType = await prisma.businessType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BusinessTypeFindFirstArgs>(args?: SelectSubset<T, BusinessTypeFindFirstArgs<ExtArgs>>): Prisma__BusinessTypeClient<$Result.GetResult<Prisma.$BusinessTypePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BusinessType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessTypeFindFirstOrThrowArgs} args - Arguments to find a BusinessType
     * @example
     * // Get one BusinessType
     * const businessType = await prisma.businessType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BusinessTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, BusinessTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__BusinessTypeClient<$Result.GetResult<Prisma.$BusinessTypePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BusinessTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BusinessTypes
     * const businessTypes = await prisma.businessType.findMany()
     * 
     * // Get first 10 BusinessTypes
     * const businessTypes = await prisma.businessType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const businessTypeWithIdOnly = await prisma.businessType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BusinessTypeFindManyArgs>(args?: SelectSubset<T, BusinessTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessTypePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BusinessType.
     * @param {BusinessTypeCreateArgs} args - Arguments to create a BusinessType.
     * @example
     * // Create one BusinessType
     * const BusinessType = await prisma.businessType.create({
     *   data: {
     *     // ... data to create a BusinessType
     *   }
     * })
     * 
     */
    create<T extends BusinessTypeCreateArgs>(args: SelectSubset<T, BusinessTypeCreateArgs<ExtArgs>>): Prisma__BusinessTypeClient<$Result.GetResult<Prisma.$BusinessTypePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BusinessTypes.
     * @param {BusinessTypeCreateManyArgs} args - Arguments to create many BusinessTypes.
     * @example
     * // Create many BusinessTypes
     * const businessType = await prisma.businessType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BusinessTypeCreateManyArgs>(args?: SelectSubset<T, BusinessTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BusinessTypes and returns the data saved in the database.
     * @param {BusinessTypeCreateManyAndReturnArgs} args - Arguments to create many BusinessTypes.
     * @example
     * // Create many BusinessTypes
     * const businessType = await prisma.businessType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BusinessTypes and only return the `id`
     * const businessTypeWithIdOnly = await prisma.businessType.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BusinessTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, BusinessTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessTypePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BusinessType.
     * @param {BusinessTypeDeleteArgs} args - Arguments to delete one BusinessType.
     * @example
     * // Delete one BusinessType
     * const BusinessType = await prisma.businessType.delete({
     *   where: {
     *     // ... filter to delete one BusinessType
     *   }
     * })
     * 
     */
    delete<T extends BusinessTypeDeleteArgs>(args: SelectSubset<T, BusinessTypeDeleteArgs<ExtArgs>>): Prisma__BusinessTypeClient<$Result.GetResult<Prisma.$BusinessTypePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BusinessType.
     * @param {BusinessTypeUpdateArgs} args - Arguments to update one BusinessType.
     * @example
     * // Update one BusinessType
     * const businessType = await prisma.businessType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BusinessTypeUpdateArgs>(args: SelectSubset<T, BusinessTypeUpdateArgs<ExtArgs>>): Prisma__BusinessTypeClient<$Result.GetResult<Prisma.$BusinessTypePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BusinessTypes.
     * @param {BusinessTypeDeleteManyArgs} args - Arguments to filter BusinessTypes to delete.
     * @example
     * // Delete a few BusinessTypes
     * const { count } = await prisma.businessType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BusinessTypeDeleteManyArgs>(args?: SelectSubset<T, BusinessTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BusinessTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BusinessTypes
     * const businessType = await prisma.businessType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BusinessTypeUpdateManyArgs>(args: SelectSubset<T, BusinessTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BusinessType.
     * @param {BusinessTypeUpsertArgs} args - Arguments to update or create a BusinessType.
     * @example
     * // Update or create a BusinessType
     * const businessType = await prisma.businessType.upsert({
     *   create: {
     *     // ... data to create a BusinessType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BusinessType we want to update
     *   }
     * })
     */
    upsert<T extends BusinessTypeUpsertArgs>(args: SelectSubset<T, BusinessTypeUpsertArgs<ExtArgs>>): Prisma__BusinessTypeClient<$Result.GetResult<Prisma.$BusinessTypePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BusinessTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessTypeCountArgs} args - Arguments to filter BusinessTypes to count.
     * @example
     * // Count the number of BusinessTypes
     * const count = await prisma.businessType.count({
     *   where: {
     *     // ... the filter for the BusinessTypes we want to count
     *   }
     * })
    **/
    count<T extends BusinessTypeCountArgs>(
      args?: Subset<T, BusinessTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BusinessTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BusinessType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BusinessTypeAggregateArgs>(args: Subset<T, BusinessTypeAggregateArgs>): Prisma.PrismaPromise<GetBusinessTypeAggregateType<T>>

    /**
     * Group by BusinessType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BusinessTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BusinessTypeGroupByArgs['orderBy'] }
        : { orderBy?: BusinessTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BusinessTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBusinessTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BusinessType model
   */
  readonly fields: BusinessTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BusinessType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BusinessTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    riskVulnerabilities<T extends BusinessType$riskVulnerabilitiesArgs<ExtArgs> = {}>(args?: Subset<T, BusinessType$riskVulnerabilitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessRiskVulnerabilityPayload<ExtArgs>, T, "findMany"> | Null>
    businessTypeStrategies<T extends BusinessType$businessTypeStrategiesArgs<ExtArgs> = {}>(args?: Subset<T, BusinessType$businessTypeStrategiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessTypeStrategyPayload<ExtArgs>, T, "findMany"> | Null>
    businessRiskProfiles<T extends BusinessType$businessRiskProfilesArgs<ExtArgs> = {}>(args?: Subset<T, BusinessType$businessRiskProfilesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessRiskProfilePayload<ExtArgs>, T, "findMany"> | Null>
    translations<T extends BusinessType$translationsArgs<ExtArgs> = {}>(args?: Subset<T, BusinessType$translationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessTypeTranslationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BusinessType model
   */ 
  interface BusinessTypeFieldRefs {
    readonly id: FieldRef<"BusinessType", 'String'>
    readonly businessTypeId: FieldRef<"BusinessType", 'String'>
    readonly name: FieldRef<"BusinessType", 'String'>
    readonly category: FieldRef<"BusinessType", 'String'>
    readonly subcategory: FieldRef<"BusinessType", 'String'>
    readonly description: FieldRef<"BusinessType", 'String'>
    readonly exampleBusinessPurposes: FieldRef<"BusinessType", 'String'>
    readonly exampleProducts: FieldRef<"BusinessType", 'String'>
    readonly exampleKeyPersonnel: FieldRef<"BusinessType", 'String'>
    readonly exampleCustomerBase: FieldRef<"BusinessType", 'String'>
    readonly minimumEquipment: FieldRef<"BusinessType", 'String'>
    readonly isActive: FieldRef<"BusinessType", 'Boolean'>
    readonly createdAt: FieldRef<"BusinessType", 'DateTime'>
    readonly updatedAt: FieldRef<"BusinessType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BusinessType findUnique
   */
  export type BusinessTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessType
     */
    select?: BusinessTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypeInclude<ExtArgs> | null
    /**
     * Filter, which BusinessType to fetch.
     */
    where: BusinessTypeWhereUniqueInput
  }

  /**
   * BusinessType findUniqueOrThrow
   */
  export type BusinessTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessType
     */
    select?: BusinessTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypeInclude<ExtArgs> | null
    /**
     * Filter, which BusinessType to fetch.
     */
    where: BusinessTypeWhereUniqueInput
  }

  /**
   * BusinessType findFirst
   */
  export type BusinessTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessType
     */
    select?: BusinessTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypeInclude<ExtArgs> | null
    /**
     * Filter, which BusinessType to fetch.
     */
    where?: BusinessTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessTypes to fetch.
     */
    orderBy?: BusinessTypeOrderByWithRelationInput | BusinessTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessTypes.
     */
    cursor?: BusinessTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessTypes.
     */
    distinct?: BusinessTypeScalarFieldEnum | BusinessTypeScalarFieldEnum[]
  }

  /**
   * BusinessType findFirstOrThrow
   */
  export type BusinessTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessType
     */
    select?: BusinessTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypeInclude<ExtArgs> | null
    /**
     * Filter, which BusinessType to fetch.
     */
    where?: BusinessTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessTypes to fetch.
     */
    orderBy?: BusinessTypeOrderByWithRelationInput | BusinessTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessTypes.
     */
    cursor?: BusinessTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessTypes.
     */
    distinct?: BusinessTypeScalarFieldEnum | BusinessTypeScalarFieldEnum[]
  }

  /**
   * BusinessType findMany
   */
  export type BusinessTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessType
     */
    select?: BusinessTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypeInclude<ExtArgs> | null
    /**
     * Filter, which BusinessTypes to fetch.
     */
    where?: BusinessTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessTypes to fetch.
     */
    orderBy?: BusinessTypeOrderByWithRelationInput | BusinessTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BusinessTypes.
     */
    cursor?: BusinessTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessTypes.
     */
    skip?: number
    distinct?: BusinessTypeScalarFieldEnum | BusinessTypeScalarFieldEnum[]
  }

  /**
   * BusinessType create
   */
  export type BusinessTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessType
     */
    select?: BusinessTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a BusinessType.
     */
    data: XOR<BusinessTypeCreateInput, BusinessTypeUncheckedCreateInput>
  }

  /**
   * BusinessType createMany
   */
  export type BusinessTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BusinessTypes.
     */
    data: BusinessTypeCreateManyInput | BusinessTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BusinessType createManyAndReturn
   */
  export type BusinessTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessType
     */
    select?: BusinessTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BusinessTypes.
     */
    data: BusinessTypeCreateManyInput | BusinessTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BusinessType update
   */
  export type BusinessTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessType
     */
    select?: BusinessTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a BusinessType.
     */
    data: XOR<BusinessTypeUpdateInput, BusinessTypeUncheckedUpdateInput>
    /**
     * Choose, which BusinessType to update.
     */
    where: BusinessTypeWhereUniqueInput
  }

  /**
   * BusinessType updateMany
   */
  export type BusinessTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BusinessTypes.
     */
    data: XOR<BusinessTypeUpdateManyMutationInput, BusinessTypeUncheckedUpdateManyInput>
    /**
     * Filter which BusinessTypes to update
     */
    where?: BusinessTypeWhereInput
  }

  /**
   * BusinessType upsert
   */
  export type BusinessTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessType
     */
    select?: BusinessTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the BusinessType to update in case it exists.
     */
    where: BusinessTypeWhereUniqueInput
    /**
     * In case the BusinessType found by the `where` argument doesn't exist, create a new BusinessType with this data.
     */
    create: XOR<BusinessTypeCreateInput, BusinessTypeUncheckedCreateInput>
    /**
     * In case the BusinessType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BusinessTypeUpdateInput, BusinessTypeUncheckedUpdateInput>
  }

  /**
   * BusinessType delete
   */
  export type BusinessTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessType
     */
    select?: BusinessTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypeInclude<ExtArgs> | null
    /**
     * Filter which BusinessType to delete.
     */
    where: BusinessTypeWhereUniqueInput
  }

  /**
   * BusinessType deleteMany
   */
  export type BusinessTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessTypes to delete
     */
    where?: BusinessTypeWhereInput
  }

  /**
   * BusinessType.riskVulnerabilities
   */
  export type BusinessType$riskVulnerabilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessRiskVulnerability
     */
    select?: BusinessRiskVulnerabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessRiskVulnerabilityInclude<ExtArgs> | null
    where?: BusinessRiskVulnerabilityWhereInput
    orderBy?: BusinessRiskVulnerabilityOrderByWithRelationInput | BusinessRiskVulnerabilityOrderByWithRelationInput[]
    cursor?: BusinessRiskVulnerabilityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BusinessRiskVulnerabilityScalarFieldEnum | BusinessRiskVulnerabilityScalarFieldEnum[]
  }

  /**
   * BusinessType.businessTypeStrategies
   */
  export type BusinessType$businessTypeStrategiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessTypeStrategy
     */
    select?: BusinessTypeStrategySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypeStrategyInclude<ExtArgs> | null
    where?: BusinessTypeStrategyWhereInput
    orderBy?: BusinessTypeStrategyOrderByWithRelationInput | BusinessTypeStrategyOrderByWithRelationInput[]
    cursor?: BusinessTypeStrategyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BusinessTypeStrategyScalarFieldEnum | BusinessTypeStrategyScalarFieldEnum[]
  }

  /**
   * BusinessType.businessRiskProfiles
   */
  export type BusinessType$businessRiskProfilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessRiskProfile
     */
    select?: BusinessRiskProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessRiskProfileInclude<ExtArgs> | null
    where?: BusinessRiskProfileWhereInput
    orderBy?: BusinessRiskProfileOrderByWithRelationInput | BusinessRiskProfileOrderByWithRelationInput[]
    cursor?: BusinessRiskProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BusinessRiskProfileScalarFieldEnum | BusinessRiskProfileScalarFieldEnum[]
  }

  /**
   * BusinessType.translations
   */
  export type BusinessType$translationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessTypeTranslation
     */
    select?: BusinessTypeTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypeTranslationInclude<ExtArgs> | null
    where?: BusinessTypeTranslationWhereInput
    orderBy?: BusinessTypeTranslationOrderByWithRelationInput | BusinessTypeTranslationOrderByWithRelationInput[]
    cursor?: BusinessTypeTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BusinessTypeTranslationScalarFieldEnum | BusinessTypeTranslationScalarFieldEnum[]
  }

  /**
   * BusinessType without action
   */
  export type BusinessTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessType
     */
    select?: BusinessTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypeInclude<ExtArgs> | null
  }


  /**
   * Model BusinessRiskVulnerability
   */

  export type AggregateBusinessRiskVulnerability = {
    _count: BusinessRiskVulnerabilityCountAggregateOutputType | null
    _avg: BusinessRiskVulnerabilityAvgAggregateOutputType | null
    _sum: BusinessRiskVulnerabilitySumAggregateOutputType | null
    _min: BusinessRiskVulnerabilityMinAggregateOutputType | null
    _max: BusinessRiskVulnerabilityMaxAggregateOutputType | null
  }

  export type BusinessRiskVulnerabilityAvgAggregateOutputType = {
    vulnerabilityLevel: number | null
    impactSeverity: number | null
    mitigationDifficulty: number | null
  }

  export type BusinessRiskVulnerabilitySumAggregateOutputType = {
    vulnerabilityLevel: number | null
    impactSeverity: number | null
    mitigationDifficulty: number | null
  }

  export type BusinessRiskVulnerabilityMinAggregateOutputType = {
    id: string | null
    businessTypeId: string | null
    riskType: string | null
    vulnerabilityLevel: number | null
    impactSeverity: number | null
    recoveryTime: string | null
    reasoning: string | null
    mitigationDifficulty: number | null
    costToRecover: string | null
    businessImpactAreas: string | null
    criticalDependencies: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BusinessRiskVulnerabilityMaxAggregateOutputType = {
    id: string | null
    businessTypeId: string | null
    riskType: string | null
    vulnerabilityLevel: number | null
    impactSeverity: number | null
    recoveryTime: string | null
    reasoning: string | null
    mitigationDifficulty: number | null
    costToRecover: string | null
    businessImpactAreas: string | null
    criticalDependencies: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BusinessRiskVulnerabilityCountAggregateOutputType = {
    id: number
    businessTypeId: number
    riskType: number
    vulnerabilityLevel: number
    impactSeverity: number
    recoveryTime: number
    reasoning: number
    mitigationDifficulty: number
    costToRecover: number
    businessImpactAreas: number
    criticalDependencies: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BusinessRiskVulnerabilityAvgAggregateInputType = {
    vulnerabilityLevel?: true
    impactSeverity?: true
    mitigationDifficulty?: true
  }

  export type BusinessRiskVulnerabilitySumAggregateInputType = {
    vulnerabilityLevel?: true
    impactSeverity?: true
    mitigationDifficulty?: true
  }

  export type BusinessRiskVulnerabilityMinAggregateInputType = {
    id?: true
    businessTypeId?: true
    riskType?: true
    vulnerabilityLevel?: true
    impactSeverity?: true
    recoveryTime?: true
    reasoning?: true
    mitigationDifficulty?: true
    costToRecover?: true
    businessImpactAreas?: true
    criticalDependencies?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BusinessRiskVulnerabilityMaxAggregateInputType = {
    id?: true
    businessTypeId?: true
    riskType?: true
    vulnerabilityLevel?: true
    impactSeverity?: true
    recoveryTime?: true
    reasoning?: true
    mitigationDifficulty?: true
    costToRecover?: true
    businessImpactAreas?: true
    criticalDependencies?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BusinessRiskVulnerabilityCountAggregateInputType = {
    id?: true
    businessTypeId?: true
    riskType?: true
    vulnerabilityLevel?: true
    impactSeverity?: true
    recoveryTime?: true
    reasoning?: true
    mitigationDifficulty?: true
    costToRecover?: true
    businessImpactAreas?: true
    criticalDependencies?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BusinessRiskVulnerabilityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessRiskVulnerability to aggregate.
     */
    where?: BusinessRiskVulnerabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessRiskVulnerabilities to fetch.
     */
    orderBy?: BusinessRiskVulnerabilityOrderByWithRelationInput | BusinessRiskVulnerabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BusinessRiskVulnerabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessRiskVulnerabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessRiskVulnerabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BusinessRiskVulnerabilities
    **/
    _count?: true | BusinessRiskVulnerabilityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BusinessRiskVulnerabilityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BusinessRiskVulnerabilitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BusinessRiskVulnerabilityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BusinessRiskVulnerabilityMaxAggregateInputType
  }

  export type GetBusinessRiskVulnerabilityAggregateType<T extends BusinessRiskVulnerabilityAggregateArgs> = {
        [P in keyof T & keyof AggregateBusinessRiskVulnerability]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBusinessRiskVulnerability[P]>
      : GetScalarType<T[P], AggregateBusinessRiskVulnerability[P]>
  }




  export type BusinessRiskVulnerabilityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessRiskVulnerabilityWhereInput
    orderBy?: BusinessRiskVulnerabilityOrderByWithAggregationInput | BusinessRiskVulnerabilityOrderByWithAggregationInput[]
    by: BusinessRiskVulnerabilityScalarFieldEnum[] | BusinessRiskVulnerabilityScalarFieldEnum
    having?: BusinessRiskVulnerabilityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BusinessRiskVulnerabilityCountAggregateInputType | true
    _avg?: BusinessRiskVulnerabilityAvgAggregateInputType
    _sum?: BusinessRiskVulnerabilitySumAggregateInputType
    _min?: BusinessRiskVulnerabilityMinAggregateInputType
    _max?: BusinessRiskVulnerabilityMaxAggregateInputType
  }

  export type BusinessRiskVulnerabilityGroupByOutputType = {
    id: string
    businessTypeId: string
    riskType: string
    vulnerabilityLevel: number
    impactSeverity: number
    recoveryTime: string | null
    reasoning: string
    mitigationDifficulty: number | null
    costToRecover: string | null
    businessImpactAreas: string | null
    criticalDependencies: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: BusinessRiskVulnerabilityCountAggregateOutputType | null
    _avg: BusinessRiskVulnerabilityAvgAggregateOutputType | null
    _sum: BusinessRiskVulnerabilitySumAggregateOutputType | null
    _min: BusinessRiskVulnerabilityMinAggregateOutputType | null
    _max: BusinessRiskVulnerabilityMaxAggregateOutputType | null
  }

  type GetBusinessRiskVulnerabilityGroupByPayload<T extends BusinessRiskVulnerabilityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BusinessRiskVulnerabilityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BusinessRiskVulnerabilityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BusinessRiskVulnerabilityGroupByOutputType[P]>
            : GetScalarType<T[P], BusinessRiskVulnerabilityGroupByOutputType[P]>
        }
      >
    >


  export type BusinessRiskVulnerabilitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessTypeId?: boolean
    riskType?: boolean
    vulnerabilityLevel?: boolean
    impactSeverity?: boolean
    recoveryTime?: boolean
    reasoning?: boolean
    mitigationDifficulty?: boolean
    costToRecover?: boolean
    businessImpactAreas?: boolean
    criticalDependencies?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    businessType?: boolean | BusinessTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["businessRiskVulnerability"]>

  export type BusinessRiskVulnerabilitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessTypeId?: boolean
    riskType?: boolean
    vulnerabilityLevel?: boolean
    impactSeverity?: boolean
    recoveryTime?: boolean
    reasoning?: boolean
    mitigationDifficulty?: boolean
    costToRecover?: boolean
    businessImpactAreas?: boolean
    criticalDependencies?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    businessType?: boolean | BusinessTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["businessRiskVulnerability"]>

  export type BusinessRiskVulnerabilitySelectScalar = {
    id?: boolean
    businessTypeId?: boolean
    riskType?: boolean
    vulnerabilityLevel?: boolean
    impactSeverity?: boolean
    recoveryTime?: boolean
    reasoning?: boolean
    mitigationDifficulty?: boolean
    costToRecover?: boolean
    businessImpactAreas?: boolean
    criticalDependencies?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BusinessRiskVulnerabilityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businessType?: boolean | BusinessTypeDefaultArgs<ExtArgs>
  }
  export type BusinessRiskVulnerabilityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businessType?: boolean | BusinessTypeDefaultArgs<ExtArgs>
  }

  export type $BusinessRiskVulnerabilityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BusinessRiskVulnerability"
    objects: {
      businessType: Prisma.$BusinessTypePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      businessTypeId: string
      riskType: string
      vulnerabilityLevel: number
      impactSeverity: number
      recoveryTime: string | null
      reasoning: string
      mitigationDifficulty: number | null
      costToRecover: string | null
      businessImpactAreas: string | null
      criticalDependencies: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["businessRiskVulnerability"]>
    composites: {}
  }

  type BusinessRiskVulnerabilityGetPayload<S extends boolean | null | undefined | BusinessRiskVulnerabilityDefaultArgs> = $Result.GetResult<Prisma.$BusinessRiskVulnerabilityPayload, S>

  type BusinessRiskVulnerabilityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BusinessRiskVulnerabilityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BusinessRiskVulnerabilityCountAggregateInputType | true
    }

  export interface BusinessRiskVulnerabilityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BusinessRiskVulnerability'], meta: { name: 'BusinessRiskVulnerability' } }
    /**
     * Find zero or one BusinessRiskVulnerability that matches the filter.
     * @param {BusinessRiskVulnerabilityFindUniqueArgs} args - Arguments to find a BusinessRiskVulnerability
     * @example
     * // Get one BusinessRiskVulnerability
     * const businessRiskVulnerability = await prisma.businessRiskVulnerability.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BusinessRiskVulnerabilityFindUniqueArgs>(args: SelectSubset<T, BusinessRiskVulnerabilityFindUniqueArgs<ExtArgs>>): Prisma__BusinessRiskVulnerabilityClient<$Result.GetResult<Prisma.$BusinessRiskVulnerabilityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BusinessRiskVulnerability that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BusinessRiskVulnerabilityFindUniqueOrThrowArgs} args - Arguments to find a BusinessRiskVulnerability
     * @example
     * // Get one BusinessRiskVulnerability
     * const businessRiskVulnerability = await prisma.businessRiskVulnerability.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BusinessRiskVulnerabilityFindUniqueOrThrowArgs>(args: SelectSubset<T, BusinessRiskVulnerabilityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BusinessRiskVulnerabilityClient<$Result.GetResult<Prisma.$BusinessRiskVulnerabilityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BusinessRiskVulnerability that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessRiskVulnerabilityFindFirstArgs} args - Arguments to find a BusinessRiskVulnerability
     * @example
     * // Get one BusinessRiskVulnerability
     * const businessRiskVulnerability = await prisma.businessRiskVulnerability.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BusinessRiskVulnerabilityFindFirstArgs>(args?: SelectSubset<T, BusinessRiskVulnerabilityFindFirstArgs<ExtArgs>>): Prisma__BusinessRiskVulnerabilityClient<$Result.GetResult<Prisma.$BusinessRiskVulnerabilityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BusinessRiskVulnerability that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessRiskVulnerabilityFindFirstOrThrowArgs} args - Arguments to find a BusinessRiskVulnerability
     * @example
     * // Get one BusinessRiskVulnerability
     * const businessRiskVulnerability = await prisma.businessRiskVulnerability.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BusinessRiskVulnerabilityFindFirstOrThrowArgs>(args?: SelectSubset<T, BusinessRiskVulnerabilityFindFirstOrThrowArgs<ExtArgs>>): Prisma__BusinessRiskVulnerabilityClient<$Result.GetResult<Prisma.$BusinessRiskVulnerabilityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BusinessRiskVulnerabilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessRiskVulnerabilityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BusinessRiskVulnerabilities
     * const businessRiskVulnerabilities = await prisma.businessRiskVulnerability.findMany()
     * 
     * // Get first 10 BusinessRiskVulnerabilities
     * const businessRiskVulnerabilities = await prisma.businessRiskVulnerability.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const businessRiskVulnerabilityWithIdOnly = await prisma.businessRiskVulnerability.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BusinessRiskVulnerabilityFindManyArgs>(args?: SelectSubset<T, BusinessRiskVulnerabilityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessRiskVulnerabilityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BusinessRiskVulnerability.
     * @param {BusinessRiskVulnerabilityCreateArgs} args - Arguments to create a BusinessRiskVulnerability.
     * @example
     * // Create one BusinessRiskVulnerability
     * const BusinessRiskVulnerability = await prisma.businessRiskVulnerability.create({
     *   data: {
     *     // ... data to create a BusinessRiskVulnerability
     *   }
     * })
     * 
     */
    create<T extends BusinessRiskVulnerabilityCreateArgs>(args: SelectSubset<T, BusinessRiskVulnerabilityCreateArgs<ExtArgs>>): Prisma__BusinessRiskVulnerabilityClient<$Result.GetResult<Prisma.$BusinessRiskVulnerabilityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BusinessRiskVulnerabilities.
     * @param {BusinessRiskVulnerabilityCreateManyArgs} args - Arguments to create many BusinessRiskVulnerabilities.
     * @example
     * // Create many BusinessRiskVulnerabilities
     * const businessRiskVulnerability = await prisma.businessRiskVulnerability.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BusinessRiskVulnerabilityCreateManyArgs>(args?: SelectSubset<T, BusinessRiskVulnerabilityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BusinessRiskVulnerabilities and returns the data saved in the database.
     * @param {BusinessRiskVulnerabilityCreateManyAndReturnArgs} args - Arguments to create many BusinessRiskVulnerabilities.
     * @example
     * // Create many BusinessRiskVulnerabilities
     * const businessRiskVulnerability = await prisma.businessRiskVulnerability.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BusinessRiskVulnerabilities and only return the `id`
     * const businessRiskVulnerabilityWithIdOnly = await prisma.businessRiskVulnerability.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BusinessRiskVulnerabilityCreateManyAndReturnArgs>(args?: SelectSubset<T, BusinessRiskVulnerabilityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessRiskVulnerabilityPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BusinessRiskVulnerability.
     * @param {BusinessRiskVulnerabilityDeleteArgs} args - Arguments to delete one BusinessRiskVulnerability.
     * @example
     * // Delete one BusinessRiskVulnerability
     * const BusinessRiskVulnerability = await prisma.businessRiskVulnerability.delete({
     *   where: {
     *     // ... filter to delete one BusinessRiskVulnerability
     *   }
     * })
     * 
     */
    delete<T extends BusinessRiskVulnerabilityDeleteArgs>(args: SelectSubset<T, BusinessRiskVulnerabilityDeleteArgs<ExtArgs>>): Prisma__BusinessRiskVulnerabilityClient<$Result.GetResult<Prisma.$BusinessRiskVulnerabilityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BusinessRiskVulnerability.
     * @param {BusinessRiskVulnerabilityUpdateArgs} args - Arguments to update one BusinessRiskVulnerability.
     * @example
     * // Update one BusinessRiskVulnerability
     * const businessRiskVulnerability = await prisma.businessRiskVulnerability.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BusinessRiskVulnerabilityUpdateArgs>(args: SelectSubset<T, BusinessRiskVulnerabilityUpdateArgs<ExtArgs>>): Prisma__BusinessRiskVulnerabilityClient<$Result.GetResult<Prisma.$BusinessRiskVulnerabilityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BusinessRiskVulnerabilities.
     * @param {BusinessRiskVulnerabilityDeleteManyArgs} args - Arguments to filter BusinessRiskVulnerabilities to delete.
     * @example
     * // Delete a few BusinessRiskVulnerabilities
     * const { count } = await prisma.businessRiskVulnerability.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BusinessRiskVulnerabilityDeleteManyArgs>(args?: SelectSubset<T, BusinessRiskVulnerabilityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BusinessRiskVulnerabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessRiskVulnerabilityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BusinessRiskVulnerabilities
     * const businessRiskVulnerability = await prisma.businessRiskVulnerability.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BusinessRiskVulnerabilityUpdateManyArgs>(args: SelectSubset<T, BusinessRiskVulnerabilityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BusinessRiskVulnerability.
     * @param {BusinessRiskVulnerabilityUpsertArgs} args - Arguments to update or create a BusinessRiskVulnerability.
     * @example
     * // Update or create a BusinessRiskVulnerability
     * const businessRiskVulnerability = await prisma.businessRiskVulnerability.upsert({
     *   create: {
     *     // ... data to create a BusinessRiskVulnerability
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BusinessRiskVulnerability we want to update
     *   }
     * })
     */
    upsert<T extends BusinessRiskVulnerabilityUpsertArgs>(args: SelectSubset<T, BusinessRiskVulnerabilityUpsertArgs<ExtArgs>>): Prisma__BusinessRiskVulnerabilityClient<$Result.GetResult<Prisma.$BusinessRiskVulnerabilityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BusinessRiskVulnerabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessRiskVulnerabilityCountArgs} args - Arguments to filter BusinessRiskVulnerabilities to count.
     * @example
     * // Count the number of BusinessRiskVulnerabilities
     * const count = await prisma.businessRiskVulnerability.count({
     *   where: {
     *     // ... the filter for the BusinessRiskVulnerabilities we want to count
     *   }
     * })
    **/
    count<T extends BusinessRiskVulnerabilityCountArgs>(
      args?: Subset<T, BusinessRiskVulnerabilityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BusinessRiskVulnerabilityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BusinessRiskVulnerability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessRiskVulnerabilityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BusinessRiskVulnerabilityAggregateArgs>(args: Subset<T, BusinessRiskVulnerabilityAggregateArgs>): Prisma.PrismaPromise<GetBusinessRiskVulnerabilityAggregateType<T>>

    /**
     * Group by BusinessRiskVulnerability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessRiskVulnerabilityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BusinessRiskVulnerabilityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BusinessRiskVulnerabilityGroupByArgs['orderBy'] }
        : { orderBy?: BusinessRiskVulnerabilityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BusinessRiskVulnerabilityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBusinessRiskVulnerabilityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BusinessRiskVulnerability model
   */
  readonly fields: BusinessRiskVulnerabilityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BusinessRiskVulnerability.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BusinessRiskVulnerabilityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    businessType<T extends BusinessTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BusinessTypeDefaultArgs<ExtArgs>>): Prisma__BusinessTypeClient<$Result.GetResult<Prisma.$BusinessTypePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BusinessRiskVulnerability model
   */ 
  interface BusinessRiskVulnerabilityFieldRefs {
    readonly id: FieldRef<"BusinessRiskVulnerability", 'String'>
    readonly businessTypeId: FieldRef<"BusinessRiskVulnerability", 'String'>
    readonly riskType: FieldRef<"BusinessRiskVulnerability", 'String'>
    readonly vulnerabilityLevel: FieldRef<"BusinessRiskVulnerability", 'Int'>
    readonly impactSeverity: FieldRef<"BusinessRiskVulnerability", 'Int'>
    readonly recoveryTime: FieldRef<"BusinessRiskVulnerability", 'String'>
    readonly reasoning: FieldRef<"BusinessRiskVulnerability", 'String'>
    readonly mitigationDifficulty: FieldRef<"BusinessRiskVulnerability", 'Int'>
    readonly costToRecover: FieldRef<"BusinessRiskVulnerability", 'String'>
    readonly businessImpactAreas: FieldRef<"BusinessRiskVulnerability", 'String'>
    readonly criticalDependencies: FieldRef<"BusinessRiskVulnerability", 'String'>
    readonly isActive: FieldRef<"BusinessRiskVulnerability", 'Boolean'>
    readonly createdAt: FieldRef<"BusinessRiskVulnerability", 'DateTime'>
    readonly updatedAt: FieldRef<"BusinessRiskVulnerability", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BusinessRiskVulnerability findUnique
   */
  export type BusinessRiskVulnerabilityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessRiskVulnerability
     */
    select?: BusinessRiskVulnerabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessRiskVulnerabilityInclude<ExtArgs> | null
    /**
     * Filter, which BusinessRiskVulnerability to fetch.
     */
    where: BusinessRiskVulnerabilityWhereUniqueInput
  }

  /**
   * BusinessRiskVulnerability findUniqueOrThrow
   */
  export type BusinessRiskVulnerabilityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessRiskVulnerability
     */
    select?: BusinessRiskVulnerabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessRiskVulnerabilityInclude<ExtArgs> | null
    /**
     * Filter, which BusinessRiskVulnerability to fetch.
     */
    where: BusinessRiskVulnerabilityWhereUniqueInput
  }

  /**
   * BusinessRiskVulnerability findFirst
   */
  export type BusinessRiskVulnerabilityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessRiskVulnerability
     */
    select?: BusinessRiskVulnerabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessRiskVulnerabilityInclude<ExtArgs> | null
    /**
     * Filter, which BusinessRiskVulnerability to fetch.
     */
    where?: BusinessRiskVulnerabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessRiskVulnerabilities to fetch.
     */
    orderBy?: BusinessRiskVulnerabilityOrderByWithRelationInput | BusinessRiskVulnerabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessRiskVulnerabilities.
     */
    cursor?: BusinessRiskVulnerabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessRiskVulnerabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessRiskVulnerabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessRiskVulnerabilities.
     */
    distinct?: BusinessRiskVulnerabilityScalarFieldEnum | BusinessRiskVulnerabilityScalarFieldEnum[]
  }

  /**
   * BusinessRiskVulnerability findFirstOrThrow
   */
  export type BusinessRiskVulnerabilityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessRiskVulnerability
     */
    select?: BusinessRiskVulnerabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessRiskVulnerabilityInclude<ExtArgs> | null
    /**
     * Filter, which BusinessRiskVulnerability to fetch.
     */
    where?: BusinessRiskVulnerabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessRiskVulnerabilities to fetch.
     */
    orderBy?: BusinessRiskVulnerabilityOrderByWithRelationInput | BusinessRiskVulnerabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessRiskVulnerabilities.
     */
    cursor?: BusinessRiskVulnerabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessRiskVulnerabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessRiskVulnerabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessRiskVulnerabilities.
     */
    distinct?: BusinessRiskVulnerabilityScalarFieldEnum | BusinessRiskVulnerabilityScalarFieldEnum[]
  }

  /**
   * BusinessRiskVulnerability findMany
   */
  export type BusinessRiskVulnerabilityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessRiskVulnerability
     */
    select?: BusinessRiskVulnerabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessRiskVulnerabilityInclude<ExtArgs> | null
    /**
     * Filter, which BusinessRiskVulnerabilities to fetch.
     */
    where?: BusinessRiskVulnerabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessRiskVulnerabilities to fetch.
     */
    orderBy?: BusinessRiskVulnerabilityOrderByWithRelationInput | BusinessRiskVulnerabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BusinessRiskVulnerabilities.
     */
    cursor?: BusinessRiskVulnerabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessRiskVulnerabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessRiskVulnerabilities.
     */
    skip?: number
    distinct?: BusinessRiskVulnerabilityScalarFieldEnum | BusinessRiskVulnerabilityScalarFieldEnum[]
  }

  /**
   * BusinessRiskVulnerability create
   */
  export type BusinessRiskVulnerabilityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessRiskVulnerability
     */
    select?: BusinessRiskVulnerabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessRiskVulnerabilityInclude<ExtArgs> | null
    /**
     * The data needed to create a BusinessRiskVulnerability.
     */
    data: XOR<BusinessRiskVulnerabilityCreateInput, BusinessRiskVulnerabilityUncheckedCreateInput>
  }

  /**
   * BusinessRiskVulnerability createMany
   */
  export type BusinessRiskVulnerabilityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BusinessRiskVulnerabilities.
     */
    data: BusinessRiskVulnerabilityCreateManyInput | BusinessRiskVulnerabilityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BusinessRiskVulnerability createManyAndReturn
   */
  export type BusinessRiskVulnerabilityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessRiskVulnerability
     */
    select?: BusinessRiskVulnerabilitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BusinessRiskVulnerabilities.
     */
    data: BusinessRiskVulnerabilityCreateManyInput | BusinessRiskVulnerabilityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessRiskVulnerabilityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BusinessRiskVulnerability update
   */
  export type BusinessRiskVulnerabilityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessRiskVulnerability
     */
    select?: BusinessRiskVulnerabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessRiskVulnerabilityInclude<ExtArgs> | null
    /**
     * The data needed to update a BusinessRiskVulnerability.
     */
    data: XOR<BusinessRiskVulnerabilityUpdateInput, BusinessRiskVulnerabilityUncheckedUpdateInput>
    /**
     * Choose, which BusinessRiskVulnerability to update.
     */
    where: BusinessRiskVulnerabilityWhereUniqueInput
  }

  /**
   * BusinessRiskVulnerability updateMany
   */
  export type BusinessRiskVulnerabilityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BusinessRiskVulnerabilities.
     */
    data: XOR<BusinessRiskVulnerabilityUpdateManyMutationInput, BusinessRiskVulnerabilityUncheckedUpdateManyInput>
    /**
     * Filter which BusinessRiskVulnerabilities to update
     */
    where?: BusinessRiskVulnerabilityWhereInput
  }

  /**
   * BusinessRiskVulnerability upsert
   */
  export type BusinessRiskVulnerabilityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessRiskVulnerability
     */
    select?: BusinessRiskVulnerabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessRiskVulnerabilityInclude<ExtArgs> | null
    /**
     * The filter to search for the BusinessRiskVulnerability to update in case it exists.
     */
    where: BusinessRiskVulnerabilityWhereUniqueInput
    /**
     * In case the BusinessRiskVulnerability found by the `where` argument doesn't exist, create a new BusinessRiskVulnerability with this data.
     */
    create: XOR<BusinessRiskVulnerabilityCreateInput, BusinessRiskVulnerabilityUncheckedCreateInput>
    /**
     * In case the BusinessRiskVulnerability was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BusinessRiskVulnerabilityUpdateInput, BusinessRiskVulnerabilityUncheckedUpdateInput>
  }

  /**
   * BusinessRiskVulnerability delete
   */
  export type BusinessRiskVulnerabilityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessRiskVulnerability
     */
    select?: BusinessRiskVulnerabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessRiskVulnerabilityInclude<ExtArgs> | null
    /**
     * Filter which BusinessRiskVulnerability to delete.
     */
    where: BusinessRiskVulnerabilityWhereUniqueInput
  }

  /**
   * BusinessRiskVulnerability deleteMany
   */
  export type BusinessRiskVulnerabilityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessRiskVulnerabilities to delete
     */
    where?: BusinessRiskVulnerabilityWhereInput
  }

  /**
   * BusinessRiskVulnerability without action
   */
  export type BusinessRiskVulnerabilityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessRiskVulnerability
     */
    select?: BusinessRiskVulnerabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessRiskVulnerabilityInclude<ExtArgs> | null
  }


  /**
   * Model RiskMitigationStrategy
   */

  export type AggregateRiskMitigationStrategy = {
    _count: RiskMitigationStrategyCountAggregateOutputType | null
    _avg: RiskMitigationStrategyAvgAggregateOutputType | null
    _sum: RiskMitigationStrategySumAggregateOutputType | null
    _min: RiskMitigationStrategyMinAggregateOutputType | null
    _max: RiskMitigationStrategyMaxAggregateOutputType | null
  }

  export type RiskMitigationStrategyAvgAggregateOutputType = {
    calculatedCostUSD: Decimal | null
    calculatedCostLocal: Decimal | null
    totalEstimatedHours: number | null
  }

  export type RiskMitigationStrategySumAggregateOutputType = {
    calculatedCostUSD: Decimal | null
    calculatedCostLocal: Decimal | null
    totalEstimatedHours: number | null
  }

  export type RiskMitigationStrategyMinAggregateOutputType = {
    id: string | null
    strategyId: string | null
    name: string | null
    description: string | null
    smeTitle: string | null
    smeSummary: string | null
    smeDescription: string | null
    whyImportant: string | null
    benefitsBullets: string | null
    realWorldExample: string | null
    calculatedCostUSD: Decimal | null
    calculatedCostLocal: Decimal | null
    currencyCode: string | null
    currencySymbol: string | null
    totalEstimatedHours: number | null
    selectionTier: string | null
    requiredForRisks: string | null
    helpfulTips: string | null
    commonMistakes: string | null
    successMetrics: string | null
    lowBudgetAlternative: string | null
    applicableRisks: string | null
    applicableBusinessTypes: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RiskMitigationStrategyMaxAggregateOutputType = {
    id: string | null
    strategyId: string | null
    name: string | null
    description: string | null
    smeTitle: string | null
    smeSummary: string | null
    smeDescription: string | null
    whyImportant: string | null
    benefitsBullets: string | null
    realWorldExample: string | null
    calculatedCostUSD: Decimal | null
    calculatedCostLocal: Decimal | null
    currencyCode: string | null
    currencySymbol: string | null
    totalEstimatedHours: number | null
    selectionTier: string | null
    requiredForRisks: string | null
    helpfulTips: string | null
    commonMistakes: string | null
    successMetrics: string | null
    lowBudgetAlternative: string | null
    applicableRisks: string | null
    applicableBusinessTypes: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RiskMitigationStrategyCountAggregateOutputType = {
    id: number
    strategyId: number
    name: number
    description: number
    smeTitle: number
    smeSummary: number
    smeDescription: number
    whyImportant: number
    benefitsBullets: number
    realWorldExample: number
    calculatedCostUSD: number
    calculatedCostLocal: number
    currencyCode: number
    currencySymbol: number
    totalEstimatedHours: number
    selectionTier: number
    requiredForRisks: number
    helpfulTips: number
    commonMistakes: number
    successMetrics: number
    lowBudgetAlternative: number
    applicableRisks: number
    applicableBusinessTypes: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RiskMitigationStrategyAvgAggregateInputType = {
    calculatedCostUSD?: true
    calculatedCostLocal?: true
    totalEstimatedHours?: true
  }

  export type RiskMitigationStrategySumAggregateInputType = {
    calculatedCostUSD?: true
    calculatedCostLocal?: true
    totalEstimatedHours?: true
  }

  export type RiskMitigationStrategyMinAggregateInputType = {
    id?: true
    strategyId?: true
    name?: true
    description?: true
    smeTitle?: true
    smeSummary?: true
    smeDescription?: true
    whyImportant?: true
    benefitsBullets?: true
    realWorldExample?: true
    calculatedCostUSD?: true
    calculatedCostLocal?: true
    currencyCode?: true
    currencySymbol?: true
    totalEstimatedHours?: true
    selectionTier?: true
    requiredForRisks?: true
    helpfulTips?: true
    commonMistakes?: true
    successMetrics?: true
    lowBudgetAlternative?: true
    applicableRisks?: true
    applicableBusinessTypes?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RiskMitigationStrategyMaxAggregateInputType = {
    id?: true
    strategyId?: true
    name?: true
    description?: true
    smeTitle?: true
    smeSummary?: true
    smeDescription?: true
    whyImportant?: true
    benefitsBullets?: true
    realWorldExample?: true
    calculatedCostUSD?: true
    calculatedCostLocal?: true
    currencyCode?: true
    currencySymbol?: true
    totalEstimatedHours?: true
    selectionTier?: true
    requiredForRisks?: true
    helpfulTips?: true
    commonMistakes?: true
    successMetrics?: true
    lowBudgetAlternative?: true
    applicableRisks?: true
    applicableBusinessTypes?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RiskMitigationStrategyCountAggregateInputType = {
    id?: true
    strategyId?: true
    name?: true
    description?: true
    smeTitle?: true
    smeSummary?: true
    smeDescription?: true
    whyImportant?: true
    benefitsBullets?: true
    realWorldExample?: true
    calculatedCostUSD?: true
    calculatedCostLocal?: true
    currencyCode?: true
    currencySymbol?: true
    totalEstimatedHours?: true
    selectionTier?: true
    requiredForRisks?: true
    helpfulTips?: true
    commonMistakes?: true
    successMetrics?: true
    lowBudgetAlternative?: true
    applicableRisks?: true
    applicableBusinessTypes?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RiskMitigationStrategyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RiskMitigationStrategy to aggregate.
     */
    where?: RiskMitigationStrategyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskMitigationStrategies to fetch.
     */
    orderBy?: RiskMitigationStrategyOrderByWithRelationInput | RiskMitigationStrategyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RiskMitigationStrategyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskMitigationStrategies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskMitigationStrategies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RiskMitigationStrategies
    **/
    _count?: true | RiskMitigationStrategyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RiskMitigationStrategyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RiskMitigationStrategySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RiskMitigationStrategyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RiskMitigationStrategyMaxAggregateInputType
  }

  export type GetRiskMitigationStrategyAggregateType<T extends RiskMitigationStrategyAggregateArgs> = {
        [P in keyof T & keyof AggregateRiskMitigationStrategy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRiskMitigationStrategy[P]>
      : GetScalarType<T[P], AggregateRiskMitigationStrategy[P]>
  }




  export type RiskMitigationStrategyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RiskMitigationStrategyWhereInput
    orderBy?: RiskMitigationStrategyOrderByWithAggregationInput | RiskMitigationStrategyOrderByWithAggregationInput[]
    by: RiskMitigationStrategyScalarFieldEnum[] | RiskMitigationStrategyScalarFieldEnum
    having?: RiskMitigationStrategyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RiskMitigationStrategyCountAggregateInputType | true
    _avg?: RiskMitigationStrategyAvgAggregateInputType
    _sum?: RiskMitigationStrategySumAggregateInputType
    _min?: RiskMitigationStrategyMinAggregateInputType
    _max?: RiskMitigationStrategyMaxAggregateInputType
  }

  export type RiskMitigationStrategyGroupByOutputType = {
    id: string
    strategyId: string
    name: string
    description: string
    smeTitle: string | null
    smeSummary: string | null
    smeDescription: string | null
    whyImportant: string | null
    benefitsBullets: string | null
    realWorldExample: string | null
    calculatedCostUSD: Decimal | null
    calculatedCostLocal: Decimal | null
    currencyCode: string | null
    currencySymbol: string | null
    totalEstimatedHours: number | null
    selectionTier: string | null
    requiredForRisks: string | null
    helpfulTips: string | null
    commonMistakes: string | null
    successMetrics: string | null
    lowBudgetAlternative: string | null
    applicableRisks: string
    applicableBusinessTypes: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: RiskMitigationStrategyCountAggregateOutputType | null
    _avg: RiskMitigationStrategyAvgAggregateOutputType | null
    _sum: RiskMitigationStrategySumAggregateOutputType | null
    _min: RiskMitigationStrategyMinAggregateOutputType | null
    _max: RiskMitigationStrategyMaxAggregateOutputType | null
  }

  type GetRiskMitigationStrategyGroupByPayload<T extends RiskMitigationStrategyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RiskMitigationStrategyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RiskMitigationStrategyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RiskMitigationStrategyGroupByOutputType[P]>
            : GetScalarType<T[P], RiskMitigationStrategyGroupByOutputType[P]>
        }
      >
    >


  export type RiskMitigationStrategySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    strategyId?: boolean
    name?: boolean
    description?: boolean
    smeTitle?: boolean
    smeSummary?: boolean
    smeDescription?: boolean
    whyImportant?: boolean
    benefitsBullets?: boolean
    realWorldExample?: boolean
    calculatedCostUSD?: boolean
    calculatedCostLocal?: boolean
    currencyCode?: boolean
    currencySymbol?: boolean
    totalEstimatedHours?: boolean
    selectionTier?: boolean
    requiredForRisks?: boolean
    helpfulTips?: boolean
    commonMistakes?: boolean
    successMetrics?: boolean
    lowBudgetAlternative?: boolean
    applicableRisks?: boolean
    applicableBusinessTypes?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    businessTypeStrategies?: boolean | RiskMitigationStrategy$businessTypeStrategiesArgs<ExtArgs>
    actionSteps?: boolean | RiskMitigationStrategy$actionStepsArgs<ExtArgs>
    itemCosts?: boolean | RiskMitigationStrategy$itemCostsArgs<ExtArgs>
    translations?: boolean | RiskMitigationStrategy$translationsArgs<ExtArgs>
    _count?: boolean | RiskMitigationStrategyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["riskMitigationStrategy"]>

  export type RiskMitigationStrategySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    strategyId?: boolean
    name?: boolean
    description?: boolean
    smeTitle?: boolean
    smeSummary?: boolean
    smeDescription?: boolean
    whyImportant?: boolean
    benefitsBullets?: boolean
    realWorldExample?: boolean
    calculatedCostUSD?: boolean
    calculatedCostLocal?: boolean
    currencyCode?: boolean
    currencySymbol?: boolean
    totalEstimatedHours?: boolean
    selectionTier?: boolean
    requiredForRisks?: boolean
    helpfulTips?: boolean
    commonMistakes?: boolean
    successMetrics?: boolean
    lowBudgetAlternative?: boolean
    applicableRisks?: boolean
    applicableBusinessTypes?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["riskMitigationStrategy"]>

  export type RiskMitigationStrategySelectScalar = {
    id?: boolean
    strategyId?: boolean
    name?: boolean
    description?: boolean
    smeTitle?: boolean
    smeSummary?: boolean
    smeDescription?: boolean
    whyImportant?: boolean
    benefitsBullets?: boolean
    realWorldExample?: boolean
    calculatedCostUSD?: boolean
    calculatedCostLocal?: boolean
    currencyCode?: boolean
    currencySymbol?: boolean
    totalEstimatedHours?: boolean
    selectionTier?: boolean
    requiredForRisks?: boolean
    helpfulTips?: boolean
    commonMistakes?: boolean
    successMetrics?: boolean
    lowBudgetAlternative?: boolean
    applicableRisks?: boolean
    applicableBusinessTypes?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RiskMitigationStrategyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businessTypeStrategies?: boolean | RiskMitigationStrategy$businessTypeStrategiesArgs<ExtArgs>
    actionSteps?: boolean | RiskMitigationStrategy$actionStepsArgs<ExtArgs>
    itemCosts?: boolean | RiskMitigationStrategy$itemCostsArgs<ExtArgs>
    translations?: boolean | RiskMitigationStrategy$translationsArgs<ExtArgs>
    _count?: boolean | RiskMitigationStrategyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RiskMitigationStrategyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RiskMitigationStrategyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RiskMitigationStrategy"
    objects: {
      businessTypeStrategies: Prisma.$BusinessTypeStrategyPayload<ExtArgs>[]
      actionSteps: Prisma.$ActionStepPayload<ExtArgs>[]
      itemCosts: Prisma.$StrategyItemCostPayload<ExtArgs>[]
      translations: Prisma.$StrategyTranslationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      strategyId: string
      name: string
      description: string
      smeTitle: string | null
      smeSummary: string | null
      smeDescription: string | null
      whyImportant: string | null
      benefitsBullets: string | null
      realWorldExample: string | null
      calculatedCostUSD: Prisma.Decimal | null
      calculatedCostLocal: Prisma.Decimal | null
      currencyCode: string | null
      currencySymbol: string | null
      totalEstimatedHours: number | null
      selectionTier: string | null
      requiredForRisks: string | null
      helpfulTips: string | null
      commonMistakes: string | null
      successMetrics: string | null
      lowBudgetAlternative: string | null
      applicableRisks: string
      applicableBusinessTypes: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["riskMitigationStrategy"]>
    composites: {}
  }

  type RiskMitigationStrategyGetPayload<S extends boolean | null | undefined | RiskMitigationStrategyDefaultArgs> = $Result.GetResult<Prisma.$RiskMitigationStrategyPayload, S>

  type RiskMitigationStrategyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RiskMitigationStrategyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RiskMitigationStrategyCountAggregateInputType | true
    }

  export interface RiskMitigationStrategyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RiskMitigationStrategy'], meta: { name: 'RiskMitigationStrategy' } }
    /**
     * Find zero or one RiskMitigationStrategy that matches the filter.
     * @param {RiskMitigationStrategyFindUniqueArgs} args - Arguments to find a RiskMitigationStrategy
     * @example
     * // Get one RiskMitigationStrategy
     * const riskMitigationStrategy = await prisma.riskMitigationStrategy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RiskMitigationStrategyFindUniqueArgs>(args: SelectSubset<T, RiskMitigationStrategyFindUniqueArgs<ExtArgs>>): Prisma__RiskMitigationStrategyClient<$Result.GetResult<Prisma.$RiskMitigationStrategyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RiskMitigationStrategy that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RiskMitigationStrategyFindUniqueOrThrowArgs} args - Arguments to find a RiskMitigationStrategy
     * @example
     * // Get one RiskMitigationStrategy
     * const riskMitigationStrategy = await prisma.riskMitigationStrategy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RiskMitigationStrategyFindUniqueOrThrowArgs>(args: SelectSubset<T, RiskMitigationStrategyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RiskMitigationStrategyClient<$Result.GetResult<Prisma.$RiskMitigationStrategyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RiskMitigationStrategy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskMitigationStrategyFindFirstArgs} args - Arguments to find a RiskMitigationStrategy
     * @example
     * // Get one RiskMitigationStrategy
     * const riskMitigationStrategy = await prisma.riskMitigationStrategy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RiskMitigationStrategyFindFirstArgs>(args?: SelectSubset<T, RiskMitigationStrategyFindFirstArgs<ExtArgs>>): Prisma__RiskMitigationStrategyClient<$Result.GetResult<Prisma.$RiskMitigationStrategyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RiskMitigationStrategy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskMitigationStrategyFindFirstOrThrowArgs} args - Arguments to find a RiskMitigationStrategy
     * @example
     * // Get one RiskMitigationStrategy
     * const riskMitigationStrategy = await prisma.riskMitigationStrategy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RiskMitigationStrategyFindFirstOrThrowArgs>(args?: SelectSubset<T, RiskMitigationStrategyFindFirstOrThrowArgs<ExtArgs>>): Prisma__RiskMitigationStrategyClient<$Result.GetResult<Prisma.$RiskMitigationStrategyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RiskMitigationStrategies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskMitigationStrategyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RiskMitigationStrategies
     * const riskMitigationStrategies = await prisma.riskMitigationStrategy.findMany()
     * 
     * // Get first 10 RiskMitigationStrategies
     * const riskMitigationStrategies = await prisma.riskMitigationStrategy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const riskMitigationStrategyWithIdOnly = await prisma.riskMitigationStrategy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RiskMitigationStrategyFindManyArgs>(args?: SelectSubset<T, RiskMitigationStrategyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RiskMitigationStrategyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RiskMitigationStrategy.
     * @param {RiskMitigationStrategyCreateArgs} args - Arguments to create a RiskMitigationStrategy.
     * @example
     * // Create one RiskMitigationStrategy
     * const RiskMitigationStrategy = await prisma.riskMitigationStrategy.create({
     *   data: {
     *     // ... data to create a RiskMitigationStrategy
     *   }
     * })
     * 
     */
    create<T extends RiskMitigationStrategyCreateArgs>(args: SelectSubset<T, RiskMitigationStrategyCreateArgs<ExtArgs>>): Prisma__RiskMitigationStrategyClient<$Result.GetResult<Prisma.$RiskMitigationStrategyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RiskMitigationStrategies.
     * @param {RiskMitigationStrategyCreateManyArgs} args - Arguments to create many RiskMitigationStrategies.
     * @example
     * // Create many RiskMitigationStrategies
     * const riskMitigationStrategy = await prisma.riskMitigationStrategy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RiskMitigationStrategyCreateManyArgs>(args?: SelectSubset<T, RiskMitigationStrategyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RiskMitigationStrategies and returns the data saved in the database.
     * @param {RiskMitigationStrategyCreateManyAndReturnArgs} args - Arguments to create many RiskMitigationStrategies.
     * @example
     * // Create many RiskMitigationStrategies
     * const riskMitigationStrategy = await prisma.riskMitigationStrategy.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RiskMitigationStrategies and only return the `id`
     * const riskMitigationStrategyWithIdOnly = await prisma.riskMitigationStrategy.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RiskMitigationStrategyCreateManyAndReturnArgs>(args?: SelectSubset<T, RiskMitigationStrategyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RiskMitigationStrategyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RiskMitigationStrategy.
     * @param {RiskMitigationStrategyDeleteArgs} args - Arguments to delete one RiskMitigationStrategy.
     * @example
     * // Delete one RiskMitigationStrategy
     * const RiskMitigationStrategy = await prisma.riskMitigationStrategy.delete({
     *   where: {
     *     // ... filter to delete one RiskMitigationStrategy
     *   }
     * })
     * 
     */
    delete<T extends RiskMitigationStrategyDeleteArgs>(args: SelectSubset<T, RiskMitigationStrategyDeleteArgs<ExtArgs>>): Prisma__RiskMitigationStrategyClient<$Result.GetResult<Prisma.$RiskMitigationStrategyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RiskMitigationStrategy.
     * @param {RiskMitigationStrategyUpdateArgs} args - Arguments to update one RiskMitigationStrategy.
     * @example
     * // Update one RiskMitigationStrategy
     * const riskMitigationStrategy = await prisma.riskMitigationStrategy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RiskMitigationStrategyUpdateArgs>(args: SelectSubset<T, RiskMitigationStrategyUpdateArgs<ExtArgs>>): Prisma__RiskMitigationStrategyClient<$Result.GetResult<Prisma.$RiskMitigationStrategyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RiskMitigationStrategies.
     * @param {RiskMitigationStrategyDeleteManyArgs} args - Arguments to filter RiskMitigationStrategies to delete.
     * @example
     * // Delete a few RiskMitigationStrategies
     * const { count } = await prisma.riskMitigationStrategy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RiskMitigationStrategyDeleteManyArgs>(args?: SelectSubset<T, RiskMitigationStrategyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RiskMitigationStrategies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskMitigationStrategyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RiskMitigationStrategies
     * const riskMitigationStrategy = await prisma.riskMitigationStrategy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RiskMitigationStrategyUpdateManyArgs>(args: SelectSubset<T, RiskMitigationStrategyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RiskMitigationStrategy.
     * @param {RiskMitigationStrategyUpsertArgs} args - Arguments to update or create a RiskMitigationStrategy.
     * @example
     * // Update or create a RiskMitigationStrategy
     * const riskMitigationStrategy = await prisma.riskMitigationStrategy.upsert({
     *   create: {
     *     // ... data to create a RiskMitigationStrategy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RiskMitigationStrategy we want to update
     *   }
     * })
     */
    upsert<T extends RiskMitigationStrategyUpsertArgs>(args: SelectSubset<T, RiskMitigationStrategyUpsertArgs<ExtArgs>>): Prisma__RiskMitigationStrategyClient<$Result.GetResult<Prisma.$RiskMitigationStrategyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RiskMitigationStrategies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskMitigationStrategyCountArgs} args - Arguments to filter RiskMitigationStrategies to count.
     * @example
     * // Count the number of RiskMitigationStrategies
     * const count = await prisma.riskMitigationStrategy.count({
     *   where: {
     *     // ... the filter for the RiskMitigationStrategies we want to count
     *   }
     * })
    **/
    count<T extends RiskMitigationStrategyCountArgs>(
      args?: Subset<T, RiskMitigationStrategyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RiskMitigationStrategyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RiskMitigationStrategy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskMitigationStrategyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RiskMitigationStrategyAggregateArgs>(args: Subset<T, RiskMitigationStrategyAggregateArgs>): Prisma.PrismaPromise<GetRiskMitigationStrategyAggregateType<T>>

    /**
     * Group by RiskMitigationStrategy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskMitigationStrategyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RiskMitigationStrategyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RiskMitigationStrategyGroupByArgs['orderBy'] }
        : { orderBy?: RiskMitigationStrategyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RiskMitigationStrategyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRiskMitigationStrategyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RiskMitigationStrategy model
   */
  readonly fields: RiskMitigationStrategyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RiskMitigationStrategy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RiskMitigationStrategyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    businessTypeStrategies<T extends RiskMitigationStrategy$businessTypeStrategiesArgs<ExtArgs> = {}>(args?: Subset<T, RiskMitigationStrategy$businessTypeStrategiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessTypeStrategyPayload<ExtArgs>, T, "findMany"> | Null>
    actionSteps<T extends RiskMitigationStrategy$actionStepsArgs<ExtArgs> = {}>(args?: Subset<T, RiskMitigationStrategy$actionStepsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionStepPayload<ExtArgs>, T, "findMany"> | Null>
    itemCosts<T extends RiskMitigationStrategy$itemCostsArgs<ExtArgs> = {}>(args?: Subset<T, RiskMitigationStrategy$itemCostsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StrategyItemCostPayload<ExtArgs>, T, "findMany"> | Null>
    translations<T extends RiskMitigationStrategy$translationsArgs<ExtArgs> = {}>(args?: Subset<T, RiskMitigationStrategy$translationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StrategyTranslationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RiskMitigationStrategy model
   */ 
  interface RiskMitigationStrategyFieldRefs {
    readonly id: FieldRef<"RiskMitigationStrategy", 'String'>
    readonly strategyId: FieldRef<"RiskMitigationStrategy", 'String'>
    readonly name: FieldRef<"RiskMitigationStrategy", 'String'>
    readonly description: FieldRef<"RiskMitigationStrategy", 'String'>
    readonly smeTitle: FieldRef<"RiskMitigationStrategy", 'String'>
    readonly smeSummary: FieldRef<"RiskMitigationStrategy", 'String'>
    readonly smeDescription: FieldRef<"RiskMitigationStrategy", 'String'>
    readonly whyImportant: FieldRef<"RiskMitigationStrategy", 'String'>
    readonly benefitsBullets: FieldRef<"RiskMitigationStrategy", 'String'>
    readonly realWorldExample: FieldRef<"RiskMitigationStrategy", 'String'>
    readonly calculatedCostUSD: FieldRef<"RiskMitigationStrategy", 'Decimal'>
    readonly calculatedCostLocal: FieldRef<"RiskMitigationStrategy", 'Decimal'>
    readonly currencyCode: FieldRef<"RiskMitigationStrategy", 'String'>
    readonly currencySymbol: FieldRef<"RiskMitigationStrategy", 'String'>
    readonly totalEstimatedHours: FieldRef<"RiskMitigationStrategy", 'Int'>
    readonly selectionTier: FieldRef<"RiskMitigationStrategy", 'String'>
    readonly requiredForRisks: FieldRef<"RiskMitigationStrategy", 'String'>
    readonly helpfulTips: FieldRef<"RiskMitigationStrategy", 'String'>
    readonly commonMistakes: FieldRef<"RiskMitigationStrategy", 'String'>
    readonly successMetrics: FieldRef<"RiskMitigationStrategy", 'String'>
    readonly lowBudgetAlternative: FieldRef<"RiskMitigationStrategy", 'String'>
    readonly applicableRisks: FieldRef<"RiskMitigationStrategy", 'String'>
    readonly applicableBusinessTypes: FieldRef<"RiskMitigationStrategy", 'String'>
    readonly isActive: FieldRef<"RiskMitigationStrategy", 'Boolean'>
    readonly createdAt: FieldRef<"RiskMitigationStrategy", 'DateTime'>
    readonly updatedAt: FieldRef<"RiskMitigationStrategy", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RiskMitigationStrategy findUnique
   */
  export type RiskMitigationStrategyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskMitigationStrategy
     */
    select?: RiskMitigationStrategySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskMitigationStrategyInclude<ExtArgs> | null
    /**
     * Filter, which RiskMitigationStrategy to fetch.
     */
    where: RiskMitigationStrategyWhereUniqueInput
  }

  /**
   * RiskMitigationStrategy findUniqueOrThrow
   */
  export type RiskMitigationStrategyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskMitigationStrategy
     */
    select?: RiskMitigationStrategySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskMitigationStrategyInclude<ExtArgs> | null
    /**
     * Filter, which RiskMitigationStrategy to fetch.
     */
    where: RiskMitigationStrategyWhereUniqueInput
  }

  /**
   * RiskMitigationStrategy findFirst
   */
  export type RiskMitigationStrategyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskMitigationStrategy
     */
    select?: RiskMitigationStrategySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskMitigationStrategyInclude<ExtArgs> | null
    /**
     * Filter, which RiskMitigationStrategy to fetch.
     */
    where?: RiskMitigationStrategyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskMitigationStrategies to fetch.
     */
    orderBy?: RiskMitigationStrategyOrderByWithRelationInput | RiskMitigationStrategyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RiskMitigationStrategies.
     */
    cursor?: RiskMitigationStrategyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskMitigationStrategies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskMitigationStrategies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RiskMitigationStrategies.
     */
    distinct?: RiskMitigationStrategyScalarFieldEnum | RiskMitigationStrategyScalarFieldEnum[]
  }

  /**
   * RiskMitigationStrategy findFirstOrThrow
   */
  export type RiskMitigationStrategyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskMitigationStrategy
     */
    select?: RiskMitigationStrategySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskMitigationStrategyInclude<ExtArgs> | null
    /**
     * Filter, which RiskMitigationStrategy to fetch.
     */
    where?: RiskMitigationStrategyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskMitigationStrategies to fetch.
     */
    orderBy?: RiskMitigationStrategyOrderByWithRelationInput | RiskMitigationStrategyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RiskMitigationStrategies.
     */
    cursor?: RiskMitigationStrategyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskMitigationStrategies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskMitigationStrategies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RiskMitigationStrategies.
     */
    distinct?: RiskMitigationStrategyScalarFieldEnum | RiskMitigationStrategyScalarFieldEnum[]
  }

  /**
   * RiskMitigationStrategy findMany
   */
  export type RiskMitigationStrategyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskMitigationStrategy
     */
    select?: RiskMitigationStrategySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskMitigationStrategyInclude<ExtArgs> | null
    /**
     * Filter, which RiskMitigationStrategies to fetch.
     */
    where?: RiskMitigationStrategyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskMitigationStrategies to fetch.
     */
    orderBy?: RiskMitigationStrategyOrderByWithRelationInput | RiskMitigationStrategyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RiskMitigationStrategies.
     */
    cursor?: RiskMitigationStrategyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskMitigationStrategies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskMitigationStrategies.
     */
    skip?: number
    distinct?: RiskMitigationStrategyScalarFieldEnum | RiskMitigationStrategyScalarFieldEnum[]
  }

  /**
   * RiskMitigationStrategy create
   */
  export type RiskMitigationStrategyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskMitigationStrategy
     */
    select?: RiskMitigationStrategySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskMitigationStrategyInclude<ExtArgs> | null
    /**
     * The data needed to create a RiskMitigationStrategy.
     */
    data: XOR<RiskMitigationStrategyCreateInput, RiskMitigationStrategyUncheckedCreateInput>
  }

  /**
   * RiskMitigationStrategy createMany
   */
  export type RiskMitigationStrategyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RiskMitigationStrategies.
     */
    data: RiskMitigationStrategyCreateManyInput | RiskMitigationStrategyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RiskMitigationStrategy createManyAndReturn
   */
  export type RiskMitigationStrategyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskMitigationStrategy
     */
    select?: RiskMitigationStrategySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RiskMitigationStrategies.
     */
    data: RiskMitigationStrategyCreateManyInput | RiskMitigationStrategyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RiskMitigationStrategy update
   */
  export type RiskMitigationStrategyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskMitigationStrategy
     */
    select?: RiskMitigationStrategySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskMitigationStrategyInclude<ExtArgs> | null
    /**
     * The data needed to update a RiskMitigationStrategy.
     */
    data: XOR<RiskMitigationStrategyUpdateInput, RiskMitigationStrategyUncheckedUpdateInput>
    /**
     * Choose, which RiskMitigationStrategy to update.
     */
    where: RiskMitigationStrategyWhereUniqueInput
  }

  /**
   * RiskMitigationStrategy updateMany
   */
  export type RiskMitigationStrategyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RiskMitigationStrategies.
     */
    data: XOR<RiskMitigationStrategyUpdateManyMutationInput, RiskMitigationStrategyUncheckedUpdateManyInput>
    /**
     * Filter which RiskMitigationStrategies to update
     */
    where?: RiskMitigationStrategyWhereInput
  }

  /**
   * RiskMitigationStrategy upsert
   */
  export type RiskMitigationStrategyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskMitigationStrategy
     */
    select?: RiskMitigationStrategySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskMitigationStrategyInclude<ExtArgs> | null
    /**
     * The filter to search for the RiskMitigationStrategy to update in case it exists.
     */
    where: RiskMitigationStrategyWhereUniqueInput
    /**
     * In case the RiskMitigationStrategy found by the `where` argument doesn't exist, create a new RiskMitigationStrategy with this data.
     */
    create: XOR<RiskMitigationStrategyCreateInput, RiskMitigationStrategyUncheckedCreateInput>
    /**
     * In case the RiskMitigationStrategy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RiskMitigationStrategyUpdateInput, RiskMitigationStrategyUncheckedUpdateInput>
  }

  /**
   * RiskMitigationStrategy delete
   */
  export type RiskMitigationStrategyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskMitigationStrategy
     */
    select?: RiskMitigationStrategySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskMitigationStrategyInclude<ExtArgs> | null
    /**
     * Filter which RiskMitigationStrategy to delete.
     */
    where: RiskMitigationStrategyWhereUniqueInput
  }

  /**
   * RiskMitigationStrategy deleteMany
   */
  export type RiskMitigationStrategyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RiskMitigationStrategies to delete
     */
    where?: RiskMitigationStrategyWhereInput
  }

  /**
   * RiskMitigationStrategy.businessTypeStrategies
   */
  export type RiskMitigationStrategy$businessTypeStrategiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessTypeStrategy
     */
    select?: BusinessTypeStrategySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypeStrategyInclude<ExtArgs> | null
    where?: BusinessTypeStrategyWhereInput
    orderBy?: BusinessTypeStrategyOrderByWithRelationInput | BusinessTypeStrategyOrderByWithRelationInput[]
    cursor?: BusinessTypeStrategyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BusinessTypeStrategyScalarFieldEnum | BusinessTypeStrategyScalarFieldEnum[]
  }

  /**
   * RiskMitigationStrategy.actionSteps
   */
  export type RiskMitigationStrategy$actionStepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionStep
     */
    select?: ActionStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionStepInclude<ExtArgs> | null
    where?: ActionStepWhereInput
    orderBy?: ActionStepOrderByWithRelationInput | ActionStepOrderByWithRelationInput[]
    cursor?: ActionStepWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActionStepScalarFieldEnum | ActionStepScalarFieldEnum[]
  }

  /**
   * RiskMitigationStrategy.itemCosts
   */
  export type RiskMitigationStrategy$itemCostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrategyItemCost
     */
    select?: StrategyItemCostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyItemCostInclude<ExtArgs> | null
    where?: StrategyItemCostWhereInput
    orderBy?: StrategyItemCostOrderByWithRelationInput | StrategyItemCostOrderByWithRelationInput[]
    cursor?: StrategyItemCostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StrategyItemCostScalarFieldEnum | StrategyItemCostScalarFieldEnum[]
  }

  /**
   * RiskMitigationStrategy.translations
   */
  export type RiskMitigationStrategy$translationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrategyTranslation
     */
    select?: StrategyTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyTranslationInclude<ExtArgs> | null
    where?: StrategyTranslationWhereInput
    orderBy?: StrategyTranslationOrderByWithRelationInput | StrategyTranslationOrderByWithRelationInput[]
    cursor?: StrategyTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StrategyTranslationScalarFieldEnum | StrategyTranslationScalarFieldEnum[]
  }

  /**
   * RiskMitigationStrategy without action
   */
  export type RiskMitigationStrategyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskMitigationStrategy
     */
    select?: RiskMitigationStrategySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskMitigationStrategyInclude<ExtArgs> | null
  }


  /**
   * Model ActionStep
   */

  export type AggregateActionStep = {
    _count: ActionStepCountAggregateOutputType | null
    _avg: ActionStepAvgAggregateOutputType | null
    _sum: ActionStepSumAggregateOutputType | null
    _min: ActionStepMinAggregateOutputType | null
    _max: ActionStepMaxAggregateOutputType | null
  }

  export type ActionStepAvgAggregateOutputType = {
    estimatedMinutes: number | null
    sortOrder: number | null
  }

  export type ActionStepSumAggregateOutputType = {
    estimatedMinutes: number | null
    sortOrder: number | null
  }

  export type ActionStepMinAggregateOutputType = {
    id: string | null
    strategyId: string | null
    stepId: string | null
    phase: string | null
    title: string | null
    description: string | null
    smeAction: string | null
    whyThisStepMatters: string | null
    whatHappensIfSkipped: string | null
    timeframe: string | null
    estimatedMinutes: number | null
    difficultyLevel: string | null
    responsibility: string | null
    estimatedCost: string | null
    estimatedCostJMD: string | null
    resources: string | null
    checklist: string | null
    howToKnowItsDone: string | null
    exampleOutput: string | null
    dependsOnSteps: string | null
    isOptional: boolean | null
    skipConditions: string | null
    freeAlternative: string | null
    lowTechOption: string | null
    commonMistakesForStep: string | null
    videoTutorialUrl: string | null
    externalResourceUrl: string | null
    sortOrder: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ActionStepMaxAggregateOutputType = {
    id: string | null
    strategyId: string | null
    stepId: string | null
    phase: string | null
    title: string | null
    description: string | null
    smeAction: string | null
    whyThisStepMatters: string | null
    whatHappensIfSkipped: string | null
    timeframe: string | null
    estimatedMinutes: number | null
    difficultyLevel: string | null
    responsibility: string | null
    estimatedCost: string | null
    estimatedCostJMD: string | null
    resources: string | null
    checklist: string | null
    howToKnowItsDone: string | null
    exampleOutput: string | null
    dependsOnSteps: string | null
    isOptional: boolean | null
    skipConditions: string | null
    freeAlternative: string | null
    lowTechOption: string | null
    commonMistakesForStep: string | null
    videoTutorialUrl: string | null
    externalResourceUrl: string | null
    sortOrder: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ActionStepCountAggregateOutputType = {
    id: number
    strategyId: number
    stepId: number
    phase: number
    title: number
    description: number
    smeAction: number
    whyThisStepMatters: number
    whatHappensIfSkipped: number
    timeframe: number
    estimatedMinutes: number
    difficultyLevel: number
    responsibility: number
    estimatedCost: number
    estimatedCostJMD: number
    resources: number
    checklist: number
    howToKnowItsDone: number
    exampleOutput: number
    dependsOnSteps: number
    isOptional: number
    skipConditions: number
    freeAlternative: number
    lowTechOption: number
    commonMistakesForStep: number
    videoTutorialUrl: number
    externalResourceUrl: number
    sortOrder: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ActionStepAvgAggregateInputType = {
    estimatedMinutes?: true
    sortOrder?: true
  }

  export type ActionStepSumAggregateInputType = {
    estimatedMinutes?: true
    sortOrder?: true
  }

  export type ActionStepMinAggregateInputType = {
    id?: true
    strategyId?: true
    stepId?: true
    phase?: true
    title?: true
    description?: true
    smeAction?: true
    whyThisStepMatters?: true
    whatHappensIfSkipped?: true
    timeframe?: true
    estimatedMinutes?: true
    difficultyLevel?: true
    responsibility?: true
    estimatedCost?: true
    estimatedCostJMD?: true
    resources?: true
    checklist?: true
    howToKnowItsDone?: true
    exampleOutput?: true
    dependsOnSteps?: true
    isOptional?: true
    skipConditions?: true
    freeAlternative?: true
    lowTechOption?: true
    commonMistakesForStep?: true
    videoTutorialUrl?: true
    externalResourceUrl?: true
    sortOrder?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ActionStepMaxAggregateInputType = {
    id?: true
    strategyId?: true
    stepId?: true
    phase?: true
    title?: true
    description?: true
    smeAction?: true
    whyThisStepMatters?: true
    whatHappensIfSkipped?: true
    timeframe?: true
    estimatedMinutes?: true
    difficultyLevel?: true
    responsibility?: true
    estimatedCost?: true
    estimatedCostJMD?: true
    resources?: true
    checklist?: true
    howToKnowItsDone?: true
    exampleOutput?: true
    dependsOnSteps?: true
    isOptional?: true
    skipConditions?: true
    freeAlternative?: true
    lowTechOption?: true
    commonMistakesForStep?: true
    videoTutorialUrl?: true
    externalResourceUrl?: true
    sortOrder?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ActionStepCountAggregateInputType = {
    id?: true
    strategyId?: true
    stepId?: true
    phase?: true
    title?: true
    description?: true
    smeAction?: true
    whyThisStepMatters?: true
    whatHappensIfSkipped?: true
    timeframe?: true
    estimatedMinutes?: true
    difficultyLevel?: true
    responsibility?: true
    estimatedCost?: true
    estimatedCostJMD?: true
    resources?: true
    checklist?: true
    howToKnowItsDone?: true
    exampleOutput?: true
    dependsOnSteps?: true
    isOptional?: true
    skipConditions?: true
    freeAlternative?: true
    lowTechOption?: true
    commonMistakesForStep?: true
    videoTutorialUrl?: true
    externalResourceUrl?: true
    sortOrder?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ActionStepAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActionStep to aggregate.
     */
    where?: ActionStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActionSteps to fetch.
     */
    orderBy?: ActionStepOrderByWithRelationInput | ActionStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActionStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActionSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActionSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActionSteps
    **/
    _count?: true | ActionStepCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActionStepAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActionStepSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActionStepMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActionStepMaxAggregateInputType
  }

  export type GetActionStepAggregateType<T extends ActionStepAggregateArgs> = {
        [P in keyof T & keyof AggregateActionStep]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActionStep[P]>
      : GetScalarType<T[P], AggregateActionStep[P]>
  }




  export type ActionStepGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActionStepWhereInput
    orderBy?: ActionStepOrderByWithAggregationInput | ActionStepOrderByWithAggregationInput[]
    by: ActionStepScalarFieldEnum[] | ActionStepScalarFieldEnum
    having?: ActionStepScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActionStepCountAggregateInputType | true
    _avg?: ActionStepAvgAggregateInputType
    _sum?: ActionStepSumAggregateInputType
    _min?: ActionStepMinAggregateInputType
    _max?: ActionStepMaxAggregateInputType
  }

  export type ActionStepGroupByOutputType = {
    id: string
    strategyId: string
    stepId: string
    phase: string
    title: string
    description: string
    smeAction: string | null
    whyThisStepMatters: string | null
    whatHappensIfSkipped: string | null
    timeframe: string | null
    estimatedMinutes: number | null
    difficultyLevel: string | null
    responsibility: string | null
    estimatedCost: string | null
    estimatedCostJMD: string | null
    resources: string | null
    checklist: string | null
    howToKnowItsDone: string | null
    exampleOutput: string | null
    dependsOnSteps: string | null
    isOptional: boolean
    skipConditions: string | null
    freeAlternative: string | null
    lowTechOption: string | null
    commonMistakesForStep: string | null
    videoTutorialUrl: string | null
    externalResourceUrl: string | null
    sortOrder: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ActionStepCountAggregateOutputType | null
    _avg: ActionStepAvgAggregateOutputType | null
    _sum: ActionStepSumAggregateOutputType | null
    _min: ActionStepMinAggregateOutputType | null
    _max: ActionStepMaxAggregateOutputType | null
  }

  type GetActionStepGroupByPayload<T extends ActionStepGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActionStepGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActionStepGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActionStepGroupByOutputType[P]>
            : GetScalarType<T[P], ActionStepGroupByOutputType[P]>
        }
      >
    >


  export type ActionStepSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    strategyId?: boolean
    stepId?: boolean
    phase?: boolean
    title?: boolean
    description?: boolean
    smeAction?: boolean
    whyThisStepMatters?: boolean
    whatHappensIfSkipped?: boolean
    timeframe?: boolean
    estimatedMinutes?: boolean
    difficultyLevel?: boolean
    responsibility?: boolean
    estimatedCost?: boolean
    estimatedCostJMD?: boolean
    resources?: boolean
    checklist?: boolean
    howToKnowItsDone?: boolean
    exampleOutput?: boolean
    dependsOnSteps?: boolean
    isOptional?: boolean
    skipConditions?: boolean
    freeAlternative?: boolean
    lowTechOption?: boolean
    commonMistakesForStep?: boolean
    videoTutorialUrl?: boolean
    externalResourceUrl?: boolean
    sortOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    strategy?: boolean | RiskMitigationStrategyDefaultArgs<ExtArgs>
    itemCosts?: boolean | ActionStep$itemCostsArgs<ExtArgs>
    translations?: boolean | ActionStep$translationsArgs<ExtArgs>
    _count?: boolean | ActionStepCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["actionStep"]>

  export type ActionStepSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    strategyId?: boolean
    stepId?: boolean
    phase?: boolean
    title?: boolean
    description?: boolean
    smeAction?: boolean
    whyThisStepMatters?: boolean
    whatHappensIfSkipped?: boolean
    timeframe?: boolean
    estimatedMinutes?: boolean
    difficultyLevel?: boolean
    responsibility?: boolean
    estimatedCost?: boolean
    estimatedCostJMD?: boolean
    resources?: boolean
    checklist?: boolean
    howToKnowItsDone?: boolean
    exampleOutput?: boolean
    dependsOnSteps?: boolean
    isOptional?: boolean
    skipConditions?: boolean
    freeAlternative?: boolean
    lowTechOption?: boolean
    commonMistakesForStep?: boolean
    videoTutorialUrl?: boolean
    externalResourceUrl?: boolean
    sortOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    strategy?: boolean | RiskMitigationStrategyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["actionStep"]>

  export type ActionStepSelectScalar = {
    id?: boolean
    strategyId?: boolean
    stepId?: boolean
    phase?: boolean
    title?: boolean
    description?: boolean
    smeAction?: boolean
    whyThisStepMatters?: boolean
    whatHappensIfSkipped?: boolean
    timeframe?: boolean
    estimatedMinutes?: boolean
    difficultyLevel?: boolean
    responsibility?: boolean
    estimatedCost?: boolean
    estimatedCostJMD?: boolean
    resources?: boolean
    checklist?: boolean
    howToKnowItsDone?: boolean
    exampleOutput?: boolean
    dependsOnSteps?: boolean
    isOptional?: boolean
    skipConditions?: boolean
    freeAlternative?: boolean
    lowTechOption?: boolean
    commonMistakesForStep?: boolean
    videoTutorialUrl?: boolean
    externalResourceUrl?: boolean
    sortOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ActionStepInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    strategy?: boolean | RiskMitigationStrategyDefaultArgs<ExtArgs>
    itemCosts?: boolean | ActionStep$itemCostsArgs<ExtArgs>
    translations?: boolean | ActionStep$translationsArgs<ExtArgs>
    _count?: boolean | ActionStepCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ActionStepIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    strategy?: boolean | RiskMitigationStrategyDefaultArgs<ExtArgs>
  }

  export type $ActionStepPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActionStep"
    objects: {
      strategy: Prisma.$RiskMitigationStrategyPayload<ExtArgs>
      itemCosts: Prisma.$ActionStepItemCostPayload<ExtArgs>[]
      translations: Prisma.$ActionStepTranslationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      strategyId: string
      stepId: string
      phase: string
      title: string
      description: string
      smeAction: string | null
      whyThisStepMatters: string | null
      whatHappensIfSkipped: string | null
      timeframe: string | null
      estimatedMinutes: number | null
      difficultyLevel: string | null
      responsibility: string | null
      estimatedCost: string | null
      estimatedCostJMD: string | null
      resources: string | null
      checklist: string | null
      howToKnowItsDone: string | null
      exampleOutput: string | null
      dependsOnSteps: string | null
      isOptional: boolean
      skipConditions: string | null
      freeAlternative: string | null
      lowTechOption: string | null
      commonMistakesForStep: string | null
      videoTutorialUrl: string | null
      externalResourceUrl: string | null
      sortOrder: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["actionStep"]>
    composites: {}
  }

  type ActionStepGetPayload<S extends boolean | null | undefined | ActionStepDefaultArgs> = $Result.GetResult<Prisma.$ActionStepPayload, S>

  type ActionStepCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ActionStepFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ActionStepCountAggregateInputType | true
    }

  export interface ActionStepDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActionStep'], meta: { name: 'ActionStep' } }
    /**
     * Find zero or one ActionStep that matches the filter.
     * @param {ActionStepFindUniqueArgs} args - Arguments to find a ActionStep
     * @example
     * // Get one ActionStep
     * const actionStep = await prisma.actionStep.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActionStepFindUniqueArgs>(args: SelectSubset<T, ActionStepFindUniqueArgs<ExtArgs>>): Prisma__ActionStepClient<$Result.GetResult<Prisma.$ActionStepPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ActionStep that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ActionStepFindUniqueOrThrowArgs} args - Arguments to find a ActionStep
     * @example
     * // Get one ActionStep
     * const actionStep = await prisma.actionStep.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActionStepFindUniqueOrThrowArgs>(args: SelectSubset<T, ActionStepFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActionStepClient<$Result.GetResult<Prisma.$ActionStepPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ActionStep that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionStepFindFirstArgs} args - Arguments to find a ActionStep
     * @example
     * // Get one ActionStep
     * const actionStep = await prisma.actionStep.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActionStepFindFirstArgs>(args?: SelectSubset<T, ActionStepFindFirstArgs<ExtArgs>>): Prisma__ActionStepClient<$Result.GetResult<Prisma.$ActionStepPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ActionStep that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionStepFindFirstOrThrowArgs} args - Arguments to find a ActionStep
     * @example
     * // Get one ActionStep
     * const actionStep = await prisma.actionStep.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActionStepFindFirstOrThrowArgs>(args?: SelectSubset<T, ActionStepFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActionStepClient<$Result.GetResult<Prisma.$ActionStepPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ActionSteps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionStepFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActionSteps
     * const actionSteps = await prisma.actionStep.findMany()
     * 
     * // Get first 10 ActionSteps
     * const actionSteps = await prisma.actionStep.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const actionStepWithIdOnly = await prisma.actionStep.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActionStepFindManyArgs>(args?: SelectSubset<T, ActionStepFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionStepPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ActionStep.
     * @param {ActionStepCreateArgs} args - Arguments to create a ActionStep.
     * @example
     * // Create one ActionStep
     * const ActionStep = await prisma.actionStep.create({
     *   data: {
     *     // ... data to create a ActionStep
     *   }
     * })
     * 
     */
    create<T extends ActionStepCreateArgs>(args: SelectSubset<T, ActionStepCreateArgs<ExtArgs>>): Prisma__ActionStepClient<$Result.GetResult<Prisma.$ActionStepPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ActionSteps.
     * @param {ActionStepCreateManyArgs} args - Arguments to create many ActionSteps.
     * @example
     * // Create many ActionSteps
     * const actionStep = await prisma.actionStep.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActionStepCreateManyArgs>(args?: SelectSubset<T, ActionStepCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ActionSteps and returns the data saved in the database.
     * @param {ActionStepCreateManyAndReturnArgs} args - Arguments to create many ActionSteps.
     * @example
     * // Create many ActionSteps
     * const actionStep = await prisma.actionStep.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ActionSteps and only return the `id`
     * const actionStepWithIdOnly = await prisma.actionStep.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActionStepCreateManyAndReturnArgs>(args?: SelectSubset<T, ActionStepCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionStepPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ActionStep.
     * @param {ActionStepDeleteArgs} args - Arguments to delete one ActionStep.
     * @example
     * // Delete one ActionStep
     * const ActionStep = await prisma.actionStep.delete({
     *   where: {
     *     // ... filter to delete one ActionStep
     *   }
     * })
     * 
     */
    delete<T extends ActionStepDeleteArgs>(args: SelectSubset<T, ActionStepDeleteArgs<ExtArgs>>): Prisma__ActionStepClient<$Result.GetResult<Prisma.$ActionStepPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ActionStep.
     * @param {ActionStepUpdateArgs} args - Arguments to update one ActionStep.
     * @example
     * // Update one ActionStep
     * const actionStep = await prisma.actionStep.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActionStepUpdateArgs>(args: SelectSubset<T, ActionStepUpdateArgs<ExtArgs>>): Prisma__ActionStepClient<$Result.GetResult<Prisma.$ActionStepPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ActionSteps.
     * @param {ActionStepDeleteManyArgs} args - Arguments to filter ActionSteps to delete.
     * @example
     * // Delete a few ActionSteps
     * const { count } = await prisma.actionStep.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActionStepDeleteManyArgs>(args?: SelectSubset<T, ActionStepDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActionSteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionStepUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActionSteps
     * const actionStep = await prisma.actionStep.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActionStepUpdateManyArgs>(args: SelectSubset<T, ActionStepUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ActionStep.
     * @param {ActionStepUpsertArgs} args - Arguments to update or create a ActionStep.
     * @example
     * // Update or create a ActionStep
     * const actionStep = await prisma.actionStep.upsert({
     *   create: {
     *     // ... data to create a ActionStep
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActionStep we want to update
     *   }
     * })
     */
    upsert<T extends ActionStepUpsertArgs>(args: SelectSubset<T, ActionStepUpsertArgs<ExtArgs>>): Prisma__ActionStepClient<$Result.GetResult<Prisma.$ActionStepPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ActionSteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionStepCountArgs} args - Arguments to filter ActionSteps to count.
     * @example
     * // Count the number of ActionSteps
     * const count = await prisma.actionStep.count({
     *   where: {
     *     // ... the filter for the ActionSteps we want to count
     *   }
     * })
    **/
    count<T extends ActionStepCountArgs>(
      args?: Subset<T, ActionStepCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActionStepCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActionStep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionStepAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActionStepAggregateArgs>(args: Subset<T, ActionStepAggregateArgs>): Prisma.PrismaPromise<GetActionStepAggregateType<T>>

    /**
     * Group by ActionStep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionStepGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActionStepGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActionStepGroupByArgs['orderBy'] }
        : { orderBy?: ActionStepGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActionStepGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActionStepGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActionStep model
   */
  readonly fields: ActionStepFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActionStep.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActionStepClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    strategy<T extends RiskMitigationStrategyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RiskMitigationStrategyDefaultArgs<ExtArgs>>): Prisma__RiskMitigationStrategyClient<$Result.GetResult<Prisma.$RiskMitigationStrategyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    itemCosts<T extends ActionStep$itemCostsArgs<ExtArgs> = {}>(args?: Subset<T, ActionStep$itemCostsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionStepItemCostPayload<ExtArgs>, T, "findMany"> | Null>
    translations<T extends ActionStep$translationsArgs<ExtArgs> = {}>(args?: Subset<T, ActionStep$translationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionStepTranslationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActionStep model
   */ 
  interface ActionStepFieldRefs {
    readonly id: FieldRef<"ActionStep", 'String'>
    readonly strategyId: FieldRef<"ActionStep", 'String'>
    readonly stepId: FieldRef<"ActionStep", 'String'>
    readonly phase: FieldRef<"ActionStep", 'String'>
    readonly title: FieldRef<"ActionStep", 'String'>
    readonly description: FieldRef<"ActionStep", 'String'>
    readonly smeAction: FieldRef<"ActionStep", 'String'>
    readonly whyThisStepMatters: FieldRef<"ActionStep", 'String'>
    readonly whatHappensIfSkipped: FieldRef<"ActionStep", 'String'>
    readonly timeframe: FieldRef<"ActionStep", 'String'>
    readonly estimatedMinutes: FieldRef<"ActionStep", 'Int'>
    readonly difficultyLevel: FieldRef<"ActionStep", 'String'>
    readonly responsibility: FieldRef<"ActionStep", 'String'>
    readonly estimatedCost: FieldRef<"ActionStep", 'String'>
    readonly estimatedCostJMD: FieldRef<"ActionStep", 'String'>
    readonly resources: FieldRef<"ActionStep", 'String'>
    readonly checklist: FieldRef<"ActionStep", 'String'>
    readonly howToKnowItsDone: FieldRef<"ActionStep", 'String'>
    readonly exampleOutput: FieldRef<"ActionStep", 'String'>
    readonly dependsOnSteps: FieldRef<"ActionStep", 'String'>
    readonly isOptional: FieldRef<"ActionStep", 'Boolean'>
    readonly skipConditions: FieldRef<"ActionStep", 'String'>
    readonly freeAlternative: FieldRef<"ActionStep", 'String'>
    readonly lowTechOption: FieldRef<"ActionStep", 'String'>
    readonly commonMistakesForStep: FieldRef<"ActionStep", 'String'>
    readonly videoTutorialUrl: FieldRef<"ActionStep", 'String'>
    readonly externalResourceUrl: FieldRef<"ActionStep", 'String'>
    readonly sortOrder: FieldRef<"ActionStep", 'Int'>
    readonly isActive: FieldRef<"ActionStep", 'Boolean'>
    readonly createdAt: FieldRef<"ActionStep", 'DateTime'>
    readonly updatedAt: FieldRef<"ActionStep", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ActionStep findUnique
   */
  export type ActionStepFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionStep
     */
    select?: ActionStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionStepInclude<ExtArgs> | null
    /**
     * Filter, which ActionStep to fetch.
     */
    where: ActionStepWhereUniqueInput
  }

  /**
   * ActionStep findUniqueOrThrow
   */
  export type ActionStepFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionStep
     */
    select?: ActionStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionStepInclude<ExtArgs> | null
    /**
     * Filter, which ActionStep to fetch.
     */
    where: ActionStepWhereUniqueInput
  }

  /**
   * ActionStep findFirst
   */
  export type ActionStepFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionStep
     */
    select?: ActionStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionStepInclude<ExtArgs> | null
    /**
     * Filter, which ActionStep to fetch.
     */
    where?: ActionStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActionSteps to fetch.
     */
    orderBy?: ActionStepOrderByWithRelationInput | ActionStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActionSteps.
     */
    cursor?: ActionStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActionSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActionSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActionSteps.
     */
    distinct?: ActionStepScalarFieldEnum | ActionStepScalarFieldEnum[]
  }

  /**
   * ActionStep findFirstOrThrow
   */
  export type ActionStepFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionStep
     */
    select?: ActionStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionStepInclude<ExtArgs> | null
    /**
     * Filter, which ActionStep to fetch.
     */
    where?: ActionStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActionSteps to fetch.
     */
    orderBy?: ActionStepOrderByWithRelationInput | ActionStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActionSteps.
     */
    cursor?: ActionStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActionSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActionSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActionSteps.
     */
    distinct?: ActionStepScalarFieldEnum | ActionStepScalarFieldEnum[]
  }

  /**
   * ActionStep findMany
   */
  export type ActionStepFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionStep
     */
    select?: ActionStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionStepInclude<ExtArgs> | null
    /**
     * Filter, which ActionSteps to fetch.
     */
    where?: ActionStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActionSteps to fetch.
     */
    orderBy?: ActionStepOrderByWithRelationInput | ActionStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActionSteps.
     */
    cursor?: ActionStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActionSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActionSteps.
     */
    skip?: number
    distinct?: ActionStepScalarFieldEnum | ActionStepScalarFieldEnum[]
  }

  /**
   * ActionStep create
   */
  export type ActionStepCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionStep
     */
    select?: ActionStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionStepInclude<ExtArgs> | null
    /**
     * The data needed to create a ActionStep.
     */
    data: XOR<ActionStepCreateInput, ActionStepUncheckedCreateInput>
  }

  /**
   * ActionStep createMany
   */
  export type ActionStepCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActionSteps.
     */
    data: ActionStepCreateManyInput | ActionStepCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActionStep createManyAndReturn
   */
  export type ActionStepCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionStep
     */
    select?: ActionStepSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ActionSteps.
     */
    data: ActionStepCreateManyInput | ActionStepCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionStepIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActionStep update
   */
  export type ActionStepUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionStep
     */
    select?: ActionStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionStepInclude<ExtArgs> | null
    /**
     * The data needed to update a ActionStep.
     */
    data: XOR<ActionStepUpdateInput, ActionStepUncheckedUpdateInput>
    /**
     * Choose, which ActionStep to update.
     */
    where: ActionStepWhereUniqueInput
  }

  /**
   * ActionStep updateMany
   */
  export type ActionStepUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActionSteps.
     */
    data: XOR<ActionStepUpdateManyMutationInput, ActionStepUncheckedUpdateManyInput>
    /**
     * Filter which ActionSteps to update
     */
    where?: ActionStepWhereInput
  }

  /**
   * ActionStep upsert
   */
  export type ActionStepUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionStep
     */
    select?: ActionStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionStepInclude<ExtArgs> | null
    /**
     * The filter to search for the ActionStep to update in case it exists.
     */
    where: ActionStepWhereUniqueInput
    /**
     * In case the ActionStep found by the `where` argument doesn't exist, create a new ActionStep with this data.
     */
    create: XOR<ActionStepCreateInput, ActionStepUncheckedCreateInput>
    /**
     * In case the ActionStep was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActionStepUpdateInput, ActionStepUncheckedUpdateInput>
  }

  /**
   * ActionStep delete
   */
  export type ActionStepDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionStep
     */
    select?: ActionStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionStepInclude<ExtArgs> | null
    /**
     * Filter which ActionStep to delete.
     */
    where: ActionStepWhereUniqueInput
  }

  /**
   * ActionStep deleteMany
   */
  export type ActionStepDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActionSteps to delete
     */
    where?: ActionStepWhereInput
  }

  /**
   * ActionStep.itemCosts
   */
  export type ActionStep$itemCostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionStepItemCost
     */
    select?: ActionStepItemCostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionStepItemCostInclude<ExtArgs> | null
    where?: ActionStepItemCostWhereInput
    orderBy?: ActionStepItemCostOrderByWithRelationInput | ActionStepItemCostOrderByWithRelationInput[]
    cursor?: ActionStepItemCostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActionStepItemCostScalarFieldEnum | ActionStepItemCostScalarFieldEnum[]
  }

  /**
   * ActionStep.translations
   */
  export type ActionStep$translationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionStepTranslation
     */
    select?: ActionStepTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionStepTranslationInclude<ExtArgs> | null
    where?: ActionStepTranslationWhereInput
    orderBy?: ActionStepTranslationOrderByWithRelationInput | ActionStepTranslationOrderByWithRelationInput[]
    cursor?: ActionStepTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActionStepTranslationScalarFieldEnum | ActionStepTranslationScalarFieldEnum[]
  }

  /**
   * ActionStep without action
   */
  export type ActionStepDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionStep
     */
    select?: ActionStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionStepInclude<ExtArgs> | null
  }


  /**
   * Model BusinessTypeStrategy
   */

  export type AggregateBusinessTypeStrategy = {
    _count: BusinessTypeStrategyCountAggregateOutputType | null
    _avg: BusinessTypeStrategyAvgAggregateOutputType | null
    _sum: BusinessTypeStrategySumAggregateOutputType | null
    _min: BusinessTypeStrategyMinAggregateOutputType | null
    _max: BusinessTypeStrategyMaxAggregateOutputType | null
  }

  export type BusinessTypeStrategyAvgAggregateOutputType = {
    relevanceScore: number | null
  }

  export type BusinessTypeStrategySumAggregateOutputType = {
    relevanceScore: number | null
  }

  export type BusinessTypeStrategyMinAggregateOutputType = {
    id: string | null
    businessTypeId: string | null
    strategyId: string | null
    relevanceScore: number | null
    customNotes: string | null
    isRecommended: boolean | null
    priority: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BusinessTypeStrategyMaxAggregateOutputType = {
    id: string | null
    businessTypeId: string | null
    strategyId: string | null
    relevanceScore: number | null
    customNotes: string | null
    isRecommended: boolean | null
    priority: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BusinessTypeStrategyCountAggregateOutputType = {
    id: number
    businessTypeId: number
    strategyId: number
    relevanceScore: number
    customNotes: number
    isRecommended: number
    priority: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BusinessTypeStrategyAvgAggregateInputType = {
    relevanceScore?: true
  }

  export type BusinessTypeStrategySumAggregateInputType = {
    relevanceScore?: true
  }

  export type BusinessTypeStrategyMinAggregateInputType = {
    id?: true
    businessTypeId?: true
    strategyId?: true
    relevanceScore?: true
    customNotes?: true
    isRecommended?: true
    priority?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BusinessTypeStrategyMaxAggregateInputType = {
    id?: true
    businessTypeId?: true
    strategyId?: true
    relevanceScore?: true
    customNotes?: true
    isRecommended?: true
    priority?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BusinessTypeStrategyCountAggregateInputType = {
    id?: true
    businessTypeId?: true
    strategyId?: true
    relevanceScore?: true
    customNotes?: true
    isRecommended?: true
    priority?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BusinessTypeStrategyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessTypeStrategy to aggregate.
     */
    where?: BusinessTypeStrategyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessTypeStrategies to fetch.
     */
    orderBy?: BusinessTypeStrategyOrderByWithRelationInput | BusinessTypeStrategyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BusinessTypeStrategyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessTypeStrategies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessTypeStrategies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BusinessTypeStrategies
    **/
    _count?: true | BusinessTypeStrategyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BusinessTypeStrategyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BusinessTypeStrategySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BusinessTypeStrategyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BusinessTypeStrategyMaxAggregateInputType
  }

  export type GetBusinessTypeStrategyAggregateType<T extends BusinessTypeStrategyAggregateArgs> = {
        [P in keyof T & keyof AggregateBusinessTypeStrategy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBusinessTypeStrategy[P]>
      : GetScalarType<T[P], AggregateBusinessTypeStrategy[P]>
  }




  export type BusinessTypeStrategyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessTypeStrategyWhereInput
    orderBy?: BusinessTypeStrategyOrderByWithAggregationInput | BusinessTypeStrategyOrderByWithAggregationInput[]
    by: BusinessTypeStrategyScalarFieldEnum[] | BusinessTypeStrategyScalarFieldEnum
    having?: BusinessTypeStrategyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BusinessTypeStrategyCountAggregateInputType | true
    _avg?: BusinessTypeStrategyAvgAggregateInputType
    _sum?: BusinessTypeStrategySumAggregateInputType
    _min?: BusinessTypeStrategyMinAggregateInputType
    _max?: BusinessTypeStrategyMaxAggregateInputType
  }

  export type BusinessTypeStrategyGroupByOutputType = {
    id: string
    businessTypeId: string
    strategyId: string
    relevanceScore: number | null
    customNotes: string | null
    isRecommended: boolean | null
    priority: string | null
    createdAt: Date
    updatedAt: Date
    _count: BusinessTypeStrategyCountAggregateOutputType | null
    _avg: BusinessTypeStrategyAvgAggregateOutputType | null
    _sum: BusinessTypeStrategySumAggregateOutputType | null
    _min: BusinessTypeStrategyMinAggregateOutputType | null
    _max: BusinessTypeStrategyMaxAggregateOutputType | null
  }

  type GetBusinessTypeStrategyGroupByPayload<T extends BusinessTypeStrategyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BusinessTypeStrategyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BusinessTypeStrategyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BusinessTypeStrategyGroupByOutputType[P]>
            : GetScalarType<T[P], BusinessTypeStrategyGroupByOutputType[P]>
        }
      >
    >


  export type BusinessTypeStrategySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessTypeId?: boolean
    strategyId?: boolean
    relevanceScore?: boolean
    customNotes?: boolean
    isRecommended?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    businessType?: boolean | BusinessTypeDefaultArgs<ExtArgs>
    strategy?: boolean | RiskMitigationStrategyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["businessTypeStrategy"]>

  export type BusinessTypeStrategySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessTypeId?: boolean
    strategyId?: boolean
    relevanceScore?: boolean
    customNotes?: boolean
    isRecommended?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    businessType?: boolean | BusinessTypeDefaultArgs<ExtArgs>
    strategy?: boolean | RiskMitigationStrategyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["businessTypeStrategy"]>

  export type BusinessTypeStrategySelectScalar = {
    id?: boolean
    businessTypeId?: boolean
    strategyId?: boolean
    relevanceScore?: boolean
    customNotes?: boolean
    isRecommended?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BusinessTypeStrategyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businessType?: boolean | BusinessTypeDefaultArgs<ExtArgs>
    strategy?: boolean | RiskMitigationStrategyDefaultArgs<ExtArgs>
  }
  export type BusinessTypeStrategyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businessType?: boolean | BusinessTypeDefaultArgs<ExtArgs>
    strategy?: boolean | RiskMitigationStrategyDefaultArgs<ExtArgs>
  }

  export type $BusinessTypeStrategyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BusinessTypeStrategy"
    objects: {
      businessType: Prisma.$BusinessTypePayload<ExtArgs>
      strategy: Prisma.$RiskMitigationStrategyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      businessTypeId: string
      strategyId: string
      relevanceScore: number | null
      customNotes: string | null
      isRecommended: boolean | null
      priority: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["businessTypeStrategy"]>
    composites: {}
  }

  type BusinessTypeStrategyGetPayload<S extends boolean | null | undefined | BusinessTypeStrategyDefaultArgs> = $Result.GetResult<Prisma.$BusinessTypeStrategyPayload, S>

  type BusinessTypeStrategyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BusinessTypeStrategyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BusinessTypeStrategyCountAggregateInputType | true
    }

  export interface BusinessTypeStrategyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BusinessTypeStrategy'], meta: { name: 'BusinessTypeStrategy' } }
    /**
     * Find zero or one BusinessTypeStrategy that matches the filter.
     * @param {BusinessTypeStrategyFindUniqueArgs} args - Arguments to find a BusinessTypeStrategy
     * @example
     * // Get one BusinessTypeStrategy
     * const businessTypeStrategy = await prisma.businessTypeStrategy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BusinessTypeStrategyFindUniqueArgs>(args: SelectSubset<T, BusinessTypeStrategyFindUniqueArgs<ExtArgs>>): Prisma__BusinessTypeStrategyClient<$Result.GetResult<Prisma.$BusinessTypeStrategyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BusinessTypeStrategy that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BusinessTypeStrategyFindUniqueOrThrowArgs} args - Arguments to find a BusinessTypeStrategy
     * @example
     * // Get one BusinessTypeStrategy
     * const businessTypeStrategy = await prisma.businessTypeStrategy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BusinessTypeStrategyFindUniqueOrThrowArgs>(args: SelectSubset<T, BusinessTypeStrategyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BusinessTypeStrategyClient<$Result.GetResult<Prisma.$BusinessTypeStrategyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BusinessTypeStrategy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessTypeStrategyFindFirstArgs} args - Arguments to find a BusinessTypeStrategy
     * @example
     * // Get one BusinessTypeStrategy
     * const businessTypeStrategy = await prisma.businessTypeStrategy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BusinessTypeStrategyFindFirstArgs>(args?: SelectSubset<T, BusinessTypeStrategyFindFirstArgs<ExtArgs>>): Prisma__BusinessTypeStrategyClient<$Result.GetResult<Prisma.$BusinessTypeStrategyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BusinessTypeStrategy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessTypeStrategyFindFirstOrThrowArgs} args - Arguments to find a BusinessTypeStrategy
     * @example
     * // Get one BusinessTypeStrategy
     * const businessTypeStrategy = await prisma.businessTypeStrategy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BusinessTypeStrategyFindFirstOrThrowArgs>(args?: SelectSubset<T, BusinessTypeStrategyFindFirstOrThrowArgs<ExtArgs>>): Prisma__BusinessTypeStrategyClient<$Result.GetResult<Prisma.$BusinessTypeStrategyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BusinessTypeStrategies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessTypeStrategyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BusinessTypeStrategies
     * const businessTypeStrategies = await prisma.businessTypeStrategy.findMany()
     * 
     * // Get first 10 BusinessTypeStrategies
     * const businessTypeStrategies = await prisma.businessTypeStrategy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const businessTypeStrategyWithIdOnly = await prisma.businessTypeStrategy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BusinessTypeStrategyFindManyArgs>(args?: SelectSubset<T, BusinessTypeStrategyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessTypeStrategyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BusinessTypeStrategy.
     * @param {BusinessTypeStrategyCreateArgs} args - Arguments to create a BusinessTypeStrategy.
     * @example
     * // Create one BusinessTypeStrategy
     * const BusinessTypeStrategy = await prisma.businessTypeStrategy.create({
     *   data: {
     *     // ... data to create a BusinessTypeStrategy
     *   }
     * })
     * 
     */
    create<T extends BusinessTypeStrategyCreateArgs>(args: SelectSubset<T, BusinessTypeStrategyCreateArgs<ExtArgs>>): Prisma__BusinessTypeStrategyClient<$Result.GetResult<Prisma.$BusinessTypeStrategyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BusinessTypeStrategies.
     * @param {BusinessTypeStrategyCreateManyArgs} args - Arguments to create many BusinessTypeStrategies.
     * @example
     * // Create many BusinessTypeStrategies
     * const businessTypeStrategy = await prisma.businessTypeStrategy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BusinessTypeStrategyCreateManyArgs>(args?: SelectSubset<T, BusinessTypeStrategyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BusinessTypeStrategies and returns the data saved in the database.
     * @param {BusinessTypeStrategyCreateManyAndReturnArgs} args - Arguments to create many BusinessTypeStrategies.
     * @example
     * // Create many BusinessTypeStrategies
     * const businessTypeStrategy = await prisma.businessTypeStrategy.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BusinessTypeStrategies and only return the `id`
     * const businessTypeStrategyWithIdOnly = await prisma.businessTypeStrategy.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BusinessTypeStrategyCreateManyAndReturnArgs>(args?: SelectSubset<T, BusinessTypeStrategyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessTypeStrategyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BusinessTypeStrategy.
     * @param {BusinessTypeStrategyDeleteArgs} args - Arguments to delete one BusinessTypeStrategy.
     * @example
     * // Delete one BusinessTypeStrategy
     * const BusinessTypeStrategy = await prisma.businessTypeStrategy.delete({
     *   where: {
     *     // ... filter to delete one BusinessTypeStrategy
     *   }
     * })
     * 
     */
    delete<T extends BusinessTypeStrategyDeleteArgs>(args: SelectSubset<T, BusinessTypeStrategyDeleteArgs<ExtArgs>>): Prisma__BusinessTypeStrategyClient<$Result.GetResult<Prisma.$BusinessTypeStrategyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BusinessTypeStrategy.
     * @param {BusinessTypeStrategyUpdateArgs} args - Arguments to update one BusinessTypeStrategy.
     * @example
     * // Update one BusinessTypeStrategy
     * const businessTypeStrategy = await prisma.businessTypeStrategy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BusinessTypeStrategyUpdateArgs>(args: SelectSubset<T, BusinessTypeStrategyUpdateArgs<ExtArgs>>): Prisma__BusinessTypeStrategyClient<$Result.GetResult<Prisma.$BusinessTypeStrategyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BusinessTypeStrategies.
     * @param {BusinessTypeStrategyDeleteManyArgs} args - Arguments to filter BusinessTypeStrategies to delete.
     * @example
     * // Delete a few BusinessTypeStrategies
     * const { count } = await prisma.businessTypeStrategy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BusinessTypeStrategyDeleteManyArgs>(args?: SelectSubset<T, BusinessTypeStrategyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BusinessTypeStrategies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessTypeStrategyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BusinessTypeStrategies
     * const businessTypeStrategy = await prisma.businessTypeStrategy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BusinessTypeStrategyUpdateManyArgs>(args: SelectSubset<T, BusinessTypeStrategyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BusinessTypeStrategy.
     * @param {BusinessTypeStrategyUpsertArgs} args - Arguments to update or create a BusinessTypeStrategy.
     * @example
     * // Update or create a BusinessTypeStrategy
     * const businessTypeStrategy = await prisma.businessTypeStrategy.upsert({
     *   create: {
     *     // ... data to create a BusinessTypeStrategy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BusinessTypeStrategy we want to update
     *   }
     * })
     */
    upsert<T extends BusinessTypeStrategyUpsertArgs>(args: SelectSubset<T, BusinessTypeStrategyUpsertArgs<ExtArgs>>): Prisma__BusinessTypeStrategyClient<$Result.GetResult<Prisma.$BusinessTypeStrategyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BusinessTypeStrategies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessTypeStrategyCountArgs} args - Arguments to filter BusinessTypeStrategies to count.
     * @example
     * // Count the number of BusinessTypeStrategies
     * const count = await prisma.businessTypeStrategy.count({
     *   where: {
     *     // ... the filter for the BusinessTypeStrategies we want to count
     *   }
     * })
    **/
    count<T extends BusinessTypeStrategyCountArgs>(
      args?: Subset<T, BusinessTypeStrategyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BusinessTypeStrategyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BusinessTypeStrategy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessTypeStrategyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BusinessTypeStrategyAggregateArgs>(args: Subset<T, BusinessTypeStrategyAggregateArgs>): Prisma.PrismaPromise<GetBusinessTypeStrategyAggregateType<T>>

    /**
     * Group by BusinessTypeStrategy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessTypeStrategyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BusinessTypeStrategyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BusinessTypeStrategyGroupByArgs['orderBy'] }
        : { orderBy?: BusinessTypeStrategyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BusinessTypeStrategyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBusinessTypeStrategyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BusinessTypeStrategy model
   */
  readonly fields: BusinessTypeStrategyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BusinessTypeStrategy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BusinessTypeStrategyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    businessType<T extends BusinessTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BusinessTypeDefaultArgs<ExtArgs>>): Prisma__BusinessTypeClient<$Result.GetResult<Prisma.$BusinessTypePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    strategy<T extends RiskMitigationStrategyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RiskMitigationStrategyDefaultArgs<ExtArgs>>): Prisma__RiskMitigationStrategyClient<$Result.GetResult<Prisma.$RiskMitigationStrategyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BusinessTypeStrategy model
   */ 
  interface BusinessTypeStrategyFieldRefs {
    readonly id: FieldRef<"BusinessTypeStrategy", 'String'>
    readonly businessTypeId: FieldRef<"BusinessTypeStrategy", 'String'>
    readonly strategyId: FieldRef<"BusinessTypeStrategy", 'String'>
    readonly relevanceScore: FieldRef<"BusinessTypeStrategy", 'Int'>
    readonly customNotes: FieldRef<"BusinessTypeStrategy", 'String'>
    readonly isRecommended: FieldRef<"BusinessTypeStrategy", 'Boolean'>
    readonly priority: FieldRef<"BusinessTypeStrategy", 'String'>
    readonly createdAt: FieldRef<"BusinessTypeStrategy", 'DateTime'>
    readonly updatedAt: FieldRef<"BusinessTypeStrategy", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BusinessTypeStrategy findUnique
   */
  export type BusinessTypeStrategyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessTypeStrategy
     */
    select?: BusinessTypeStrategySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypeStrategyInclude<ExtArgs> | null
    /**
     * Filter, which BusinessTypeStrategy to fetch.
     */
    where: BusinessTypeStrategyWhereUniqueInput
  }

  /**
   * BusinessTypeStrategy findUniqueOrThrow
   */
  export type BusinessTypeStrategyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessTypeStrategy
     */
    select?: BusinessTypeStrategySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypeStrategyInclude<ExtArgs> | null
    /**
     * Filter, which BusinessTypeStrategy to fetch.
     */
    where: BusinessTypeStrategyWhereUniqueInput
  }

  /**
   * BusinessTypeStrategy findFirst
   */
  export type BusinessTypeStrategyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessTypeStrategy
     */
    select?: BusinessTypeStrategySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypeStrategyInclude<ExtArgs> | null
    /**
     * Filter, which BusinessTypeStrategy to fetch.
     */
    where?: BusinessTypeStrategyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessTypeStrategies to fetch.
     */
    orderBy?: BusinessTypeStrategyOrderByWithRelationInput | BusinessTypeStrategyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessTypeStrategies.
     */
    cursor?: BusinessTypeStrategyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessTypeStrategies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessTypeStrategies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessTypeStrategies.
     */
    distinct?: BusinessTypeStrategyScalarFieldEnum | BusinessTypeStrategyScalarFieldEnum[]
  }

  /**
   * BusinessTypeStrategy findFirstOrThrow
   */
  export type BusinessTypeStrategyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessTypeStrategy
     */
    select?: BusinessTypeStrategySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypeStrategyInclude<ExtArgs> | null
    /**
     * Filter, which BusinessTypeStrategy to fetch.
     */
    where?: BusinessTypeStrategyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessTypeStrategies to fetch.
     */
    orderBy?: BusinessTypeStrategyOrderByWithRelationInput | BusinessTypeStrategyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessTypeStrategies.
     */
    cursor?: BusinessTypeStrategyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessTypeStrategies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessTypeStrategies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessTypeStrategies.
     */
    distinct?: BusinessTypeStrategyScalarFieldEnum | BusinessTypeStrategyScalarFieldEnum[]
  }

  /**
   * BusinessTypeStrategy findMany
   */
  export type BusinessTypeStrategyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessTypeStrategy
     */
    select?: BusinessTypeStrategySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypeStrategyInclude<ExtArgs> | null
    /**
     * Filter, which BusinessTypeStrategies to fetch.
     */
    where?: BusinessTypeStrategyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessTypeStrategies to fetch.
     */
    orderBy?: BusinessTypeStrategyOrderByWithRelationInput | BusinessTypeStrategyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BusinessTypeStrategies.
     */
    cursor?: BusinessTypeStrategyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessTypeStrategies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessTypeStrategies.
     */
    skip?: number
    distinct?: BusinessTypeStrategyScalarFieldEnum | BusinessTypeStrategyScalarFieldEnum[]
  }

  /**
   * BusinessTypeStrategy create
   */
  export type BusinessTypeStrategyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessTypeStrategy
     */
    select?: BusinessTypeStrategySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypeStrategyInclude<ExtArgs> | null
    /**
     * The data needed to create a BusinessTypeStrategy.
     */
    data: XOR<BusinessTypeStrategyCreateInput, BusinessTypeStrategyUncheckedCreateInput>
  }

  /**
   * BusinessTypeStrategy createMany
   */
  export type BusinessTypeStrategyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BusinessTypeStrategies.
     */
    data: BusinessTypeStrategyCreateManyInput | BusinessTypeStrategyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BusinessTypeStrategy createManyAndReturn
   */
  export type BusinessTypeStrategyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessTypeStrategy
     */
    select?: BusinessTypeStrategySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BusinessTypeStrategies.
     */
    data: BusinessTypeStrategyCreateManyInput | BusinessTypeStrategyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypeStrategyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BusinessTypeStrategy update
   */
  export type BusinessTypeStrategyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessTypeStrategy
     */
    select?: BusinessTypeStrategySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypeStrategyInclude<ExtArgs> | null
    /**
     * The data needed to update a BusinessTypeStrategy.
     */
    data: XOR<BusinessTypeStrategyUpdateInput, BusinessTypeStrategyUncheckedUpdateInput>
    /**
     * Choose, which BusinessTypeStrategy to update.
     */
    where: BusinessTypeStrategyWhereUniqueInput
  }

  /**
   * BusinessTypeStrategy updateMany
   */
  export type BusinessTypeStrategyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BusinessTypeStrategies.
     */
    data: XOR<BusinessTypeStrategyUpdateManyMutationInput, BusinessTypeStrategyUncheckedUpdateManyInput>
    /**
     * Filter which BusinessTypeStrategies to update
     */
    where?: BusinessTypeStrategyWhereInput
  }

  /**
   * BusinessTypeStrategy upsert
   */
  export type BusinessTypeStrategyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessTypeStrategy
     */
    select?: BusinessTypeStrategySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypeStrategyInclude<ExtArgs> | null
    /**
     * The filter to search for the BusinessTypeStrategy to update in case it exists.
     */
    where: BusinessTypeStrategyWhereUniqueInput
    /**
     * In case the BusinessTypeStrategy found by the `where` argument doesn't exist, create a new BusinessTypeStrategy with this data.
     */
    create: XOR<BusinessTypeStrategyCreateInput, BusinessTypeStrategyUncheckedCreateInput>
    /**
     * In case the BusinessTypeStrategy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BusinessTypeStrategyUpdateInput, BusinessTypeStrategyUncheckedUpdateInput>
  }

  /**
   * BusinessTypeStrategy delete
   */
  export type BusinessTypeStrategyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessTypeStrategy
     */
    select?: BusinessTypeStrategySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypeStrategyInclude<ExtArgs> | null
    /**
     * Filter which BusinessTypeStrategy to delete.
     */
    where: BusinessTypeStrategyWhereUniqueInput
  }

  /**
   * BusinessTypeStrategy deleteMany
   */
  export type BusinessTypeStrategyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessTypeStrategies to delete
     */
    where?: BusinessTypeStrategyWhereInput
  }

  /**
   * BusinessTypeStrategy without action
   */
  export type BusinessTypeStrategyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessTypeStrategy
     */
    select?: BusinessTypeStrategySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypeStrategyInclude<ExtArgs> | null
  }


  /**
   * Model BusinessRiskProfile
   */

  export type AggregateBusinessRiskProfile = {
    _count: BusinessRiskProfileCountAggregateOutputType | null
    _avg: BusinessRiskProfileAvgAggregateOutputType | null
    _sum: BusinessRiskProfileSumAggregateOutputType | null
    _min: BusinessRiskProfileMinAggregateOutputType | null
    _max: BusinessRiskProfileMaxAggregateOutputType | null
  }

  export type BusinessRiskProfileAvgAggregateOutputType = {
    overallRiskScore: number | null
  }

  export type BusinessRiskProfileSumAggregateOutputType = {
    overallRiskScore: number | null
  }

  export type BusinessRiskProfileMinAggregateOutputType = {
    id: string | null
    businessTypeId: string | null
    parishId: string | null
    combinedRisks: string | null
    recommendedStrategies: string | null
    overallRiskScore: number | null
    priorityActions: string | null
    calculatedAt: Date | null
    calculatedBy: string | null
    isActive: boolean | null
  }

  export type BusinessRiskProfileMaxAggregateOutputType = {
    id: string | null
    businessTypeId: string | null
    parishId: string | null
    combinedRisks: string | null
    recommendedStrategies: string | null
    overallRiskScore: number | null
    priorityActions: string | null
    calculatedAt: Date | null
    calculatedBy: string | null
    isActive: boolean | null
  }

  export type BusinessRiskProfileCountAggregateOutputType = {
    id: number
    businessTypeId: number
    parishId: number
    combinedRisks: number
    recommendedStrategies: number
    overallRiskScore: number
    priorityActions: number
    calculatedAt: number
    calculatedBy: number
    isActive: number
    _all: number
  }


  export type BusinessRiskProfileAvgAggregateInputType = {
    overallRiskScore?: true
  }

  export type BusinessRiskProfileSumAggregateInputType = {
    overallRiskScore?: true
  }

  export type BusinessRiskProfileMinAggregateInputType = {
    id?: true
    businessTypeId?: true
    parishId?: true
    combinedRisks?: true
    recommendedStrategies?: true
    overallRiskScore?: true
    priorityActions?: true
    calculatedAt?: true
    calculatedBy?: true
    isActive?: true
  }

  export type BusinessRiskProfileMaxAggregateInputType = {
    id?: true
    businessTypeId?: true
    parishId?: true
    combinedRisks?: true
    recommendedStrategies?: true
    overallRiskScore?: true
    priorityActions?: true
    calculatedAt?: true
    calculatedBy?: true
    isActive?: true
  }

  export type BusinessRiskProfileCountAggregateInputType = {
    id?: true
    businessTypeId?: true
    parishId?: true
    combinedRisks?: true
    recommendedStrategies?: true
    overallRiskScore?: true
    priorityActions?: true
    calculatedAt?: true
    calculatedBy?: true
    isActive?: true
    _all?: true
  }

  export type BusinessRiskProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessRiskProfile to aggregate.
     */
    where?: BusinessRiskProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessRiskProfiles to fetch.
     */
    orderBy?: BusinessRiskProfileOrderByWithRelationInput | BusinessRiskProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BusinessRiskProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessRiskProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessRiskProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BusinessRiskProfiles
    **/
    _count?: true | BusinessRiskProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BusinessRiskProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BusinessRiskProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BusinessRiskProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BusinessRiskProfileMaxAggregateInputType
  }

  export type GetBusinessRiskProfileAggregateType<T extends BusinessRiskProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateBusinessRiskProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBusinessRiskProfile[P]>
      : GetScalarType<T[P], AggregateBusinessRiskProfile[P]>
  }




  export type BusinessRiskProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessRiskProfileWhereInput
    orderBy?: BusinessRiskProfileOrderByWithAggregationInput | BusinessRiskProfileOrderByWithAggregationInput[]
    by: BusinessRiskProfileScalarFieldEnum[] | BusinessRiskProfileScalarFieldEnum
    having?: BusinessRiskProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BusinessRiskProfileCountAggregateInputType | true
    _avg?: BusinessRiskProfileAvgAggregateInputType
    _sum?: BusinessRiskProfileSumAggregateInputType
    _min?: BusinessRiskProfileMinAggregateInputType
    _max?: BusinessRiskProfileMaxAggregateInputType
  }

  export type BusinessRiskProfileGroupByOutputType = {
    id: string
    businessTypeId: string
    parishId: string
    combinedRisks: string
    recommendedStrategies: string
    overallRiskScore: number
    priorityActions: string | null
    calculatedAt: Date
    calculatedBy: string | null
    isActive: boolean
    _count: BusinessRiskProfileCountAggregateOutputType | null
    _avg: BusinessRiskProfileAvgAggregateOutputType | null
    _sum: BusinessRiskProfileSumAggregateOutputType | null
    _min: BusinessRiskProfileMinAggregateOutputType | null
    _max: BusinessRiskProfileMaxAggregateOutputType | null
  }

  type GetBusinessRiskProfileGroupByPayload<T extends BusinessRiskProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BusinessRiskProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BusinessRiskProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BusinessRiskProfileGroupByOutputType[P]>
            : GetScalarType<T[P], BusinessRiskProfileGroupByOutputType[P]>
        }
      >
    >


  export type BusinessRiskProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessTypeId?: boolean
    parishId?: boolean
    combinedRisks?: boolean
    recommendedStrategies?: boolean
    overallRiskScore?: boolean
    priorityActions?: boolean
    calculatedAt?: boolean
    calculatedBy?: boolean
    isActive?: boolean
    businessType?: boolean | BusinessTypeDefaultArgs<ExtArgs>
    parish?: boolean | ParishDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["businessRiskProfile"]>

  export type BusinessRiskProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessTypeId?: boolean
    parishId?: boolean
    combinedRisks?: boolean
    recommendedStrategies?: boolean
    overallRiskScore?: boolean
    priorityActions?: boolean
    calculatedAt?: boolean
    calculatedBy?: boolean
    isActive?: boolean
    businessType?: boolean | BusinessTypeDefaultArgs<ExtArgs>
    parish?: boolean | ParishDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["businessRiskProfile"]>

  export type BusinessRiskProfileSelectScalar = {
    id?: boolean
    businessTypeId?: boolean
    parishId?: boolean
    combinedRisks?: boolean
    recommendedStrategies?: boolean
    overallRiskScore?: boolean
    priorityActions?: boolean
    calculatedAt?: boolean
    calculatedBy?: boolean
    isActive?: boolean
  }

  export type BusinessRiskProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businessType?: boolean | BusinessTypeDefaultArgs<ExtArgs>
    parish?: boolean | ParishDefaultArgs<ExtArgs>
  }
  export type BusinessRiskProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businessType?: boolean | BusinessTypeDefaultArgs<ExtArgs>
    parish?: boolean | ParishDefaultArgs<ExtArgs>
  }

  export type $BusinessRiskProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BusinessRiskProfile"
    objects: {
      businessType: Prisma.$BusinessTypePayload<ExtArgs>
      parish: Prisma.$ParishPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      businessTypeId: string
      parishId: string
      combinedRisks: string
      recommendedStrategies: string
      overallRiskScore: number
      priorityActions: string | null
      calculatedAt: Date
      calculatedBy: string | null
      isActive: boolean
    }, ExtArgs["result"]["businessRiskProfile"]>
    composites: {}
  }

  type BusinessRiskProfileGetPayload<S extends boolean | null | undefined | BusinessRiskProfileDefaultArgs> = $Result.GetResult<Prisma.$BusinessRiskProfilePayload, S>

  type BusinessRiskProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BusinessRiskProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BusinessRiskProfileCountAggregateInputType | true
    }

  export interface BusinessRiskProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BusinessRiskProfile'], meta: { name: 'BusinessRiskProfile' } }
    /**
     * Find zero or one BusinessRiskProfile that matches the filter.
     * @param {BusinessRiskProfileFindUniqueArgs} args - Arguments to find a BusinessRiskProfile
     * @example
     * // Get one BusinessRiskProfile
     * const businessRiskProfile = await prisma.businessRiskProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BusinessRiskProfileFindUniqueArgs>(args: SelectSubset<T, BusinessRiskProfileFindUniqueArgs<ExtArgs>>): Prisma__BusinessRiskProfileClient<$Result.GetResult<Prisma.$BusinessRiskProfilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BusinessRiskProfile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BusinessRiskProfileFindUniqueOrThrowArgs} args - Arguments to find a BusinessRiskProfile
     * @example
     * // Get one BusinessRiskProfile
     * const businessRiskProfile = await prisma.businessRiskProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BusinessRiskProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, BusinessRiskProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BusinessRiskProfileClient<$Result.GetResult<Prisma.$BusinessRiskProfilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BusinessRiskProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessRiskProfileFindFirstArgs} args - Arguments to find a BusinessRiskProfile
     * @example
     * // Get one BusinessRiskProfile
     * const businessRiskProfile = await prisma.businessRiskProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BusinessRiskProfileFindFirstArgs>(args?: SelectSubset<T, BusinessRiskProfileFindFirstArgs<ExtArgs>>): Prisma__BusinessRiskProfileClient<$Result.GetResult<Prisma.$BusinessRiskProfilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BusinessRiskProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessRiskProfileFindFirstOrThrowArgs} args - Arguments to find a BusinessRiskProfile
     * @example
     * // Get one BusinessRiskProfile
     * const businessRiskProfile = await prisma.businessRiskProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BusinessRiskProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, BusinessRiskProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__BusinessRiskProfileClient<$Result.GetResult<Prisma.$BusinessRiskProfilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BusinessRiskProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessRiskProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BusinessRiskProfiles
     * const businessRiskProfiles = await prisma.businessRiskProfile.findMany()
     * 
     * // Get first 10 BusinessRiskProfiles
     * const businessRiskProfiles = await prisma.businessRiskProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const businessRiskProfileWithIdOnly = await prisma.businessRiskProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BusinessRiskProfileFindManyArgs>(args?: SelectSubset<T, BusinessRiskProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessRiskProfilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BusinessRiskProfile.
     * @param {BusinessRiskProfileCreateArgs} args - Arguments to create a BusinessRiskProfile.
     * @example
     * // Create one BusinessRiskProfile
     * const BusinessRiskProfile = await prisma.businessRiskProfile.create({
     *   data: {
     *     // ... data to create a BusinessRiskProfile
     *   }
     * })
     * 
     */
    create<T extends BusinessRiskProfileCreateArgs>(args: SelectSubset<T, BusinessRiskProfileCreateArgs<ExtArgs>>): Prisma__BusinessRiskProfileClient<$Result.GetResult<Prisma.$BusinessRiskProfilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BusinessRiskProfiles.
     * @param {BusinessRiskProfileCreateManyArgs} args - Arguments to create many BusinessRiskProfiles.
     * @example
     * // Create many BusinessRiskProfiles
     * const businessRiskProfile = await prisma.businessRiskProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BusinessRiskProfileCreateManyArgs>(args?: SelectSubset<T, BusinessRiskProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BusinessRiskProfiles and returns the data saved in the database.
     * @param {BusinessRiskProfileCreateManyAndReturnArgs} args - Arguments to create many BusinessRiskProfiles.
     * @example
     * // Create many BusinessRiskProfiles
     * const businessRiskProfile = await prisma.businessRiskProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BusinessRiskProfiles and only return the `id`
     * const businessRiskProfileWithIdOnly = await prisma.businessRiskProfile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BusinessRiskProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, BusinessRiskProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessRiskProfilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BusinessRiskProfile.
     * @param {BusinessRiskProfileDeleteArgs} args - Arguments to delete one BusinessRiskProfile.
     * @example
     * // Delete one BusinessRiskProfile
     * const BusinessRiskProfile = await prisma.businessRiskProfile.delete({
     *   where: {
     *     // ... filter to delete one BusinessRiskProfile
     *   }
     * })
     * 
     */
    delete<T extends BusinessRiskProfileDeleteArgs>(args: SelectSubset<T, BusinessRiskProfileDeleteArgs<ExtArgs>>): Prisma__BusinessRiskProfileClient<$Result.GetResult<Prisma.$BusinessRiskProfilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BusinessRiskProfile.
     * @param {BusinessRiskProfileUpdateArgs} args - Arguments to update one BusinessRiskProfile.
     * @example
     * // Update one BusinessRiskProfile
     * const businessRiskProfile = await prisma.businessRiskProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BusinessRiskProfileUpdateArgs>(args: SelectSubset<T, BusinessRiskProfileUpdateArgs<ExtArgs>>): Prisma__BusinessRiskProfileClient<$Result.GetResult<Prisma.$BusinessRiskProfilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BusinessRiskProfiles.
     * @param {BusinessRiskProfileDeleteManyArgs} args - Arguments to filter BusinessRiskProfiles to delete.
     * @example
     * // Delete a few BusinessRiskProfiles
     * const { count } = await prisma.businessRiskProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BusinessRiskProfileDeleteManyArgs>(args?: SelectSubset<T, BusinessRiskProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BusinessRiskProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessRiskProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BusinessRiskProfiles
     * const businessRiskProfile = await prisma.businessRiskProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BusinessRiskProfileUpdateManyArgs>(args: SelectSubset<T, BusinessRiskProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BusinessRiskProfile.
     * @param {BusinessRiskProfileUpsertArgs} args - Arguments to update or create a BusinessRiskProfile.
     * @example
     * // Update or create a BusinessRiskProfile
     * const businessRiskProfile = await prisma.businessRiskProfile.upsert({
     *   create: {
     *     // ... data to create a BusinessRiskProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BusinessRiskProfile we want to update
     *   }
     * })
     */
    upsert<T extends BusinessRiskProfileUpsertArgs>(args: SelectSubset<T, BusinessRiskProfileUpsertArgs<ExtArgs>>): Prisma__BusinessRiskProfileClient<$Result.GetResult<Prisma.$BusinessRiskProfilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BusinessRiskProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessRiskProfileCountArgs} args - Arguments to filter BusinessRiskProfiles to count.
     * @example
     * // Count the number of BusinessRiskProfiles
     * const count = await prisma.businessRiskProfile.count({
     *   where: {
     *     // ... the filter for the BusinessRiskProfiles we want to count
     *   }
     * })
    **/
    count<T extends BusinessRiskProfileCountArgs>(
      args?: Subset<T, BusinessRiskProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BusinessRiskProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BusinessRiskProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessRiskProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BusinessRiskProfileAggregateArgs>(args: Subset<T, BusinessRiskProfileAggregateArgs>): Prisma.PrismaPromise<GetBusinessRiskProfileAggregateType<T>>

    /**
     * Group by BusinessRiskProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessRiskProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BusinessRiskProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BusinessRiskProfileGroupByArgs['orderBy'] }
        : { orderBy?: BusinessRiskProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BusinessRiskProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBusinessRiskProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BusinessRiskProfile model
   */
  readonly fields: BusinessRiskProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BusinessRiskProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BusinessRiskProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    businessType<T extends BusinessTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BusinessTypeDefaultArgs<ExtArgs>>): Prisma__BusinessTypeClient<$Result.GetResult<Prisma.$BusinessTypePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    parish<T extends ParishDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ParishDefaultArgs<ExtArgs>>): Prisma__ParishClient<$Result.GetResult<Prisma.$ParishPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BusinessRiskProfile model
   */ 
  interface BusinessRiskProfileFieldRefs {
    readonly id: FieldRef<"BusinessRiskProfile", 'String'>
    readonly businessTypeId: FieldRef<"BusinessRiskProfile", 'String'>
    readonly parishId: FieldRef<"BusinessRiskProfile", 'String'>
    readonly combinedRisks: FieldRef<"BusinessRiskProfile", 'String'>
    readonly recommendedStrategies: FieldRef<"BusinessRiskProfile", 'String'>
    readonly overallRiskScore: FieldRef<"BusinessRiskProfile", 'Int'>
    readonly priorityActions: FieldRef<"BusinessRiskProfile", 'String'>
    readonly calculatedAt: FieldRef<"BusinessRiskProfile", 'DateTime'>
    readonly calculatedBy: FieldRef<"BusinessRiskProfile", 'String'>
    readonly isActive: FieldRef<"BusinessRiskProfile", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * BusinessRiskProfile findUnique
   */
  export type BusinessRiskProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessRiskProfile
     */
    select?: BusinessRiskProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessRiskProfileInclude<ExtArgs> | null
    /**
     * Filter, which BusinessRiskProfile to fetch.
     */
    where: BusinessRiskProfileWhereUniqueInput
  }

  /**
   * BusinessRiskProfile findUniqueOrThrow
   */
  export type BusinessRiskProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessRiskProfile
     */
    select?: BusinessRiskProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessRiskProfileInclude<ExtArgs> | null
    /**
     * Filter, which BusinessRiskProfile to fetch.
     */
    where: BusinessRiskProfileWhereUniqueInput
  }

  /**
   * BusinessRiskProfile findFirst
   */
  export type BusinessRiskProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessRiskProfile
     */
    select?: BusinessRiskProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessRiskProfileInclude<ExtArgs> | null
    /**
     * Filter, which BusinessRiskProfile to fetch.
     */
    where?: BusinessRiskProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessRiskProfiles to fetch.
     */
    orderBy?: BusinessRiskProfileOrderByWithRelationInput | BusinessRiskProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessRiskProfiles.
     */
    cursor?: BusinessRiskProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessRiskProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessRiskProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessRiskProfiles.
     */
    distinct?: BusinessRiskProfileScalarFieldEnum | BusinessRiskProfileScalarFieldEnum[]
  }

  /**
   * BusinessRiskProfile findFirstOrThrow
   */
  export type BusinessRiskProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessRiskProfile
     */
    select?: BusinessRiskProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessRiskProfileInclude<ExtArgs> | null
    /**
     * Filter, which BusinessRiskProfile to fetch.
     */
    where?: BusinessRiskProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessRiskProfiles to fetch.
     */
    orderBy?: BusinessRiskProfileOrderByWithRelationInput | BusinessRiskProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessRiskProfiles.
     */
    cursor?: BusinessRiskProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessRiskProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessRiskProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessRiskProfiles.
     */
    distinct?: BusinessRiskProfileScalarFieldEnum | BusinessRiskProfileScalarFieldEnum[]
  }

  /**
   * BusinessRiskProfile findMany
   */
  export type BusinessRiskProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessRiskProfile
     */
    select?: BusinessRiskProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessRiskProfileInclude<ExtArgs> | null
    /**
     * Filter, which BusinessRiskProfiles to fetch.
     */
    where?: BusinessRiskProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessRiskProfiles to fetch.
     */
    orderBy?: BusinessRiskProfileOrderByWithRelationInput | BusinessRiskProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BusinessRiskProfiles.
     */
    cursor?: BusinessRiskProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessRiskProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessRiskProfiles.
     */
    skip?: number
    distinct?: BusinessRiskProfileScalarFieldEnum | BusinessRiskProfileScalarFieldEnum[]
  }

  /**
   * BusinessRiskProfile create
   */
  export type BusinessRiskProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessRiskProfile
     */
    select?: BusinessRiskProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessRiskProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a BusinessRiskProfile.
     */
    data: XOR<BusinessRiskProfileCreateInput, BusinessRiskProfileUncheckedCreateInput>
  }

  /**
   * BusinessRiskProfile createMany
   */
  export type BusinessRiskProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BusinessRiskProfiles.
     */
    data: BusinessRiskProfileCreateManyInput | BusinessRiskProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BusinessRiskProfile createManyAndReturn
   */
  export type BusinessRiskProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessRiskProfile
     */
    select?: BusinessRiskProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BusinessRiskProfiles.
     */
    data: BusinessRiskProfileCreateManyInput | BusinessRiskProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessRiskProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BusinessRiskProfile update
   */
  export type BusinessRiskProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessRiskProfile
     */
    select?: BusinessRiskProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessRiskProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a BusinessRiskProfile.
     */
    data: XOR<BusinessRiskProfileUpdateInput, BusinessRiskProfileUncheckedUpdateInput>
    /**
     * Choose, which BusinessRiskProfile to update.
     */
    where: BusinessRiskProfileWhereUniqueInput
  }

  /**
   * BusinessRiskProfile updateMany
   */
  export type BusinessRiskProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BusinessRiskProfiles.
     */
    data: XOR<BusinessRiskProfileUpdateManyMutationInput, BusinessRiskProfileUncheckedUpdateManyInput>
    /**
     * Filter which BusinessRiskProfiles to update
     */
    where?: BusinessRiskProfileWhereInput
  }

  /**
   * BusinessRiskProfile upsert
   */
  export type BusinessRiskProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessRiskProfile
     */
    select?: BusinessRiskProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessRiskProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the BusinessRiskProfile to update in case it exists.
     */
    where: BusinessRiskProfileWhereUniqueInput
    /**
     * In case the BusinessRiskProfile found by the `where` argument doesn't exist, create a new BusinessRiskProfile with this data.
     */
    create: XOR<BusinessRiskProfileCreateInput, BusinessRiskProfileUncheckedCreateInput>
    /**
     * In case the BusinessRiskProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BusinessRiskProfileUpdateInput, BusinessRiskProfileUncheckedUpdateInput>
  }

  /**
   * BusinessRiskProfile delete
   */
  export type BusinessRiskProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessRiskProfile
     */
    select?: BusinessRiskProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessRiskProfileInclude<ExtArgs> | null
    /**
     * Filter which BusinessRiskProfile to delete.
     */
    where: BusinessRiskProfileWhereUniqueInput
  }

  /**
   * BusinessRiskProfile deleteMany
   */
  export type BusinessRiskProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessRiskProfiles to delete
     */
    where?: BusinessRiskProfileWhereInput
  }

  /**
   * BusinessRiskProfile without action
   */
  export type BusinessRiskProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessRiskProfile
     */
    select?: BusinessRiskProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessRiskProfileInclude<ExtArgs> | null
  }


  /**
   * Model RiskMultiplier
   */

  export type AggregateRiskMultiplier = {
    _count: RiskMultiplierCountAggregateOutputType | null
    _avg: RiskMultiplierAvgAggregateOutputType | null
    _sum: RiskMultiplierSumAggregateOutputType | null
    _min: RiskMultiplierMinAggregateOutputType | null
    _max: RiskMultiplierMaxAggregateOutputType | null
  }

  export type RiskMultiplierAvgAggregateOutputType = {
    thresholdValue: number | null
    minValue: number | null
    maxValue: number | null
    multiplierFactor: number | null
    priority: number | null
  }

  export type RiskMultiplierSumAggregateOutputType = {
    thresholdValue: number | null
    minValue: number | null
    maxValue: number | null
    multiplierFactor: number | null
    priority: number | null
  }

  export type RiskMultiplierMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    characteristicType: string | null
    conditionType: string | null
    thresholdValue: number | null
    minValue: number | null
    maxValue: number | null
    multiplierFactor: number | null
    applicableHazards: string | null
    wizardQuestion: string | null
    wizardAnswerOptions: string | null
    wizardHelpText: string | null
    isActive: boolean | null
    priority: number | null
    reasoning: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
  }

  export type RiskMultiplierMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    characteristicType: string | null
    conditionType: string | null
    thresholdValue: number | null
    minValue: number | null
    maxValue: number | null
    multiplierFactor: number | null
    applicableHazards: string | null
    wizardQuestion: string | null
    wizardAnswerOptions: string | null
    wizardHelpText: string | null
    isActive: boolean | null
    priority: number | null
    reasoning: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
  }

  export type RiskMultiplierCountAggregateOutputType = {
    id: number
    name: number
    description: number
    characteristicType: number
    conditionType: number
    thresholdValue: number
    minValue: number
    maxValue: number
    multiplierFactor: number
    applicableHazards: number
    wizardQuestion: number
    wizardAnswerOptions: number
    wizardHelpText: number
    isActive: number
    priority: number
    reasoning: number
    createdAt: number
    updatedAt: number
    createdBy: number
    _all: number
  }


  export type RiskMultiplierAvgAggregateInputType = {
    thresholdValue?: true
    minValue?: true
    maxValue?: true
    multiplierFactor?: true
    priority?: true
  }

  export type RiskMultiplierSumAggregateInputType = {
    thresholdValue?: true
    minValue?: true
    maxValue?: true
    multiplierFactor?: true
    priority?: true
  }

  export type RiskMultiplierMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    characteristicType?: true
    conditionType?: true
    thresholdValue?: true
    minValue?: true
    maxValue?: true
    multiplierFactor?: true
    applicableHazards?: true
    wizardQuestion?: true
    wizardAnswerOptions?: true
    wizardHelpText?: true
    isActive?: true
    priority?: true
    reasoning?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
  }

  export type RiskMultiplierMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    characteristicType?: true
    conditionType?: true
    thresholdValue?: true
    minValue?: true
    maxValue?: true
    multiplierFactor?: true
    applicableHazards?: true
    wizardQuestion?: true
    wizardAnswerOptions?: true
    wizardHelpText?: true
    isActive?: true
    priority?: true
    reasoning?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
  }

  export type RiskMultiplierCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    characteristicType?: true
    conditionType?: true
    thresholdValue?: true
    minValue?: true
    maxValue?: true
    multiplierFactor?: true
    applicableHazards?: true
    wizardQuestion?: true
    wizardAnswerOptions?: true
    wizardHelpText?: true
    isActive?: true
    priority?: true
    reasoning?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    _all?: true
  }

  export type RiskMultiplierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RiskMultiplier to aggregate.
     */
    where?: RiskMultiplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskMultipliers to fetch.
     */
    orderBy?: RiskMultiplierOrderByWithRelationInput | RiskMultiplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RiskMultiplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskMultipliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskMultipliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RiskMultipliers
    **/
    _count?: true | RiskMultiplierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RiskMultiplierAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RiskMultiplierSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RiskMultiplierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RiskMultiplierMaxAggregateInputType
  }

  export type GetRiskMultiplierAggregateType<T extends RiskMultiplierAggregateArgs> = {
        [P in keyof T & keyof AggregateRiskMultiplier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRiskMultiplier[P]>
      : GetScalarType<T[P], AggregateRiskMultiplier[P]>
  }




  export type RiskMultiplierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RiskMultiplierWhereInput
    orderBy?: RiskMultiplierOrderByWithAggregationInput | RiskMultiplierOrderByWithAggregationInput[]
    by: RiskMultiplierScalarFieldEnum[] | RiskMultiplierScalarFieldEnum
    having?: RiskMultiplierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RiskMultiplierCountAggregateInputType | true
    _avg?: RiskMultiplierAvgAggregateInputType
    _sum?: RiskMultiplierSumAggregateInputType
    _min?: RiskMultiplierMinAggregateInputType
    _max?: RiskMultiplierMaxAggregateInputType
  }

  export type RiskMultiplierGroupByOutputType = {
    id: string
    name: string
    description: string
    characteristicType: string
    conditionType: string
    thresholdValue: number | null
    minValue: number | null
    maxValue: number | null
    multiplierFactor: number
    applicableHazards: string
    wizardQuestion: string | null
    wizardAnswerOptions: string | null
    wizardHelpText: string | null
    isActive: boolean
    priority: number
    reasoning: string | null
    createdAt: Date
    updatedAt: Date
    createdBy: string
    _count: RiskMultiplierCountAggregateOutputType | null
    _avg: RiskMultiplierAvgAggregateOutputType | null
    _sum: RiskMultiplierSumAggregateOutputType | null
    _min: RiskMultiplierMinAggregateOutputType | null
    _max: RiskMultiplierMaxAggregateOutputType | null
  }

  type GetRiskMultiplierGroupByPayload<T extends RiskMultiplierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RiskMultiplierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RiskMultiplierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RiskMultiplierGroupByOutputType[P]>
            : GetScalarType<T[P], RiskMultiplierGroupByOutputType[P]>
        }
      >
    >


  export type RiskMultiplierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    characteristicType?: boolean
    conditionType?: boolean
    thresholdValue?: boolean
    minValue?: boolean
    maxValue?: boolean
    multiplierFactor?: boolean
    applicableHazards?: boolean
    wizardQuestion?: boolean
    wizardAnswerOptions?: boolean
    wizardHelpText?: boolean
    isActive?: boolean
    priority?: boolean
    reasoning?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    translations?: boolean | RiskMultiplier$translationsArgs<ExtArgs>
    _count?: boolean | RiskMultiplierCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["riskMultiplier"]>

  export type RiskMultiplierSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    characteristicType?: boolean
    conditionType?: boolean
    thresholdValue?: boolean
    minValue?: boolean
    maxValue?: boolean
    multiplierFactor?: boolean
    applicableHazards?: boolean
    wizardQuestion?: boolean
    wizardAnswerOptions?: boolean
    wizardHelpText?: boolean
    isActive?: boolean
    priority?: boolean
    reasoning?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
  }, ExtArgs["result"]["riskMultiplier"]>

  export type RiskMultiplierSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    characteristicType?: boolean
    conditionType?: boolean
    thresholdValue?: boolean
    minValue?: boolean
    maxValue?: boolean
    multiplierFactor?: boolean
    applicableHazards?: boolean
    wizardQuestion?: boolean
    wizardAnswerOptions?: boolean
    wizardHelpText?: boolean
    isActive?: boolean
    priority?: boolean
    reasoning?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
  }

  export type RiskMultiplierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    translations?: boolean | RiskMultiplier$translationsArgs<ExtArgs>
    _count?: boolean | RiskMultiplierCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RiskMultiplierIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RiskMultiplierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RiskMultiplier"
    objects: {
      translations: Prisma.$RiskMultiplierTranslationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      characteristicType: string
      conditionType: string
      thresholdValue: number | null
      minValue: number | null
      maxValue: number | null
      multiplierFactor: number
      applicableHazards: string
      wizardQuestion: string | null
      wizardAnswerOptions: string | null
      wizardHelpText: string | null
      isActive: boolean
      priority: number
      reasoning: string | null
      createdAt: Date
      updatedAt: Date
      createdBy: string
    }, ExtArgs["result"]["riskMultiplier"]>
    composites: {}
  }

  type RiskMultiplierGetPayload<S extends boolean | null | undefined | RiskMultiplierDefaultArgs> = $Result.GetResult<Prisma.$RiskMultiplierPayload, S>

  type RiskMultiplierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RiskMultiplierFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RiskMultiplierCountAggregateInputType | true
    }

  export interface RiskMultiplierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RiskMultiplier'], meta: { name: 'RiskMultiplier' } }
    /**
     * Find zero or one RiskMultiplier that matches the filter.
     * @param {RiskMultiplierFindUniqueArgs} args - Arguments to find a RiskMultiplier
     * @example
     * // Get one RiskMultiplier
     * const riskMultiplier = await prisma.riskMultiplier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RiskMultiplierFindUniqueArgs>(args: SelectSubset<T, RiskMultiplierFindUniqueArgs<ExtArgs>>): Prisma__RiskMultiplierClient<$Result.GetResult<Prisma.$RiskMultiplierPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RiskMultiplier that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RiskMultiplierFindUniqueOrThrowArgs} args - Arguments to find a RiskMultiplier
     * @example
     * // Get one RiskMultiplier
     * const riskMultiplier = await prisma.riskMultiplier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RiskMultiplierFindUniqueOrThrowArgs>(args: SelectSubset<T, RiskMultiplierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RiskMultiplierClient<$Result.GetResult<Prisma.$RiskMultiplierPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RiskMultiplier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskMultiplierFindFirstArgs} args - Arguments to find a RiskMultiplier
     * @example
     * // Get one RiskMultiplier
     * const riskMultiplier = await prisma.riskMultiplier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RiskMultiplierFindFirstArgs>(args?: SelectSubset<T, RiskMultiplierFindFirstArgs<ExtArgs>>): Prisma__RiskMultiplierClient<$Result.GetResult<Prisma.$RiskMultiplierPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RiskMultiplier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskMultiplierFindFirstOrThrowArgs} args - Arguments to find a RiskMultiplier
     * @example
     * // Get one RiskMultiplier
     * const riskMultiplier = await prisma.riskMultiplier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RiskMultiplierFindFirstOrThrowArgs>(args?: SelectSubset<T, RiskMultiplierFindFirstOrThrowArgs<ExtArgs>>): Prisma__RiskMultiplierClient<$Result.GetResult<Prisma.$RiskMultiplierPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RiskMultipliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskMultiplierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RiskMultipliers
     * const riskMultipliers = await prisma.riskMultiplier.findMany()
     * 
     * // Get first 10 RiskMultipliers
     * const riskMultipliers = await prisma.riskMultiplier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const riskMultiplierWithIdOnly = await prisma.riskMultiplier.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RiskMultiplierFindManyArgs>(args?: SelectSubset<T, RiskMultiplierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RiskMultiplierPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RiskMultiplier.
     * @param {RiskMultiplierCreateArgs} args - Arguments to create a RiskMultiplier.
     * @example
     * // Create one RiskMultiplier
     * const RiskMultiplier = await prisma.riskMultiplier.create({
     *   data: {
     *     // ... data to create a RiskMultiplier
     *   }
     * })
     * 
     */
    create<T extends RiskMultiplierCreateArgs>(args: SelectSubset<T, RiskMultiplierCreateArgs<ExtArgs>>): Prisma__RiskMultiplierClient<$Result.GetResult<Prisma.$RiskMultiplierPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RiskMultipliers.
     * @param {RiskMultiplierCreateManyArgs} args - Arguments to create many RiskMultipliers.
     * @example
     * // Create many RiskMultipliers
     * const riskMultiplier = await prisma.riskMultiplier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RiskMultiplierCreateManyArgs>(args?: SelectSubset<T, RiskMultiplierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RiskMultipliers and returns the data saved in the database.
     * @param {RiskMultiplierCreateManyAndReturnArgs} args - Arguments to create many RiskMultipliers.
     * @example
     * // Create many RiskMultipliers
     * const riskMultiplier = await prisma.riskMultiplier.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RiskMultipliers and only return the `id`
     * const riskMultiplierWithIdOnly = await prisma.riskMultiplier.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RiskMultiplierCreateManyAndReturnArgs>(args?: SelectSubset<T, RiskMultiplierCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RiskMultiplierPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RiskMultiplier.
     * @param {RiskMultiplierDeleteArgs} args - Arguments to delete one RiskMultiplier.
     * @example
     * // Delete one RiskMultiplier
     * const RiskMultiplier = await prisma.riskMultiplier.delete({
     *   where: {
     *     // ... filter to delete one RiskMultiplier
     *   }
     * })
     * 
     */
    delete<T extends RiskMultiplierDeleteArgs>(args: SelectSubset<T, RiskMultiplierDeleteArgs<ExtArgs>>): Prisma__RiskMultiplierClient<$Result.GetResult<Prisma.$RiskMultiplierPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RiskMultiplier.
     * @param {RiskMultiplierUpdateArgs} args - Arguments to update one RiskMultiplier.
     * @example
     * // Update one RiskMultiplier
     * const riskMultiplier = await prisma.riskMultiplier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RiskMultiplierUpdateArgs>(args: SelectSubset<T, RiskMultiplierUpdateArgs<ExtArgs>>): Prisma__RiskMultiplierClient<$Result.GetResult<Prisma.$RiskMultiplierPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RiskMultipliers.
     * @param {RiskMultiplierDeleteManyArgs} args - Arguments to filter RiskMultipliers to delete.
     * @example
     * // Delete a few RiskMultipliers
     * const { count } = await prisma.riskMultiplier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RiskMultiplierDeleteManyArgs>(args?: SelectSubset<T, RiskMultiplierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RiskMultipliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskMultiplierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RiskMultipliers
     * const riskMultiplier = await prisma.riskMultiplier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RiskMultiplierUpdateManyArgs>(args: SelectSubset<T, RiskMultiplierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RiskMultiplier.
     * @param {RiskMultiplierUpsertArgs} args - Arguments to update or create a RiskMultiplier.
     * @example
     * // Update or create a RiskMultiplier
     * const riskMultiplier = await prisma.riskMultiplier.upsert({
     *   create: {
     *     // ... data to create a RiskMultiplier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RiskMultiplier we want to update
     *   }
     * })
     */
    upsert<T extends RiskMultiplierUpsertArgs>(args: SelectSubset<T, RiskMultiplierUpsertArgs<ExtArgs>>): Prisma__RiskMultiplierClient<$Result.GetResult<Prisma.$RiskMultiplierPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RiskMultipliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskMultiplierCountArgs} args - Arguments to filter RiskMultipliers to count.
     * @example
     * // Count the number of RiskMultipliers
     * const count = await prisma.riskMultiplier.count({
     *   where: {
     *     // ... the filter for the RiskMultipliers we want to count
     *   }
     * })
    **/
    count<T extends RiskMultiplierCountArgs>(
      args?: Subset<T, RiskMultiplierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RiskMultiplierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RiskMultiplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskMultiplierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RiskMultiplierAggregateArgs>(args: Subset<T, RiskMultiplierAggregateArgs>): Prisma.PrismaPromise<GetRiskMultiplierAggregateType<T>>

    /**
     * Group by RiskMultiplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskMultiplierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RiskMultiplierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RiskMultiplierGroupByArgs['orderBy'] }
        : { orderBy?: RiskMultiplierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RiskMultiplierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRiskMultiplierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RiskMultiplier model
   */
  readonly fields: RiskMultiplierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RiskMultiplier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RiskMultiplierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    translations<T extends RiskMultiplier$translationsArgs<ExtArgs> = {}>(args?: Subset<T, RiskMultiplier$translationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RiskMultiplierTranslationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RiskMultiplier model
   */ 
  interface RiskMultiplierFieldRefs {
    readonly id: FieldRef<"RiskMultiplier", 'String'>
    readonly name: FieldRef<"RiskMultiplier", 'String'>
    readonly description: FieldRef<"RiskMultiplier", 'String'>
    readonly characteristicType: FieldRef<"RiskMultiplier", 'String'>
    readonly conditionType: FieldRef<"RiskMultiplier", 'String'>
    readonly thresholdValue: FieldRef<"RiskMultiplier", 'Float'>
    readonly minValue: FieldRef<"RiskMultiplier", 'Float'>
    readonly maxValue: FieldRef<"RiskMultiplier", 'Float'>
    readonly multiplierFactor: FieldRef<"RiskMultiplier", 'Float'>
    readonly applicableHazards: FieldRef<"RiskMultiplier", 'String'>
    readonly wizardQuestion: FieldRef<"RiskMultiplier", 'String'>
    readonly wizardAnswerOptions: FieldRef<"RiskMultiplier", 'String'>
    readonly wizardHelpText: FieldRef<"RiskMultiplier", 'String'>
    readonly isActive: FieldRef<"RiskMultiplier", 'Boolean'>
    readonly priority: FieldRef<"RiskMultiplier", 'Int'>
    readonly reasoning: FieldRef<"RiskMultiplier", 'String'>
    readonly createdAt: FieldRef<"RiskMultiplier", 'DateTime'>
    readonly updatedAt: FieldRef<"RiskMultiplier", 'DateTime'>
    readonly createdBy: FieldRef<"RiskMultiplier", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RiskMultiplier findUnique
   */
  export type RiskMultiplierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskMultiplier
     */
    select?: RiskMultiplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskMultiplierInclude<ExtArgs> | null
    /**
     * Filter, which RiskMultiplier to fetch.
     */
    where: RiskMultiplierWhereUniqueInput
  }

  /**
   * RiskMultiplier findUniqueOrThrow
   */
  export type RiskMultiplierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskMultiplier
     */
    select?: RiskMultiplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskMultiplierInclude<ExtArgs> | null
    /**
     * Filter, which RiskMultiplier to fetch.
     */
    where: RiskMultiplierWhereUniqueInput
  }

  /**
   * RiskMultiplier findFirst
   */
  export type RiskMultiplierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskMultiplier
     */
    select?: RiskMultiplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskMultiplierInclude<ExtArgs> | null
    /**
     * Filter, which RiskMultiplier to fetch.
     */
    where?: RiskMultiplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskMultipliers to fetch.
     */
    orderBy?: RiskMultiplierOrderByWithRelationInput | RiskMultiplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RiskMultipliers.
     */
    cursor?: RiskMultiplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskMultipliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskMultipliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RiskMultipliers.
     */
    distinct?: RiskMultiplierScalarFieldEnum | RiskMultiplierScalarFieldEnum[]
  }

  /**
   * RiskMultiplier findFirstOrThrow
   */
  export type RiskMultiplierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskMultiplier
     */
    select?: RiskMultiplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskMultiplierInclude<ExtArgs> | null
    /**
     * Filter, which RiskMultiplier to fetch.
     */
    where?: RiskMultiplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskMultipliers to fetch.
     */
    orderBy?: RiskMultiplierOrderByWithRelationInput | RiskMultiplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RiskMultipliers.
     */
    cursor?: RiskMultiplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskMultipliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskMultipliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RiskMultipliers.
     */
    distinct?: RiskMultiplierScalarFieldEnum | RiskMultiplierScalarFieldEnum[]
  }

  /**
   * RiskMultiplier findMany
   */
  export type RiskMultiplierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskMultiplier
     */
    select?: RiskMultiplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskMultiplierInclude<ExtArgs> | null
    /**
     * Filter, which RiskMultipliers to fetch.
     */
    where?: RiskMultiplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskMultipliers to fetch.
     */
    orderBy?: RiskMultiplierOrderByWithRelationInput | RiskMultiplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RiskMultipliers.
     */
    cursor?: RiskMultiplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskMultipliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskMultipliers.
     */
    skip?: number
    distinct?: RiskMultiplierScalarFieldEnum | RiskMultiplierScalarFieldEnum[]
  }

  /**
   * RiskMultiplier create
   */
  export type RiskMultiplierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskMultiplier
     */
    select?: RiskMultiplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskMultiplierInclude<ExtArgs> | null
    /**
     * The data needed to create a RiskMultiplier.
     */
    data: XOR<RiskMultiplierCreateInput, RiskMultiplierUncheckedCreateInput>
  }

  /**
   * RiskMultiplier createMany
   */
  export type RiskMultiplierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RiskMultipliers.
     */
    data: RiskMultiplierCreateManyInput | RiskMultiplierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RiskMultiplier createManyAndReturn
   */
  export type RiskMultiplierCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskMultiplier
     */
    select?: RiskMultiplierSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RiskMultipliers.
     */
    data: RiskMultiplierCreateManyInput | RiskMultiplierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RiskMultiplier update
   */
  export type RiskMultiplierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskMultiplier
     */
    select?: RiskMultiplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskMultiplierInclude<ExtArgs> | null
    /**
     * The data needed to update a RiskMultiplier.
     */
    data: XOR<RiskMultiplierUpdateInput, RiskMultiplierUncheckedUpdateInput>
    /**
     * Choose, which RiskMultiplier to update.
     */
    where: RiskMultiplierWhereUniqueInput
  }

  /**
   * RiskMultiplier updateMany
   */
  export type RiskMultiplierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RiskMultipliers.
     */
    data: XOR<RiskMultiplierUpdateManyMutationInput, RiskMultiplierUncheckedUpdateManyInput>
    /**
     * Filter which RiskMultipliers to update
     */
    where?: RiskMultiplierWhereInput
  }

  /**
   * RiskMultiplier upsert
   */
  export type RiskMultiplierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskMultiplier
     */
    select?: RiskMultiplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskMultiplierInclude<ExtArgs> | null
    /**
     * The filter to search for the RiskMultiplier to update in case it exists.
     */
    where: RiskMultiplierWhereUniqueInput
    /**
     * In case the RiskMultiplier found by the `where` argument doesn't exist, create a new RiskMultiplier with this data.
     */
    create: XOR<RiskMultiplierCreateInput, RiskMultiplierUncheckedCreateInput>
    /**
     * In case the RiskMultiplier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RiskMultiplierUpdateInput, RiskMultiplierUncheckedUpdateInput>
  }

  /**
   * RiskMultiplier delete
   */
  export type RiskMultiplierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskMultiplier
     */
    select?: RiskMultiplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskMultiplierInclude<ExtArgs> | null
    /**
     * Filter which RiskMultiplier to delete.
     */
    where: RiskMultiplierWhereUniqueInput
  }

  /**
   * RiskMultiplier deleteMany
   */
  export type RiskMultiplierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RiskMultipliers to delete
     */
    where?: RiskMultiplierWhereInput
  }

  /**
   * RiskMultiplier.translations
   */
  export type RiskMultiplier$translationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskMultiplierTranslation
     */
    select?: RiskMultiplierTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskMultiplierTranslationInclude<ExtArgs> | null
    where?: RiskMultiplierTranslationWhereInput
    orderBy?: RiskMultiplierTranslationOrderByWithRelationInput | RiskMultiplierTranslationOrderByWithRelationInput[]
    cursor?: RiskMultiplierTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RiskMultiplierTranslationScalarFieldEnum | RiskMultiplierTranslationScalarFieldEnum[]
  }

  /**
   * RiskMultiplier without action
   */
  export type RiskMultiplierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskMultiplier
     */
    select?: RiskMultiplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskMultiplierInclude<ExtArgs> | null
  }


  /**
   * Model CostItem
   */

  export type AggregateCostItem = {
    _count: CostItemCountAggregateOutputType | null
    _avg: CostItemAvgAggregateOutputType | null
    _sum: CostItemSumAggregateOutputType | null
    _min: CostItemMinAggregateOutputType | null
    _max: CostItemMaxAggregateOutputType | null
  }

  export type CostItemAvgAggregateOutputType = {
    baseUSD: number | null
    baseUSDMin: number | null
    baseUSDMax: number | null
  }

  export type CostItemSumAggregateOutputType = {
    baseUSD: number | null
    baseUSDMin: number | null
    baseUSDMax: number | null
  }

  export type CostItemMinAggregateOutputType = {
    id: string | null
    itemId: string | null
    name: string | null
    description: string | null
    category: string | null
    baseUSD: number | null
    baseUSDMin: number | null
    baseUSDMax: number | null
    unit: string | null
    complexity: string | null
    notes: string | null
    tags: string | null
    budgetAlternativeId: string | null
    premiumAlternativeId: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CostItemMaxAggregateOutputType = {
    id: string | null
    itemId: string | null
    name: string | null
    description: string | null
    category: string | null
    baseUSD: number | null
    baseUSDMin: number | null
    baseUSDMax: number | null
    unit: string | null
    complexity: string | null
    notes: string | null
    tags: string | null
    budgetAlternativeId: string | null
    premiumAlternativeId: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CostItemCountAggregateOutputType = {
    id: number
    itemId: number
    name: number
    description: number
    category: number
    baseUSD: number
    baseUSDMin: number
    baseUSDMax: number
    unit: number
    complexity: number
    notes: number
    tags: number
    budgetAlternativeId: number
    premiumAlternativeId: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CostItemAvgAggregateInputType = {
    baseUSD?: true
    baseUSDMin?: true
    baseUSDMax?: true
  }

  export type CostItemSumAggregateInputType = {
    baseUSD?: true
    baseUSDMin?: true
    baseUSDMax?: true
  }

  export type CostItemMinAggregateInputType = {
    id?: true
    itemId?: true
    name?: true
    description?: true
    category?: true
    baseUSD?: true
    baseUSDMin?: true
    baseUSDMax?: true
    unit?: true
    complexity?: true
    notes?: true
    tags?: true
    budgetAlternativeId?: true
    premiumAlternativeId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CostItemMaxAggregateInputType = {
    id?: true
    itemId?: true
    name?: true
    description?: true
    category?: true
    baseUSD?: true
    baseUSDMin?: true
    baseUSDMax?: true
    unit?: true
    complexity?: true
    notes?: true
    tags?: true
    budgetAlternativeId?: true
    premiumAlternativeId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CostItemCountAggregateInputType = {
    id?: true
    itemId?: true
    name?: true
    description?: true
    category?: true
    baseUSD?: true
    baseUSDMin?: true
    baseUSDMax?: true
    unit?: true
    complexity?: true
    notes?: true
    tags?: true
    budgetAlternativeId?: true
    premiumAlternativeId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CostItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CostItem to aggregate.
     */
    where?: CostItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostItems to fetch.
     */
    orderBy?: CostItemOrderByWithRelationInput | CostItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CostItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CostItems
    **/
    _count?: true | CostItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CostItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CostItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CostItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CostItemMaxAggregateInputType
  }

  export type GetCostItemAggregateType<T extends CostItemAggregateArgs> = {
        [P in keyof T & keyof AggregateCostItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCostItem[P]>
      : GetScalarType<T[P], AggregateCostItem[P]>
  }




  export type CostItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CostItemWhereInput
    orderBy?: CostItemOrderByWithAggregationInput | CostItemOrderByWithAggregationInput[]
    by: CostItemScalarFieldEnum[] | CostItemScalarFieldEnum
    having?: CostItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CostItemCountAggregateInputType | true
    _avg?: CostItemAvgAggregateInputType
    _sum?: CostItemSumAggregateInputType
    _min?: CostItemMinAggregateInputType
    _max?: CostItemMaxAggregateInputType
  }

  export type CostItemGroupByOutputType = {
    id: string
    itemId: string
    name: string
    description: string | null
    category: string
    baseUSD: number
    baseUSDMin: number | null
    baseUSDMax: number | null
    unit: string | null
    complexity: string
    notes: string | null
    tags: string | null
    budgetAlternativeId: string | null
    premiumAlternativeId: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: CostItemCountAggregateOutputType | null
    _avg: CostItemAvgAggregateOutputType | null
    _sum: CostItemSumAggregateOutputType | null
    _min: CostItemMinAggregateOutputType | null
    _max: CostItemMaxAggregateOutputType | null
  }

  type GetCostItemGroupByPayload<T extends CostItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CostItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CostItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CostItemGroupByOutputType[P]>
            : GetScalarType<T[P], CostItemGroupByOutputType[P]>
        }
      >
    >


  export type CostItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemId?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    baseUSD?: boolean
    baseUSDMin?: boolean
    baseUSDMax?: boolean
    unit?: boolean
    complexity?: boolean
    notes?: boolean
    tags?: boolean
    budgetAlternativeId?: boolean
    premiumAlternativeId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    strategyItems?: boolean | CostItem$strategyItemsArgs<ExtArgs>
    actionStepItems?: boolean | CostItem$actionStepItemsArgs<ExtArgs>
    _count?: boolean | CostItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["costItem"]>

  export type CostItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemId?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    baseUSD?: boolean
    baseUSDMin?: boolean
    baseUSDMax?: boolean
    unit?: boolean
    complexity?: boolean
    notes?: boolean
    tags?: boolean
    budgetAlternativeId?: boolean
    premiumAlternativeId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["costItem"]>

  export type CostItemSelectScalar = {
    id?: boolean
    itemId?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    baseUSD?: boolean
    baseUSDMin?: boolean
    baseUSDMax?: boolean
    unit?: boolean
    complexity?: boolean
    notes?: boolean
    tags?: boolean
    budgetAlternativeId?: boolean
    premiumAlternativeId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CostItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    strategyItems?: boolean | CostItem$strategyItemsArgs<ExtArgs>
    actionStepItems?: boolean | CostItem$actionStepItemsArgs<ExtArgs>
    _count?: boolean | CostItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CostItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CostItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CostItem"
    objects: {
      strategyItems: Prisma.$StrategyItemCostPayload<ExtArgs>[]
      actionStepItems: Prisma.$ActionStepItemCostPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      itemId: string
      name: string
      description: string | null
      category: string
      baseUSD: number
      baseUSDMin: number | null
      baseUSDMax: number | null
      unit: string | null
      complexity: string
      notes: string | null
      tags: string | null
      budgetAlternativeId: string | null
      premiumAlternativeId: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["costItem"]>
    composites: {}
  }

  type CostItemGetPayload<S extends boolean | null | undefined | CostItemDefaultArgs> = $Result.GetResult<Prisma.$CostItemPayload, S>

  type CostItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CostItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CostItemCountAggregateInputType | true
    }

  export interface CostItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CostItem'], meta: { name: 'CostItem' } }
    /**
     * Find zero or one CostItem that matches the filter.
     * @param {CostItemFindUniqueArgs} args - Arguments to find a CostItem
     * @example
     * // Get one CostItem
     * const costItem = await prisma.costItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CostItemFindUniqueArgs>(args: SelectSubset<T, CostItemFindUniqueArgs<ExtArgs>>): Prisma__CostItemClient<$Result.GetResult<Prisma.$CostItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CostItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CostItemFindUniqueOrThrowArgs} args - Arguments to find a CostItem
     * @example
     * // Get one CostItem
     * const costItem = await prisma.costItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CostItemFindUniqueOrThrowArgs>(args: SelectSubset<T, CostItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CostItemClient<$Result.GetResult<Prisma.$CostItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CostItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostItemFindFirstArgs} args - Arguments to find a CostItem
     * @example
     * // Get one CostItem
     * const costItem = await prisma.costItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CostItemFindFirstArgs>(args?: SelectSubset<T, CostItemFindFirstArgs<ExtArgs>>): Prisma__CostItemClient<$Result.GetResult<Prisma.$CostItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CostItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostItemFindFirstOrThrowArgs} args - Arguments to find a CostItem
     * @example
     * // Get one CostItem
     * const costItem = await prisma.costItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CostItemFindFirstOrThrowArgs>(args?: SelectSubset<T, CostItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__CostItemClient<$Result.GetResult<Prisma.$CostItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CostItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CostItems
     * const costItems = await prisma.costItem.findMany()
     * 
     * // Get first 10 CostItems
     * const costItems = await prisma.costItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const costItemWithIdOnly = await prisma.costItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CostItemFindManyArgs>(args?: SelectSubset<T, CostItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CostItem.
     * @param {CostItemCreateArgs} args - Arguments to create a CostItem.
     * @example
     * // Create one CostItem
     * const CostItem = await prisma.costItem.create({
     *   data: {
     *     // ... data to create a CostItem
     *   }
     * })
     * 
     */
    create<T extends CostItemCreateArgs>(args: SelectSubset<T, CostItemCreateArgs<ExtArgs>>): Prisma__CostItemClient<$Result.GetResult<Prisma.$CostItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CostItems.
     * @param {CostItemCreateManyArgs} args - Arguments to create many CostItems.
     * @example
     * // Create many CostItems
     * const costItem = await prisma.costItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CostItemCreateManyArgs>(args?: SelectSubset<T, CostItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CostItems and returns the data saved in the database.
     * @param {CostItemCreateManyAndReturnArgs} args - Arguments to create many CostItems.
     * @example
     * // Create many CostItems
     * const costItem = await prisma.costItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CostItems and only return the `id`
     * const costItemWithIdOnly = await prisma.costItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CostItemCreateManyAndReturnArgs>(args?: SelectSubset<T, CostItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CostItem.
     * @param {CostItemDeleteArgs} args - Arguments to delete one CostItem.
     * @example
     * // Delete one CostItem
     * const CostItem = await prisma.costItem.delete({
     *   where: {
     *     // ... filter to delete one CostItem
     *   }
     * })
     * 
     */
    delete<T extends CostItemDeleteArgs>(args: SelectSubset<T, CostItemDeleteArgs<ExtArgs>>): Prisma__CostItemClient<$Result.GetResult<Prisma.$CostItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CostItem.
     * @param {CostItemUpdateArgs} args - Arguments to update one CostItem.
     * @example
     * // Update one CostItem
     * const costItem = await prisma.costItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CostItemUpdateArgs>(args: SelectSubset<T, CostItemUpdateArgs<ExtArgs>>): Prisma__CostItemClient<$Result.GetResult<Prisma.$CostItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CostItems.
     * @param {CostItemDeleteManyArgs} args - Arguments to filter CostItems to delete.
     * @example
     * // Delete a few CostItems
     * const { count } = await prisma.costItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CostItemDeleteManyArgs>(args?: SelectSubset<T, CostItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CostItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CostItems
     * const costItem = await prisma.costItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CostItemUpdateManyArgs>(args: SelectSubset<T, CostItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CostItem.
     * @param {CostItemUpsertArgs} args - Arguments to update or create a CostItem.
     * @example
     * // Update or create a CostItem
     * const costItem = await prisma.costItem.upsert({
     *   create: {
     *     // ... data to create a CostItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CostItem we want to update
     *   }
     * })
     */
    upsert<T extends CostItemUpsertArgs>(args: SelectSubset<T, CostItemUpsertArgs<ExtArgs>>): Prisma__CostItemClient<$Result.GetResult<Prisma.$CostItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CostItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostItemCountArgs} args - Arguments to filter CostItems to count.
     * @example
     * // Count the number of CostItems
     * const count = await prisma.costItem.count({
     *   where: {
     *     // ... the filter for the CostItems we want to count
     *   }
     * })
    **/
    count<T extends CostItemCountArgs>(
      args?: Subset<T, CostItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CostItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CostItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CostItemAggregateArgs>(args: Subset<T, CostItemAggregateArgs>): Prisma.PrismaPromise<GetCostItemAggregateType<T>>

    /**
     * Group by CostItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CostItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CostItemGroupByArgs['orderBy'] }
        : { orderBy?: CostItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CostItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCostItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CostItem model
   */
  readonly fields: CostItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CostItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CostItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    strategyItems<T extends CostItem$strategyItemsArgs<ExtArgs> = {}>(args?: Subset<T, CostItem$strategyItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StrategyItemCostPayload<ExtArgs>, T, "findMany"> | Null>
    actionStepItems<T extends CostItem$actionStepItemsArgs<ExtArgs> = {}>(args?: Subset<T, CostItem$actionStepItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionStepItemCostPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CostItem model
   */ 
  interface CostItemFieldRefs {
    readonly id: FieldRef<"CostItem", 'String'>
    readonly itemId: FieldRef<"CostItem", 'String'>
    readonly name: FieldRef<"CostItem", 'String'>
    readonly description: FieldRef<"CostItem", 'String'>
    readonly category: FieldRef<"CostItem", 'String'>
    readonly baseUSD: FieldRef<"CostItem", 'Float'>
    readonly baseUSDMin: FieldRef<"CostItem", 'Float'>
    readonly baseUSDMax: FieldRef<"CostItem", 'Float'>
    readonly unit: FieldRef<"CostItem", 'String'>
    readonly complexity: FieldRef<"CostItem", 'String'>
    readonly notes: FieldRef<"CostItem", 'String'>
    readonly tags: FieldRef<"CostItem", 'String'>
    readonly budgetAlternativeId: FieldRef<"CostItem", 'String'>
    readonly premiumAlternativeId: FieldRef<"CostItem", 'String'>
    readonly isActive: FieldRef<"CostItem", 'Boolean'>
    readonly createdAt: FieldRef<"CostItem", 'DateTime'>
    readonly updatedAt: FieldRef<"CostItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CostItem findUnique
   */
  export type CostItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItem
     */
    select?: CostItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostItemInclude<ExtArgs> | null
    /**
     * Filter, which CostItem to fetch.
     */
    where: CostItemWhereUniqueInput
  }

  /**
   * CostItem findUniqueOrThrow
   */
  export type CostItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItem
     */
    select?: CostItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostItemInclude<ExtArgs> | null
    /**
     * Filter, which CostItem to fetch.
     */
    where: CostItemWhereUniqueInput
  }

  /**
   * CostItem findFirst
   */
  export type CostItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItem
     */
    select?: CostItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostItemInclude<ExtArgs> | null
    /**
     * Filter, which CostItem to fetch.
     */
    where?: CostItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostItems to fetch.
     */
    orderBy?: CostItemOrderByWithRelationInput | CostItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CostItems.
     */
    cursor?: CostItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CostItems.
     */
    distinct?: CostItemScalarFieldEnum | CostItemScalarFieldEnum[]
  }

  /**
   * CostItem findFirstOrThrow
   */
  export type CostItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItem
     */
    select?: CostItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostItemInclude<ExtArgs> | null
    /**
     * Filter, which CostItem to fetch.
     */
    where?: CostItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostItems to fetch.
     */
    orderBy?: CostItemOrderByWithRelationInput | CostItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CostItems.
     */
    cursor?: CostItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CostItems.
     */
    distinct?: CostItemScalarFieldEnum | CostItemScalarFieldEnum[]
  }

  /**
   * CostItem findMany
   */
  export type CostItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItem
     */
    select?: CostItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostItemInclude<ExtArgs> | null
    /**
     * Filter, which CostItems to fetch.
     */
    where?: CostItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostItems to fetch.
     */
    orderBy?: CostItemOrderByWithRelationInput | CostItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CostItems.
     */
    cursor?: CostItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostItems.
     */
    skip?: number
    distinct?: CostItemScalarFieldEnum | CostItemScalarFieldEnum[]
  }

  /**
   * CostItem create
   */
  export type CostItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItem
     */
    select?: CostItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostItemInclude<ExtArgs> | null
    /**
     * The data needed to create a CostItem.
     */
    data: XOR<CostItemCreateInput, CostItemUncheckedCreateInput>
  }

  /**
   * CostItem createMany
   */
  export type CostItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CostItems.
     */
    data: CostItemCreateManyInput | CostItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CostItem createManyAndReturn
   */
  export type CostItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItem
     */
    select?: CostItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CostItems.
     */
    data: CostItemCreateManyInput | CostItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CostItem update
   */
  export type CostItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItem
     */
    select?: CostItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostItemInclude<ExtArgs> | null
    /**
     * The data needed to update a CostItem.
     */
    data: XOR<CostItemUpdateInput, CostItemUncheckedUpdateInput>
    /**
     * Choose, which CostItem to update.
     */
    where: CostItemWhereUniqueInput
  }

  /**
   * CostItem updateMany
   */
  export type CostItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CostItems.
     */
    data: XOR<CostItemUpdateManyMutationInput, CostItemUncheckedUpdateManyInput>
    /**
     * Filter which CostItems to update
     */
    where?: CostItemWhereInput
  }

  /**
   * CostItem upsert
   */
  export type CostItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItem
     */
    select?: CostItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostItemInclude<ExtArgs> | null
    /**
     * The filter to search for the CostItem to update in case it exists.
     */
    where: CostItemWhereUniqueInput
    /**
     * In case the CostItem found by the `where` argument doesn't exist, create a new CostItem with this data.
     */
    create: XOR<CostItemCreateInput, CostItemUncheckedCreateInput>
    /**
     * In case the CostItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CostItemUpdateInput, CostItemUncheckedUpdateInput>
  }

  /**
   * CostItem delete
   */
  export type CostItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItem
     */
    select?: CostItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostItemInclude<ExtArgs> | null
    /**
     * Filter which CostItem to delete.
     */
    where: CostItemWhereUniqueInput
  }

  /**
   * CostItem deleteMany
   */
  export type CostItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CostItems to delete
     */
    where?: CostItemWhereInput
  }

  /**
   * CostItem.strategyItems
   */
  export type CostItem$strategyItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrategyItemCost
     */
    select?: StrategyItemCostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyItemCostInclude<ExtArgs> | null
    where?: StrategyItemCostWhereInput
    orderBy?: StrategyItemCostOrderByWithRelationInput | StrategyItemCostOrderByWithRelationInput[]
    cursor?: StrategyItemCostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StrategyItemCostScalarFieldEnum | StrategyItemCostScalarFieldEnum[]
  }

  /**
   * CostItem.actionStepItems
   */
  export type CostItem$actionStepItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionStepItemCost
     */
    select?: ActionStepItemCostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionStepItemCostInclude<ExtArgs> | null
    where?: ActionStepItemCostWhereInput
    orderBy?: ActionStepItemCostOrderByWithRelationInput | ActionStepItemCostOrderByWithRelationInput[]
    cursor?: ActionStepItemCostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActionStepItemCostScalarFieldEnum | ActionStepItemCostScalarFieldEnum[]
  }

  /**
   * CostItem without action
   */
  export type CostItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItem
     */
    select?: CostItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostItemInclude<ExtArgs> | null
  }


  /**
   * Model CountryCostMultiplier
   */

  export type AggregateCountryCostMultiplier = {
    _count: CountryCostMultiplierCountAggregateOutputType | null
    _avg: CountryCostMultiplierAvgAggregateOutputType | null
    _sum: CountryCostMultiplierSumAggregateOutputType | null
    _min: CountryCostMultiplierMinAggregateOutputType | null
    _max: CountryCostMultiplierMaxAggregateOutputType | null
  }

  export type CountryCostMultiplierAvgAggregateOutputType = {
    construction: number | null
    equipment: number | null
    service: number | null
    supplies: number | null
    exchangeRateUSD: number | null
  }

  export type CountryCostMultiplierSumAggregateOutputType = {
    construction: number | null
    equipment: number | null
    service: number | null
    supplies: number | null
    exchangeRateUSD: number | null
  }

  export type CountryCostMultiplierMinAggregateOutputType = {
    id: string | null
    countryCode: string | null
    construction: number | null
    equipment: number | null
    service: number | null
    supplies: number | null
    currency: string | null
    currencySymbol: string | null
    exchangeRateUSD: number | null
    lastUpdated: Date | null
    updatedBy: string | null
    dataSource: string | null
    confidenceLevel: string | null
    notes: string | null
  }

  export type CountryCostMultiplierMaxAggregateOutputType = {
    id: string | null
    countryCode: string | null
    construction: number | null
    equipment: number | null
    service: number | null
    supplies: number | null
    currency: string | null
    currencySymbol: string | null
    exchangeRateUSD: number | null
    lastUpdated: Date | null
    updatedBy: string | null
    dataSource: string | null
    confidenceLevel: string | null
    notes: string | null
  }

  export type CountryCostMultiplierCountAggregateOutputType = {
    id: number
    countryCode: number
    construction: number
    equipment: number
    service: number
    supplies: number
    currency: number
    currencySymbol: number
    exchangeRateUSD: number
    lastUpdated: number
    updatedBy: number
    dataSource: number
    confidenceLevel: number
    notes: number
    _all: number
  }


  export type CountryCostMultiplierAvgAggregateInputType = {
    construction?: true
    equipment?: true
    service?: true
    supplies?: true
    exchangeRateUSD?: true
  }

  export type CountryCostMultiplierSumAggregateInputType = {
    construction?: true
    equipment?: true
    service?: true
    supplies?: true
    exchangeRateUSD?: true
  }

  export type CountryCostMultiplierMinAggregateInputType = {
    id?: true
    countryCode?: true
    construction?: true
    equipment?: true
    service?: true
    supplies?: true
    currency?: true
    currencySymbol?: true
    exchangeRateUSD?: true
    lastUpdated?: true
    updatedBy?: true
    dataSource?: true
    confidenceLevel?: true
    notes?: true
  }

  export type CountryCostMultiplierMaxAggregateInputType = {
    id?: true
    countryCode?: true
    construction?: true
    equipment?: true
    service?: true
    supplies?: true
    currency?: true
    currencySymbol?: true
    exchangeRateUSD?: true
    lastUpdated?: true
    updatedBy?: true
    dataSource?: true
    confidenceLevel?: true
    notes?: true
  }

  export type CountryCostMultiplierCountAggregateInputType = {
    id?: true
    countryCode?: true
    construction?: true
    equipment?: true
    service?: true
    supplies?: true
    currency?: true
    currencySymbol?: true
    exchangeRateUSD?: true
    lastUpdated?: true
    updatedBy?: true
    dataSource?: true
    confidenceLevel?: true
    notes?: true
    _all?: true
  }

  export type CountryCostMultiplierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CountryCostMultiplier to aggregate.
     */
    where?: CountryCostMultiplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CountryCostMultipliers to fetch.
     */
    orderBy?: CountryCostMultiplierOrderByWithRelationInput | CountryCostMultiplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CountryCostMultiplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CountryCostMultipliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CountryCostMultipliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CountryCostMultipliers
    **/
    _count?: true | CountryCostMultiplierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CountryCostMultiplierAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CountryCostMultiplierSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CountryCostMultiplierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CountryCostMultiplierMaxAggregateInputType
  }

  export type GetCountryCostMultiplierAggregateType<T extends CountryCostMultiplierAggregateArgs> = {
        [P in keyof T & keyof AggregateCountryCostMultiplier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCountryCostMultiplier[P]>
      : GetScalarType<T[P], AggregateCountryCostMultiplier[P]>
  }




  export type CountryCostMultiplierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CountryCostMultiplierWhereInput
    orderBy?: CountryCostMultiplierOrderByWithAggregationInput | CountryCostMultiplierOrderByWithAggregationInput[]
    by: CountryCostMultiplierScalarFieldEnum[] | CountryCostMultiplierScalarFieldEnum
    having?: CountryCostMultiplierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CountryCostMultiplierCountAggregateInputType | true
    _avg?: CountryCostMultiplierAvgAggregateInputType
    _sum?: CountryCostMultiplierSumAggregateInputType
    _min?: CountryCostMultiplierMinAggregateInputType
    _max?: CountryCostMultiplierMaxAggregateInputType
  }

  export type CountryCostMultiplierGroupByOutputType = {
    id: string
    countryCode: string
    construction: number
    equipment: number
    service: number
    supplies: number
    currency: string
    currencySymbol: string | null
    exchangeRateUSD: number
    lastUpdated: Date
    updatedBy: string | null
    dataSource: string | null
    confidenceLevel: string
    notes: string | null
    _count: CountryCostMultiplierCountAggregateOutputType | null
    _avg: CountryCostMultiplierAvgAggregateOutputType | null
    _sum: CountryCostMultiplierSumAggregateOutputType | null
    _min: CountryCostMultiplierMinAggregateOutputType | null
    _max: CountryCostMultiplierMaxAggregateOutputType | null
  }

  type GetCountryCostMultiplierGroupByPayload<T extends CountryCostMultiplierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CountryCostMultiplierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CountryCostMultiplierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CountryCostMultiplierGroupByOutputType[P]>
            : GetScalarType<T[P], CountryCostMultiplierGroupByOutputType[P]>
        }
      >
    >


  export type CountryCostMultiplierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    countryCode?: boolean
    construction?: boolean
    equipment?: boolean
    service?: boolean
    supplies?: boolean
    currency?: boolean
    currencySymbol?: boolean
    exchangeRateUSD?: boolean
    lastUpdated?: boolean
    updatedBy?: boolean
    dataSource?: boolean
    confidenceLevel?: boolean
    notes?: boolean
  }, ExtArgs["result"]["countryCostMultiplier"]>

  export type CountryCostMultiplierSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    countryCode?: boolean
    construction?: boolean
    equipment?: boolean
    service?: boolean
    supplies?: boolean
    currency?: boolean
    currencySymbol?: boolean
    exchangeRateUSD?: boolean
    lastUpdated?: boolean
    updatedBy?: boolean
    dataSource?: boolean
    confidenceLevel?: boolean
    notes?: boolean
  }, ExtArgs["result"]["countryCostMultiplier"]>

  export type CountryCostMultiplierSelectScalar = {
    id?: boolean
    countryCode?: boolean
    construction?: boolean
    equipment?: boolean
    service?: boolean
    supplies?: boolean
    currency?: boolean
    currencySymbol?: boolean
    exchangeRateUSD?: boolean
    lastUpdated?: boolean
    updatedBy?: boolean
    dataSource?: boolean
    confidenceLevel?: boolean
    notes?: boolean
  }


  export type $CountryCostMultiplierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CountryCostMultiplier"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      countryCode: string
      construction: number
      equipment: number
      service: number
      supplies: number
      currency: string
      currencySymbol: string | null
      exchangeRateUSD: number
      lastUpdated: Date
      updatedBy: string | null
      dataSource: string | null
      confidenceLevel: string
      notes: string | null
    }, ExtArgs["result"]["countryCostMultiplier"]>
    composites: {}
  }

  type CountryCostMultiplierGetPayload<S extends boolean | null | undefined | CountryCostMultiplierDefaultArgs> = $Result.GetResult<Prisma.$CountryCostMultiplierPayload, S>

  type CountryCostMultiplierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CountryCostMultiplierFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CountryCostMultiplierCountAggregateInputType | true
    }

  export interface CountryCostMultiplierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CountryCostMultiplier'], meta: { name: 'CountryCostMultiplier' } }
    /**
     * Find zero or one CountryCostMultiplier that matches the filter.
     * @param {CountryCostMultiplierFindUniqueArgs} args - Arguments to find a CountryCostMultiplier
     * @example
     * // Get one CountryCostMultiplier
     * const countryCostMultiplier = await prisma.countryCostMultiplier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CountryCostMultiplierFindUniqueArgs>(args: SelectSubset<T, CountryCostMultiplierFindUniqueArgs<ExtArgs>>): Prisma__CountryCostMultiplierClient<$Result.GetResult<Prisma.$CountryCostMultiplierPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CountryCostMultiplier that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CountryCostMultiplierFindUniqueOrThrowArgs} args - Arguments to find a CountryCostMultiplier
     * @example
     * // Get one CountryCostMultiplier
     * const countryCostMultiplier = await prisma.countryCostMultiplier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CountryCostMultiplierFindUniqueOrThrowArgs>(args: SelectSubset<T, CountryCostMultiplierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CountryCostMultiplierClient<$Result.GetResult<Prisma.$CountryCostMultiplierPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CountryCostMultiplier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryCostMultiplierFindFirstArgs} args - Arguments to find a CountryCostMultiplier
     * @example
     * // Get one CountryCostMultiplier
     * const countryCostMultiplier = await prisma.countryCostMultiplier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CountryCostMultiplierFindFirstArgs>(args?: SelectSubset<T, CountryCostMultiplierFindFirstArgs<ExtArgs>>): Prisma__CountryCostMultiplierClient<$Result.GetResult<Prisma.$CountryCostMultiplierPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CountryCostMultiplier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryCostMultiplierFindFirstOrThrowArgs} args - Arguments to find a CountryCostMultiplier
     * @example
     * // Get one CountryCostMultiplier
     * const countryCostMultiplier = await prisma.countryCostMultiplier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CountryCostMultiplierFindFirstOrThrowArgs>(args?: SelectSubset<T, CountryCostMultiplierFindFirstOrThrowArgs<ExtArgs>>): Prisma__CountryCostMultiplierClient<$Result.GetResult<Prisma.$CountryCostMultiplierPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CountryCostMultipliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryCostMultiplierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CountryCostMultipliers
     * const countryCostMultipliers = await prisma.countryCostMultiplier.findMany()
     * 
     * // Get first 10 CountryCostMultipliers
     * const countryCostMultipliers = await prisma.countryCostMultiplier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const countryCostMultiplierWithIdOnly = await prisma.countryCostMultiplier.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CountryCostMultiplierFindManyArgs>(args?: SelectSubset<T, CountryCostMultiplierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryCostMultiplierPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CountryCostMultiplier.
     * @param {CountryCostMultiplierCreateArgs} args - Arguments to create a CountryCostMultiplier.
     * @example
     * // Create one CountryCostMultiplier
     * const CountryCostMultiplier = await prisma.countryCostMultiplier.create({
     *   data: {
     *     // ... data to create a CountryCostMultiplier
     *   }
     * })
     * 
     */
    create<T extends CountryCostMultiplierCreateArgs>(args: SelectSubset<T, CountryCostMultiplierCreateArgs<ExtArgs>>): Prisma__CountryCostMultiplierClient<$Result.GetResult<Prisma.$CountryCostMultiplierPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CountryCostMultipliers.
     * @param {CountryCostMultiplierCreateManyArgs} args - Arguments to create many CountryCostMultipliers.
     * @example
     * // Create many CountryCostMultipliers
     * const countryCostMultiplier = await prisma.countryCostMultiplier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CountryCostMultiplierCreateManyArgs>(args?: SelectSubset<T, CountryCostMultiplierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CountryCostMultipliers and returns the data saved in the database.
     * @param {CountryCostMultiplierCreateManyAndReturnArgs} args - Arguments to create many CountryCostMultipliers.
     * @example
     * // Create many CountryCostMultipliers
     * const countryCostMultiplier = await prisma.countryCostMultiplier.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CountryCostMultipliers and only return the `id`
     * const countryCostMultiplierWithIdOnly = await prisma.countryCostMultiplier.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CountryCostMultiplierCreateManyAndReturnArgs>(args?: SelectSubset<T, CountryCostMultiplierCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryCostMultiplierPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CountryCostMultiplier.
     * @param {CountryCostMultiplierDeleteArgs} args - Arguments to delete one CountryCostMultiplier.
     * @example
     * // Delete one CountryCostMultiplier
     * const CountryCostMultiplier = await prisma.countryCostMultiplier.delete({
     *   where: {
     *     // ... filter to delete one CountryCostMultiplier
     *   }
     * })
     * 
     */
    delete<T extends CountryCostMultiplierDeleteArgs>(args: SelectSubset<T, CountryCostMultiplierDeleteArgs<ExtArgs>>): Prisma__CountryCostMultiplierClient<$Result.GetResult<Prisma.$CountryCostMultiplierPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CountryCostMultiplier.
     * @param {CountryCostMultiplierUpdateArgs} args - Arguments to update one CountryCostMultiplier.
     * @example
     * // Update one CountryCostMultiplier
     * const countryCostMultiplier = await prisma.countryCostMultiplier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CountryCostMultiplierUpdateArgs>(args: SelectSubset<T, CountryCostMultiplierUpdateArgs<ExtArgs>>): Prisma__CountryCostMultiplierClient<$Result.GetResult<Prisma.$CountryCostMultiplierPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CountryCostMultipliers.
     * @param {CountryCostMultiplierDeleteManyArgs} args - Arguments to filter CountryCostMultipliers to delete.
     * @example
     * // Delete a few CountryCostMultipliers
     * const { count } = await prisma.countryCostMultiplier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CountryCostMultiplierDeleteManyArgs>(args?: SelectSubset<T, CountryCostMultiplierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CountryCostMultipliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryCostMultiplierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CountryCostMultipliers
     * const countryCostMultiplier = await prisma.countryCostMultiplier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CountryCostMultiplierUpdateManyArgs>(args: SelectSubset<T, CountryCostMultiplierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CountryCostMultiplier.
     * @param {CountryCostMultiplierUpsertArgs} args - Arguments to update or create a CountryCostMultiplier.
     * @example
     * // Update or create a CountryCostMultiplier
     * const countryCostMultiplier = await prisma.countryCostMultiplier.upsert({
     *   create: {
     *     // ... data to create a CountryCostMultiplier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CountryCostMultiplier we want to update
     *   }
     * })
     */
    upsert<T extends CountryCostMultiplierUpsertArgs>(args: SelectSubset<T, CountryCostMultiplierUpsertArgs<ExtArgs>>): Prisma__CountryCostMultiplierClient<$Result.GetResult<Prisma.$CountryCostMultiplierPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CountryCostMultipliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryCostMultiplierCountArgs} args - Arguments to filter CountryCostMultipliers to count.
     * @example
     * // Count the number of CountryCostMultipliers
     * const count = await prisma.countryCostMultiplier.count({
     *   where: {
     *     // ... the filter for the CountryCostMultipliers we want to count
     *   }
     * })
    **/
    count<T extends CountryCostMultiplierCountArgs>(
      args?: Subset<T, CountryCostMultiplierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CountryCostMultiplierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CountryCostMultiplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryCostMultiplierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CountryCostMultiplierAggregateArgs>(args: Subset<T, CountryCostMultiplierAggregateArgs>): Prisma.PrismaPromise<GetCountryCostMultiplierAggregateType<T>>

    /**
     * Group by CountryCostMultiplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryCostMultiplierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CountryCostMultiplierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CountryCostMultiplierGroupByArgs['orderBy'] }
        : { orderBy?: CountryCostMultiplierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CountryCostMultiplierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCountryCostMultiplierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CountryCostMultiplier model
   */
  readonly fields: CountryCostMultiplierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CountryCostMultiplier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CountryCostMultiplierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CountryCostMultiplier model
   */ 
  interface CountryCostMultiplierFieldRefs {
    readonly id: FieldRef<"CountryCostMultiplier", 'String'>
    readonly countryCode: FieldRef<"CountryCostMultiplier", 'String'>
    readonly construction: FieldRef<"CountryCostMultiplier", 'Float'>
    readonly equipment: FieldRef<"CountryCostMultiplier", 'Float'>
    readonly service: FieldRef<"CountryCostMultiplier", 'Float'>
    readonly supplies: FieldRef<"CountryCostMultiplier", 'Float'>
    readonly currency: FieldRef<"CountryCostMultiplier", 'String'>
    readonly currencySymbol: FieldRef<"CountryCostMultiplier", 'String'>
    readonly exchangeRateUSD: FieldRef<"CountryCostMultiplier", 'Float'>
    readonly lastUpdated: FieldRef<"CountryCostMultiplier", 'DateTime'>
    readonly updatedBy: FieldRef<"CountryCostMultiplier", 'String'>
    readonly dataSource: FieldRef<"CountryCostMultiplier", 'String'>
    readonly confidenceLevel: FieldRef<"CountryCostMultiplier", 'String'>
    readonly notes: FieldRef<"CountryCostMultiplier", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CountryCostMultiplier findUnique
   */
  export type CountryCostMultiplierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCostMultiplier
     */
    select?: CountryCostMultiplierSelect<ExtArgs> | null
    /**
     * Filter, which CountryCostMultiplier to fetch.
     */
    where: CountryCostMultiplierWhereUniqueInput
  }

  /**
   * CountryCostMultiplier findUniqueOrThrow
   */
  export type CountryCostMultiplierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCostMultiplier
     */
    select?: CountryCostMultiplierSelect<ExtArgs> | null
    /**
     * Filter, which CountryCostMultiplier to fetch.
     */
    where: CountryCostMultiplierWhereUniqueInput
  }

  /**
   * CountryCostMultiplier findFirst
   */
  export type CountryCostMultiplierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCostMultiplier
     */
    select?: CountryCostMultiplierSelect<ExtArgs> | null
    /**
     * Filter, which CountryCostMultiplier to fetch.
     */
    where?: CountryCostMultiplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CountryCostMultipliers to fetch.
     */
    orderBy?: CountryCostMultiplierOrderByWithRelationInput | CountryCostMultiplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CountryCostMultipliers.
     */
    cursor?: CountryCostMultiplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CountryCostMultipliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CountryCostMultipliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CountryCostMultipliers.
     */
    distinct?: CountryCostMultiplierScalarFieldEnum | CountryCostMultiplierScalarFieldEnum[]
  }

  /**
   * CountryCostMultiplier findFirstOrThrow
   */
  export type CountryCostMultiplierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCostMultiplier
     */
    select?: CountryCostMultiplierSelect<ExtArgs> | null
    /**
     * Filter, which CountryCostMultiplier to fetch.
     */
    where?: CountryCostMultiplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CountryCostMultipliers to fetch.
     */
    orderBy?: CountryCostMultiplierOrderByWithRelationInput | CountryCostMultiplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CountryCostMultipliers.
     */
    cursor?: CountryCostMultiplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CountryCostMultipliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CountryCostMultipliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CountryCostMultipliers.
     */
    distinct?: CountryCostMultiplierScalarFieldEnum | CountryCostMultiplierScalarFieldEnum[]
  }

  /**
   * CountryCostMultiplier findMany
   */
  export type CountryCostMultiplierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCostMultiplier
     */
    select?: CountryCostMultiplierSelect<ExtArgs> | null
    /**
     * Filter, which CountryCostMultipliers to fetch.
     */
    where?: CountryCostMultiplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CountryCostMultipliers to fetch.
     */
    orderBy?: CountryCostMultiplierOrderByWithRelationInput | CountryCostMultiplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CountryCostMultipliers.
     */
    cursor?: CountryCostMultiplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CountryCostMultipliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CountryCostMultipliers.
     */
    skip?: number
    distinct?: CountryCostMultiplierScalarFieldEnum | CountryCostMultiplierScalarFieldEnum[]
  }

  /**
   * CountryCostMultiplier create
   */
  export type CountryCostMultiplierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCostMultiplier
     */
    select?: CountryCostMultiplierSelect<ExtArgs> | null
    /**
     * The data needed to create a CountryCostMultiplier.
     */
    data: XOR<CountryCostMultiplierCreateInput, CountryCostMultiplierUncheckedCreateInput>
  }

  /**
   * CountryCostMultiplier createMany
   */
  export type CountryCostMultiplierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CountryCostMultipliers.
     */
    data: CountryCostMultiplierCreateManyInput | CountryCostMultiplierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CountryCostMultiplier createManyAndReturn
   */
  export type CountryCostMultiplierCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCostMultiplier
     */
    select?: CountryCostMultiplierSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CountryCostMultipliers.
     */
    data: CountryCostMultiplierCreateManyInput | CountryCostMultiplierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CountryCostMultiplier update
   */
  export type CountryCostMultiplierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCostMultiplier
     */
    select?: CountryCostMultiplierSelect<ExtArgs> | null
    /**
     * The data needed to update a CountryCostMultiplier.
     */
    data: XOR<CountryCostMultiplierUpdateInput, CountryCostMultiplierUncheckedUpdateInput>
    /**
     * Choose, which CountryCostMultiplier to update.
     */
    where: CountryCostMultiplierWhereUniqueInput
  }

  /**
   * CountryCostMultiplier updateMany
   */
  export type CountryCostMultiplierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CountryCostMultipliers.
     */
    data: XOR<CountryCostMultiplierUpdateManyMutationInput, CountryCostMultiplierUncheckedUpdateManyInput>
    /**
     * Filter which CountryCostMultipliers to update
     */
    where?: CountryCostMultiplierWhereInput
  }

  /**
   * CountryCostMultiplier upsert
   */
  export type CountryCostMultiplierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCostMultiplier
     */
    select?: CountryCostMultiplierSelect<ExtArgs> | null
    /**
     * The filter to search for the CountryCostMultiplier to update in case it exists.
     */
    where: CountryCostMultiplierWhereUniqueInput
    /**
     * In case the CountryCostMultiplier found by the `where` argument doesn't exist, create a new CountryCostMultiplier with this data.
     */
    create: XOR<CountryCostMultiplierCreateInput, CountryCostMultiplierUncheckedCreateInput>
    /**
     * In case the CountryCostMultiplier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CountryCostMultiplierUpdateInput, CountryCostMultiplierUncheckedUpdateInput>
  }

  /**
   * CountryCostMultiplier delete
   */
  export type CountryCostMultiplierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCostMultiplier
     */
    select?: CountryCostMultiplierSelect<ExtArgs> | null
    /**
     * Filter which CountryCostMultiplier to delete.
     */
    where: CountryCostMultiplierWhereUniqueInput
  }

  /**
   * CountryCostMultiplier deleteMany
   */
  export type CountryCostMultiplierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CountryCostMultipliers to delete
     */
    where?: CountryCostMultiplierWhereInput
  }

  /**
   * CountryCostMultiplier without action
   */
  export type CountryCostMultiplierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCostMultiplier
     */
    select?: CountryCostMultiplierSelect<ExtArgs> | null
  }


  /**
   * Model StrategyItemCost
   */

  export type AggregateStrategyItemCost = {
    _count: StrategyItemCostCountAggregateOutputType | null
    _avg: StrategyItemCostAvgAggregateOutputType | null
    _sum: StrategyItemCostSumAggregateOutputType | null
    _min: StrategyItemCostMinAggregateOutputType | null
    _max: StrategyItemCostMaxAggregateOutputType | null
  }

  export type StrategyItemCostAvgAggregateOutputType = {
    quantity: number | null
    displayOrder: number | null
  }

  export type StrategyItemCostSumAggregateOutputType = {
    quantity: number | null
    displayOrder: number | null
  }

  export type StrategyItemCostMinAggregateOutputType = {
    id: string | null
    strategyId: string | null
    itemId: string | null
    quantity: number | null
    customNotes: string | null
    countryOverrides: string | null
    isRequired: boolean | null
    displayOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StrategyItemCostMaxAggregateOutputType = {
    id: string | null
    strategyId: string | null
    itemId: string | null
    quantity: number | null
    customNotes: string | null
    countryOverrides: string | null
    isRequired: boolean | null
    displayOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StrategyItemCostCountAggregateOutputType = {
    id: number
    strategyId: number
    itemId: number
    quantity: number
    customNotes: number
    countryOverrides: number
    isRequired: number
    displayOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StrategyItemCostAvgAggregateInputType = {
    quantity?: true
    displayOrder?: true
  }

  export type StrategyItemCostSumAggregateInputType = {
    quantity?: true
    displayOrder?: true
  }

  export type StrategyItemCostMinAggregateInputType = {
    id?: true
    strategyId?: true
    itemId?: true
    quantity?: true
    customNotes?: true
    countryOverrides?: true
    isRequired?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StrategyItemCostMaxAggregateInputType = {
    id?: true
    strategyId?: true
    itemId?: true
    quantity?: true
    customNotes?: true
    countryOverrides?: true
    isRequired?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StrategyItemCostCountAggregateInputType = {
    id?: true
    strategyId?: true
    itemId?: true
    quantity?: true
    customNotes?: true
    countryOverrides?: true
    isRequired?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StrategyItemCostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StrategyItemCost to aggregate.
     */
    where?: StrategyItemCostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StrategyItemCosts to fetch.
     */
    orderBy?: StrategyItemCostOrderByWithRelationInput | StrategyItemCostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StrategyItemCostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StrategyItemCosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StrategyItemCosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StrategyItemCosts
    **/
    _count?: true | StrategyItemCostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StrategyItemCostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StrategyItemCostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StrategyItemCostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StrategyItemCostMaxAggregateInputType
  }

  export type GetStrategyItemCostAggregateType<T extends StrategyItemCostAggregateArgs> = {
        [P in keyof T & keyof AggregateStrategyItemCost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStrategyItemCost[P]>
      : GetScalarType<T[P], AggregateStrategyItemCost[P]>
  }




  export type StrategyItemCostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StrategyItemCostWhereInput
    orderBy?: StrategyItemCostOrderByWithAggregationInput | StrategyItemCostOrderByWithAggregationInput[]
    by: StrategyItemCostScalarFieldEnum[] | StrategyItemCostScalarFieldEnum
    having?: StrategyItemCostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StrategyItemCostCountAggregateInputType | true
    _avg?: StrategyItemCostAvgAggregateInputType
    _sum?: StrategyItemCostSumAggregateInputType
    _min?: StrategyItemCostMinAggregateInputType
    _max?: StrategyItemCostMaxAggregateInputType
  }

  export type StrategyItemCostGroupByOutputType = {
    id: string
    strategyId: string
    itemId: string
    quantity: number
    customNotes: string | null
    countryOverrides: string | null
    isRequired: boolean
    displayOrder: number
    createdAt: Date
    updatedAt: Date
    _count: StrategyItemCostCountAggregateOutputType | null
    _avg: StrategyItemCostAvgAggregateOutputType | null
    _sum: StrategyItemCostSumAggregateOutputType | null
    _min: StrategyItemCostMinAggregateOutputType | null
    _max: StrategyItemCostMaxAggregateOutputType | null
  }

  type GetStrategyItemCostGroupByPayload<T extends StrategyItemCostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StrategyItemCostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StrategyItemCostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StrategyItemCostGroupByOutputType[P]>
            : GetScalarType<T[P], StrategyItemCostGroupByOutputType[P]>
        }
      >
    >


  export type StrategyItemCostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    strategyId?: boolean
    itemId?: boolean
    quantity?: boolean
    customNotes?: boolean
    countryOverrides?: boolean
    isRequired?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    strategy?: boolean | RiskMitigationStrategyDefaultArgs<ExtArgs>
    item?: boolean | CostItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["strategyItemCost"]>

  export type StrategyItemCostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    strategyId?: boolean
    itemId?: boolean
    quantity?: boolean
    customNotes?: boolean
    countryOverrides?: boolean
    isRequired?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    strategy?: boolean | RiskMitigationStrategyDefaultArgs<ExtArgs>
    item?: boolean | CostItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["strategyItemCost"]>

  export type StrategyItemCostSelectScalar = {
    id?: boolean
    strategyId?: boolean
    itemId?: boolean
    quantity?: boolean
    customNotes?: boolean
    countryOverrides?: boolean
    isRequired?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StrategyItemCostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    strategy?: boolean | RiskMitigationStrategyDefaultArgs<ExtArgs>
    item?: boolean | CostItemDefaultArgs<ExtArgs>
  }
  export type StrategyItemCostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    strategy?: boolean | RiskMitigationStrategyDefaultArgs<ExtArgs>
    item?: boolean | CostItemDefaultArgs<ExtArgs>
  }

  export type $StrategyItemCostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StrategyItemCost"
    objects: {
      strategy: Prisma.$RiskMitigationStrategyPayload<ExtArgs>
      item: Prisma.$CostItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      strategyId: string
      itemId: string
      quantity: number
      customNotes: string | null
      countryOverrides: string | null
      isRequired: boolean
      displayOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["strategyItemCost"]>
    composites: {}
  }

  type StrategyItemCostGetPayload<S extends boolean | null | undefined | StrategyItemCostDefaultArgs> = $Result.GetResult<Prisma.$StrategyItemCostPayload, S>

  type StrategyItemCostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StrategyItemCostFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StrategyItemCostCountAggregateInputType | true
    }

  export interface StrategyItemCostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StrategyItemCost'], meta: { name: 'StrategyItemCost' } }
    /**
     * Find zero or one StrategyItemCost that matches the filter.
     * @param {StrategyItemCostFindUniqueArgs} args - Arguments to find a StrategyItemCost
     * @example
     * // Get one StrategyItemCost
     * const strategyItemCost = await prisma.strategyItemCost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StrategyItemCostFindUniqueArgs>(args: SelectSubset<T, StrategyItemCostFindUniqueArgs<ExtArgs>>): Prisma__StrategyItemCostClient<$Result.GetResult<Prisma.$StrategyItemCostPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StrategyItemCost that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StrategyItemCostFindUniqueOrThrowArgs} args - Arguments to find a StrategyItemCost
     * @example
     * // Get one StrategyItemCost
     * const strategyItemCost = await prisma.strategyItemCost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StrategyItemCostFindUniqueOrThrowArgs>(args: SelectSubset<T, StrategyItemCostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StrategyItemCostClient<$Result.GetResult<Prisma.$StrategyItemCostPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StrategyItemCost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrategyItemCostFindFirstArgs} args - Arguments to find a StrategyItemCost
     * @example
     * // Get one StrategyItemCost
     * const strategyItemCost = await prisma.strategyItemCost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StrategyItemCostFindFirstArgs>(args?: SelectSubset<T, StrategyItemCostFindFirstArgs<ExtArgs>>): Prisma__StrategyItemCostClient<$Result.GetResult<Prisma.$StrategyItemCostPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StrategyItemCost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrategyItemCostFindFirstOrThrowArgs} args - Arguments to find a StrategyItemCost
     * @example
     * // Get one StrategyItemCost
     * const strategyItemCost = await prisma.strategyItemCost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StrategyItemCostFindFirstOrThrowArgs>(args?: SelectSubset<T, StrategyItemCostFindFirstOrThrowArgs<ExtArgs>>): Prisma__StrategyItemCostClient<$Result.GetResult<Prisma.$StrategyItemCostPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StrategyItemCosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrategyItemCostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StrategyItemCosts
     * const strategyItemCosts = await prisma.strategyItemCost.findMany()
     * 
     * // Get first 10 StrategyItemCosts
     * const strategyItemCosts = await prisma.strategyItemCost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const strategyItemCostWithIdOnly = await prisma.strategyItemCost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StrategyItemCostFindManyArgs>(args?: SelectSubset<T, StrategyItemCostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StrategyItemCostPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StrategyItemCost.
     * @param {StrategyItemCostCreateArgs} args - Arguments to create a StrategyItemCost.
     * @example
     * // Create one StrategyItemCost
     * const StrategyItemCost = await prisma.strategyItemCost.create({
     *   data: {
     *     // ... data to create a StrategyItemCost
     *   }
     * })
     * 
     */
    create<T extends StrategyItemCostCreateArgs>(args: SelectSubset<T, StrategyItemCostCreateArgs<ExtArgs>>): Prisma__StrategyItemCostClient<$Result.GetResult<Prisma.$StrategyItemCostPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StrategyItemCosts.
     * @param {StrategyItemCostCreateManyArgs} args - Arguments to create many StrategyItemCosts.
     * @example
     * // Create many StrategyItemCosts
     * const strategyItemCost = await prisma.strategyItemCost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StrategyItemCostCreateManyArgs>(args?: SelectSubset<T, StrategyItemCostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StrategyItemCosts and returns the data saved in the database.
     * @param {StrategyItemCostCreateManyAndReturnArgs} args - Arguments to create many StrategyItemCosts.
     * @example
     * // Create many StrategyItemCosts
     * const strategyItemCost = await prisma.strategyItemCost.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StrategyItemCosts and only return the `id`
     * const strategyItemCostWithIdOnly = await prisma.strategyItemCost.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StrategyItemCostCreateManyAndReturnArgs>(args?: SelectSubset<T, StrategyItemCostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StrategyItemCostPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StrategyItemCost.
     * @param {StrategyItemCostDeleteArgs} args - Arguments to delete one StrategyItemCost.
     * @example
     * // Delete one StrategyItemCost
     * const StrategyItemCost = await prisma.strategyItemCost.delete({
     *   where: {
     *     // ... filter to delete one StrategyItemCost
     *   }
     * })
     * 
     */
    delete<T extends StrategyItemCostDeleteArgs>(args: SelectSubset<T, StrategyItemCostDeleteArgs<ExtArgs>>): Prisma__StrategyItemCostClient<$Result.GetResult<Prisma.$StrategyItemCostPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StrategyItemCost.
     * @param {StrategyItemCostUpdateArgs} args - Arguments to update one StrategyItemCost.
     * @example
     * // Update one StrategyItemCost
     * const strategyItemCost = await prisma.strategyItemCost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StrategyItemCostUpdateArgs>(args: SelectSubset<T, StrategyItemCostUpdateArgs<ExtArgs>>): Prisma__StrategyItemCostClient<$Result.GetResult<Prisma.$StrategyItemCostPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StrategyItemCosts.
     * @param {StrategyItemCostDeleteManyArgs} args - Arguments to filter StrategyItemCosts to delete.
     * @example
     * // Delete a few StrategyItemCosts
     * const { count } = await prisma.strategyItemCost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StrategyItemCostDeleteManyArgs>(args?: SelectSubset<T, StrategyItemCostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StrategyItemCosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrategyItemCostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StrategyItemCosts
     * const strategyItemCost = await prisma.strategyItemCost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StrategyItemCostUpdateManyArgs>(args: SelectSubset<T, StrategyItemCostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StrategyItemCost.
     * @param {StrategyItemCostUpsertArgs} args - Arguments to update or create a StrategyItemCost.
     * @example
     * // Update or create a StrategyItemCost
     * const strategyItemCost = await prisma.strategyItemCost.upsert({
     *   create: {
     *     // ... data to create a StrategyItemCost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StrategyItemCost we want to update
     *   }
     * })
     */
    upsert<T extends StrategyItemCostUpsertArgs>(args: SelectSubset<T, StrategyItemCostUpsertArgs<ExtArgs>>): Prisma__StrategyItemCostClient<$Result.GetResult<Prisma.$StrategyItemCostPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StrategyItemCosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrategyItemCostCountArgs} args - Arguments to filter StrategyItemCosts to count.
     * @example
     * // Count the number of StrategyItemCosts
     * const count = await prisma.strategyItemCost.count({
     *   where: {
     *     // ... the filter for the StrategyItemCosts we want to count
     *   }
     * })
    **/
    count<T extends StrategyItemCostCountArgs>(
      args?: Subset<T, StrategyItemCostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StrategyItemCostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StrategyItemCost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrategyItemCostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StrategyItemCostAggregateArgs>(args: Subset<T, StrategyItemCostAggregateArgs>): Prisma.PrismaPromise<GetStrategyItemCostAggregateType<T>>

    /**
     * Group by StrategyItemCost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrategyItemCostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StrategyItemCostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StrategyItemCostGroupByArgs['orderBy'] }
        : { orderBy?: StrategyItemCostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StrategyItemCostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStrategyItemCostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StrategyItemCost model
   */
  readonly fields: StrategyItemCostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StrategyItemCost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StrategyItemCostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    strategy<T extends RiskMitigationStrategyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RiskMitigationStrategyDefaultArgs<ExtArgs>>): Prisma__RiskMitigationStrategyClient<$Result.GetResult<Prisma.$RiskMitigationStrategyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    item<T extends CostItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CostItemDefaultArgs<ExtArgs>>): Prisma__CostItemClient<$Result.GetResult<Prisma.$CostItemPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StrategyItemCost model
   */ 
  interface StrategyItemCostFieldRefs {
    readonly id: FieldRef<"StrategyItemCost", 'String'>
    readonly strategyId: FieldRef<"StrategyItemCost", 'String'>
    readonly itemId: FieldRef<"StrategyItemCost", 'String'>
    readonly quantity: FieldRef<"StrategyItemCost", 'Int'>
    readonly customNotes: FieldRef<"StrategyItemCost", 'String'>
    readonly countryOverrides: FieldRef<"StrategyItemCost", 'String'>
    readonly isRequired: FieldRef<"StrategyItemCost", 'Boolean'>
    readonly displayOrder: FieldRef<"StrategyItemCost", 'Int'>
    readonly createdAt: FieldRef<"StrategyItemCost", 'DateTime'>
    readonly updatedAt: FieldRef<"StrategyItemCost", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StrategyItemCost findUnique
   */
  export type StrategyItemCostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrategyItemCost
     */
    select?: StrategyItemCostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyItemCostInclude<ExtArgs> | null
    /**
     * Filter, which StrategyItemCost to fetch.
     */
    where: StrategyItemCostWhereUniqueInput
  }

  /**
   * StrategyItemCost findUniqueOrThrow
   */
  export type StrategyItemCostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrategyItemCost
     */
    select?: StrategyItemCostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyItemCostInclude<ExtArgs> | null
    /**
     * Filter, which StrategyItemCost to fetch.
     */
    where: StrategyItemCostWhereUniqueInput
  }

  /**
   * StrategyItemCost findFirst
   */
  export type StrategyItemCostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrategyItemCost
     */
    select?: StrategyItemCostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyItemCostInclude<ExtArgs> | null
    /**
     * Filter, which StrategyItemCost to fetch.
     */
    where?: StrategyItemCostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StrategyItemCosts to fetch.
     */
    orderBy?: StrategyItemCostOrderByWithRelationInput | StrategyItemCostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StrategyItemCosts.
     */
    cursor?: StrategyItemCostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StrategyItemCosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StrategyItemCosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StrategyItemCosts.
     */
    distinct?: StrategyItemCostScalarFieldEnum | StrategyItemCostScalarFieldEnum[]
  }

  /**
   * StrategyItemCost findFirstOrThrow
   */
  export type StrategyItemCostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrategyItemCost
     */
    select?: StrategyItemCostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyItemCostInclude<ExtArgs> | null
    /**
     * Filter, which StrategyItemCost to fetch.
     */
    where?: StrategyItemCostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StrategyItemCosts to fetch.
     */
    orderBy?: StrategyItemCostOrderByWithRelationInput | StrategyItemCostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StrategyItemCosts.
     */
    cursor?: StrategyItemCostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StrategyItemCosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StrategyItemCosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StrategyItemCosts.
     */
    distinct?: StrategyItemCostScalarFieldEnum | StrategyItemCostScalarFieldEnum[]
  }

  /**
   * StrategyItemCost findMany
   */
  export type StrategyItemCostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrategyItemCost
     */
    select?: StrategyItemCostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyItemCostInclude<ExtArgs> | null
    /**
     * Filter, which StrategyItemCosts to fetch.
     */
    where?: StrategyItemCostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StrategyItemCosts to fetch.
     */
    orderBy?: StrategyItemCostOrderByWithRelationInput | StrategyItemCostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StrategyItemCosts.
     */
    cursor?: StrategyItemCostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StrategyItemCosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StrategyItemCosts.
     */
    skip?: number
    distinct?: StrategyItemCostScalarFieldEnum | StrategyItemCostScalarFieldEnum[]
  }

  /**
   * StrategyItemCost create
   */
  export type StrategyItemCostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrategyItemCost
     */
    select?: StrategyItemCostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyItemCostInclude<ExtArgs> | null
    /**
     * The data needed to create a StrategyItemCost.
     */
    data: XOR<StrategyItemCostCreateInput, StrategyItemCostUncheckedCreateInput>
  }

  /**
   * StrategyItemCost createMany
   */
  export type StrategyItemCostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StrategyItemCosts.
     */
    data: StrategyItemCostCreateManyInput | StrategyItemCostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StrategyItemCost createManyAndReturn
   */
  export type StrategyItemCostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrategyItemCost
     */
    select?: StrategyItemCostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StrategyItemCosts.
     */
    data: StrategyItemCostCreateManyInput | StrategyItemCostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyItemCostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StrategyItemCost update
   */
  export type StrategyItemCostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrategyItemCost
     */
    select?: StrategyItemCostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyItemCostInclude<ExtArgs> | null
    /**
     * The data needed to update a StrategyItemCost.
     */
    data: XOR<StrategyItemCostUpdateInput, StrategyItemCostUncheckedUpdateInput>
    /**
     * Choose, which StrategyItemCost to update.
     */
    where: StrategyItemCostWhereUniqueInput
  }

  /**
   * StrategyItemCost updateMany
   */
  export type StrategyItemCostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StrategyItemCosts.
     */
    data: XOR<StrategyItemCostUpdateManyMutationInput, StrategyItemCostUncheckedUpdateManyInput>
    /**
     * Filter which StrategyItemCosts to update
     */
    where?: StrategyItemCostWhereInput
  }

  /**
   * StrategyItemCost upsert
   */
  export type StrategyItemCostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrategyItemCost
     */
    select?: StrategyItemCostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyItemCostInclude<ExtArgs> | null
    /**
     * The filter to search for the StrategyItemCost to update in case it exists.
     */
    where: StrategyItemCostWhereUniqueInput
    /**
     * In case the StrategyItemCost found by the `where` argument doesn't exist, create a new StrategyItemCost with this data.
     */
    create: XOR<StrategyItemCostCreateInput, StrategyItemCostUncheckedCreateInput>
    /**
     * In case the StrategyItemCost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StrategyItemCostUpdateInput, StrategyItemCostUncheckedUpdateInput>
  }

  /**
   * StrategyItemCost delete
   */
  export type StrategyItemCostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrategyItemCost
     */
    select?: StrategyItemCostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyItemCostInclude<ExtArgs> | null
    /**
     * Filter which StrategyItemCost to delete.
     */
    where: StrategyItemCostWhereUniqueInput
  }

  /**
   * StrategyItemCost deleteMany
   */
  export type StrategyItemCostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StrategyItemCosts to delete
     */
    where?: StrategyItemCostWhereInput
  }

  /**
   * StrategyItemCost without action
   */
  export type StrategyItemCostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrategyItemCost
     */
    select?: StrategyItemCostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyItemCostInclude<ExtArgs> | null
  }


  /**
   * Model ActionStepItemCost
   */

  export type AggregateActionStepItemCost = {
    _count: ActionStepItemCostCountAggregateOutputType | null
    _avg: ActionStepItemCostAvgAggregateOutputType | null
    _sum: ActionStepItemCostSumAggregateOutputType | null
    _min: ActionStepItemCostMinAggregateOutputType | null
    _max: ActionStepItemCostMaxAggregateOutputType | null
  }

  export type ActionStepItemCostAvgAggregateOutputType = {
    quantity: number | null
    displayOrder: number | null
  }

  export type ActionStepItemCostSumAggregateOutputType = {
    quantity: number | null
    displayOrder: number | null
  }

  export type ActionStepItemCostMinAggregateOutputType = {
    id: string | null
    actionStepId: string | null
    itemId: string | null
    quantity: number | null
    customNotes: string | null
    countryOverrides: string | null
    displayOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ActionStepItemCostMaxAggregateOutputType = {
    id: string | null
    actionStepId: string | null
    itemId: string | null
    quantity: number | null
    customNotes: string | null
    countryOverrides: string | null
    displayOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ActionStepItemCostCountAggregateOutputType = {
    id: number
    actionStepId: number
    itemId: number
    quantity: number
    customNotes: number
    countryOverrides: number
    displayOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ActionStepItemCostAvgAggregateInputType = {
    quantity?: true
    displayOrder?: true
  }

  export type ActionStepItemCostSumAggregateInputType = {
    quantity?: true
    displayOrder?: true
  }

  export type ActionStepItemCostMinAggregateInputType = {
    id?: true
    actionStepId?: true
    itemId?: true
    quantity?: true
    customNotes?: true
    countryOverrides?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ActionStepItemCostMaxAggregateInputType = {
    id?: true
    actionStepId?: true
    itemId?: true
    quantity?: true
    customNotes?: true
    countryOverrides?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ActionStepItemCostCountAggregateInputType = {
    id?: true
    actionStepId?: true
    itemId?: true
    quantity?: true
    customNotes?: true
    countryOverrides?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ActionStepItemCostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActionStepItemCost to aggregate.
     */
    where?: ActionStepItemCostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActionStepItemCosts to fetch.
     */
    orderBy?: ActionStepItemCostOrderByWithRelationInput | ActionStepItemCostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActionStepItemCostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActionStepItemCosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActionStepItemCosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActionStepItemCosts
    **/
    _count?: true | ActionStepItemCostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActionStepItemCostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActionStepItemCostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActionStepItemCostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActionStepItemCostMaxAggregateInputType
  }

  export type GetActionStepItemCostAggregateType<T extends ActionStepItemCostAggregateArgs> = {
        [P in keyof T & keyof AggregateActionStepItemCost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActionStepItemCost[P]>
      : GetScalarType<T[P], AggregateActionStepItemCost[P]>
  }




  export type ActionStepItemCostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActionStepItemCostWhereInput
    orderBy?: ActionStepItemCostOrderByWithAggregationInput | ActionStepItemCostOrderByWithAggregationInput[]
    by: ActionStepItemCostScalarFieldEnum[] | ActionStepItemCostScalarFieldEnum
    having?: ActionStepItemCostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActionStepItemCostCountAggregateInputType | true
    _avg?: ActionStepItemCostAvgAggregateInputType
    _sum?: ActionStepItemCostSumAggregateInputType
    _min?: ActionStepItemCostMinAggregateInputType
    _max?: ActionStepItemCostMaxAggregateInputType
  }

  export type ActionStepItemCostGroupByOutputType = {
    id: string
    actionStepId: string
    itemId: string
    quantity: number
    customNotes: string | null
    countryOverrides: string | null
    displayOrder: number
    createdAt: Date
    updatedAt: Date
    _count: ActionStepItemCostCountAggregateOutputType | null
    _avg: ActionStepItemCostAvgAggregateOutputType | null
    _sum: ActionStepItemCostSumAggregateOutputType | null
    _min: ActionStepItemCostMinAggregateOutputType | null
    _max: ActionStepItemCostMaxAggregateOutputType | null
  }

  type GetActionStepItemCostGroupByPayload<T extends ActionStepItemCostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActionStepItemCostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActionStepItemCostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActionStepItemCostGroupByOutputType[P]>
            : GetScalarType<T[P], ActionStepItemCostGroupByOutputType[P]>
        }
      >
    >


  export type ActionStepItemCostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actionStepId?: boolean
    itemId?: boolean
    quantity?: boolean
    customNotes?: boolean
    countryOverrides?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    actionStep?: boolean | ActionStepDefaultArgs<ExtArgs>
    item?: boolean | CostItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["actionStepItemCost"]>

  export type ActionStepItemCostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actionStepId?: boolean
    itemId?: boolean
    quantity?: boolean
    customNotes?: boolean
    countryOverrides?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    actionStep?: boolean | ActionStepDefaultArgs<ExtArgs>
    item?: boolean | CostItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["actionStepItemCost"]>

  export type ActionStepItemCostSelectScalar = {
    id?: boolean
    actionStepId?: boolean
    itemId?: boolean
    quantity?: boolean
    customNotes?: boolean
    countryOverrides?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ActionStepItemCostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actionStep?: boolean | ActionStepDefaultArgs<ExtArgs>
    item?: boolean | CostItemDefaultArgs<ExtArgs>
  }
  export type ActionStepItemCostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actionStep?: boolean | ActionStepDefaultArgs<ExtArgs>
    item?: boolean | CostItemDefaultArgs<ExtArgs>
  }

  export type $ActionStepItemCostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActionStepItemCost"
    objects: {
      actionStep: Prisma.$ActionStepPayload<ExtArgs>
      item: Prisma.$CostItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      actionStepId: string
      itemId: string
      quantity: number
      customNotes: string | null
      countryOverrides: string | null
      displayOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["actionStepItemCost"]>
    composites: {}
  }

  type ActionStepItemCostGetPayload<S extends boolean | null | undefined | ActionStepItemCostDefaultArgs> = $Result.GetResult<Prisma.$ActionStepItemCostPayload, S>

  type ActionStepItemCostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ActionStepItemCostFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ActionStepItemCostCountAggregateInputType | true
    }

  export interface ActionStepItemCostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActionStepItemCost'], meta: { name: 'ActionStepItemCost' } }
    /**
     * Find zero or one ActionStepItemCost that matches the filter.
     * @param {ActionStepItemCostFindUniqueArgs} args - Arguments to find a ActionStepItemCost
     * @example
     * // Get one ActionStepItemCost
     * const actionStepItemCost = await prisma.actionStepItemCost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActionStepItemCostFindUniqueArgs>(args: SelectSubset<T, ActionStepItemCostFindUniqueArgs<ExtArgs>>): Prisma__ActionStepItemCostClient<$Result.GetResult<Prisma.$ActionStepItemCostPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ActionStepItemCost that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ActionStepItemCostFindUniqueOrThrowArgs} args - Arguments to find a ActionStepItemCost
     * @example
     * // Get one ActionStepItemCost
     * const actionStepItemCost = await prisma.actionStepItemCost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActionStepItemCostFindUniqueOrThrowArgs>(args: SelectSubset<T, ActionStepItemCostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActionStepItemCostClient<$Result.GetResult<Prisma.$ActionStepItemCostPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ActionStepItemCost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionStepItemCostFindFirstArgs} args - Arguments to find a ActionStepItemCost
     * @example
     * // Get one ActionStepItemCost
     * const actionStepItemCost = await prisma.actionStepItemCost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActionStepItemCostFindFirstArgs>(args?: SelectSubset<T, ActionStepItemCostFindFirstArgs<ExtArgs>>): Prisma__ActionStepItemCostClient<$Result.GetResult<Prisma.$ActionStepItemCostPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ActionStepItemCost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionStepItemCostFindFirstOrThrowArgs} args - Arguments to find a ActionStepItemCost
     * @example
     * // Get one ActionStepItemCost
     * const actionStepItemCost = await prisma.actionStepItemCost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActionStepItemCostFindFirstOrThrowArgs>(args?: SelectSubset<T, ActionStepItemCostFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActionStepItemCostClient<$Result.GetResult<Prisma.$ActionStepItemCostPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ActionStepItemCosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionStepItemCostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActionStepItemCosts
     * const actionStepItemCosts = await prisma.actionStepItemCost.findMany()
     * 
     * // Get first 10 ActionStepItemCosts
     * const actionStepItemCosts = await prisma.actionStepItemCost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const actionStepItemCostWithIdOnly = await prisma.actionStepItemCost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActionStepItemCostFindManyArgs>(args?: SelectSubset<T, ActionStepItemCostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionStepItemCostPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ActionStepItemCost.
     * @param {ActionStepItemCostCreateArgs} args - Arguments to create a ActionStepItemCost.
     * @example
     * // Create one ActionStepItemCost
     * const ActionStepItemCost = await prisma.actionStepItemCost.create({
     *   data: {
     *     // ... data to create a ActionStepItemCost
     *   }
     * })
     * 
     */
    create<T extends ActionStepItemCostCreateArgs>(args: SelectSubset<T, ActionStepItemCostCreateArgs<ExtArgs>>): Prisma__ActionStepItemCostClient<$Result.GetResult<Prisma.$ActionStepItemCostPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ActionStepItemCosts.
     * @param {ActionStepItemCostCreateManyArgs} args - Arguments to create many ActionStepItemCosts.
     * @example
     * // Create many ActionStepItemCosts
     * const actionStepItemCost = await prisma.actionStepItemCost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActionStepItemCostCreateManyArgs>(args?: SelectSubset<T, ActionStepItemCostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ActionStepItemCosts and returns the data saved in the database.
     * @param {ActionStepItemCostCreateManyAndReturnArgs} args - Arguments to create many ActionStepItemCosts.
     * @example
     * // Create many ActionStepItemCosts
     * const actionStepItemCost = await prisma.actionStepItemCost.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ActionStepItemCosts and only return the `id`
     * const actionStepItemCostWithIdOnly = await prisma.actionStepItemCost.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActionStepItemCostCreateManyAndReturnArgs>(args?: SelectSubset<T, ActionStepItemCostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionStepItemCostPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ActionStepItemCost.
     * @param {ActionStepItemCostDeleteArgs} args - Arguments to delete one ActionStepItemCost.
     * @example
     * // Delete one ActionStepItemCost
     * const ActionStepItemCost = await prisma.actionStepItemCost.delete({
     *   where: {
     *     // ... filter to delete one ActionStepItemCost
     *   }
     * })
     * 
     */
    delete<T extends ActionStepItemCostDeleteArgs>(args: SelectSubset<T, ActionStepItemCostDeleteArgs<ExtArgs>>): Prisma__ActionStepItemCostClient<$Result.GetResult<Prisma.$ActionStepItemCostPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ActionStepItemCost.
     * @param {ActionStepItemCostUpdateArgs} args - Arguments to update one ActionStepItemCost.
     * @example
     * // Update one ActionStepItemCost
     * const actionStepItemCost = await prisma.actionStepItemCost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActionStepItemCostUpdateArgs>(args: SelectSubset<T, ActionStepItemCostUpdateArgs<ExtArgs>>): Prisma__ActionStepItemCostClient<$Result.GetResult<Prisma.$ActionStepItemCostPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ActionStepItemCosts.
     * @param {ActionStepItemCostDeleteManyArgs} args - Arguments to filter ActionStepItemCosts to delete.
     * @example
     * // Delete a few ActionStepItemCosts
     * const { count } = await prisma.actionStepItemCost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActionStepItemCostDeleteManyArgs>(args?: SelectSubset<T, ActionStepItemCostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActionStepItemCosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionStepItemCostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActionStepItemCosts
     * const actionStepItemCost = await prisma.actionStepItemCost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActionStepItemCostUpdateManyArgs>(args: SelectSubset<T, ActionStepItemCostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ActionStepItemCost.
     * @param {ActionStepItemCostUpsertArgs} args - Arguments to update or create a ActionStepItemCost.
     * @example
     * // Update or create a ActionStepItemCost
     * const actionStepItemCost = await prisma.actionStepItemCost.upsert({
     *   create: {
     *     // ... data to create a ActionStepItemCost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActionStepItemCost we want to update
     *   }
     * })
     */
    upsert<T extends ActionStepItemCostUpsertArgs>(args: SelectSubset<T, ActionStepItemCostUpsertArgs<ExtArgs>>): Prisma__ActionStepItemCostClient<$Result.GetResult<Prisma.$ActionStepItemCostPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ActionStepItemCosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionStepItemCostCountArgs} args - Arguments to filter ActionStepItemCosts to count.
     * @example
     * // Count the number of ActionStepItemCosts
     * const count = await prisma.actionStepItemCost.count({
     *   where: {
     *     // ... the filter for the ActionStepItemCosts we want to count
     *   }
     * })
    **/
    count<T extends ActionStepItemCostCountArgs>(
      args?: Subset<T, ActionStepItemCostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActionStepItemCostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActionStepItemCost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionStepItemCostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActionStepItemCostAggregateArgs>(args: Subset<T, ActionStepItemCostAggregateArgs>): Prisma.PrismaPromise<GetActionStepItemCostAggregateType<T>>

    /**
     * Group by ActionStepItemCost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionStepItemCostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActionStepItemCostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActionStepItemCostGroupByArgs['orderBy'] }
        : { orderBy?: ActionStepItemCostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActionStepItemCostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActionStepItemCostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActionStepItemCost model
   */
  readonly fields: ActionStepItemCostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActionStepItemCost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActionStepItemCostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    actionStep<T extends ActionStepDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ActionStepDefaultArgs<ExtArgs>>): Prisma__ActionStepClient<$Result.GetResult<Prisma.$ActionStepPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    item<T extends CostItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CostItemDefaultArgs<ExtArgs>>): Prisma__CostItemClient<$Result.GetResult<Prisma.$CostItemPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActionStepItemCost model
   */ 
  interface ActionStepItemCostFieldRefs {
    readonly id: FieldRef<"ActionStepItemCost", 'String'>
    readonly actionStepId: FieldRef<"ActionStepItemCost", 'String'>
    readonly itemId: FieldRef<"ActionStepItemCost", 'String'>
    readonly quantity: FieldRef<"ActionStepItemCost", 'Int'>
    readonly customNotes: FieldRef<"ActionStepItemCost", 'String'>
    readonly countryOverrides: FieldRef<"ActionStepItemCost", 'String'>
    readonly displayOrder: FieldRef<"ActionStepItemCost", 'Int'>
    readonly createdAt: FieldRef<"ActionStepItemCost", 'DateTime'>
    readonly updatedAt: FieldRef<"ActionStepItemCost", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ActionStepItemCost findUnique
   */
  export type ActionStepItemCostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionStepItemCost
     */
    select?: ActionStepItemCostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionStepItemCostInclude<ExtArgs> | null
    /**
     * Filter, which ActionStepItemCost to fetch.
     */
    where: ActionStepItemCostWhereUniqueInput
  }

  /**
   * ActionStepItemCost findUniqueOrThrow
   */
  export type ActionStepItemCostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionStepItemCost
     */
    select?: ActionStepItemCostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionStepItemCostInclude<ExtArgs> | null
    /**
     * Filter, which ActionStepItemCost to fetch.
     */
    where: ActionStepItemCostWhereUniqueInput
  }

  /**
   * ActionStepItemCost findFirst
   */
  export type ActionStepItemCostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionStepItemCost
     */
    select?: ActionStepItemCostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionStepItemCostInclude<ExtArgs> | null
    /**
     * Filter, which ActionStepItemCost to fetch.
     */
    where?: ActionStepItemCostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActionStepItemCosts to fetch.
     */
    orderBy?: ActionStepItemCostOrderByWithRelationInput | ActionStepItemCostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActionStepItemCosts.
     */
    cursor?: ActionStepItemCostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActionStepItemCosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActionStepItemCosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActionStepItemCosts.
     */
    distinct?: ActionStepItemCostScalarFieldEnum | ActionStepItemCostScalarFieldEnum[]
  }

  /**
   * ActionStepItemCost findFirstOrThrow
   */
  export type ActionStepItemCostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionStepItemCost
     */
    select?: ActionStepItemCostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionStepItemCostInclude<ExtArgs> | null
    /**
     * Filter, which ActionStepItemCost to fetch.
     */
    where?: ActionStepItemCostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActionStepItemCosts to fetch.
     */
    orderBy?: ActionStepItemCostOrderByWithRelationInput | ActionStepItemCostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActionStepItemCosts.
     */
    cursor?: ActionStepItemCostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActionStepItemCosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActionStepItemCosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActionStepItemCosts.
     */
    distinct?: ActionStepItemCostScalarFieldEnum | ActionStepItemCostScalarFieldEnum[]
  }

  /**
   * ActionStepItemCost findMany
   */
  export type ActionStepItemCostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionStepItemCost
     */
    select?: ActionStepItemCostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionStepItemCostInclude<ExtArgs> | null
    /**
     * Filter, which ActionStepItemCosts to fetch.
     */
    where?: ActionStepItemCostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActionStepItemCosts to fetch.
     */
    orderBy?: ActionStepItemCostOrderByWithRelationInput | ActionStepItemCostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActionStepItemCosts.
     */
    cursor?: ActionStepItemCostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActionStepItemCosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActionStepItemCosts.
     */
    skip?: number
    distinct?: ActionStepItemCostScalarFieldEnum | ActionStepItemCostScalarFieldEnum[]
  }

  /**
   * ActionStepItemCost create
   */
  export type ActionStepItemCostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionStepItemCost
     */
    select?: ActionStepItemCostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionStepItemCostInclude<ExtArgs> | null
    /**
     * The data needed to create a ActionStepItemCost.
     */
    data: XOR<ActionStepItemCostCreateInput, ActionStepItemCostUncheckedCreateInput>
  }

  /**
   * ActionStepItemCost createMany
   */
  export type ActionStepItemCostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActionStepItemCosts.
     */
    data: ActionStepItemCostCreateManyInput | ActionStepItemCostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActionStepItemCost createManyAndReturn
   */
  export type ActionStepItemCostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionStepItemCost
     */
    select?: ActionStepItemCostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ActionStepItemCosts.
     */
    data: ActionStepItemCostCreateManyInput | ActionStepItemCostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionStepItemCostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActionStepItemCost update
   */
  export type ActionStepItemCostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionStepItemCost
     */
    select?: ActionStepItemCostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionStepItemCostInclude<ExtArgs> | null
    /**
     * The data needed to update a ActionStepItemCost.
     */
    data: XOR<ActionStepItemCostUpdateInput, ActionStepItemCostUncheckedUpdateInput>
    /**
     * Choose, which ActionStepItemCost to update.
     */
    where: ActionStepItemCostWhereUniqueInput
  }

  /**
   * ActionStepItemCost updateMany
   */
  export type ActionStepItemCostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActionStepItemCosts.
     */
    data: XOR<ActionStepItemCostUpdateManyMutationInput, ActionStepItemCostUncheckedUpdateManyInput>
    /**
     * Filter which ActionStepItemCosts to update
     */
    where?: ActionStepItemCostWhereInput
  }

  /**
   * ActionStepItemCost upsert
   */
  export type ActionStepItemCostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionStepItemCost
     */
    select?: ActionStepItemCostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionStepItemCostInclude<ExtArgs> | null
    /**
     * The filter to search for the ActionStepItemCost to update in case it exists.
     */
    where: ActionStepItemCostWhereUniqueInput
    /**
     * In case the ActionStepItemCost found by the `where` argument doesn't exist, create a new ActionStepItemCost with this data.
     */
    create: XOR<ActionStepItemCostCreateInput, ActionStepItemCostUncheckedCreateInput>
    /**
     * In case the ActionStepItemCost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActionStepItemCostUpdateInput, ActionStepItemCostUncheckedUpdateInput>
  }

  /**
   * ActionStepItemCost delete
   */
  export type ActionStepItemCostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionStepItemCost
     */
    select?: ActionStepItemCostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionStepItemCostInclude<ExtArgs> | null
    /**
     * Filter which ActionStepItemCost to delete.
     */
    where: ActionStepItemCostWhereUniqueInput
  }

  /**
   * ActionStepItemCost deleteMany
   */
  export type ActionStepItemCostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActionStepItemCosts to delete
     */
    where?: ActionStepItemCostWhereInput
  }

  /**
   * ActionStepItemCost without action
   */
  export type ActionStepItemCostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionStepItemCost
     */
    select?: ActionStepItemCostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionStepItemCostInclude<ExtArgs> | null
  }


  /**
   * Model BusinessTypeTranslation
   */

  export type AggregateBusinessTypeTranslation = {
    _count: BusinessTypeTranslationCountAggregateOutputType | null
    _min: BusinessTypeTranslationMinAggregateOutputType | null
    _max: BusinessTypeTranslationMaxAggregateOutputType | null
  }

  export type BusinessTypeTranslationMinAggregateOutputType = {
    id: string | null
    businessTypeId: string | null
    locale: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BusinessTypeTranslationMaxAggregateOutputType = {
    id: string | null
    businessTypeId: string | null
    locale: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BusinessTypeTranslationCountAggregateOutputType = {
    id: number
    businessTypeId: number
    locale: number
    name: number
    description: number
    exampleBusinessPurposes: number
    exampleProducts: number
    exampleKeyPersonnel: number
    exampleCustomerBase: number
    minimumEquipment: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BusinessTypeTranslationMinAggregateInputType = {
    id?: true
    businessTypeId?: true
    locale?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BusinessTypeTranslationMaxAggregateInputType = {
    id?: true
    businessTypeId?: true
    locale?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BusinessTypeTranslationCountAggregateInputType = {
    id?: true
    businessTypeId?: true
    locale?: true
    name?: true
    description?: true
    exampleBusinessPurposes?: true
    exampleProducts?: true
    exampleKeyPersonnel?: true
    exampleCustomerBase?: true
    minimumEquipment?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BusinessTypeTranslationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessTypeTranslation to aggregate.
     */
    where?: BusinessTypeTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessTypeTranslations to fetch.
     */
    orderBy?: BusinessTypeTranslationOrderByWithRelationInput | BusinessTypeTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BusinessTypeTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessTypeTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessTypeTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BusinessTypeTranslations
    **/
    _count?: true | BusinessTypeTranslationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BusinessTypeTranslationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BusinessTypeTranslationMaxAggregateInputType
  }

  export type GetBusinessTypeTranslationAggregateType<T extends BusinessTypeTranslationAggregateArgs> = {
        [P in keyof T & keyof AggregateBusinessTypeTranslation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBusinessTypeTranslation[P]>
      : GetScalarType<T[P], AggregateBusinessTypeTranslation[P]>
  }




  export type BusinessTypeTranslationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessTypeTranslationWhereInput
    orderBy?: BusinessTypeTranslationOrderByWithAggregationInput | BusinessTypeTranslationOrderByWithAggregationInput[]
    by: BusinessTypeTranslationScalarFieldEnum[] | BusinessTypeTranslationScalarFieldEnum
    having?: BusinessTypeTranslationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BusinessTypeTranslationCountAggregateInputType | true
    _min?: BusinessTypeTranslationMinAggregateInputType
    _max?: BusinessTypeTranslationMaxAggregateInputType
  }

  export type BusinessTypeTranslationGroupByOutputType = {
    id: string
    businessTypeId: string
    locale: string
    name: string
    description: string | null
    exampleBusinessPurposes: JsonValue | null
    exampleProducts: JsonValue | null
    exampleKeyPersonnel: JsonValue | null
    exampleCustomerBase: JsonValue | null
    minimumEquipment: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: BusinessTypeTranslationCountAggregateOutputType | null
    _min: BusinessTypeTranslationMinAggregateOutputType | null
    _max: BusinessTypeTranslationMaxAggregateOutputType | null
  }

  type GetBusinessTypeTranslationGroupByPayload<T extends BusinessTypeTranslationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BusinessTypeTranslationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BusinessTypeTranslationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BusinessTypeTranslationGroupByOutputType[P]>
            : GetScalarType<T[P], BusinessTypeTranslationGroupByOutputType[P]>
        }
      >
    >


  export type BusinessTypeTranslationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessTypeId?: boolean
    locale?: boolean
    name?: boolean
    description?: boolean
    exampleBusinessPurposes?: boolean
    exampleProducts?: boolean
    exampleKeyPersonnel?: boolean
    exampleCustomerBase?: boolean
    minimumEquipment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    businessType?: boolean | BusinessTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["businessTypeTranslation"]>

  export type BusinessTypeTranslationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessTypeId?: boolean
    locale?: boolean
    name?: boolean
    description?: boolean
    exampleBusinessPurposes?: boolean
    exampleProducts?: boolean
    exampleKeyPersonnel?: boolean
    exampleCustomerBase?: boolean
    minimumEquipment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    businessType?: boolean | BusinessTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["businessTypeTranslation"]>

  export type BusinessTypeTranslationSelectScalar = {
    id?: boolean
    businessTypeId?: boolean
    locale?: boolean
    name?: boolean
    description?: boolean
    exampleBusinessPurposes?: boolean
    exampleProducts?: boolean
    exampleKeyPersonnel?: boolean
    exampleCustomerBase?: boolean
    minimumEquipment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BusinessTypeTranslationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businessType?: boolean | BusinessTypeDefaultArgs<ExtArgs>
  }
  export type BusinessTypeTranslationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businessType?: boolean | BusinessTypeDefaultArgs<ExtArgs>
  }

  export type $BusinessTypeTranslationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BusinessTypeTranslation"
    objects: {
      businessType: Prisma.$BusinessTypePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      businessTypeId: string
      locale: string
      name: string
      description: string | null
      exampleBusinessPurposes: Prisma.JsonValue | null
      exampleProducts: Prisma.JsonValue | null
      exampleKeyPersonnel: Prisma.JsonValue | null
      exampleCustomerBase: Prisma.JsonValue | null
      minimumEquipment: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["businessTypeTranslation"]>
    composites: {}
  }

  type BusinessTypeTranslationGetPayload<S extends boolean | null | undefined | BusinessTypeTranslationDefaultArgs> = $Result.GetResult<Prisma.$BusinessTypeTranslationPayload, S>

  type BusinessTypeTranslationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BusinessTypeTranslationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BusinessTypeTranslationCountAggregateInputType | true
    }

  export interface BusinessTypeTranslationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BusinessTypeTranslation'], meta: { name: 'BusinessTypeTranslation' } }
    /**
     * Find zero or one BusinessTypeTranslation that matches the filter.
     * @param {BusinessTypeTranslationFindUniqueArgs} args - Arguments to find a BusinessTypeTranslation
     * @example
     * // Get one BusinessTypeTranslation
     * const businessTypeTranslation = await prisma.businessTypeTranslation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BusinessTypeTranslationFindUniqueArgs>(args: SelectSubset<T, BusinessTypeTranslationFindUniqueArgs<ExtArgs>>): Prisma__BusinessTypeTranslationClient<$Result.GetResult<Prisma.$BusinessTypeTranslationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BusinessTypeTranslation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BusinessTypeTranslationFindUniqueOrThrowArgs} args - Arguments to find a BusinessTypeTranslation
     * @example
     * // Get one BusinessTypeTranslation
     * const businessTypeTranslation = await prisma.businessTypeTranslation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BusinessTypeTranslationFindUniqueOrThrowArgs>(args: SelectSubset<T, BusinessTypeTranslationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BusinessTypeTranslationClient<$Result.GetResult<Prisma.$BusinessTypeTranslationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BusinessTypeTranslation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessTypeTranslationFindFirstArgs} args - Arguments to find a BusinessTypeTranslation
     * @example
     * // Get one BusinessTypeTranslation
     * const businessTypeTranslation = await prisma.businessTypeTranslation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BusinessTypeTranslationFindFirstArgs>(args?: SelectSubset<T, BusinessTypeTranslationFindFirstArgs<ExtArgs>>): Prisma__BusinessTypeTranslationClient<$Result.GetResult<Prisma.$BusinessTypeTranslationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BusinessTypeTranslation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessTypeTranslationFindFirstOrThrowArgs} args - Arguments to find a BusinessTypeTranslation
     * @example
     * // Get one BusinessTypeTranslation
     * const businessTypeTranslation = await prisma.businessTypeTranslation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BusinessTypeTranslationFindFirstOrThrowArgs>(args?: SelectSubset<T, BusinessTypeTranslationFindFirstOrThrowArgs<ExtArgs>>): Prisma__BusinessTypeTranslationClient<$Result.GetResult<Prisma.$BusinessTypeTranslationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BusinessTypeTranslations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessTypeTranslationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BusinessTypeTranslations
     * const businessTypeTranslations = await prisma.businessTypeTranslation.findMany()
     * 
     * // Get first 10 BusinessTypeTranslations
     * const businessTypeTranslations = await prisma.businessTypeTranslation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const businessTypeTranslationWithIdOnly = await prisma.businessTypeTranslation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BusinessTypeTranslationFindManyArgs>(args?: SelectSubset<T, BusinessTypeTranslationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessTypeTranslationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BusinessTypeTranslation.
     * @param {BusinessTypeTranslationCreateArgs} args - Arguments to create a BusinessTypeTranslation.
     * @example
     * // Create one BusinessTypeTranslation
     * const BusinessTypeTranslation = await prisma.businessTypeTranslation.create({
     *   data: {
     *     // ... data to create a BusinessTypeTranslation
     *   }
     * })
     * 
     */
    create<T extends BusinessTypeTranslationCreateArgs>(args: SelectSubset<T, BusinessTypeTranslationCreateArgs<ExtArgs>>): Prisma__BusinessTypeTranslationClient<$Result.GetResult<Prisma.$BusinessTypeTranslationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BusinessTypeTranslations.
     * @param {BusinessTypeTranslationCreateManyArgs} args - Arguments to create many BusinessTypeTranslations.
     * @example
     * // Create many BusinessTypeTranslations
     * const businessTypeTranslation = await prisma.businessTypeTranslation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BusinessTypeTranslationCreateManyArgs>(args?: SelectSubset<T, BusinessTypeTranslationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BusinessTypeTranslations and returns the data saved in the database.
     * @param {BusinessTypeTranslationCreateManyAndReturnArgs} args - Arguments to create many BusinessTypeTranslations.
     * @example
     * // Create many BusinessTypeTranslations
     * const businessTypeTranslation = await prisma.businessTypeTranslation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BusinessTypeTranslations and only return the `id`
     * const businessTypeTranslationWithIdOnly = await prisma.businessTypeTranslation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BusinessTypeTranslationCreateManyAndReturnArgs>(args?: SelectSubset<T, BusinessTypeTranslationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessTypeTranslationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BusinessTypeTranslation.
     * @param {BusinessTypeTranslationDeleteArgs} args - Arguments to delete one BusinessTypeTranslation.
     * @example
     * // Delete one BusinessTypeTranslation
     * const BusinessTypeTranslation = await prisma.businessTypeTranslation.delete({
     *   where: {
     *     // ... filter to delete one BusinessTypeTranslation
     *   }
     * })
     * 
     */
    delete<T extends BusinessTypeTranslationDeleteArgs>(args: SelectSubset<T, BusinessTypeTranslationDeleteArgs<ExtArgs>>): Prisma__BusinessTypeTranslationClient<$Result.GetResult<Prisma.$BusinessTypeTranslationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BusinessTypeTranslation.
     * @param {BusinessTypeTranslationUpdateArgs} args - Arguments to update one BusinessTypeTranslation.
     * @example
     * // Update one BusinessTypeTranslation
     * const businessTypeTranslation = await prisma.businessTypeTranslation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BusinessTypeTranslationUpdateArgs>(args: SelectSubset<T, BusinessTypeTranslationUpdateArgs<ExtArgs>>): Prisma__BusinessTypeTranslationClient<$Result.GetResult<Prisma.$BusinessTypeTranslationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BusinessTypeTranslations.
     * @param {BusinessTypeTranslationDeleteManyArgs} args - Arguments to filter BusinessTypeTranslations to delete.
     * @example
     * // Delete a few BusinessTypeTranslations
     * const { count } = await prisma.businessTypeTranslation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BusinessTypeTranslationDeleteManyArgs>(args?: SelectSubset<T, BusinessTypeTranslationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BusinessTypeTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessTypeTranslationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BusinessTypeTranslations
     * const businessTypeTranslation = await prisma.businessTypeTranslation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BusinessTypeTranslationUpdateManyArgs>(args: SelectSubset<T, BusinessTypeTranslationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BusinessTypeTranslation.
     * @param {BusinessTypeTranslationUpsertArgs} args - Arguments to update or create a BusinessTypeTranslation.
     * @example
     * // Update or create a BusinessTypeTranslation
     * const businessTypeTranslation = await prisma.businessTypeTranslation.upsert({
     *   create: {
     *     // ... data to create a BusinessTypeTranslation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BusinessTypeTranslation we want to update
     *   }
     * })
     */
    upsert<T extends BusinessTypeTranslationUpsertArgs>(args: SelectSubset<T, BusinessTypeTranslationUpsertArgs<ExtArgs>>): Prisma__BusinessTypeTranslationClient<$Result.GetResult<Prisma.$BusinessTypeTranslationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BusinessTypeTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessTypeTranslationCountArgs} args - Arguments to filter BusinessTypeTranslations to count.
     * @example
     * // Count the number of BusinessTypeTranslations
     * const count = await prisma.businessTypeTranslation.count({
     *   where: {
     *     // ... the filter for the BusinessTypeTranslations we want to count
     *   }
     * })
    **/
    count<T extends BusinessTypeTranslationCountArgs>(
      args?: Subset<T, BusinessTypeTranslationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BusinessTypeTranslationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BusinessTypeTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessTypeTranslationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BusinessTypeTranslationAggregateArgs>(args: Subset<T, BusinessTypeTranslationAggregateArgs>): Prisma.PrismaPromise<GetBusinessTypeTranslationAggregateType<T>>

    /**
     * Group by BusinessTypeTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessTypeTranslationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BusinessTypeTranslationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BusinessTypeTranslationGroupByArgs['orderBy'] }
        : { orderBy?: BusinessTypeTranslationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BusinessTypeTranslationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBusinessTypeTranslationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BusinessTypeTranslation model
   */
  readonly fields: BusinessTypeTranslationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BusinessTypeTranslation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BusinessTypeTranslationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    businessType<T extends BusinessTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BusinessTypeDefaultArgs<ExtArgs>>): Prisma__BusinessTypeClient<$Result.GetResult<Prisma.$BusinessTypePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BusinessTypeTranslation model
   */ 
  interface BusinessTypeTranslationFieldRefs {
    readonly id: FieldRef<"BusinessTypeTranslation", 'String'>
    readonly businessTypeId: FieldRef<"BusinessTypeTranslation", 'String'>
    readonly locale: FieldRef<"BusinessTypeTranslation", 'String'>
    readonly name: FieldRef<"BusinessTypeTranslation", 'String'>
    readonly description: FieldRef<"BusinessTypeTranslation", 'String'>
    readonly exampleBusinessPurposes: FieldRef<"BusinessTypeTranslation", 'Json'>
    readonly exampleProducts: FieldRef<"BusinessTypeTranslation", 'Json'>
    readonly exampleKeyPersonnel: FieldRef<"BusinessTypeTranslation", 'Json'>
    readonly exampleCustomerBase: FieldRef<"BusinessTypeTranslation", 'Json'>
    readonly minimumEquipment: FieldRef<"BusinessTypeTranslation", 'Json'>
    readonly createdAt: FieldRef<"BusinessTypeTranslation", 'DateTime'>
    readonly updatedAt: FieldRef<"BusinessTypeTranslation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BusinessTypeTranslation findUnique
   */
  export type BusinessTypeTranslationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessTypeTranslation
     */
    select?: BusinessTypeTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypeTranslationInclude<ExtArgs> | null
    /**
     * Filter, which BusinessTypeTranslation to fetch.
     */
    where: BusinessTypeTranslationWhereUniqueInput
  }

  /**
   * BusinessTypeTranslation findUniqueOrThrow
   */
  export type BusinessTypeTranslationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessTypeTranslation
     */
    select?: BusinessTypeTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypeTranslationInclude<ExtArgs> | null
    /**
     * Filter, which BusinessTypeTranslation to fetch.
     */
    where: BusinessTypeTranslationWhereUniqueInput
  }

  /**
   * BusinessTypeTranslation findFirst
   */
  export type BusinessTypeTranslationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessTypeTranslation
     */
    select?: BusinessTypeTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypeTranslationInclude<ExtArgs> | null
    /**
     * Filter, which BusinessTypeTranslation to fetch.
     */
    where?: BusinessTypeTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessTypeTranslations to fetch.
     */
    orderBy?: BusinessTypeTranslationOrderByWithRelationInput | BusinessTypeTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessTypeTranslations.
     */
    cursor?: BusinessTypeTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessTypeTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessTypeTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessTypeTranslations.
     */
    distinct?: BusinessTypeTranslationScalarFieldEnum | BusinessTypeTranslationScalarFieldEnum[]
  }

  /**
   * BusinessTypeTranslation findFirstOrThrow
   */
  export type BusinessTypeTranslationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessTypeTranslation
     */
    select?: BusinessTypeTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypeTranslationInclude<ExtArgs> | null
    /**
     * Filter, which BusinessTypeTranslation to fetch.
     */
    where?: BusinessTypeTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessTypeTranslations to fetch.
     */
    orderBy?: BusinessTypeTranslationOrderByWithRelationInput | BusinessTypeTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessTypeTranslations.
     */
    cursor?: BusinessTypeTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessTypeTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessTypeTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessTypeTranslations.
     */
    distinct?: BusinessTypeTranslationScalarFieldEnum | BusinessTypeTranslationScalarFieldEnum[]
  }

  /**
   * BusinessTypeTranslation findMany
   */
  export type BusinessTypeTranslationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessTypeTranslation
     */
    select?: BusinessTypeTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypeTranslationInclude<ExtArgs> | null
    /**
     * Filter, which BusinessTypeTranslations to fetch.
     */
    where?: BusinessTypeTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessTypeTranslations to fetch.
     */
    orderBy?: BusinessTypeTranslationOrderByWithRelationInput | BusinessTypeTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BusinessTypeTranslations.
     */
    cursor?: BusinessTypeTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessTypeTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessTypeTranslations.
     */
    skip?: number
    distinct?: BusinessTypeTranslationScalarFieldEnum | BusinessTypeTranslationScalarFieldEnum[]
  }

  /**
   * BusinessTypeTranslation create
   */
  export type BusinessTypeTranslationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessTypeTranslation
     */
    select?: BusinessTypeTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypeTranslationInclude<ExtArgs> | null
    /**
     * The data needed to create a BusinessTypeTranslation.
     */
    data: XOR<BusinessTypeTranslationCreateInput, BusinessTypeTranslationUncheckedCreateInput>
  }

  /**
   * BusinessTypeTranslation createMany
   */
  export type BusinessTypeTranslationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BusinessTypeTranslations.
     */
    data: BusinessTypeTranslationCreateManyInput | BusinessTypeTranslationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BusinessTypeTranslation createManyAndReturn
   */
  export type BusinessTypeTranslationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessTypeTranslation
     */
    select?: BusinessTypeTranslationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BusinessTypeTranslations.
     */
    data: BusinessTypeTranslationCreateManyInput | BusinessTypeTranslationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypeTranslationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BusinessTypeTranslation update
   */
  export type BusinessTypeTranslationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessTypeTranslation
     */
    select?: BusinessTypeTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypeTranslationInclude<ExtArgs> | null
    /**
     * The data needed to update a BusinessTypeTranslation.
     */
    data: XOR<BusinessTypeTranslationUpdateInput, BusinessTypeTranslationUncheckedUpdateInput>
    /**
     * Choose, which BusinessTypeTranslation to update.
     */
    where: BusinessTypeTranslationWhereUniqueInput
  }

  /**
   * BusinessTypeTranslation updateMany
   */
  export type BusinessTypeTranslationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BusinessTypeTranslations.
     */
    data: XOR<BusinessTypeTranslationUpdateManyMutationInput, BusinessTypeTranslationUncheckedUpdateManyInput>
    /**
     * Filter which BusinessTypeTranslations to update
     */
    where?: BusinessTypeTranslationWhereInput
  }

  /**
   * BusinessTypeTranslation upsert
   */
  export type BusinessTypeTranslationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessTypeTranslation
     */
    select?: BusinessTypeTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypeTranslationInclude<ExtArgs> | null
    /**
     * The filter to search for the BusinessTypeTranslation to update in case it exists.
     */
    where: BusinessTypeTranslationWhereUniqueInput
    /**
     * In case the BusinessTypeTranslation found by the `where` argument doesn't exist, create a new BusinessTypeTranslation with this data.
     */
    create: XOR<BusinessTypeTranslationCreateInput, BusinessTypeTranslationUncheckedCreateInput>
    /**
     * In case the BusinessTypeTranslation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BusinessTypeTranslationUpdateInput, BusinessTypeTranslationUncheckedUpdateInput>
  }

  /**
   * BusinessTypeTranslation delete
   */
  export type BusinessTypeTranslationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessTypeTranslation
     */
    select?: BusinessTypeTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypeTranslationInclude<ExtArgs> | null
    /**
     * Filter which BusinessTypeTranslation to delete.
     */
    where: BusinessTypeTranslationWhereUniqueInput
  }

  /**
   * BusinessTypeTranslation deleteMany
   */
  export type BusinessTypeTranslationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessTypeTranslations to delete
     */
    where?: BusinessTypeTranslationWhereInput
  }

  /**
   * BusinessTypeTranslation without action
   */
  export type BusinessTypeTranslationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessTypeTranslation
     */
    select?: BusinessTypeTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypeTranslationInclude<ExtArgs> | null
  }


  /**
   * Model StrategyTranslation
   */

  export type AggregateStrategyTranslation = {
    _count: StrategyTranslationCountAggregateOutputType | null
    _min: StrategyTranslationMinAggregateOutputType | null
    _max: StrategyTranslationMaxAggregateOutputType | null
  }

  export type StrategyTranslationMinAggregateOutputType = {
    id: string | null
    strategyId: string | null
    locale: string | null
    name: string | null
    description: string | null
    smeTitle: string | null
    smeSummary: string | null
    realWorldExample: string | null
    whyImportant: string | null
    whenToImplement: string | null
    expectedOutcome: string | null
    lowBudgetAlternative: string | null
    diyApproach: string | null
    bcpTemplateText: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StrategyTranslationMaxAggregateOutputType = {
    id: string | null
    strategyId: string | null
    locale: string | null
    name: string | null
    description: string | null
    smeTitle: string | null
    smeSummary: string | null
    realWorldExample: string | null
    whyImportant: string | null
    whenToImplement: string | null
    expectedOutcome: string | null
    lowBudgetAlternative: string | null
    diyApproach: string | null
    bcpTemplateText: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StrategyTranslationCountAggregateOutputType = {
    id: number
    strategyId: number
    locale: number
    name: number
    description: number
    smeTitle: number
    smeSummary: number
    realWorldExample: number
    whyImportant: number
    whenToImplement: number
    expectedOutcome: number
    benefitsBullets: number
    helpfulTips: number
    commonMistakes: number
    successMetrics: number
    requiredResources: number
    lowBudgetAlternative: number
    diyApproach: number
    bcpTemplateText: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StrategyTranslationMinAggregateInputType = {
    id?: true
    strategyId?: true
    locale?: true
    name?: true
    description?: true
    smeTitle?: true
    smeSummary?: true
    realWorldExample?: true
    whyImportant?: true
    whenToImplement?: true
    expectedOutcome?: true
    lowBudgetAlternative?: true
    diyApproach?: true
    bcpTemplateText?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StrategyTranslationMaxAggregateInputType = {
    id?: true
    strategyId?: true
    locale?: true
    name?: true
    description?: true
    smeTitle?: true
    smeSummary?: true
    realWorldExample?: true
    whyImportant?: true
    whenToImplement?: true
    expectedOutcome?: true
    lowBudgetAlternative?: true
    diyApproach?: true
    bcpTemplateText?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StrategyTranslationCountAggregateInputType = {
    id?: true
    strategyId?: true
    locale?: true
    name?: true
    description?: true
    smeTitle?: true
    smeSummary?: true
    realWorldExample?: true
    whyImportant?: true
    whenToImplement?: true
    expectedOutcome?: true
    benefitsBullets?: true
    helpfulTips?: true
    commonMistakes?: true
    successMetrics?: true
    requiredResources?: true
    lowBudgetAlternative?: true
    diyApproach?: true
    bcpTemplateText?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StrategyTranslationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StrategyTranslation to aggregate.
     */
    where?: StrategyTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StrategyTranslations to fetch.
     */
    orderBy?: StrategyTranslationOrderByWithRelationInput | StrategyTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StrategyTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StrategyTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StrategyTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StrategyTranslations
    **/
    _count?: true | StrategyTranslationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StrategyTranslationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StrategyTranslationMaxAggregateInputType
  }

  export type GetStrategyTranslationAggregateType<T extends StrategyTranslationAggregateArgs> = {
        [P in keyof T & keyof AggregateStrategyTranslation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStrategyTranslation[P]>
      : GetScalarType<T[P], AggregateStrategyTranslation[P]>
  }




  export type StrategyTranslationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StrategyTranslationWhereInput
    orderBy?: StrategyTranslationOrderByWithAggregationInput | StrategyTranslationOrderByWithAggregationInput[]
    by: StrategyTranslationScalarFieldEnum[] | StrategyTranslationScalarFieldEnum
    having?: StrategyTranslationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StrategyTranslationCountAggregateInputType | true
    _min?: StrategyTranslationMinAggregateInputType
    _max?: StrategyTranslationMaxAggregateInputType
  }

  export type StrategyTranslationGroupByOutputType = {
    id: string
    strategyId: string
    locale: string
    name: string
    description: string
    smeTitle: string | null
    smeSummary: string | null
    realWorldExample: string | null
    whyImportant: string | null
    whenToImplement: string | null
    expectedOutcome: string | null
    benefitsBullets: JsonValue | null
    helpfulTips: JsonValue | null
    commonMistakes: JsonValue | null
    successMetrics: JsonValue | null
    requiredResources: JsonValue | null
    lowBudgetAlternative: string | null
    diyApproach: string | null
    bcpTemplateText: string | null
    createdAt: Date
    updatedAt: Date
    _count: StrategyTranslationCountAggregateOutputType | null
    _min: StrategyTranslationMinAggregateOutputType | null
    _max: StrategyTranslationMaxAggregateOutputType | null
  }

  type GetStrategyTranslationGroupByPayload<T extends StrategyTranslationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StrategyTranslationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StrategyTranslationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StrategyTranslationGroupByOutputType[P]>
            : GetScalarType<T[P], StrategyTranslationGroupByOutputType[P]>
        }
      >
    >


  export type StrategyTranslationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    strategyId?: boolean
    locale?: boolean
    name?: boolean
    description?: boolean
    smeTitle?: boolean
    smeSummary?: boolean
    realWorldExample?: boolean
    whyImportant?: boolean
    whenToImplement?: boolean
    expectedOutcome?: boolean
    benefitsBullets?: boolean
    helpfulTips?: boolean
    commonMistakes?: boolean
    successMetrics?: boolean
    requiredResources?: boolean
    lowBudgetAlternative?: boolean
    diyApproach?: boolean
    bcpTemplateText?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    strategy?: boolean | RiskMitigationStrategyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["strategyTranslation"]>

  export type StrategyTranslationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    strategyId?: boolean
    locale?: boolean
    name?: boolean
    description?: boolean
    smeTitle?: boolean
    smeSummary?: boolean
    realWorldExample?: boolean
    whyImportant?: boolean
    whenToImplement?: boolean
    expectedOutcome?: boolean
    benefitsBullets?: boolean
    helpfulTips?: boolean
    commonMistakes?: boolean
    successMetrics?: boolean
    requiredResources?: boolean
    lowBudgetAlternative?: boolean
    diyApproach?: boolean
    bcpTemplateText?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    strategy?: boolean | RiskMitigationStrategyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["strategyTranslation"]>

  export type StrategyTranslationSelectScalar = {
    id?: boolean
    strategyId?: boolean
    locale?: boolean
    name?: boolean
    description?: boolean
    smeTitle?: boolean
    smeSummary?: boolean
    realWorldExample?: boolean
    whyImportant?: boolean
    whenToImplement?: boolean
    expectedOutcome?: boolean
    benefitsBullets?: boolean
    helpfulTips?: boolean
    commonMistakes?: boolean
    successMetrics?: boolean
    requiredResources?: boolean
    lowBudgetAlternative?: boolean
    diyApproach?: boolean
    bcpTemplateText?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StrategyTranslationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    strategy?: boolean | RiskMitigationStrategyDefaultArgs<ExtArgs>
  }
  export type StrategyTranslationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    strategy?: boolean | RiskMitigationStrategyDefaultArgs<ExtArgs>
  }

  export type $StrategyTranslationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StrategyTranslation"
    objects: {
      strategy: Prisma.$RiskMitigationStrategyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      strategyId: string
      locale: string
      name: string
      description: string
      smeTitle: string | null
      smeSummary: string | null
      realWorldExample: string | null
      whyImportant: string | null
      whenToImplement: string | null
      expectedOutcome: string | null
      benefitsBullets: Prisma.JsonValue | null
      helpfulTips: Prisma.JsonValue | null
      commonMistakes: Prisma.JsonValue | null
      successMetrics: Prisma.JsonValue | null
      requiredResources: Prisma.JsonValue | null
      lowBudgetAlternative: string | null
      diyApproach: string | null
      bcpTemplateText: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["strategyTranslation"]>
    composites: {}
  }

  type StrategyTranslationGetPayload<S extends boolean | null | undefined | StrategyTranslationDefaultArgs> = $Result.GetResult<Prisma.$StrategyTranslationPayload, S>

  type StrategyTranslationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StrategyTranslationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StrategyTranslationCountAggregateInputType | true
    }

  export interface StrategyTranslationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StrategyTranslation'], meta: { name: 'StrategyTranslation' } }
    /**
     * Find zero or one StrategyTranslation that matches the filter.
     * @param {StrategyTranslationFindUniqueArgs} args - Arguments to find a StrategyTranslation
     * @example
     * // Get one StrategyTranslation
     * const strategyTranslation = await prisma.strategyTranslation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StrategyTranslationFindUniqueArgs>(args: SelectSubset<T, StrategyTranslationFindUniqueArgs<ExtArgs>>): Prisma__StrategyTranslationClient<$Result.GetResult<Prisma.$StrategyTranslationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StrategyTranslation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StrategyTranslationFindUniqueOrThrowArgs} args - Arguments to find a StrategyTranslation
     * @example
     * // Get one StrategyTranslation
     * const strategyTranslation = await prisma.strategyTranslation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StrategyTranslationFindUniqueOrThrowArgs>(args: SelectSubset<T, StrategyTranslationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StrategyTranslationClient<$Result.GetResult<Prisma.$StrategyTranslationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StrategyTranslation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrategyTranslationFindFirstArgs} args - Arguments to find a StrategyTranslation
     * @example
     * // Get one StrategyTranslation
     * const strategyTranslation = await prisma.strategyTranslation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StrategyTranslationFindFirstArgs>(args?: SelectSubset<T, StrategyTranslationFindFirstArgs<ExtArgs>>): Prisma__StrategyTranslationClient<$Result.GetResult<Prisma.$StrategyTranslationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StrategyTranslation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrategyTranslationFindFirstOrThrowArgs} args - Arguments to find a StrategyTranslation
     * @example
     * // Get one StrategyTranslation
     * const strategyTranslation = await prisma.strategyTranslation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StrategyTranslationFindFirstOrThrowArgs>(args?: SelectSubset<T, StrategyTranslationFindFirstOrThrowArgs<ExtArgs>>): Prisma__StrategyTranslationClient<$Result.GetResult<Prisma.$StrategyTranslationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StrategyTranslations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrategyTranslationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StrategyTranslations
     * const strategyTranslations = await prisma.strategyTranslation.findMany()
     * 
     * // Get first 10 StrategyTranslations
     * const strategyTranslations = await prisma.strategyTranslation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const strategyTranslationWithIdOnly = await prisma.strategyTranslation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StrategyTranslationFindManyArgs>(args?: SelectSubset<T, StrategyTranslationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StrategyTranslationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StrategyTranslation.
     * @param {StrategyTranslationCreateArgs} args - Arguments to create a StrategyTranslation.
     * @example
     * // Create one StrategyTranslation
     * const StrategyTranslation = await prisma.strategyTranslation.create({
     *   data: {
     *     // ... data to create a StrategyTranslation
     *   }
     * })
     * 
     */
    create<T extends StrategyTranslationCreateArgs>(args: SelectSubset<T, StrategyTranslationCreateArgs<ExtArgs>>): Prisma__StrategyTranslationClient<$Result.GetResult<Prisma.$StrategyTranslationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StrategyTranslations.
     * @param {StrategyTranslationCreateManyArgs} args - Arguments to create many StrategyTranslations.
     * @example
     * // Create many StrategyTranslations
     * const strategyTranslation = await prisma.strategyTranslation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StrategyTranslationCreateManyArgs>(args?: SelectSubset<T, StrategyTranslationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StrategyTranslations and returns the data saved in the database.
     * @param {StrategyTranslationCreateManyAndReturnArgs} args - Arguments to create many StrategyTranslations.
     * @example
     * // Create many StrategyTranslations
     * const strategyTranslation = await prisma.strategyTranslation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StrategyTranslations and only return the `id`
     * const strategyTranslationWithIdOnly = await prisma.strategyTranslation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StrategyTranslationCreateManyAndReturnArgs>(args?: SelectSubset<T, StrategyTranslationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StrategyTranslationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StrategyTranslation.
     * @param {StrategyTranslationDeleteArgs} args - Arguments to delete one StrategyTranslation.
     * @example
     * // Delete one StrategyTranslation
     * const StrategyTranslation = await prisma.strategyTranslation.delete({
     *   where: {
     *     // ... filter to delete one StrategyTranslation
     *   }
     * })
     * 
     */
    delete<T extends StrategyTranslationDeleteArgs>(args: SelectSubset<T, StrategyTranslationDeleteArgs<ExtArgs>>): Prisma__StrategyTranslationClient<$Result.GetResult<Prisma.$StrategyTranslationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StrategyTranslation.
     * @param {StrategyTranslationUpdateArgs} args - Arguments to update one StrategyTranslation.
     * @example
     * // Update one StrategyTranslation
     * const strategyTranslation = await prisma.strategyTranslation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StrategyTranslationUpdateArgs>(args: SelectSubset<T, StrategyTranslationUpdateArgs<ExtArgs>>): Prisma__StrategyTranslationClient<$Result.GetResult<Prisma.$StrategyTranslationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StrategyTranslations.
     * @param {StrategyTranslationDeleteManyArgs} args - Arguments to filter StrategyTranslations to delete.
     * @example
     * // Delete a few StrategyTranslations
     * const { count } = await prisma.strategyTranslation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StrategyTranslationDeleteManyArgs>(args?: SelectSubset<T, StrategyTranslationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StrategyTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrategyTranslationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StrategyTranslations
     * const strategyTranslation = await prisma.strategyTranslation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StrategyTranslationUpdateManyArgs>(args: SelectSubset<T, StrategyTranslationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StrategyTranslation.
     * @param {StrategyTranslationUpsertArgs} args - Arguments to update or create a StrategyTranslation.
     * @example
     * // Update or create a StrategyTranslation
     * const strategyTranslation = await prisma.strategyTranslation.upsert({
     *   create: {
     *     // ... data to create a StrategyTranslation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StrategyTranslation we want to update
     *   }
     * })
     */
    upsert<T extends StrategyTranslationUpsertArgs>(args: SelectSubset<T, StrategyTranslationUpsertArgs<ExtArgs>>): Prisma__StrategyTranslationClient<$Result.GetResult<Prisma.$StrategyTranslationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StrategyTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrategyTranslationCountArgs} args - Arguments to filter StrategyTranslations to count.
     * @example
     * // Count the number of StrategyTranslations
     * const count = await prisma.strategyTranslation.count({
     *   where: {
     *     // ... the filter for the StrategyTranslations we want to count
     *   }
     * })
    **/
    count<T extends StrategyTranslationCountArgs>(
      args?: Subset<T, StrategyTranslationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StrategyTranslationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StrategyTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrategyTranslationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StrategyTranslationAggregateArgs>(args: Subset<T, StrategyTranslationAggregateArgs>): Prisma.PrismaPromise<GetStrategyTranslationAggregateType<T>>

    /**
     * Group by StrategyTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrategyTranslationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StrategyTranslationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StrategyTranslationGroupByArgs['orderBy'] }
        : { orderBy?: StrategyTranslationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StrategyTranslationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStrategyTranslationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StrategyTranslation model
   */
  readonly fields: StrategyTranslationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StrategyTranslation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StrategyTranslationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    strategy<T extends RiskMitigationStrategyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RiskMitigationStrategyDefaultArgs<ExtArgs>>): Prisma__RiskMitigationStrategyClient<$Result.GetResult<Prisma.$RiskMitigationStrategyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StrategyTranslation model
   */ 
  interface StrategyTranslationFieldRefs {
    readonly id: FieldRef<"StrategyTranslation", 'String'>
    readonly strategyId: FieldRef<"StrategyTranslation", 'String'>
    readonly locale: FieldRef<"StrategyTranslation", 'String'>
    readonly name: FieldRef<"StrategyTranslation", 'String'>
    readonly description: FieldRef<"StrategyTranslation", 'String'>
    readonly smeTitle: FieldRef<"StrategyTranslation", 'String'>
    readonly smeSummary: FieldRef<"StrategyTranslation", 'String'>
    readonly realWorldExample: FieldRef<"StrategyTranslation", 'String'>
    readonly whyImportant: FieldRef<"StrategyTranslation", 'String'>
    readonly whenToImplement: FieldRef<"StrategyTranslation", 'String'>
    readonly expectedOutcome: FieldRef<"StrategyTranslation", 'String'>
    readonly benefitsBullets: FieldRef<"StrategyTranslation", 'Json'>
    readonly helpfulTips: FieldRef<"StrategyTranslation", 'Json'>
    readonly commonMistakes: FieldRef<"StrategyTranslation", 'Json'>
    readonly successMetrics: FieldRef<"StrategyTranslation", 'Json'>
    readonly requiredResources: FieldRef<"StrategyTranslation", 'Json'>
    readonly lowBudgetAlternative: FieldRef<"StrategyTranslation", 'String'>
    readonly diyApproach: FieldRef<"StrategyTranslation", 'String'>
    readonly bcpTemplateText: FieldRef<"StrategyTranslation", 'String'>
    readonly createdAt: FieldRef<"StrategyTranslation", 'DateTime'>
    readonly updatedAt: FieldRef<"StrategyTranslation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StrategyTranslation findUnique
   */
  export type StrategyTranslationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrategyTranslation
     */
    select?: StrategyTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyTranslationInclude<ExtArgs> | null
    /**
     * Filter, which StrategyTranslation to fetch.
     */
    where: StrategyTranslationWhereUniqueInput
  }

  /**
   * StrategyTranslation findUniqueOrThrow
   */
  export type StrategyTranslationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrategyTranslation
     */
    select?: StrategyTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyTranslationInclude<ExtArgs> | null
    /**
     * Filter, which StrategyTranslation to fetch.
     */
    where: StrategyTranslationWhereUniqueInput
  }

  /**
   * StrategyTranslation findFirst
   */
  export type StrategyTranslationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrategyTranslation
     */
    select?: StrategyTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyTranslationInclude<ExtArgs> | null
    /**
     * Filter, which StrategyTranslation to fetch.
     */
    where?: StrategyTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StrategyTranslations to fetch.
     */
    orderBy?: StrategyTranslationOrderByWithRelationInput | StrategyTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StrategyTranslations.
     */
    cursor?: StrategyTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StrategyTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StrategyTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StrategyTranslations.
     */
    distinct?: StrategyTranslationScalarFieldEnum | StrategyTranslationScalarFieldEnum[]
  }

  /**
   * StrategyTranslation findFirstOrThrow
   */
  export type StrategyTranslationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrategyTranslation
     */
    select?: StrategyTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyTranslationInclude<ExtArgs> | null
    /**
     * Filter, which StrategyTranslation to fetch.
     */
    where?: StrategyTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StrategyTranslations to fetch.
     */
    orderBy?: StrategyTranslationOrderByWithRelationInput | StrategyTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StrategyTranslations.
     */
    cursor?: StrategyTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StrategyTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StrategyTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StrategyTranslations.
     */
    distinct?: StrategyTranslationScalarFieldEnum | StrategyTranslationScalarFieldEnum[]
  }

  /**
   * StrategyTranslation findMany
   */
  export type StrategyTranslationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrategyTranslation
     */
    select?: StrategyTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyTranslationInclude<ExtArgs> | null
    /**
     * Filter, which StrategyTranslations to fetch.
     */
    where?: StrategyTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StrategyTranslations to fetch.
     */
    orderBy?: StrategyTranslationOrderByWithRelationInput | StrategyTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StrategyTranslations.
     */
    cursor?: StrategyTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StrategyTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StrategyTranslations.
     */
    skip?: number
    distinct?: StrategyTranslationScalarFieldEnum | StrategyTranslationScalarFieldEnum[]
  }

  /**
   * StrategyTranslation create
   */
  export type StrategyTranslationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrategyTranslation
     */
    select?: StrategyTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyTranslationInclude<ExtArgs> | null
    /**
     * The data needed to create a StrategyTranslation.
     */
    data: XOR<StrategyTranslationCreateInput, StrategyTranslationUncheckedCreateInput>
  }

  /**
   * StrategyTranslation createMany
   */
  export type StrategyTranslationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StrategyTranslations.
     */
    data: StrategyTranslationCreateManyInput | StrategyTranslationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StrategyTranslation createManyAndReturn
   */
  export type StrategyTranslationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrategyTranslation
     */
    select?: StrategyTranslationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StrategyTranslations.
     */
    data: StrategyTranslationCreateManyInput | StrategyTranslationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyTranslationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StrategyTranslation update
   */
  export type StrategyTranslationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrategyTranslation
     */
    select?: StrategyTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyTranslationInclude<ExtArgs> | null
    /**
     * The data needed to update a StrategyTranslation.
     */
    data: XOR<StrategyTranslationUpdateInput, StrategyTranslationUncheckedUpdateInput>
    /**
     * Choose, which StrategyTranslation to update.
     */
    where: StrategyTranslationWhereUniqueInput
  }

  /**
   * StrategyTranslation updateMany
   */
  export type StrategyTranslationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StrategyTranslations.
     */
    data: XOR<StrategyTranslationUpdateManyMutationInput, StrategyTranslationUncheckedUpdateManyInput>
    /**
     * Filter which StrategyTranslations to update
     */
    where?: StrategyTranslationWhereInput
  }

  /**
   * StrategyTranslation upsert
   */
  export type StrategyTranslationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrategyTranslation
     */
    select?: StrategyTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyTranslationInclude<ExtArgs> | null
    /**
     * The filter to search for the StrategyTranslation to update in case it exists.
     */
    where: StrategyTranslationWhereUniqueInput
    /**
     * In case the StrategyTranslation found by the `where` argument doesn't exist, create a new StrategyTranslation with this data.
     */
    create: XOR<StrategyTranslationCreateInput, StrategyTranslationUncheckedCreateInput>
    /**
     * In case the StrategyTranslation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StrategyTranslationUpdateInput, StrategyTranslationUncheckedUpdateInput>
  }

  /**
   * StrategyTranslation delete
   */
  export type StrategyTranslationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrategyTranslation
     */
    select?: StrategyTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyTranslationInclude<ExtArgs> | null
    /**
     * Filter which StrategyTranslation to delete.
     */
    where: StrategyTranslationWhereUniqueInput
  }

  /**
   * StrategyTranslation deleteMany
   */
  export type StrategyTranslationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StrategyTranslations to delete
     */
    where?: StrategyTranslationWhereInput
  }

  /**
   * StrategyTranslation without action
   */
  export type StrategyTranslationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrategyTranslation
     */
    select?: StrategyTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyTranslationInclude<ExtArgs> | null
  }


  /**
   * Model ActionStepTranslation
   */

  export type AggregateActionStepTranslation = {
    _count: ActionStepTranslationCountAggregateOutputType | null
    _min: ActionStepTranslationMinAggregateOutputType | null
    _max: ActionStepTranslationMaxAggregateOutputType | null
  }

  export type ActionStepTranslationMinAggregateOutputType = {
    id: string | null
    actionStepId: string | null
    locale: string | null
    title: string | null
    description: string | null
    smeAction: string | null
    timeframe: string | null
    whyThisStepMatters: string | null
    howToKnowItsDone: string | null
    whatHappensIfSkipped: string | null
    exampleOutput: string | null
    freeAlternative: string | null
    lowTechOption: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ActionStepTranslationMaxAggregateOutputType = {
    id: string | null
    actionStepId: string | null
    locale: string | null
    title: string | null
    description: string | null
    smeAction: string | null
    timeframe: string | null
    whyThisStepMatters: string | null
    howToKnowItsDone: string | null
    whatHappensIfSkipped: string | null
    exampleOutput: string | null
    freeAlternative: string | null
    lowTechOption: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ActionStepTranslationCountAggregateOutputType = {
    id: number
    actionStepId: number
    locale: number
    title: number
    description: number
    smeAction: number
    timeframe: number
    whyThisStepMatters: number
    howToKnowItsDone: number
    whatHappensIfSkipped: number
    exampleOutput: number
    freeAlternative: number
    lowTechOption: number
    commonMistakesForStep: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ActionStepTranslationMinAggregateInputType = {
    id?: true
    actionStepId?: true
    locale?: true
    title?: true
    description?: true
    smeAction?: true
    timeframe?: true
    whyThisStepMatters?: true
    howToKnowItsDone?: true
    whatHappensIfSkipped?: true
    exampleOutput?: true
    freeAlternative?: true
    lowTechOption?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ActionStepTranslationMaxAggregateInputType = {
    id?: true
    actionStepId?: true
    locale?: true
    title?: true
    description?: true
    smeAction?: true
    timeframe?: true
    whyThisStepMatters?: true
    howToKnowItsDone?: true
    whatHappensIfSkipped?: true
    exampleOutput?: true
    freeAlternative?: true
    lowTechOption?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ActionStepTranslationCountAggregateInputType = {
    id?: true
    actionStepId?: true
    locale?: true
    title?: true
    description?: true
    smeAction?: true
    timeframe?: true
    whyThisStepMatters?: true
    howToKnowItsDone?: true
    whatHappensIfSkipped?: true
    exampleOutput?: true
    freeAlternative?: true
    lowTechOption?: true
    commonMistakesForStep?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ActionStepTranslationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActionStepTranslation to aggregate.
     */
    where?: ActionStepTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActionStepTranslations to fetch.
     */
    orderBy?: ActionStepTranslationOrderByWithRelationInput | ActionStepTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActionStepTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActionStepTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActionStepTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActionStepTranslations
    **/
    _count?: true | ActionStepTranslationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActionStepTranslationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActionStepTranslationMaxAggregateInputType
  }

  export type GetActionStepTranslationAggregateType<T extends ActionStepTranslationAggregateArgs> = {
        [P in keyof T & keyof AggregateActionStepTranslation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActionStepTranslation[P]>
      : GetScalarType<T[P], AggregateActionStepTranslation[P]>
  }




  export type ActionStepTranslationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActionStepTranslationWhereInput
    orderBy?: ActionStepTranslationOrderByWithAggregationInput | ActionStepTranslationOrderByWithAggregationInput[]
    by: ActionStepTranslationScalarFieldEnum[] | ActionStepTranslationScalarFieldEnum
    having?: ActionStepTranslationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActionStepTranslationCountAggregateInputType | true
    _min?: ActionStepTranslationMinAggregateInputType
    _max?: ActionStepTranslationMaxAggregateInputType
  }

  export type ActionStepTranslationGroupByOutputType = {
    id: string
    actionStepId: string
    locale: string
    title: string
    description: string | null
    smeAction: string | null
    timeframe: string | null
    whyThisStepMatters: string | null
    howToKnowItsDone: string | null
    whatHappensIfSkipped: string | null
    exampleOutput: string | null
    freeAlternative: string | null
    lowTechOption: string | null
    commonMistakesForStep: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: ActionStepTranslationCountAggregateOutputType | null
    _min: ActionStepTranslationMinAggregateOutputType | null
    _max: ActionStepTranslationMaxAggregateOutputType | null
  }

  type GetActionStepTranslationGroupByPayload<T extends ActionStepTranslationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActionStepTranslationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActionStepTranslationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActionStepTranslationGroupByOutputType[P]>
            : GetScalarType<T[P], ActionStepTranslationGroupByOutputType[P]>
        }
      >
    >


  export type ActionStepTranslationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actionStepId?: boolean
    locale?: boolean
    title?: boolean
    description?: boolean
    smeAction?: boolean
    timeframe?: boolean
    whyThisStepMatters?: boolean
    howToKnowItsDone?: boolean
    whatHappensIfSkipped?: boolean
    exampleOutput?: boolean
    freeAlternative?: boolean
    lowTechOption?: boolean
    commonMistakesForStep?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    actionStep?: boolean | ActionStepDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["actionStepTranslation"]>

  export type ActionStepTranslationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actionStepId?: boolean
    locale?: boolean
    title?: boolean
    description?: boolean
    smeAction?: boolean
    timeframe?: boolean
    whyThisStepMatters?: boolean
    howToKnowItsDone?: boolean
    whatHappensIfSkipped?: boolean
    exampleOutput?: boolean
    freeAlternative?: boolean
    lowTechOption?: boolean
    commonMistakesForStep?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    actionStep?: boolean | ActionStepDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["actionStepTranslation"]>

  export type ActionStepTranslationSelectScalar = {
    id?: boolean
    actionStepId?: boolean
    locale?: boolean
    title?: boolean
    description?: boolean
    smeAction?: boolean
    timeframe?: boolean
    whyThisStepMatters?: boolean
    howToKnowItsDone?: boolean
    whatHappensIfSkipped?: boolean
    exampleOutput?: boolean
    freeAlternative?: boolean
    lowTechOption?: boolean
    commonMistakesForStep?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ActionStepTranslationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actionStep?: boolean | ActionStepDefaultArgs<ExtArgs>
  }
  export type ActionStepTranslationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actionStep?: boolean | ActionStepDefaultArgs<ExtArgs>
  }

  export type $ActionStepTranslationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActionStepTranslation"
    objects: {
      actionStep: Prisma.$ActionStepPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      actionStepId: string
      locale: string
      title: string
      description: string | null
      smeAction: string | null
      timeframe: string | null
      whyThisStepMatters: string | null
      howToKnowItsDone: string | null
      whatHappensIfSkipped: string | null
      exampleOutput: string | null
      freeAlternative: string | null
      lowTechOption: string | null
      commonMistakesForStep: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["actionStepTranslation"]>
    composites: {}
  }

  type ActionStepTranslationGetPayload<S extends boolean | null | undefined | ActionStepTranslationDefaultArgs> = $Result.GetResult<Prisma.$ActionStepTranslationPayload, S>

  type ActionStepTranslationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ActionStepTranslationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ActionStepTranslationCountAggregateInputType | true
    }

  export interface ActionStepTranslationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActionStepTranslation'], meta: { name: 'ActionStepTranslation' } }
    /**
     * Find zero or one ActionStepTranslation that matches the filter.
     * @param {ActionStepTranslationFindUniqueArgs} args - Arguments to find a ActionStepTranslation
     * @example
     * // Get one ActionStepTranslation
     * const actionStepTranslation = await prisma.actionStepTranslation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActionStepTranslationFindUniqueArgs>(args: SelectSubset<T, ActionStepTranslationFindUniqueArgs<ExtArgs>>): Prisma__ActionStepTranslationClient<$Result.GetResult<Prisma.$ActionStepTranslationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ActionStepTranslation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ActionStepTranslationFindUniqueOrThrowArgs} args - Arguments to find a ActionStepTranslation
     * @example
     * // Get one ActionStepTranslation
     * const actionStepTranslation = await prisma.actionStepTranslation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActionStepTranslationFindUniqueOrThrowArgs>(args: SelectSubset<T, ActionStepTranslationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActionStepTranslationClient<$Result.GetResult<Prisma.$ActionStepTranslationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ActionStepTranslation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionStepTranslationFindFirstArgs} args - Arguments to find a ActionStepTranslation
     * @example
     * // Get one ActionStepTranslation
     * const actionStepTranslation = await prisma.actionStepTranslation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActionStepTranslationFindFirstArgs>(args?: SelectSubset<T, ActionStepTranslationFindFirstArgs<ExtArgs>>): Prisma__ActionStepTranslationClient<$Result.GetResult<Prisma.$ActionStepTranslationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ActionStepTranslation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionStepTranslationFindFirstOrThrowArgs} args - Arguments to find a ActionStepTranslation
     * @example
     * // Get one ActionStepTranslation
     * const actionStepTranslation = await prisma.actionStepTranslation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActionStepTranslationFindFirstOrThrowArgs>(args?: SelectSubset<T, ActionStepTranslationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActionStepTranslationClient<$Result.GetResult<Prisma.$ActionStepTranslationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ActionStepTranslations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionStepTranslationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActionStepTranslations
     * const actionStepTranslations = await prisma.actionStepTranslation.findMany()
     * 
     * // Get first 10 ActionStepTranslations
     * const actionStepTranslations = await prisma.actionStepTranslation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const actionStepTranslationWithIdOnly = await prisma.actionStepTranslation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActionStepTranslationFindManyArgs>(args?: SelectSubset<T, ActionStepTranslationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionStepTranslationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ActionStepTranslation.
     * @param {ActionStepTranslationCreateArgs} args - Arguments to create a ActionStepTranslation.
     * @example
     * // Create one ActionStepTranslation
     * const ActionStepTranslation = await prisma.actionStepTranslation.create({
     *   data: {
     *     // ... data to create a ActionStepTranslation
     *   }
     * })
     * 
     */
    create<T extends ActionStepTranslationCreateArgs>(args: SelectSubset<T, ActionStepTranslationCreateArgs<ExtArgs>>): Prisma__ActionStepTranslationClient<$Result.GetResult<Prisma.$ActionStepTranslationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ActionStepTranslations.
     * @param {ActionStepTranslationCreateManyArgs} args - Arguments to create many ActionStepTranslations.
     * @example
     * // Create many ActionStepTranslations
     * const actionStepTranslation = await prisma.actionStepTranslation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActionStepTranslationCreateManyArgs>(args?: SelectSubset<T, ActionStepTranslationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ActionStepTranslations and returns the data saved in the database.
     * @param {ActionStepTranslationCreateManyAndReturnArgs} args - Arguments to create many ActionStepTranslations.
     * @example
     * // Create many ActionStepTranslations
     * const actionStepTranslation = await prisma.actionStepTranslation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ActionStepTranslations and only return the `id`
     * const actionStepTranslationWithIdOnly = await prisma.actionStepTranslation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActionStepTranslationCreateManyAndReturnArgs>(args?: SelectSubset<T, ActionStepTranslationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionStepTranslationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ActionStepTranslation.
     * @param {ActionStepTranslationDeleteArgs} args - Arguments to delete one ActionStepTranslation.
     * @example
     * // Delete one ActionStepTranslation
     * const ActionStepTranslation = await prisma.actionStepTranslation.delete({
     *   where: {
     *     // ... filter to delete one ActionStepTranslation
     *   }
     * })
     * 
     */
    delete<T extends ActionStepTranslationDeleteArgs>(args: SelectSubset<T, ActionStepTranslationDeleteArgs<ExtArgs>>): Prisma__ActionStepTranslationClient<$Result.GetResult<Prisma.$ActionStepTranslationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ActionStepTranslation.
     * @param {ActionStepTranslationUpdateArgs} args - Arguments to update one ActionStepTranslation.
     * @example
     * // Update one ActionStepTranslation
     * const actionStepTranslation = await prisma.actionStepTranslation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActionStepTranslationUpdateArgs>(args: SelectSubset<T, ActionStepTranslationUpdateArgs<ExtArgs>>): Prisma__ActionStepTranslationClient<$Result.GetResult<Prisma.$ActionStepTranslationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ActionStepTranslations.
     * @param {ActionStepTranslationDeleteManyArgs} args - Arguments to filter ActionStepTranslations to delete.
     * @example
     * // Delete a few ActionStepTranslations
     * const { count } = await prisma.actionStepTranslation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActionStepTranslationDeleteManyArgs>(args?: SelectSubset<T, ActionStepTranslationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActionStepTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionStepTranslationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActionStepTranslations
     * const actionStepTranslation = await prisma.actionStepTranslation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActionStepTranslationUpdateManyArgs>(args: SelectSubset<T, ActionStepTranslationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ActionStepTranslation.
     * @param {ActionStepTranslationUpsertArgs} args - Arguments to update or create a ActionStepTranslation.
     * @example
     * // Update or create a ActionStepTranslation
     * const actionStepTranslation = await prisma.actionStepTranslation.upsert({
     *   create: {
     *     // ... data to create a ActionStepTranslation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActionStepTranslation we want to update
     *   }
     * })
     */
    upsert<T extends ActionStepTranslationUpsertArgs>(args: SelectSubset<T, ActionStepTranslationUpsertArgs<ExtArgs>>): Prisma__ActionStepTranslationClient<$Result.GetResult<Prisma.$ActionStepTranslationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ActionStepTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionStepTranslationCountArgs} args - Arguments to filter ActionStepTranslations to count.
     * @example
     * // Count the number of ActionStepTranslations
     * const count = await prisma.actionStepTranslation.count({
     *   where: {
     *     // ... the filter for the ActionStepTranslations we want to count
     *   }
     * })
    **/
    count<T extends ActionStepTranslationCountArgs>(
      args?: Subset<T, ActionStepTranslationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActionStepTranslationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActionStepTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionStepTranslationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActionStepTranslationAggregateArgs>(args: Subset<T, ActionStepTranslationAggregateArgs>): Prisma.PrismaPromise<GetActionStepTranslationAggregateType<T>>

    /**
     * Group by ActionStepTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionStepTranslationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActionStepTranslationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActionStepTranslationGroupByArgs['orderBy'] }
        : { orderBy?: ActionStepTranslationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActionStepTranslationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActionStepTranslationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActionStepTranslation model
   */
  readonly fields: ActionStepTranslationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActionStepTranslation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActionStepTranslationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    actionStep<T extends ActionStepDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ActionStepDefaultArgs<ExtArgs>>): Prisma__ActionStepClient<$Result.GetResult<Prisma.$ActionStepPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActionStepTranslation model
   */ 
  interface ActionStepTranslationFieldRefs {
    readonly id: FieldRef<"ActionStepTranslation", 'String'>
    readonly actionStepId: FieldRef<"ActionStepTranslation", 'String'>
    readonly locale: FieldRef<"ActionStepTranslation", 'String'>
    readonly title: FieldRef<"ActionStepTranslation", 'String'>
    readonly description: FieldRef<"ActionStepTranslation", 'String'>
    readonly smeAction: FieldRef<"ActionStepTranslation", 'String'>
    readonly timeframe: FieldRef<"ActionStepTranslation", 'String'>
    readonly whyThisStepMatters: FieldRef<"ActionStepTranslation", 'String'>
    readonly howToKnowItsDone: FieldRef<"ActionStepTranslation", 'String'>
    readonly whatHappensIfSkipped: FieldRef<"ActionStepTranslation", 'String'>
    readonly exampleOutput: FieldRef<"ActionStepTranslation", 'String'>
    readonly freeAlternative: FieldRef<"ActionStepTranslation", 'String'>
    readonly lowTechOption: FieldRef<"ActionStepTranslation", 'String'>
    readonly commonMistakesForStep: FieldRef<"ActionStepTranslation", 'Json'>
    readonly createdAt: FieldRef<"ActionStepTranslation", 'DateTime'>
    readonly updatedAt: FieldRef<"ActionStepTranslation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ActionStepTranslation findUnique
   */
  export type ActionStepTranslationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionStepTranslation
     */
    select?: ActionStepTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionStepTranslationInclude<ExtArgs> | null
    /**
     * Filter, which ActionStepTranslation to fetch.
     */
    where: ActionStepTranslationWhereUniqueInput
  }

  /**
   * ActionStepTranslation findUniqueOrThrow
   */
  export type ActionStepTranslationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionStepTranslation
     */
    select?: ActionStepTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionStepTranslationInclude<ExtArgs> | null
    /**
     * Filter, which ActionStepTranslation to fetch.
     */
    where: ActionStepTranslationWhereUniqueInput
  }

  /**
   * ActionStepTranslation findFirst
   */
  export type ActionStepTranslationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionStepTranslation
     */
    select?: ActionStepTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionStepTranslationInclude<ExtArgs> | null
    /**
     * Filter, which ActionStepTranslation to fetch.
     */
    where?: ActionStepTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActionStepTranslations to fetch.
     */
    orderBy?: ActionStepTranslationOrderByWithRelationInput | ActionStepTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActionStepTranslations.
     */
    cursor?: ActionStepTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActionStepTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActionStepTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActionStepTranslations.
     */
    distinct?: ActionStepTranslationScalarFieldEnum | ActionStepTranslationScalarFieldEnum[]
  }

  /**
   * ActionStepTranslation findFirstOrThrow
   */
  export type ActionStepTranslationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionStepTranslation
     */
    select?: ActionStepTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionStepTranslationInclude<ExtArgs> | null
    /**
     * Filter, which ActionStepTranslation to fetch.
     */
    where?: ActionStepTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActionStepTranslations to fetch.
     */
    orderBy?: ActionStepTranslationOrderByWithRelationInput | ActionStepTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActionStepTranslations.
     */
    cursor?: ActionStepTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActionStepTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActionStepTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActionStepTranslations.
     */
    distinct?: ActionStepTranslationScalarFieldEnum | ActionStepTranslationScalarFieldEnum[]
  }

  /**
   * ActionStepTranslation findMany
   */
  export type ActionStepTranslationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionStepTranslation
     */
    select?: ActionStepTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionStepTranslationInclude<ExtArgs> | null
    /**
     * Filter, which ActionStepTranslations to fetch.
     */
    where?: ActionStepTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActionStepTranslations to fetch.
     */
    orderBy?: ActionStepTranslationOrderByWithRelationInput | ActionStepTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActionStepTranslations.
     */
    cursor?: ActionStepTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActionStepTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActionStepTranslations.
     */
    skip?: number
    distinct?: ActionStepTranslationScalarFieldEnum | ActionStepTranslationScalarFieldEnum[]
  }

  /**
   * ActionStepTranslation create
   */
  export type ActionStepTranslationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionStepTranslation
     */
    select?: ActionStepTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionStepTranslationInclude<ExtArgs> | null
    /**
     * The data needed to create a ActionStepTranslation.
     */
    data: XOR<ActionStepTranslationCreateInput, ActionStepTranslationUncheckedCreateInput>
  }

  /**
   * ActionStepTranslation createMany
   */
  export type ActionStepTranslationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActionStepTranslations.
     */
    data: ActionStepTranslationCreateManyInput | ActionStepTranslationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActionStepTranslation createManyAndReturn
   */
  export type ActionStepTranslationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionStepTranslation
     */
    select?: ActionStepTranslationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ActionStepTranslations.
     */
    data: ActionStepTranslationCreateManyInput | ActionStepTranslationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionStepTranslationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActionStepTranslation update
   */
  export type ActionStepTranslationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionStepTranslation
     */
    select?: ActionStepTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionStepTranslationInclude<ExtArgs> | null
    /**
     * The data needed to update a ActionStepTranslation.
     */
    data: XOR<ActionStepTranslationUpdateInput, ActionStepTranslationUncheckedUpdateInput>
    /**
     * Choose, which ActionStepTranslation to update.
     */
    where: ActionStepTranslationWhereUniqueInput
  }

  /**
   * ActionStepTranslation updateMany
   */
  export type ActionStepTranslationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActionStepTranslations.
     */
    data: XOR<ActionStepTranslationUpdateManyMutationInput, ActionStepTranslationUncheckedUpdateManyInput>
    /**
     * Filter which ActionStepTranslations to update
     */
    where?: ActionStepTranslationWhereInput
  }

  /**
   * ActionStepTranslation upsert
   */
  export type ActionStepTranslationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionStepTranslation
     */
    select?: ActionStepTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionStepTranslationInclude<ExtArgs> | null
    /**
     * The filter to search for the ActionStepTranslation to update in case it exists.
     */
    where: ActionStepTranslationWhereUniqueInput
    /**
     * In case the ActionStepTranslation found by the `where` argument doesn't exist, create a new ActionStepTranslation with this data.
     */
    create: XOR<ActionStepTranslationCreateInput, ActionStepTranslationUncheckedCreateInput>
    /**
     * In case the ActionStepTranslation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActionStepTranslationUpdateInput, ActionStepTranslationUncheckedUpdateInput>
  }

  /**
   * ActionStepTranslation delete
   */
  export type ActionStepTranslationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionStepTranslation
     */
    select?: ActionStepTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionStepTranslationInclude<ExtArgs> | null
    /**
     * Filter which ActionStepTranslation to delete.
     */
    where: ActionStepTranslationWhereUniqueInput
  }

  /**
   * ActionStepTranslation deleteMany
   */
  export type ActionStepTranslationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActionStepTranslations to delete
     */
    where?: ActionStepTranslationWhereInput
  }

  /**
   * ActionStepTranslation without action
   */
  export type ActionStepTranslationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionStepTranslation
     */
    select?: ActionStepTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionStepTranslationInclude<ExtArgs> | null
  }


  /**
   * Model HazardTranslation
   */

  export type AggregateHazardTranslation = {
    _count: HazardTranslationCountAggregateOutputType | null
    _min: HazardTranslationMinAggregateOutputType | null
    _max: HazardTranslationMaxAggregateOutputType | null
  }

  export type HazardTranslationMinAggregateOutputType = {
    id: string | null
    hazardId: string | null
    locale: string | null
    name: string | null
    description: string | null
    impact: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HazardTranslationMaxAggregateOutputType = {
    id: string | null
    hazardId: string | null
    locale: string | null
    name: string | null
    description: string | null
    impact: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HazardTranslationCountAggregateOutputType = {
    id: number
    hazardId: number
    locale: number
    name: number
    description: number
    impact: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HazardTranslationMinAggregateInputType = {
    id?: true
    hazardId?: true
    locale?: true
    name?: true
    description?: true
    impact?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HazardTranslationMaxAggregateInputType = {
    id?: true
    hazardId?: true
    locale?: true
    name?: true
    description?: true
    impact?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HazardTranslationCountAggregateInputType = {
    id?: true
    hazardId?: true
    locale?: true
    name?: true
    description?: true
    impact?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HazardTranslationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HazardTranslation to aggregate.
     */
    where?: HazardTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HazardTranslations to fetch.
     */
    orderBy?: HazardTranslationOrderByWithRelationInput | HazardTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HazardTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HazardTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HazardTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HazardTranslations
    **/
    _count?: true | HazardTranslationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HazardTranslationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HazardTranslationMaxAggregateInputType
  }

  export type GetHazardTranslationAggregateType<T extends HazardTranslationAggregateArgs> = {
        [P in keyof T & keyof AggregateHazardTranslation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHazardTranslation[P]>
      : GetScalarType<T[P], AggregateHazardTranslation[P]>
  }




  export type HazardTranslationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HazardTranslationWhereInput
    orderBy?: HazardTranslationOrderByWithAggregationInput | HazardTranslationOrderByWithAggregationInput[]
    by: HazardTranslationScalarFieldEnum[] | HazardTranslationScalarFieldEnum
    having?: HazardTranslationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HazardTranslationCountAggregateInputType | true
    _min?: HazardTranslationMinAggregateInputType
    _max?: HazardTranslationMaxAggregateInputType
  }

  export type HazardTranslationGroupByOutputType = {
    id: string
    hazardId: string
    locale: string
    name: string
    description: string | null
    impact: string | null
    createdAt: Date
    updatedAt: Date
    _count: HazardTranslationCountAggregateOutputType | null
    _min: HazardTranslationMinAggregateOutputType | null
    _max: HazardTranslationMaxAggregateOutputType | null
  }

  type GetHazardTranslationGroupByPayload<T extends HazardTranslationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HazardTranslationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HazardTranslationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HazardTranslationGroupByOutputType[P]>
            : GetScalarType<T[P], HazardTranslationGroupByOutputType[P]>
        }
      >
    >


  export type HazardTranslationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hazardId?: boolean
    locale?: boolean
    name?: boolean
    description?: boolean
    impact?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hazard?: boolean | AdminHazardTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hazardTranslation"]>

  export type HazardTranslationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hazardId?: boolean
    locale?: boolean
    name?: boolean
    description?: boolean
    impact?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hazard?: boolean | AdminHazardTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hazardTranslation"]>

  export type HazardTranslationSelectScalar = {
    id?: boolean
    hazardId?: boolean
    locale?: boolean
    name?: boolean
    description?: boolean
    impact?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HazardTranslationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hazard?: boolean | AdminHazardTypeDefaultArgs<ExtArgs>
  }
  export type HazardTranslationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hazard?: boolean | AdminHazardTypeDefaultArgs<ExtArgs>
  }

  export type $HazardTranslationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HazardTranslation"
    objects: {
      hazard: Prisma.$AdminHazardTypePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      hazardId: string
      locale: string
      name: string
      description: string | null
      impact: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["hazardTranslation"]>
    composites: {}
  }

  type HazardTranslationGetPayload<S extends boolean | null | undefined | HazardTranslationDefaultArgs> = $Result.GetResult<Prisma.$HazardTranslationPayload, S>

  type HazardTranslationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HazardTranslationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HazardTranslationCountAggregateInputType | true
    }

  export interface HazardTranslationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HazardTranslation'], meta: { name: 'HazardTranslation' } }
    /**
     * Find zero or one HazardTranslation that matches the filter.
     * @param {HazardTranslationFindUniqueArgs} args - Arguments to find a HazardTranslation
     * @example
     * // Get one HazardTranslation
     * const hazardTranslation = await prisma.hazardTranslation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HazardTranslationFindUniqueArgs>(args: SelectSubset<T, HazardTranslationFindUniqueArgs<ExtArgs>>): Prisma__HazardTranslationClient<$Result.GetResult<Prisma.$HazardTranslationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one HazardTranslation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HazardTranslationFindUniqueOrThrowArgs} args - Arguments to find a HazardTranslation
     * @example
     * // Get one HazardTranslation
     * const hazardTranslation = await prisma.hazardTranslation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HazardTranslationFindUniqueOrThrowArgs>(args: SelectSubset<T, HazardTranslationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HazardTranslationClient<$Result.GetResult<Prisma.$HazardTranslationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first HazardTranslation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HazardTranslationFindFirstArgs} args - Arguments to find a HazardTranslation
     * @example
     * // Get one HazardTranslation
     * const hazardTranslation = await prisma.hazardTranslation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HazardTranslationFindFirstArgs>(args?: SelectSubset<T, HazardTranslationFindFirstArgs<ExtArgs>>): Prisma__HazardTranslationClient<$Result.GetResult<Prisma.$HazardTranslationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first HazardTranslation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HazardTranslationFindFirstOrThrowArgs} args - Arguments to find a HazardTranslation
     * @example
     * // Get one HazardTranslation
     * const hazardTranslation = await prisma.hazardTranslation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HazardTranslationFindFirstOrThrowArgs>(args?: SelectSubset<T, HazardTranslationFindFirstOrThrowArgs<ExtArgs>>): Prisma__HazardTranslationClient<$Result.GetResult<Prisma.$HazardTranslationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more HazardTranslations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HazardTranslationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HazardTranslations
     * const hazardTranslations = await prisma.hazardTranslation.findMany()
     * 
     * // Get first 10 HazardTranslations
     * const hazardTranslations = await prisma.hazardTranslation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hazardTranslationWithIdOnly = await prisma.hazardTranslation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HazardTranslationFindManyArgs>(args?: SelectSubset<T, HazardTranslationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HazardTranslationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a HazardTranslation.
     * @param {HazardTranslationCreateArgs} args - Arguments to create a HazardTranslation.
     * @example
     * // Create one HazardTranslation
     * const HazardTranslation = await prisma.hazardTranslation.create({
     *   data: {
     *     // ... data to create a HazardTranslation
     *   }
     * })
     * 
     */
    create<T extends HazardTranslationCreateArgs>(args: SelectSubset<T, HazardTranslationCreateArgs<ExtArgs>>): Prisma__HazardTranslationClient<$Result.GetResult<Prisma.$HazardTranslationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many HazardTranslations.
     * @param {HazardTranslationCreateManyArgs} args - Arguments to create many HazardTranslations.
     * @example
     * // Create many HazardTranslations
     * const hazardTranslation = await prisma.hazardTranslation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HazardTranslationCreateManyArgs>(args?: SelectSubset<T, HazardTranslationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HazardTranslations and returns the data saved in the database.
     * @param {HazardTranslationCreateManyAndReturnArgs} args - Arguments to create many HazardTranslations.
     * @example
     * // Create many HazardTranslations
     * const hazardTranslation = await prisma.hazardTranslation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HazardTranslations and only return the `id`
     * const hazardTranslationWithIdOnly = await prisma.hazardTranslation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HazardTranslationCreateManyAndReturnArgs>(args?: SelectSubset<T, HazardTranslationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HazardTranslationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a HazardTranslation.
     * @param {HazardTranslationDeleteArgs} args - Arguments to delete one HazardTranslation.
     * @example
     * // Delete one HazardTranslation
     * const HazardTranslation = await prisma.hazardTranslation.delete({
     *   where: {
     *     // ... filter to delete one HazardTranslation
     *   }
     * })
     * 
     */
    delete<T extends HazardTranslationDeleteArgs>(args: SelectSubset<T, HazardTranslationDeleteArgs<ExtArgs>>): Prisma__HazardTranslationClient<$Result.GetResult<Prisma.$HazardTranslationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one HazardTranslation.
     * @param {HazardTranslationUpdateArgs} args - Arguments to update one HazardTranslation.
     * @example
     * // Update one HazardTranslation
     * const hazardTranslation = await prisma.hazardTranslation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HazardTranslationUpdateArgs>(args: SelectSubset<T, HazardTranslationUpdateArgs<ExtArgs>>): Prisma__HazardTranslationClient<$Result.GetResult<Prisma.$HazardTranslationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more HazardTranslations.
     * @param {HazardTranslationDeleteManyArgs} args - Arguments to filter HazardTranslations to delete.
     * @example
     * // Delete a few HazardTranslations
     * const { count } = await prisma.hazardTranslation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HazardTranslationDeleteManyArgs>(args?: SelectSubset<T, HazardTranslationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HazardTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HazardTranslationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HazardTranslations
     * const hazardTranslation = await prisma.hazardTranslation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HazardTranslationUpdateManyArgs>(args: SelectSubset<T, HazardTranslationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HazardTranslation.
     * @param {HazardTranslationUpsertArgs} args - Arguments to update or create a HazardTranslation.
     * @example
     * // Update or create a HazardTranslation
     * const hazardTranslation = await prisma.hazardTranslation.upsert({
     *   create: {
     *     // ... data to create a HazardTranslation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HazardTranslation we want to update
     *   }
     * })
     */
    upsert<T extends HazardTranslationUpsertArgs>(args: SelectSubset<T, HazardTranslationUpsertArgs<ExtArgs>>): Prisma__HazardTranslationClient<$Result.GetResult<Prisma.$HazardTranslationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of HazardTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HazardTranslationCountArgs} args - Arguments to filter HazardTranslations to count.
     * @example
     * // Count the number of HazardTranslations
     * const count = await prisma.hazardTranslation.count({
     *   where: {
     *     // ... the filter for the HazardTranslations we want to count
     *   }
     * })
    **/
    count<T extends HazardTranslationCountArgs>(
      args?: Subset<T, HazardTranslationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HazardTranslationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HazardTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HazardTranslationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HazardTranslationAggregateArgs>(args: Subset<T, HazardTranslationAggregateArgs>): Prisma.PrismaPromise<GetHazardTranslationAggregateType<T>>

    /**
     * Group by HazardTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HazardTranslationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HazardTranslationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HazardTranslationGroupByArgs['orderBy'] }
        : { orderBy?: HazardTranslationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HazardTranslationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHazardTranslationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HazardTranslation model
   */
  readonly fields: HazardTranslationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HazardTranslation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HazardTranslationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    hazard<T extends AdminHazardTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminHazardTypeDefaultArgs<ExtArgs>>): Prisma__AdminHazardTypeClient<$Result.GetResult<Prisma.$AdminHazardTypePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HazardTranslation model
   */ 
  interface HazardTranslationFieldRefs {
    readonly id: FieldRef<"HazardTranslation", 'String'>
    readonly hazardId: FieldRef<"HazardTranslation", 'String'>
    readonly locale: FieldRef<"HazardTranslation", 'String'>
    readonly name: FieldRef<"HazardTranslation", 'String'>
    readonly description: FieldRef<"HazardTranslation", 'String'>
    readonly impact: FieldRef<"HazardTranslation", 'String'>
    readonly createdAt: FieldRef<"HazardTranslation", 'DateTime'>
    readonly updatedAt: FieldRef<"HazardTranslation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HazardTranslation findUnique
   */
  export type HazardTranslationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HazardTranslation
     */
    select?: HazardTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HazardTranslationInclude<ExtArgs> | null
    /**
     * Filter, which HazardTranslation to fetch.
     */
    where: HazardTranslationWhereUniqueInput
  }

  /**
   * HazardTranslation findUniqueOrThrow
   */
  export type HazardTranslationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HazardTranslation
     */
    select?: HazardTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HazardTranslationInclude<ExtArgs> | null
    /**
     * Filter, which HazardTranslation to fetch.
     */
    where: HazardTranslationWhereUniqueInput
  }

  /**
   * HazardTranslation findFirst
   */
  export type HazardTranslationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HazardTranslation
     */
    select?: HazardTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HazardTranslationInclude<ExtArgs> | null
    /**
     * Filter, which HazardTranslation to fetch.
     */
    where?: HazardTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HazardTranslations to fetch.
     */
    orderBy?: HazardTranslationOrderByWithRelationInput | HazardTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HazardTranslations.
     */
    cursor?: HazardTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HazardTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HazardTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HazardTranslations.
     */
    distinct?: HazardTranslationScalarFieldEnum | HazardTranslationScalarFieldEnum[]
  }

  /**
   * HazardTranslation findFirstOrThrow
   */
  export type HazardTranslationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HazardTranslation
     */
    select?: HazardTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HazardTranslationInclude<ExtArgs> | null
    /**
     * Filter, which HazardTranslation to fetch.
     */
    where?: HazardTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HazardTranslations to fetch.
     */
    orderBy?: HazardTranslationOrderByWithRelationInput | HazardTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HazardTranslations.
     */
    cursor?: HazardTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HazardTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HazardTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HazardTranslations.
     */
    distinct?: HazardTranslationScalarFieldEnum | HazardTranslationScalarFieldEnum[]
  }

  /**
   * HazardTranslation findMany
   */
  export type HazardTranslationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HazardTranslation
     */
    select?: HazardTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HazardTranslationInclude<ExtArgs> | null
    /**
     * Filter, which HazardTranslations to fetch.
     */
    where?: HazardTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HazardTranslations to fetch.
     */
    orderBy?: HazardTranslationOrderByWithRelationInput | HazardTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HazardTranslations.
     */
    cursor?: HazardTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HazardTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HazardTranslations.
     */
    skip?: number
    distinct?: HazardTranslationScalarFieldEnum | HazardTranslationScalarFieldEnum[]
  }

  /**
   * HazardTranslation create
   */
  export type HazardTranslationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HazardTranslation
     */
    select?: HazardTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HazardTranslationInclude<ExtArgs> | null
    /**
     * The data needed to create a HazardTranslation.
     */
    data: XOR<HazardTranslationCreateInput, HazardTranslationUncheckedCreateInput>
  }

  /**
   * HazardTranslation createMany
   */
  export type HazardTranslationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HazardTranslations.
     */
    data: HazardTranslationCreateManyInput | HazardTranslationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HazardTranslation createManyAndReturn
   */
  export type HazardTranslationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HazardTranslation
     */
    select?: HazardTranslationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many HazardTranslations.
     */
    data: HazardTranslationCreateManyInput | HazardTranslationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HazardTranslationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HazardTranslation update
   */
  export type HazardTranslationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HazardTranslation
     */
    select?: HazardTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HazardTranslationInclude<ExtArgs> | null
    /**
     * The data needed to update a HazardTranslation.
     */
    data: XOR<HazardTranslationUpdateInput, HazardTranslationUncheckedUpdateInput>
    /**
     * Choose, which HazardTranslation to update.
     */
    where: HazardTranslationWhereUniqueInput
  }

  /**
   * HazardTranslation updateMany
   */
  export type HazardTranslationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HazardTranslations.
     */
    data: XOR<HazardTranslationUpdateManyMutationInput, HazardTranslationUncheckedUpdateManyInput>
    /**
     * Filter which HazardTranslations to update
     */
    where?: HazardTranslationWhereInput
  }

  /**
   * HazardTranslation upsert
   */
  export type HazardTranslationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HazardTranslation
     */
    select?: HazardTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HazardTranslationInclude<ExtArgs> | null
    /**
     * The filter to search for the HazardTranslation to update in case it exists.
     */
    where: HazardTranslationWhereUniqueInput
    /**
     * In case the HazardTranslation found by the `where` argument doesn't exist, create a new HazardTranslation with this data.
     */
    create: XOR<HazardTranslationCreateInput, HazardTranslationUncheckedCreateInput>
    /**
     * In case the HazardTranslation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HazardTranslationUpdateInput, HazardTranslationUncheckedUpdateInput>
  }

  /**
   * HazardTranslation delete
   */
  export type HazardTranslationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HazardTranslation
     */
    select?: HazardTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HazardTranslationInclude<ExtArgs> | null
    /**
     * Filter which HazardTranslation to delete.
     */
    where: HazardTranslationWhereUniqueInput
  }

  /**
   * HazardTranslation deleteMany
   */
  export type HazardTranslationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HazardTranslations to delete
     */
    where?: HazardTranslationWhereInput
  }

  /**
   * HazardTranslation without action
   */
  export type HazardTranslationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HazardTranslation
     */
    select?: HazardTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HazardTranslationInclude<ExtArgs> | null
  }


  /**
   * Model RiskMultiplierTranslation
   */

  export type AggregateRiskMultiplierTranslation = {
    _count: RiskMultiplierTranslationCountAggregateOutputType | null
    _min: RiskMultiplierTranslationMinAggregateOutputType | null
    _max: RiskMultiplierTranslationMaxAggregateOutputType | null
  }

  export type RiskMultiplierTranslationMinAggregateOutputType = {
    id: string | null
    riskMultiplierId: string | null
    locale: string | null
    name: string | null
    description: string | null
    reasoning: string | null
    wizardQuestion: string | null
    wizardHelpText: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RiskMultiplierTranslationMaxAggregateOutputType = {
    id: string | null
    riskMultiplierId: string | null
    locale: string | null
    name: string | null
    description: string | null
    reasoning: string | null
    wizardQuestion: string | null
    wizardHelpText: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RiskMultiplierTranslationCountAggregateOutputType = {
    id: number
    riskMultiplierId: number
    locale: number
    name: number
    description: number
    reasoning: number
    wizardQuestion: number
    wizardHelpText: number
    wizardAnswerOptions: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RiskMultiplierTranslationMinAggregateInputType = {
    id?: true
    riskMultiplierId?: true
    locale?: true
    name?: true
    description?: true
    reasoning?: true
    wizardQuestion?: true
    wizardHelpText?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RiskMultiplierTranslationMaxAggregateInputType = {
    id?: true
    riskMultiplierId?: true
    locale?: true
    name?: true
    description?: true
    reasoning?: true
    wizardQuestion?: true
    wizardHelpText?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RiskMultiplierTranslationCountAggregateInputType = {
    id?: true
    riskMultiplierId?: true
    locale?: true
    name?: true
    description?: true
    reasoning?: true
    wizardQuestion?: true
    wizardHelpText?: true
    wizardAnswerOptions?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RiskMultiplierTranslationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RiskMultiplierTranslation to aggregate.
     */
    where?: RiskMultiplierTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskMultiplierTranslations to fetch.
     */
    orderBy?: RiskMultiplierTranslationOrderByWithRelationInput | RiskMultiplierTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RiskMultiplierTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskMultiplierTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskMultiplierTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RiskMultiplierTranslations
    **/
    _count?: true | RiskMultiplierTranslationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RiskMultiplierTranslationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RiskMultiplierTranslationMaxAggregateInputType
  }

  export type GetRiskMultiplierTranslationAggregateType<T extends RiskMultiplierTranslationAggregateArgs> = {
        [P in keyof T & keyof AggregateRiskMultiplierTranslation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRiskMultiplierTranslation[P]>
      : GetScalarType<T[P], AggregateRiskMultiplierTranslation[P]>
  }




  export type RiskMultiplierTranslationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RiskMultiplierTranslationWhereInput
    orderBy?: RiskMultiplierTranslationOrderByWithAggregationInput | RiskMultiplierTranslationOrderByWithAggregationInput[]
    by: RiskMultiplierTranslationScalarFieldEnum[] | RiskMultiplierTranslationScalarFieldEnum
    having?: RiskMultiplierTranslationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RiskMultiplierTranslationCountAggregateInputType | true
    _min?: RiskMultiplierTranslationMinAggregateInputType
    _max?: RiskMultiplierTranslationMaxAggregateInputType
  }

  export type RiskMultiplierTranslationGroupByOutputType = {
    id: string
    riskMultiplierId: string
    locale: string
    name: string
    description: string | null
    reasoning: string | null
    wizardQuestion: string | null
    wizardHelpText: string | null
    wizardAnswerOptions: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: RiskMultiplierTranslationCountAggregateOutputType | null
    _min: RiskMultiplierTranslationMinAggregateOutputType | null
    _max: RiskMultiplierTranslationMaxAggregateOutputType | null
  }

  type GetRiskMultiplierTranslationGroupByPayload<T extends RiskMultiplierTranslationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RiskMultiplierTranslationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RiskMultiplierTranslationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RiskMultiplierTranslationGroupByOutputType[P]>
            : GetScalarType<T[P], RiskMultiplierTranslationGroupByOutputType[P]>
        }
      >
    >


  export type RiskMultiplierTranslationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    riskMultiplierId?: boolean
    locale?: boolean
    name?: boolean
    description?: boolean
    reasoning?: boolean
    wizardQuestion?: boolean
    wizardHelpText?: boolean
    wizardAnswerOptions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    riskMultiplier?: boolean | RiskMultiplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["riskMultiplierTranslation"]>

  export type RiskMultiplierTranslationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    riskMultiplierId?: boolean
    locale?: boolean
    name?: boolean
    description?: boolean
    reasoning?: boolean
    wizardQuestion?: boolean
    wizardHelpText?: boolean
    wizardAnswerOptions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    riskMultiplier?: boolean | RiskMultiplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["riskMultiplierTranslation"]>

  export type RiskMultiplierTranslationSelectScalar = {
    id?: boolean
    riskMultiplierId?: boolean
    locale?: boolean
    name?: boolean
    description?: boolean
    reasoning?: boolean
    wizardQuestion?: boolean
    wizardHelpText?: boolean
    wizardAnswerOptions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RiskMultiplierTranslationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    riskMultiplier?: boolean | RiskMultiplierDefaultArgs<ExtArgs>
  }
  export type RiskMultiplierTranslationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    riskMultiplier?: boolean | RiskMultiplierDefaultArgs<ExtArgs>
  }

  export type $RiskMultiplierTranslationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RiskMultiplierTranslation"
    objects: {
      riskMultiplier: Prisma.$RiskMultiplierPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      riskMultiplierId: string
      locale: string
      name: string
      description: string | null
      reasoning: string | null
      wizardQuestion: string | null
      wizardHelpText: string | null
      wizardAnswerOptions: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["riskMultiplierTranslation"]>
    composites: {}
  }

  type RiskMultiplierTranslationGetPayload<S extends boolean | null | undefined | RiskMultiplierTranslationDefaultArgs> = $Result.GetResult<Prisma.$RiskMultiplierTranslationPayload, S>

  type RiskMultiplierTranslationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RiskMultiplierTranslationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RiskMultiplierTranslationCountAggregateInputType | true
    }

  export interface RiskMultiplierTranslationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RiskMultiplierTranslation'], meta: { name: 'RiskMultiplierTranslation' } }
    /**
     * Find zero or one RiskMultiplierTranslation that matches the filter.
     * @param {RiskMultiplierTranslationFindUniqueArgs} args - Arguments to find a RiskMultiplierTranslation
     * @example
     * // Get one RiskMultiplierTranslation
     * const riskMultiplierTranslation = await prisma.riskMultiplierTranslation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RiskMultiplierTranslationFindUniqueArgs>(args: SelectSubset<T, RiskMultiplierTranslationFindUniqueArgs<ExtArgs>>): Prisma__RiskMultiplierTranslationClient<$Result.GetResult<Prisma.$RiskMultiplierTranslationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RiskMultiplierTranslation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RiskMultiplierTranslationFindUniqueOrThrowArgs} args - Arguments to find a RiskMultiplierTranslation
     * @example
     * // Get one RiskMultiplierTranslation
     * const riskMultiplierTranslation = await prisma.riskMultiplierTranslation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RiskMultiplierTranslationFindUniqueOrThrowArgs>(args: SelectSubset<T, RiskMultiplierTranslationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RiskMultiplierTranslationClient<$Result.GetResult<Prisma.$RiskMultiplierTranslationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RiskMultiplierTranslation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskMultiplierTranslationFindFirstArgs} args - Arguments to find a RiskMultiplierTranslation
     * @example
     * // Get one RiskMultiplierTranslation
     * const riskMultiplierTranslation = await prisma.riskMultiplierTranslation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RiskMultiplierTranslationFindFirstArgs>(args?: SelectSubset<T, RiskMultiplierTranslationFindFirstArgs<ExtArgs>>): Prisma__RiskMultiplierTranslationClient<$Result.GetResult<Prisma.$RiskMultiplierTranslationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RiskMultiplierTranslation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskMultiplierTranslationFindFirstOrThrowArgs} args - Arguments to find a RiskMultiplierTranslation
     * @example
     * // Get one RiskMultiplierTranslation
     * const riskMultiplierTranslation = await prisma.riskMultiplierTranslation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RiskMultiplierTranslationFindFirstOrThrowArgs>(args?: SelectSubset<T, RiskMultiplierTranslationFindFirstOrThrowArgs<ExtArgs>>): Prisma__RiskMultiplierTranslationClient<$Result.GetResult<Prisma.$RiskMultiplierTranslationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RiskMultiplierTranslations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskMultiplierTranslationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RiskMultiplierTranslations
     * const riskMultiplierTranslations = await prisma.riskMultiplierTranslation.findMany()
     * 
     * // Get first 10 RiskMultiplierTranslations
     * const riskMultiplierTranslations = await prisma.riskMultiplierTranslation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const riskMultiplierTranslationWithIdOnly = await prisma.riskMultiplierTranslation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RiskMultiplierTranslationFindManyArgs>(args?: SelectSubset<T, RiskMultiplierTranslationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RiskMultiplierTranslationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RiskMultiplierTranslation.
     * @param {RiskMultiplierTranslationCreateArgs} args - Arguments to create a RiskMultiplierTranslation.
     * @example
     * // Create one RiskMultiplierTranslation
     * const RiskMultiplierTranslation = await prisma.riskMultiplierTranslation.create({
     *   data: {
     *     // ... data to create a RiskMultiplierTranslation
     *   }
     * })
     * 
     */
    create<T extends RiskMultiplierTranslationCreateArgs>(args: SelectSubset<T, RiskMultiplierTranslationCreateArgs<ExtArgs>>): Prisma__RiskMultiplierTranslationClient<$Result.GetResult<Prisma.$RiskMultiplierTranslationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RiskMultiplierTranslations.
     * @param {RiskMultiplierTranslationCreateManyArgs} args - Arguments to create many RiskMultiplierTranslations.
     * @example
     * // Create many RiskMultiplierTranslations
     * const riskMultiplierTranslation = await prisma.riskMultiplierTranslation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RiskMultiplierTranslationCreateManyArgs>(args?: SelectSubset<T, RiskMultiplierTranslationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RiskMultiplierTranslations and returns the data saved in the database.
     * @param {RiskMultiplierTranslationCreateManyAndReturnArgs} args - Arguments to create many RiskMultiplierTranslations.
     * @example
     * // Create many RiskMultiplierTranslations
     * const riskMultiplierTranslation = await prisma.riskMultiplierTranslation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RiskMultiplierTranslations and only return the `id`
     * const riskMultiplierTranslationWithIdOnly = await prisma.riskMultiplierTranslation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RiskMultiplierTranslationCreateManyAndReturnArgs>(args?: SelectSubset<T, RiskMultiplierTranslationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RiskMultiplierTranslationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RiskMultiplierTranslation.
     * @param {RiskMultiplierTranslationDeleteArgs} args - Arguments to delete one RiskMultiplierTranslation.
     * @example
     * // Delete one RiskMultiplierTranslation
     * const RiskMultiplierTranslation = await prisma.riskMultiplierTranslation.delete({
     *   where: {
     *     // ... filter to delete one RiskMultiplierTranslation
     *   }
     * })
     * 
     */
    delete<T extends RiskMultiplierTranslationDeleteArgs>(args: SelectSubset<T, RiskMultiplierTranslationDeleteArgs<ExtArgs>>): Prisma__RiskMultiplierTranslationClient<$Result.GetResult<Prisma.$RiskMultiplierTranslationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RiskMultiplierTranslation.
     * @param {RiskMultiplierTranslationUpdateArgs} args - Arguments to update one RiskMultiplierTranslation.
     * @example
     * // Update one RiskMultiplierTranslation
     * const riskMultiplierTranslation = await prisma.riskMultiplierTranslation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RiskMultiplierTranslationUpdateArgs>(args: SelectSubset<T, RiskMultiplierTranslationUpdateArgs<ExtArgs>>): Prisma__RiskMultiplierTranslationClient<$Result.GetResult<Prisma.$RiskMultiplierTranslationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RiskMultiplierTranslations.
     * @param {RiskMultiplierTranslationDeleteManyArgs} args - Arguments to filter RiskMultiplierTranslations to delete.
     * @example
     * // Delete a few RiskMultiplierTranslations
     * const { count } = await prisma.riskMultiplierTranslation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RiskMultiplierTranslationDeleteManyArgs>(args?: SelectSubset<T, RiskMultiplierTranslationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RiskMultiplierTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskMultiplierTranslationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RiskMultiplierTranslations
     * const riskMultiplierTranslation = await prisma.riskMultiplierTranslation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RiskMultiplierTranslationUpdateManyArgs>(args: SelectSubset<T, RiskMultiplierTranslationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RiskMultiplierTranslation.
     * @param {RiskMultiplierTranslationUpsertArgs} args - Arguments to update or create a RiskMultiplierTranslation.
     * @example
     * // Update or create a RiskMultiplierTranslation
     * const riskMultiplierTranslation = await prisma.riskMultiplierTranslation.upsert({
     *   create: {
     *     // ... data to create a RiskMultiplierTranslation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RiskMultiplierTranslation we want to update
     *   }
     * })
     */
    upsert<T extends RiskMultiplierTranslationUpsertArgs>(args: SelectSubset<T, RiskMultiplierTranslationUpsertArgs<ExtArgs>>): Prisma__RiskMultiplierTranslationClient<$Result.GetResult<Prisma.$RiskMultiplierTranslationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RiskMultiplierTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskMultiplierTranslationCountArgs} args - Arguments to filter RiskMultiplierTranslations to count.
     * @example
     * // Count the number of RiskMultiplierTranslations
     * const count = await prisma.riskMultiplierTranslation.count({
     *   where: {
     *     // ... the filter for the RiskMultiplierTranslations we want to count
     *   }
     * })
    **/
    count<T extends RiskMultiplierTranslationCountArgs>(
      args?: Subset<T, RiskMultiplierTranslationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RiskMultiplierTranslationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RiskMultiplierTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskMultiplierTranslationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RiskMultiplierTranslationAggregateArgs>(args: Subset<T, RiskMultiplierTranslationAggregateArgs>): Prisma.PrismaPromise<GetRiskMultiplierTranslationAggregateType<T>>

    /**
     * Group by RiskMultiplierTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskMultiplierTranslationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RiskMultiplierTranslationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RiskMultiplierTranslationGroupByArgs['orderBy'] }
        : { orderBy?: RiskMultiplierTranslationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RiskMultiplierTranslationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRiskMultiplierTranslationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RiskMultiplierTranslation model
   */
  readonly fields: RiskMultiplierTranslationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RiskMultiplierTranslation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RiskMultiplierTranslationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    riskMultiplier<T extends RiskMultiplierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RiskMultiplierDefaultArgs<ExtArgs>>): Prisma__RiskMultiplierClient<$Result.GetResult<Prisma.$RiskMultiplierPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RiskMultiplierTranslation model
   */ 
  interface RiskMultiplierTranslationFieldRefs {
    readonly id: FieldRef<"RiskMultiplierTranslation", 'String'>
    readonly riskMultiplierId: FieldRef<"RiskMultiplierTranslation", 'String'>
    readonly locale: FieldRef<"RiskMultiplierTranslation", 'String'>
    readonly name: FieldRef<"RiskMultiplierTranslation", 'String'>
    readonly description: FieldRef<"RiskMultiplierTranslation", 'String'>
    readonly reasoning: FieldRef<"RiskMultiplierTranslation", 'String'>
    readonly wizardQuestion: FieldRef<"RiskMultiplierTranslation", 'String'>
    readonly wizardHelpText: FieldRef<"RiskMultiplierTranslation", 'String'>
    readonly wizardAnswerOptions: FieldRef<"RiskMultiplierTranslation", 'Json'>
    readonly createdAt: FieldRef<"RiskMultiplierTranslation", 'DateTime'>
    readonly updatedAt: FieldRef<"RiskMultiplierTranslation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RiskMultiplierTranslation findUnique
   */
  export type RiskMultiplierTranslationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskMultiplierTranslation
     */
    select?: RiskMultiplierTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskMultiplierTranslationInclude<ExtArgs> | null
    /**
     * Filter, which RiskMultiplierTranslation to fetch.
     */
    where: RiskMultiplierTranslationWhereUniqueInput
  }

  /**
   * RiskMultiplierTranslation findUniqueOrThrow
   */
  export type RiskMultiplierTranslationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskMultiplierTranslation
     */
    select?: RiskMultiplierTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskMultiplierTranslationInclude<ExtArgs> | null
    /**
     * Filter, which RiskMultiplierTranslation to fetch.
     */
    where: RiskMultiplierTranslationWhereUniqueInput
  }

  /**
   * RiskMultiplierTranslation findFirst
   */
  export type RiskMultiplierTranslationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskMultiplierTranslation
     */
    select?: RiskMultiplierTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskMultiplierTranslationInclude<ExtArgs> | null
    /**
     * Filter, which RiskMultiplierTranslation to fetch.
     */
    where?: RiskMultiplierTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskMultiplierTranslations to fetch.
     */
    orderBy?: RiskMultiplierTranslationOrderByWithRelationInput | RiskMultiplierTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RiskMultiplierTranslations.
     */
    cursor?: RiskMultiplierTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskMultiplierTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskMultiplierTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RiskMultiplierTranslations.
     */
    distinct?: RiskMultiplierTranslationScalarFieldEnum | RiskMultiplierTranslationScalarFieldEnum[]
  }

  /**
   * RiskMultiplierTranslation findFirstOrThrow
   */
  export type RiskMultiplierTranslationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskMultiplierTranslation
     */
    select?: RiskMultiplierTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskMultiplierTranslationInclude<ExtArgs> | null
    /**
     * Filter, which RiskMultiplierTranslation to fetch.
     */
    where?: RiskMultiplierTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskMultiplierTranslations to fetch.
     */
    orderBy?: RiskMultiplierTranslationOrderByWithRelationInput | RiskMultiplierTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RiskMultiplierTranslations.
     */
    cursor?: RiskMultiplierTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskMultiplierTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskMultiplierTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RiskMultiplierTranslations.
     */
    distinct?: RiskMultiplierTranslationScalarFieldEnum | RiskMultiplierTranslationScalarFieldEnum[]
  }

  /**
   * RiskMultiplierTranslation findMany
   */
  export type RiskMultiplierTranslationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskMultiplierTranslation
     */
    select?: RiskMultiplierTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskMultiplierTranslationInclude<ExtArgs> | null
    /**
     * Filter, which RiskMultiplierTranslations to fetch.
     */
    where?: RiskMultiplierTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskMultiplierTranslations to fetch.
     */
    orderBy?: RiskMultiplierTranslationOrderByWithRelationInput | RiskMultiplierTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RiskMultiplierTranslations.
     */
    cursor?: RiskMultiplierTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskMultiplierTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskMultiplierTranslations.
     */
    skip?: number
    distinct?: RiskMultiplierTranslationScalarFieldEnum | RiskMultiplierTranslationScalarFieldEnum[]
  }

  /**
   * RiskMultiplierTranslation create
   */
  export type RiskMultiplierTranslationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskMultiplierTranslation
     */
    select?: RiskMultiplierTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskMultiplierTranslationInclude<ExtArgs> | null
    /**
     * The data needed to create a RiskMultiplierTranslation.
     */
    data: XOR<RiskMultiplierTranslationCreateInput, RiskMultiplierTranslationUncheckedCreateInput>
  }

  /**
   * RiskMultiplierTranslation createMany
   */
  export type RiskMultiplierTranslationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RiskMultiplierTranslations.
     */
    data: RiskMultiplierTranslationCreateManyInput | RiskMultiplierTranslationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RiskMultiplierTranslation createManyAndReturn
   */
  export type RiskMultiplierTranslationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskMultiplierTranslation
     */
    select?: RiskMultiplierTranslationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RiskMultiplierTranslations.
     */
    data: RiskMultiplierTranslationCreateManyInput | RiskMultiplierTranslationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskMultiplierTranslationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RiskMultiplierTranslation update
   */
  export type RiskMultiplierTranslationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskMultiplierTranslation
     */
    select?: RiskMultiplierTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskMultiplierTranslationInclude<ExtArgs> | null
    /**
     * The data needed to update a RiskMultiplierTranslation.
     */
    data: XOR<RiskMultiplierTranslationUpdateInput, RiskMultiplierTranslationUncheckedUpdateInput>
    /**
     * Choose, which RiskMultiplierTranslation to update.
     */
    where: RiskMultiplierTranslationWhereUniqueInput
  }

  /**
   * RiskMultiplierTranslation updateMany
   */
  export type RiskMultiplierTranslationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RiskMultiplierTranslations.
     */
    data: XOR<RiskMultiplierTranslationUpdateManyMutationInput, RiskMultiplierTranslationUncheckedUpdateManyInput>
    /**
     * Filter which RiskMultiplierTranslations to update
     */
    where?: RiskMultiplierTranslationWhereInput
  }

  /**
   * RiskMultiplierTranslation upsert
   */
  export type RiskMultiplierTranslationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskMultiplierTranslation
     */
    select?: RiskMultiplierTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskMultiplierTranslationInclude<ExtArgs> | null
    /**
     * The filter to search for the RiskMultiplierTranslation to update in case it exists.
     */
    where: RiskMultiplierTranslationWhereUniqueInput
    /**
     * In case the RiskMultiplierTranslation found by the `where` argument doesn't exist, create a new RiskMultiplierTranslation with this data.
     */
    create: XOR<RiskMultiplierTranslationCreateInput, RiskMultiplierTranslationUncheckedCreateInput>
    /**
     * In case the RiskMultiplierTranslation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RiskMultiplierTranslationUpdateInput, RiskMultiplierTranslationUncheckedUpdateInput>
  }

  /**
   * RiskMultiplierTranslation delete
   */
  export type RiskMultiplierTranslationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskMultiplierTranslation
     */
    select?: RiskMultiplierTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskMultiplierTranslationInclude<ExtArgs> | null
    /**
     * Filter which RiskMultiplierTranslation to delete.
     */
    where: RiskMultiplierTranslationWhereUniqueInput
  }

  /**
   * RiskMultiplierTranslation deleteMany
   */
  export type RiskMultiplierTranslationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RiskMultiplierTranslations to delete
     */
    where?: RiskMultiplierTranslationWhereInput
  }

  /**
   * RiskMultiplierTranslation without action
   */
  export type RiskMultiplierTranslationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskMultiplierTranslation
     */
    select?: RiskMultiplierTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskMultiplierTranslationInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const BusinessContinuityPlanScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BusinessContinuityPlanScalarFieldEnum = (typeof BusinessContinuityPlanScalarFieldEnum)[keyof typeof BusinessContinuityPlanScalarFieldEnum]


  export const PlanInformationScalarFieldEnum: {
    id: 'id',
    planId: 'planId',
    companyName: 'companyName',
    planManager: 'planManager',
    alternateManager: 'alternateManager',
    physicalPlanLocation: 'physicalPlanLocation',
    digitalPlanLocation: 'digitalPlanLocation'
  };

  export type PlanInformationScalarFieldEnum = (typeof PlanInformationScalarFieldEnum)[keyof typeof PlanInformationScalarFieldEnum]


  export const BusinessOverviewScalarFieldEnum: {
    id: 'id',
    planId: 'planId',
    businessLicenseNumber: 'businessLicenseNumber',
    businessPurpose: 'businessPurpose',
    productsAndServices: 'productsAndServices',
    serviceDeliveryMethods: 'serviceDeliveryMethods',
    operatingHours: 'operatingHours',
    keyPersonnel: 'keyPersonnel',
    minimumResources: 'minimumResources',
    customerBase: 'customerBase',
    serviceProviderBCP: 'serviceProviderBCP'
  };

  export type BusinessOverviewScalarFieldEnum = (typeof BusinessOverviewScalarFieldEnum)[keyof typeof BusinessOverviewScalarFieldEnum]


  export const EssentialFunctionScalarFieldEnum: {
    id: 'id',
    planId: 'planId',
    supplyChainManagement: 'supplyChainManagement',
    staffManagement: 'staffManagement',
    technology: 'technology',
    productsServices: 'productsServices',
    infrastructureFacilities: 'infrastructureFacilities',
    sales: 'sales',
    administration: 'administration'
  };

  export type EssentialFunctionScalarFieldEnum = (typeof EssentialFunctionScalarFieldEnum)[keyof typeof EssentialFunctionScalarFieldEnum]


  export const RiskAssessmentScalarFieldEnum: {
    id: 'id',
    planId: 'planId',
    potentialHazards: 'potentialHazards',
    hazards: 'hazards'
  };

  export type RiskAssessmentScalarFieldEnum = (typeof RiskAssessmentScalarFieldEnum)[keyof typeof RiskAssessmentScalarFieldEnum]


  export const StrategyScalarFieldEnum: {
    id: 'id',
    planId: 'planId',
    preventionStrategies: 'preventionStrategies',
    responseStrategies: 'responseStrategies',
    recoveryStrategies: 'recoveryStrategies',
    longTermRiskReduction: 'longTermRiskReduction'
  };

  export type StrategyScalarFieldEnum = (typeof StrategyScalarFieldEnum)[keyof typeof StrategyScalarFieldEnum]


  export const ActionPlanScalarFieldEnum: {
    id: 'id',
    planId: 'planId',
    actionPlanByRisk: 'actionPlanByRisk',
    implementationTimeline: 'implementationTimeline',
    resourceRequirements: 'resourceRequirements',
    responsibleParties: 'responsibleParties',
    reviewUpdateSchedule: 'reviewUpdateSchedule',
    testingAssessmentPlan: 'testingAssessmentPlan'
  };

  export type ActionPlanScalarFieldEnum = (typeof ActionPlanScalarFieldEnum)[keyof typeof ActionPlanScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    currentStep: 'currentStep',
    stepData: 'stepData'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const BusinessProfileScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    name: 'name',
    industry: 'industry',
    size: 'size',
    location: 'location'
  };

  export type BusinessProfileScalarFieldEnum = (typeof BusinessProfileScalarFieldEnum)[keyof typeof BusinessProfileScalarFieldEnum]


  export const ContactsInformationScalarFieldEnum: {
    id: 'id',
    planId: 'planId',
    staffContactInfo: 'staffContactInfo',
    keyCustomerContacts: 'keyCustomerContacts',
    supplierInformation: 'supplierInformation',
    emergencyServicesUtilities: 'emergencyServicesUtilities',
    criticalBusinessInfo: 'criticalBusinessInfo',
    planDistributionList: 'planDistributionList'
  };

  export type ContactsInformationScalarFieldEnum = (typeof ContactsInformationScalarFieldEnum)[keyof typeof ContactsInformationScalarFieldEnum]


  export const TestingMaintenanceScalarFieldEnum: {
    id: 'id',
    planId: 'planId',
    planTestingSchedule: 'planTestingSchedule',
    planRevisionHistory: 'planRevisionHistory',
    improvementTracking: 'improvementTracking',
    annualReviewProcess: 'annualReviewProcess',
    triggerEventsForUpdates: 'triggerEventsForUpdates'
  };

  export type TestingMaintenanceScalarFieldEnum = (typeof TestingMaintenanceScalarFieldEnum)[keyof typeof TestingMaintenanceScalarFieldEnum]


  export const AnonymousSessionScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    businessName: 'businessName',
    displayBusinessName: 'displayBusinessName',
    pin: 'pin',
    email: 'email',
    planData: 'planData',
    shareableId: 'shareableId',
    allowSharing: 'allowSharing',
    createdAt: 'createdAt',
    lastAccessed: 'lastAccessed'
  };

  export type AnonymousSessionScalarFieldEnum = (typeof AnonymousSessionScalarFieldEnum)[keyof typeof AnonymousSessionScalarFieldEnum]


  export const AdminBusinessTypeScalarFieldEnum: {
    id: 'id',
    businessTypeId: 'businessTypeId',
    name: 'name',
    localName: 'localName',
    category: 'category',
    description: 'description',
    typicalOperatingHours: 'typicalOperatingHours',
    minimumStaff: 'minimumStaff',
    minimumEquipment: 'minimumEquipment',
    minimumUtilities: 'minimumUtilities',
    minimumSpace: 'minimumSpace',
    essentialFunctions: 'essentialFunctions',
    criticalSuppliers: 'criticalSuppliers',
    exampleBusinessPurposes: 'exampleBusinessPurposes',
    exampleProducts: 'exampleProducts',
    exampleKeyPersonnel: 'exampleKeyPersonnel',
    exampleCustomerBase: 'exampleCustomerBase',
    dependencies: 'dependencies',
    vulnerabilityMatrix: 'vulnerabilityMatrix',
    operationalThresholds: 'operationalThresholds',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdminBusinessTypeScalarFieldEnum = (typeof AdminBusinessTypeScalarFieldEnum)[keyof typeof AdminBusinessTypeScalarFieldEnum]


  export const AdminHazardTypeScalarFieldEnum: {
    id: 'id',
    hazardId: 'hazardId',
    name: 'name',
    category: 'category',
    description: 'description',
    defaultFrequency: 'defaultFrequency',
    defaultImpact: 'defaultImpact',
    seasonalPattern: 'seasonalPattern',
    peakMonths: 'peakMonths',
    warningTime: 'warningTime',
    geographicScope: 'geographicScope',
    cascadingRisks: 'cascadingRisks',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdminHazardTypeScalarFieldEnum = (typeof AdminHazardTypeScalarFieldEnum)[keyof typeof AdminHazardTypeScalarFieldEnum]


  export const AdminLocationScalarFieldEnum: {
    id: 'id',
    country: 'country',
    countryCode: 'countryCode',
    parish: 'parish',
    isCoastal: 'isCoastal',
    isUrban: 'isUrban',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdminLocationScalarFieldEnum = (typeof AdminLocationScalarFieldEnum)[keyof typeof AdminLocationScalarFieldEnum]


  export const AdminBusinessTypeHazardScalarFieldEnum: {
    id: 'id',
    businessTypeId: 'businessTypeId',
    hazardId: 'hazardId',
    riskLevel: 'riskLevel',
    frequency: 'frequency',
    impact: 'impact',
    notes: 'notes',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdminBusinessTypeHazardScalarFieldEnum = (typeof AdminBusinessTypeHazardScalarFieldEnum)[keyof typeof AdminBusinessTypeHazardScalarFieldEnum]


  export const AdminLocationHazardScalarFieldEnum: {
    id: 'id',
    locationId: 'locationId',
    hazardId: 'hazardId',
    riskLevel: 'riskLevel',
    frequency: 'frequency',
    impact: 'impact',
    notes: 'notes',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdminLocationHazardScalarFieldEnum = (typeof AdminLocationHazardScalarFieldEnum)[keyof typeof AdminLocationHazardScalarFieldEnum]


  export const AdminStrategyScalarFieldEnum: {
    id: 'id',
    strategyId: 'strategyId',
    title: 'title',
    description: 'description',
    category: 'category',
    reasoning: 'reasoning',
    icon: 'icon',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdminStrategyScalarFieldEnum = (typeof AdminStrategyScalarFieldEnum)[keyof typeof AdminStrategyScalarFieldEnum]


  export const AdminHazardStrategyScalarFieldEnum: {
    id: 'id',
    hazardId: 'hazardId',
    strategyId: 'strategyId',
    businessTypes: 'businessTypes',
    priority: 'priority',
    isRecommended: 'isRecommended',
    notes: 'notes',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdminHazardStrategyScalarFieldEnum = (typeof AdminHazardStrategyScalarFieldEnum)[keyof typeof AdminHazardStrategyScalarFieldEnum]


  export const AdminActionPlanScalarFieldEnum: {
    id: 'id',
    hazardId: 'hazardId',
    resourcesNeeded: 'resourcesNeeded',
    immediateActions: 'immediateActions',
    shortTermActions: 'shortTermActions',
    mediumTermActions: 'mediumTermActions',
    longTermReduction: 'longTermReduction',
    businessTypeModifiers: 'businessTypeModifiers',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdminActionPlanScalarFieldEnum = (typeof AdminActionPlanScalarFieldEnum)[keyof typeof AdminActionPlanScalarFieldEnum]


  export const AdminHazardActionPlanScalarFieldEnum: {
    id: 'id',
    hazardId: 'hazardId',
    actionPlanId: 'actionPlanId',
    businessTypes: 'businessTypes',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdminHazardActionPlanScalarFieldEnum = (typeof AdminHazardActionPlanScalarFieldEnum)[keyof typeof AdminHazardActionPlanScalarFieldEnum]


  export const AdminRiskProfileScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    businessTypeId: 'businessTypeId',
    locationId: 'locationId',
    calculatedRisks: 'calculatedRisks',
    recommendedStrategies: 'recommendedStrategies',
    lastCalculated: 'lastCalculated',
    riskScore: 'riskScore'
  };

  export type AdminRiskProfileScalarFieldEnum = (typeof AdminRiskProfileScalarFieldEnum)[keyof typeof AdminRiskProfileScalarFieldEnum]


  export const CountryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    region: 'region',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CountryScalarFieldEnum = (typeof CountryScalarFieldEnum)[keyof typeof CountryScalarFieldEnum]


  export const AdminUnitScalarFieldEnum: {
    id: 'id',
    name: 'name',
    localName: 'localName',
    type: 'type',
    region: 'region',
    countryId: 'countryId',
    population: 'population',
    area: 'area',
    elevation: 'elevation',
    coordinates: 'coordinates',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isActive: 'isActive'
  };

  export type AdminUnitScalarFieldEnum = (typeof AdminUnitScalarFieldEnum)[keyof typeof AdminUnitScalarFieldEnum]


  export const ParishScalarFieldEnum: {
    id: 'id',
    name: 'name',
    region: 'region',
    countryCode: 'countryCode',
    population: 'population',
    area: 'area',
    elevation: 'elevation',
    coordinates: 'coordinates',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isActive: 'isActive'
  };

  export type ParishScalarFieldEnum = (typeof ParishScalarFieldEnum)[keyof typeof ParishScalarFieldEnum]


  export const AdminUnitRiskScalarFieldEnum: {
    id: 'id',
    adminUnitId: 'adminUnitId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastUpdated: 'lastUpdated',
    updatedBy: 'updatedBy',
    hurricaneLevel: 'hurricaneLevel',
    hurricaneNotes: 'hurricaneNotes',
    floodLevel: 'floodLevel',
    floodNotes: 'floodNotes',
    earthquakeLevel: 'earthquakeLevel',
    earthquakeNotes: 'earthquakeNotes',
    droughtLevel: 'droughtLevel',
    droughtNotes: 'droughtNotes',
    landslideLevel: 'landslideLevel',
    landslideNotes: 'landslideNotes',
    powerOutageLevel: 'powerOutageLevel',
    powerOutageNotes: 'powerOutageNotes',
    riskProfileJson: 'riskProfileJson',
    isActive: 'isActive'
  };

  export type AdminUnitRiskScalarFieldEnum = (typeof AdminUnitRiskScalarFieldEnum)[keyof typeof AdminUnitRiskScalarFieldEnum]


  export const AdminUnitRiskChangeLogScalarFieldEnum: {
    id: 'id',
    adminUnitRiskId: 'adminUnitRiskId',
    riskType: 'riskType',
    oldLevel: 'oldLevel',
    newLevel: 'newLevel',
    oldNotes: 'oldNotes',
    newNotes: 'newNotes',
    changedBy: 'changedBy',
    changeReason: 'changeReason',
    createdAt: 'createdAt'
  };

  export type AdminUnitRiskChangeLogScalarFieldEnum = (typeof AdminUnitRiskChangeLogScalarFieldEnum)[keyof typeof AdminUnitRiskChangeLogScalarFieldEnum]


  export const ParishRiskScalarFieldEnum: {
    id: 'id',
    parishId: 'parishId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastUpdated: 'lastUpdated',
    updatedBy: 'updatedBy',
    hurricaneLevel: 'hurricaneLevel',
    hurricaneNotes: 'hurricaneNotes',
    floodLevel: 'floodLevel',
    floodNotes: 'floodNotes',
    earthquakeLevel: 'earthquakeLevel',
    earthquakeNotes: 'earthquakeNotes',
    droughtLevel: 'droughtLevel',
    droughtNotes: 'droughtNotes',
    landslideLevel: 'landslideLevel',
    landslideNotes: 'landslideNotes',
    powerOutageLevel: 'powerOutageLevel',
    powerOutageNotes: 'powerOutageNotes',
    riskProfileJson: 'riskProfileJson',
    isActive: 'isActive'
  };

  export type ParishRiskScalarFieldEnum = (typeof ParishRiskScalarFieldEnum)[keyof typeof ParishRiskScalarFieldEnum]


  export const RiskChangeLogScalarFieldEnum: {
    id: 'id',
    parishRiskId: 'parishRiskId',
    riskType: 'riskType',
    oldLevel: 'oldLevel',
    newLevel: 'newLevel',
    oldNotes: 'oldNotes',
    newNotes: 'newNotes',
    changedBy: 'changedBy',
    changeReason: 'changeReason',
    createdAt: 'createdAt'
  };

  export type RiskChangeLogScalarFieldEnum = (typeof RiskChangeLogScalarFieldEnum)[keyof typeof RiskChangeLogScalarFieldEnum]


  export const BusinessTypeScalarFieldEnum: {
    id: 'id',
    businessTypeId: 'businessTypeId',
    name: 'name',
    category: 'category',
    subcategory: 'subcategory',
    description: 'description',
    exampleBusinessPurposes: 'exampleBusinessPurposes',
    exampleProducts: 'exampleProducts',
    exampleKeyPersonnel: 'exampleKeyPersonnel',
    exampleCustomerBase: 'exampleCustomerBase',
    minimumEquipment: 'minimumEquipment',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BusinessTypeScalarFieldEnum = (typeof BusinessTypeScalarFieldEnum)[keyof typeof BusinessTypeScalarFieldEnum]


  export const BusinessRiskVulnerabilityScalarFieldEnum: {
    id: 'id',
    businessTypeId: 'businessTypeId',
    riskType: 'riskType',
    vulnerabilityLevel: 'vulnerabilityLevel',
    impactSeverity: 'impactSeverity',
    recoveryTime: 'recoveryTime',
    reasoning: 'reasoning',
    mitigationDifficulty: 'mitigationDifficulty',
    costToRecover: 'costToRecover',
    businessImpactAreas: 'businessImpactAreas',
    criticalDependencies: 'criticalDependencies',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BusinessRiskVulnerabilityScalarFieldEnum = (typeof BusinessRiskVulnerabilityScalarFieldEnum)[keyof typeof BusinessRiskVulnerabilityScalarFieldEnum]


  export const RiskMitigationStrategyScalarFieldEnum: {
    id: 'id',
    strategyId: 'strategyId',
    name: 'name',
    description: 'description',
    smeTitle: 'smeTitle',
    smeSummary: 'smeSummary',
    smeDescription: 'smeDescription',
    whyImportant: 'whyImportant',
    benefitsBullets: 'benefitsBullets',
    realWorldExample: 'realWorldExample',
    calculatedCostUSD: 'calculatedCostUSD',
    calculatedCostLocal: 'calculatedCostLocal',
    currencyCode: 'currencyCode',
    currencySymbol: 'currencySymbol',
    totalEstimatedHours: 'totalEstimatedHours',
    selectionTier: 'selectionTier',
    requiredForRisks: 'requiredForRisks',
    helpfulTips: 'helpfulTips',
    commonMistakes: 'commonMistakes',
    successMetrics: 'successMetrics',
    lowBudgetAlternative: 'lowBudgetAlternative',
    applicableRisks: 'applicableRisks',
    applicableBusinessTypes: 'applicableBusinessTypes',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RiskMitigationStrategyScalarFieldEnum = (typeof RiskMitigationStrategyScalarFieldEnum)[keyof typeof RiskMitigationStrategyScalarFieldEnum]


  export const ActionStepScalarFieldEnum: {
    id: 'id',
    strategyId: 'strategyId',
    stepId: 'stepId',
    phase: 'phase',
    title: 'title',
    description: 'description',
    smeAction: 'smeAction',
    whyThisStepMatters: 'whyThisStepMatters',
    whatHappensIfSkipped: 'whatHappensIfSkipped',
    timeframe: 'timeframe',
    estimatedMinutes: 'estimatedMinutes',
    difficultyLevel: 'difficultyLevel',
    responsibility: 'responsibility',
    estimatedCost: 'estimatedCost',
    estimatedCostJMD: 'estimatedCostJMD',
    resources: 'resources',
    checklist: 'checklist',
    howToKnowItsDone: 'howToKnowItsDone',
    exampleOutput: 'exampleOutput',
    dependsOnSteps: 'dependsOnSteps',
    isOptional: 'isOptional',
    skipConditions: 'skipConditions',
    freeAlternative: 'freeAlternative',
    lowTechOption: 'lowTechOption',
    commonMistakesForStep: 'commonMistakesForStep',
    videoTutorialUrl: 'videoTutorialUrl',
    externalResourceUrl: 'externalResourceUrl',
    sortOrder: 'sortOrder',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ActionStepScalarFieldEnum = (typeof ActionStepScalarFieldEnum)[keyof typeof ActionStepScalarFieldEnum]


  export const BusinessTypeStrategyScalarFieldEnum: {
    id: 'id',
    businessTypeId: 'businessTypeId',
    strategyId: 'strategyId',
    relevanceScore: 'relevanceScore',
    customNotes: 'customNotes',
    isRecommended: 'isRecommended',
    priority: 'priority',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BusinessTypeStrategyScalarFieldEnum = (typeof BusinessTypeStrategyScalarFieldEnum)[keyof typeof BusinessTypeStrategyScalarFieldEnum]


  export const BusinessRiskProfileScalarFieldEnum: {
    id: 'id',
    businessTypeId: 'businessTypeId',
    parishId: 'parishId',
    combinedRisks: 'combinedRisks',
    recommendedStrategies: 'recommendedStrategies',
    overallRiskScore: 'overallRiskScore',
    priorityActions: 'priorityActions',
    calculatedAt: 'calculatedAt',
    calculatedBy: 'calculatedBy',
    isActive: 'isActive'
  };

  export type BusinessRiskProfileScalarFieldEnum = (typeof BusinessRiskProfileScalarFieldEnum)[keyof typeof BusinessRiskProfileScalarFieldEnum]


  export const RiskMultiplierScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    characteristicType: 'characteristicType',
    conditionType: 'conditionType',
    thresholdValue: 'thresholdValue',
    minValue: 'minValue',
    maxValue: 'maxValue',
    multiplierFactor: 'multiplierFactor',
    applicableHazards: 'applicableHazards',
    wizardQuestion: 'wizardQuestion',
    wizardAnswerOptions: 'wizardAnswerOptions',
    wizardHelpText: 'wizardHelpText',
    isActive: 'isActive',
    priority: 'priority',
    reasoning: 'reasoning',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy'
  };

  export type RiskMultiplierScalarFieldEnum = (typeof RiskMultiplierScalarFieldEnum)[keyof typeof RiskMultiplierScalarFieldEnum]


  export const CostItemScalarFieldEnum: {
    id: 'id',
    itemId: 'itemId',
    name: 'name',
    description: 'description',
    category: 'category',
    baseUSD: 'baseUSD',
    baseUSDMin: 'baseUSDMin',
    baseUSDMax: 'baseUSDMax',
    unit: 'unit',
    complexity: 'complexity',
    notes: 'notes',
    tags: 'tags',
    budgetAlternativeId: 'budgetAlternativeId',
    premiumAlternativeId: 'premiumAlternativeId',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CostItemScalarFieldEnum = (typeof CostItemScalarFieldEnum)[keyof typeof CostItemScalarFieldEnum]


  export const CountryCostMultiplierScalarFieldEnum: {
    id: 'id',
    countryCode: 'countryCode',
    construction: 'construction',
    equipment: 'equipment',
    service: 'service',
    supplies: 'supplies',
    currency: 'currency',
    currencySymbol: 'currencySymbol',
    exchangeRateUSD: 'exchangeRateUSD',
    lastUpdated: 'lastUpdated',
    updatedBy: 'updatedBy',
    dataSource: 'dataSource',
    confidenceLevel: 'confidenceLevel',
    notes: 'notes'
  };

  export type CountryCostMultiplierScalarFieldEnum = (typeof CountryCostMultiplierScalarFieldEnum)[keyof typeof CountryCostMultiplierScalarFieldEnum]


  export const StrategyItemCostScalarFieldEnum: {
    id: 'id',
    strategyId: 'strategyId',
    itemId: 'itemId',
    quantity: 'quantity',
    customNotes: 'customNotes',
    countryOverrides: 'countryOverrides',
    isRequired: 'isRequired',
    displayOrder: 'displayOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StrategyItemCostScalarFieldEnum = (typeof StrategyItemCostScalarFieldEnum)[keyof typeof StrategyItemCostScalarFieldEnum]


  export const ActionStepItemCostScalarFieldEnum: {
    id: 'id',
    actionStepId: 'actionStepId',
    itemId: 'itemId',
    quantity: 'quantity',
    customNotes: 'customNotes',
    countryOverrides: 'countryOverrides',
    displayOrder: 'displayOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ActionStepItemCostScalarFieldEnum = (typeof ActionStepItemCostScalarFieldEnum)[keyof typeof ActionStepItemCostScalarFieldEnum]


  export const BusinessTypeTranslationScalarFieldEnum: {
    id: 'id',
    businessTypeId: 'businessTypeId',
    locale: 'locale',
    name: 'name',
    description: 'description',
    exampleBusinessPurposes: 'exampleBusinessPurposes',
    exampleProducts: 'exampleProducts',
    exampleKeyPersonnel: 'exampleKeyPersonnel',
    exampleCustomerBase: 'exampleCustomerBase',
    minimumEquipment: 'minimumEquipment',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BusinessTypeTranslationScalarFieldEnum = (typeof BusinessTypeTranslationScalarFieldEnum)[keyof typeof BusinessTypeTranslationScalarFieldEnum]


  export const StrategyTranslationScalarFieldEnum: {
    id: 'id',
    strategyId: 'strategyId',
    locale: 'locale',
    name: 'name',
    description: 'description',
    smeTitle: 'smeTitle',
    smeSummary: 'smeSummary',
    realWorldExample: 'realWorldExample',
    whyImportant: 'whyImportant',
    whenToImplement: 'whenToImplement',
    expectedOutcome: 'expectedOutcome',
    benefitsBullets: 'benefitsBullets',
    helpfulTips: 'helpfulTips',
    commonMistakes: 'commonMistakes',
    successMetrics: 'successMetrics',
    requiredResources: 'requiredResources',
    lowBudgetAlternative: 'lowBudgetAlternative',
    diyApproach: 'diyApproach',
    bcpTemplateText: 'bcpTemplateText',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StrategyTranslationScalarFieldEnum = (typeof StrategyTranslationScalarFieldEnum)[keyof typeof StrategyTranslationScalarFieldEnum]


  export const ActionStepTranslationScalarFieldEnum: {
    id: 'id',
    actionStepId: 'actionStepId',
    locale: 'locale',
    title: 'title',
    description: 'description',
    smeAction: 'smeAction',
    timeframe: 'timeframe',
    whyThisStepMatters: 'whyThisStepMatters',
    howToKnowItsDone: 'howToKnowItsDone',
    whatHappensIfSkipped: 'whatHappensIfSkipped',
    exampleOutput: 'exampleOutput',
    freeAlternative: 'freeAlternative',
    lowTechOption: 'lowTechOption',
    commonMistakesForStep: 'commonMistakesForStep',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ActionStepTranslationScalarFieldEnum = (typeof ActionStepTranslationScalarFieldEnum)[keyof typeof ActionStepTranslationScalarFieldEnum]


  export const HazardTranslationScalarFieldEnum: {
    id: 'id',
    hazardId: 'hazardId',
    locale: 'locale',
    name: 'name',
    description: 'description',
    impact: 'impact',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HazardTranslationScalarFieldEnum = (typeof HazardTranslationScalarFieldEnum)[keyof typeof HazardTranslationScalarFieldEnum]


  export const RiskMultiplierTranslationScalarFieldEnum: {
    id: 'id',
    riskMultiplierId: 'riskMultiplierId',
    locale: 'locale',
    name: 'name',
    description: 'description',
    reasoning: 'reasoning',
    wizardQuestion: 'wizardQuestion',
    wizardHelpText: 'wizardHelpText',
    wizardAnswerOptions: 'wizardAnswerOptions',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RiskMultiplierTranslationScalarFieldEnum = (typeof RiskMultiplierTranslationScalarFieldEnum)[keyof typeof RiskMultiplierTranslationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    
  /**
   * Deep Input Types
   */


  export type BusinessContinuityPlanWhereInput = {
    AND?: BusinessContinuityPlanWhereInput | BusinessContinuityPlanWhereInput[]
    OR?: BusinessContinuityPlanWhereInput[]
    NOT?: BusinessContinuityPlanWhereInput | BusinessContinuityPlanWhereInput[]
    id?: StringFilter<"BusinessContinuityPlan"> | string
    createdAt?: DateTimeFilter<"BusinessContinuityPlan"> | Date | string
    updatedAt?: DateTimeFilter<"BusinessContinuityPlan"> | Date | string
    planInformation?: XOR<PlanInformationNullableRelationFilter, PlanInformationWhereInput> | null
    businessOverview?: XOR<BusinessOverviewNullableRelationFilter, BusinessOverviewWhereInput> | null
    essentialFunction?: XOR<EssentialFunctionNullableRelationFilter, EssentialFunctionWhereInput> | null
    riskAssessment?: XOR<RiskAssessmentNullableRelationFilter, RiskAssessmentWhereInput> | null
    strategy?: XOR<StrategyNullableRelationFilter, StrategyWhereInput> | null
    actionPlan?: XOR<ActionPlanNullableRelationFilter, ActionPlanWhereInput> | null
    contactsInformation?: XOR<ContactsInformationNullableRelationFilter, ContactsInformationWhereInput> | null
    testingMaintenance?: XOR<TestingMaintenanceNullableRelationFilter, TestingMaintenanceWhereInput> | null
  }

  export type BusinessContinuityPlanOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    planInformation?: PlanInformationOrderByWithRelationInput
    businessOverview?: BusinessOverviewOrderByWithRelationInput
    essentialFunction?: EssentialFunctionOrderByWithRelationInput
    riskAssessment?: RiskAssessmentOrderByWithRelationInput
    strategy?: StrategyOrderByWithRelationInput
    actionPlan?: ActionPlanOrderByWithRelationInput
    contactsInformation?: ContactsInformationOrderByWithRelationInput
    testingMaintenance?: TestingMaintenanceOrderByWithRelationInput
  }

  export type BusinessContinuityPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BusinessContinuityPlanWhereInput | BusinessContinuityPlanWhereInput[]
    OR?: BusinessContinuityPlanWhereInput[]
    NOT?: BusinessContinuityPlanWhereInput | BusinessContinuityPlanWhereInput[]
    createdAt?: DateTimeFilter<"BusinessContinuityPlan"> | Date | string
    updatedAt?: DateTimeFilter<"BusinessContinuityPlan"> | Date | string
    planInformation?: XOR<PlanInformationNullableRelationFilter, PlanInformationWhereInput> | null
    businessOverview?: XOR<BusinessOverviewNullableRelationFilter, BusinessOverviewWhereInput> | null
    essentialFunction?: XOR<EssentialFunctionNullableRelationFilter, EssentialFunctionWhereInput> | null
    riskAssessment?: XOR<RiskAssessmentNullableRelationFilter, RiskAssessmentWhereInput> | null
    strategy?: XOR<StrategyNullableRelationFilter, StrategyWhereInput> | null
    actionPlan?: XOR<ActionPlanNullableRelationFilter, ActionPlanWhereInput> | null
    contactsInformation?: XOR<ContactsInformationNullableRelationFilter, ContactsInformationWhereInput> | null
    testingMaintenance?: XOR<TestingMaintenanceNullableRelationFilter, TestingMaintenanceWhereInput> | null
  }, "id">

  export type BusinessContinuityPlanOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BusinessContinuityPlanCountOrderByAggregateInput
    _max?: BusinessContinuityPlanMaxOrderByAggregateInput
    _min?: BusinessContinuityPlanMinOrderByAggregateInput
  }

  export type BusinessContinuityPlanScalarWhereWithAggregatesInput = {
    AND?: BusinessContinuityPlanScalarWhereWithAggregatesInput | BusinessContinuityPlanScalarWhereWithAggregatesInput[]
    OR?: BusinessContinuityPlanScalarWhereWithAggregatesInput[]
    NOT?: BusinessContinuityPlanScalarWhereWithAggregatesInput | BusinessContinuityPlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BusinessContinuityPlan"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BusinessContinuityPlan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BusinessContinuityPlan"> | Date | string
  }

  export type PlanInformationWhereInput = {
    AND?: PlanInformationWhereInput | PlanInformationWhereInput[]
    OR?: PlanInformationWhereInput[]
    NOT?: PlanInformationWhereInput | PlanInformationWhereInput[]
    id?: StringFilter<"PlanInformation"> | string
    planId?: StringFilter<"PlanInformation"> | string
    companyName?: StringFilter<"PlanInformation"> | string
    planManager?: StringFilter<"PlanInformation"> | string
    alternateManager?: StringNullableFilter<"PlanInformation"> | string | null
    physicalPlanLocation?: StringFilter<"PlanInformation"> | string
    digitalPlanLocation?: StringNullableFilter<"PlanInformation"> | string | null
    plan?: XOR<BusinessContinuityPlanRelationFilter, BusinessContinuityPlanWhereInput>
  }

  export type PlanInformationOrderByWithRelationInput = {
    id?: SortOrder
    planId?: SortOrder
    companyName?: SortOrder
    planManager?: SortOrder
    alternateManager?: SortOrderInput | SortOrder
    physicalPlanLocation?: SortOrder
    digitalPlanLocation?: SortOrderInput | SortOrder
    plan?: BusinessContinuityPlanOrderByWithRelationInput
  }

  export type PlanInformationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    planId?: string
    AND?: PlanInformationWhereInput | PlanInformationWhereInput[]
    OR?: PlanInformationWhereInput[]
    NOT?: PlanInformationWhereInput | PlanInformationWhereInput[]
    companyName?: StringFilter<"PlanInformation"> | string
    planManager?: StringFilter<"PlanInformation"> | string
    alternateManager?: StringNullableFilter<"PlanInformation"> | string | null
    physicalPlanLocation?: StringFilter<"PlanInformation"> | string
    digitalPlanLocation?: StringNullableFilter<"PlanInformation"> | string | null
    plan?: XOR<BusinessContinuityPlanRelationFilter, BusinessContinuityPlanWhereInput>
  }, "id" | "planId">

  export type PlanInformationOrderByWithAggregationInput = {
    id?: SortOrder
    planId?: SortOrder
    companyName?: SortOrder
    planManager?: SortOrder
    alternateManager?: SortOrderInput | SortOrder
    physicalPlanLocation?: SortOrder
    digitalPlanLocation?: SortOrderInput | SortOrder
    _count?: PlanInformationCountOrderByAggregateInput
    _max?: PlanInformationMaxOrderByAggregateInput
    _min?: PlanInformationMinOrderByAggregateInput
  }

  export type PlanInformationScalarWhereWithAggregatesInput = {
    AND?: PlanInformationScalarWhereWithAggregatesInput | PlanInformationScalarWhereWithAggregatesInput[]
    OR?: PlanInformationScalarWhereWithAggregatesInput[]
    NOT?: PlanInformationScalarWhereWithAggregatesInput | PlanInformationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PlanInformation"> | string
    planId?: StringWithAggregatesFilter<"PlanInformation"> | string
    companyName?: StringWithAggregatesFilter<"PlanInformation"> | string
    planManager?: StringWithAggregatesFilter<"PlanInformation"> | string
    alternateManager?: StringNullableWithAggregatesFilter<"PlanInformation"> | string | null
    physicalPlanLocation?: StringWithAggregatesFilter<"PlanInformation"> | string
    digitalPlanLocation?: StringNullableWithAggregatesFilter<"PlanInformation"> | string | null
  }

  export type BusinessOverviewWhereInput = {
    AND?: BusinessOverviewWhereInput | BusinessOverviewWhereInput[]
    OR?: BusinessOverviewWhereInput[]
    NOT?: BusinessOverviewWhereInput | BusinessOverviewWhereInput[]
    id?: StringFilter<"BusinessOverview"> | string
    planId?: StringFilter<"BusinessOverview"> | string
    businessLicenseNumber?: StringFilter<"BusinessOverview"> | string
    businessPurpose?: StringFilter<"BusinessOverview"> | string
    productsAndServices?: StringFilter<"BusinessOverview"> | string
    serviceDeliveryMethods?: StringFilter<"BusinessOverview"> | string
    operatingHours?: StringFilter<"BusinessOverview"> | string
    keyPersonnel?: StringFilter<"BusinessOverview"> | string
    minimumResources?: StringFilter<"BusinessOverview"> | string
    customerBase?: StringFilter<"BusinessOverview"> | string
    serviceProviderBCP?: StringFilter<"BusinessOverview"> | string
    plan?: XOR<BusinessContinuityPlanRelationFilter, BusinessContinuityPlanWhereInput>
  }

  export type BusinessOverviewOrderByWithRelationInput = {
    id?: SortOrder
    planId?: SortOrder
    businessLicenseNumber?: SortOrder
    businessPurpose?: SortOrder
    productsAndServices?: SortOrder
    serviceDeliveryMethods?: SortOrder
    operatingHours?: SortOrder
    keyPersonnel?: SortOrder
    minimumResources?: SortOrder
    customerBase?: SortOrder
    serviceProviderBCP?: SortOrder
    plan?: BusinessContinuityPlanOrderByWithRelationInput
  }

  export type BusinessOverviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    planId?: string
    AND?: BusinessOverviewWhereInput | BusinessOverviewWhereInput[]
    OR?: BusinessOverviewWhereInput[]
    NOT?: BusinessOverviewWhereInput | BusinessOverviewWhereInput[]
    businessLicenseNumber?: StringFilter<"BusinessOverview"> | string
    businessPurpose?: StringFilter<"BusinessOverview"> | string
    productsAndServices?: StringFilter<"BusinessOverview"> | string
    serviceDeliveryMethods?: StringFilter<"BusinessOverview"> | string
    operatingHours?: StringFilter<"BusinessOverview"> | string
    keyPersonnel?: StringFilter<"BusinessOverview"> | string
    minimumResources?: StringFilter<"BusinessOverview"> | string
    customerBase?: StringFilter<"BusinessOverview"> | string
    serviceProviderBCP?: StringFilter<"BusinessOverview"> | string
    plan?: XOR<BusinessContinuityPlanRelationFilter, BusinessContinuityPlanWhereInput>
  }, "id" | "planId">

  export type BusinessOverviewOrderByWithAggregationInput = {
    id?: SortOrder
    planId?: SortOrder
    businessLicenseNumber?: SortOrder
    businessPurpose?: SortOrder
    productsAndServices?: SortOrder
    serviceDeliveryMethods?: SortOrder
    operatingHours?: SortOrder
    keyPersonnel?: SortOrder
    minimumResources?: SortOrder
    customerBase?: SortOrder
    serviceProviderBCP?: SortOrder
    _count?: BusinessOverviewCountOrderByAggregateInput
    _max?: BusinessOverviewMaxOrderByAggregateInput
    _min?: BusinessOverviewMinOrderByAggregateInput
  }

  export type BusinessOverviewScalarWhereWithAggregatesInput = {
    AND?: BusinessOverviewScalarWhereWithAggregatesInput | BusinessOverviewScalarWhereWithAggregatesInput[]
    OR?: BusinessOverviewScalarWhereWithAggregatesInput[]
    NOT?: BusinessOverviewScalarWhereWithAggregatesInput | BusinessOverviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BusinessOverview"> | string
    planId?: StringWithAggregatesFilter<"BusinessOverview"> | string
    businessLicenseNumber?: StringWithAggregatesFilter<"BusinessOverview"> | string
    businessPurpose?: StringWithAggregatesFilter<"BusinessOverview"> | string
    productsAndServices?: StringWithAggregatesFilter<"BusinessOverview"> | string
    serviceDeliveryMethods?: StringWithAggregatesFilter<"BusinessOverview"> | string
    operatingHours?: StringWithAggregatesFilter<"BusinessOverview"> | string
    keyPersonnel?: StringWithAggregatesFilter<"BusinessOverview"> | string
    minimumResources?: StringWithAggregatesFilter<"BusinessOverview"> | string
    customerBase?: StringWithAggregatesFilter<"BusinessOverview"> | string
    serviceProviderBCP?: StringWithAggregatesFilter<"BusinessOverview"> | string
  }

  export type EssentialFunctionWhereInput = {
    AND?: EssentialFunctionWhereInput | EssentialFunctionWhereInput[]
    OR?: EssentialFunctionWhereInput[]
    NOT?: EssentialFunctionWhereInput | EssentialFunctionWhereInput[]
    id?: StringFilter<"EssentialFunction"> | string
    planId?: StringFilter<"EssentialFunction"> | string
    supplyChainManagement?: StringFilter<"EssentialFunction"> | string
    staffManagement?: StringFilter<"EssentialFunction"> | string
    technology?: StringFilter<"EssentialFunction"> | string
    productsServices?: StringFilter<"EssentialFunction"> | string
    infrastructureFacilities?: StringFilter<"EssentialFunction"> | string
    sales?: StringFilter<"EssentialFunction"> | string
    administration?: StringFilter<"EssentialFunction"> | string
    plan?: XOR<BusinessContinuityPlanRelationFilter, BusinessContinuityPlanWhereInput>
  }

  export type EssentialFunctionOrderByWithRelationInput = {
    id?: SortOrder
    planId?: SortOrder
    supplyChainManagement?: SortOrder
    staffManagement?: SortOrder
    technology?: SortOrder
    productsServices?: SortOrder
    infrastructureFacilities?: SortOrder
    sales?: SortOrder
    administration?: SortOrder
    plan?: BusinessContinuityPlanOrderByWithRelationInput
  }

  export type EssentialFunctionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    planId?: string
    AND?: EssentialFunctionWhereInput | EssentialFunctionWhereInput[]
    OR?: EssentialFunctionWhereInput[]
    NOT?: EssentialFunctionWhereInput | EssentialFunctionWhereInput[]
    supplyChainManagement?: StringFilter<"EssentialFunction"> | string
    staffManagement?: StringFilter<"EssentialFunction"> | string
    technology?: StringFilter<"EssentialFunction"> | string
    productsServices?: StringFilter<"EssentialFunction"> | string
    infrastructureFacilities?: StringFilter<"EssentialFunction"> | string
    sales?: StringFilter<"EssentialFunction"> | string
    administration?: StringFilter<"EssentialFunction"> | string
    plan?: XOR<BusinessContinuityPlanRelationFilter, BusinessContinuityPlanWhereInput>
  }, "id" | "planId">

  export type EssentialFunctionOrderByWithAggregationInput = {
    id?: SortOrder
    planId?: SortOrder
    supplyChainManagement?: SortOrder
    staffManagement?: SortOrder
    technology?: SortOrder
    productsServices?: SortOrder
    infrastructureFacilities?: SortOrder
    sales?: SortOrder
    administration?: SortOrder
    _count?: EssentialFunctionCountOrderByAggregateInput
    _max?: EssentialFunctionMaxOrderByAggregateInput
    _min?: EssentialFunctionMinOrderByAggregateInput
  }

  export type EssentialFunctionScalarWhereWithAggregatesInput = {
    AND?: EssentialFunctionScalarWhereWithAggregatesInput | EssentialFunctionScalarWhereWithAggregatesInput[]
    OR?: EssentialFunctionScalarWhereWithAggregatesInput[]
    NOT?: EssentialFunctionScalarWhereWithAggregatesInput | EssentialFunctionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EssentialFunction"> | string
    planId?: StringWithAggregatesFilter<"EssentialFunction"> | string
    supplyChainManagement?: StringWithAggregatesFilter<"EssentialFunction"> | string
    staffManagement?: StringWithAggregatesFilter<"EssentialFunction"> | string
    technology?: StringWithAggregatesFilter<"EssentialFunction"> | string
    productsServices?: StringWithAggregatesFilter<"EssentialFunction"> | string
    infrastructureFacilities?: StringWithAggregatesFilter<"EssentialFunction"> | string
    sales?: StringWithAggregatesFilter<"EssentialFunction"> | string
    administration?: StringWithAggregatesFilter<"EssentialFunction"> | string
  }

  export type RiskAssessmentWhereInput = {
    AND?: RiskAssessmentWhereInput | RiskAssessmentWhereInput[]
    OR?: RiskAssessmentWhereInput[]
    NOT?: RiskAssessmentWhereInput | RiskAssessmentWhereInput[]
    id?: StringFilter<"RiskAssessment"> | string
    planId?: StringFilter<"RiskAssessment"> | string
    potentialHazards?: StringFilter<"RiskAssessment"> | string
    hazards?: StringFilter<"RiskAssessment"> | string
    plan?: XOR<BusinessContinuityPlanRelationFilter, BusinessContinuityPlanWhereInput>
  }

  export type RiskAssessmentOrderByWithRelationInput = {
    id?: SortOrder
    planId?: SortOrder
    potentialHazards?: SortOrder
    hazards?: SortOrder
    plan?: BusinessContinuityPlanOrderByWithRelationInput
  }

  export type RiskAssessmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    planId?: string
    AND?: RiskAssessmentWhereInput | RiskAssessmentWhereInput[]
    OR?: RiskAssessmentWhereInput[]
    NOT?: RiskAssessmentWhereInput | RiskAssessmentWhereInput[]
    potentialHazards?: StringFilter<"RiskAssessment"> | string
    hazards?: StringFilter<"RiskAssessment"> | string
    plan?: XOR<BusinessContinuityPlanRelationFilter, BusinessContinuityPlanWhereInput>
  }, "id" | "planId">

  export type RiskAssessmentOrderByWithAggregationInput = {
    id?: SortOrder
    planId?: SortOrder
    potentialHazards?: SortOrder
    hazards?: SortOrder
    _count?: RiskAssessmentCountOrderByAggregateInput
    _max?: RiskAssessmentMaxOrderByAggregateInput
    _min?: RiskAssessmentMinOrderByAggregateInput
  }

  export type RiskAssessmentScalarWhereWithAggregatesInput = {
    AND?: RiskAssessmentScalarWhereWithAggregatesInput | RiskAssessmentScalarWhereWithAggregatesInput[]
    OR?: RiskAssessmentScalarWhereWithAggregatesInput[]
    NOT?: RiskAssessmentScalarWhereWithAggregatesInput | RiskAssessmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RiskAssessment"> | string
    planId?: StringWithAggregatesFilter<"RiskAssessment"> | string
    potentialHazards?: StringWithAggregatesFilter<"RiskAssessment"> | string
    hazards?: StringWithAggregatesFilter<"RiskAssessment"> | string
  }

  export type StrategyWhereInput = {
    AND?: StrategyWhereInput | StrategyWhereInput[]
    OR?: StrategyWhereInput[]
    NOT?: StrategyWhereInput | StrategyWhereInput[]
    id?: StringFilter<"Strategy"> | string
    planId?: StringFilter<"Strategy"> | string
    preventionStrategies?: StringFilter<"Strategy"> | string
    responseStrategies?: StringFilter<"Strategy"> | string
    recoveryStrategies?: StringFilter<"Strategy"> | string
    longTermRiskReduction?: StringFilter<"Strategy"> | string
    plan?: XOR<BusinessContinuityPlanRelationFilter, BusinessContinuityPlanWhereInput>
  }

  export type StrategyOrderByWithRelationInput = {
    id?: SortOrder
    planId?: SortOrder
    preventionStrategies?: SortOrder
    responseStrategies?: SortOrder
    recoveryStrategies?: SortOrder
    longTermRiskReduction?: SortOrder
    plan?: BusinessContinuityPlanOrderByWithRelationInput
  }

  export type StrategyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    planId?: string
    AND?: StrategyWhereInput | StrategyWhereInput[]
    OR?: StrategyWhereInput[]
    NOT?: StrategyWhereInput | StrategyWhereInput[]
    preventionStrategies?: StringFilter<"Strategy"> | string
    responseStrategies?: StringFilter<"Strategy"> | string
    recoveryStrategies?: StringFilter<"Strategy"> | string
    longTermRiskReduction?: StringFilter<"Strategy"> | string
    plan?: XOR<BusinessContinuityPlanRelationFilter, BusinessContinuityPlanWhereInput>
  }, "id" | "planId">

  export type StrategyOrderByWithAggregationInput = {
    id?: SortOrder
    planId?: SortOrder
    preventionStrategies?: SortOrder
    responseStrategies?: SortOrder
    recoveryStrategies?: SortOrder
    longTermRiskReduction?: SortOrder
    _count?: StrategyCountOrderByAggregateInput
    _max?: StrategyMaxOrderByAggregateInput
    _min?: StrategyMinOrderByAggregateInput
  }

  export type StrategyScalarWhereWithAggregatesInput = {
    AND?: StrategyScalarWhereWithAggregatesInput | StrategyScalarWhereWithAggregatesInput[]
    OR?: StrategyScalarWhereWithAggregatesInput[]
    NOT?: StrategyScalarWhereWithAggregatesInput | StrategyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Strategy"> | string
    planId?: StringWithAggregatesFilter<"Strategy"> | string
    preventionStrategies?: StringWithAggregatesFilter<"Strategy"> | string
    responseStrategies?: StringWithAggregatesFilter<"Strategy"> | string
    recoveryStrategies?: StringWithAggregatesFilter<"Strategy"> | string
    longTermRiskReduction?: StringWithAggregatesFilter<"Strategy"> | string
  }

  export type ActionPlanWhereInput = {
    AND?: ActionPlanWhereInput | ActionPlanWhereInput[]
    OR?: ActionPlanWhereInput[]
    NOT?: ActionPlanWhereInput | ActionPlanWhereInput[]
    id?: StringFilter<"ActionPlan"> | string
    planId?: StringFilter<"ActionPlan"> | string
    actionPlanByRisk?: StringFilter<"ActionPlan"> | string
    implementationTimeline?: StringFilter<"ActionPlan"> | string
    resourceRequirements?: StringFilter<"ActionPlan"> | string
    responsibleParties?: StringFilter<"ActionPlan"> | string
    reviewUpdateSchedule?: StringFilter<"ActionPlan"> | string
    testingAssessmentPlan?: StringFilter<"ActionPlan"> | string
    plan?: XOR<BusinessContinuityPlanRelationFilter, BusinessContinuityPlanWhereInput>
  }

  export type ActionPlanOrderByWithRelationInput = {
    id?: SortOrder
    planId?: SortOrder
    actionPlanByRisk?: SortOrder
    implementationTimeline?: SortOrder
    resourceRequirements?: SortOrder
    responsibleParties?: SortOrder
    reviewUpdateSchedule?: SortOrder
    testingAssessmentPlan?: SortOrder
    plan?: BusinessContinuityPlanOrderByWithRelationInput
  }

  export type ActionPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    planId?: string
    AND?: ActionPlanWhereInput | ActionPlanWhereInput[]
    OR?: ActionPlanWhereInput[]
    NOT?: ActionPlanWhereInput | ActionPlanWhereInput[]
    actionPlanByRisk?: StringFilter<"ActionPlan"> | string
    implementationTimeline?: StringFilter<"ActionPlan"> | string
    resourceRequirements?: StringFilter<"ActionPlan"> | string
    responsibleParties?: StringFilter<"ActionPlan"> | string
    reviewUpdateSchedule?: StringFilter<"ActionPlan"> | string
    testingAssessmentPlan?: StringFilter<"ActionPlan"> | string
    plan?: XOR<BusinessContinuityPlanRelationFilter, BusinessContinuityPlanWhereInput>
  }, "id" | "planId">

  export type ActionPlanOrderByWithAggregationInput = {
    id?: SortOrder
    planId?: SortOrder
    actionPlanByRisk?: SortOrder
    implementationTimeline?: SortOrder
    resourceRequirements?: SortOrder
    responsibleParties?: SortOrder
    reviewUpdateSchedule?: SortOrder
    testingAssessmentPlan?: SortOrder
    _count?: ActionPlanCountOrderByAggregateInput
    _max?: ActionPlanMaxOrderByAggregateInput
    _min?: ActionPlanMinOrderByAggregateInput
  }

  export type ActionPlanScalarWhereWithAggregatesInput = {
    AND?: ActionPlanScalarWhereWithAggregatesInput | ActionPlanScalarWhereWithAggregatesInput[]
    OR?: ActionPlanScalarWhereWithAggregatesInput[]
    NOT?: ActionPlanScalarWhereWithAggregatesInput | ActionPlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ActionPlan"> | string
    planId?: StringWithAggregatesFilter<"ActionPlan"> | string
    actionPlanByRisk?: StringWithAggregatesFilter<"ActionPlan"> | string
    implementationTimeline?: StringWithAggregatesFilter<"ActionPlan"> | string
    resourceRequirements?: StringWithAggregatesFilter<"ActionPlan"> | string
    responsibleParties?: StringWithAggregatesFilter<"ActionPlan"> | string
    reviewUpdateSchedule?: StringWithAggregatesFilter<"ActionPlan"> | string
    testingAssessmentPlan?: StringWithAggregatesFilter<"ActionPlan"> | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    currentStep?: StringFilter<"Session"> | string
    stepData?: StringFilter<"Session"> | string
    businessProfile?: XOR<BusinessProfileNullableRelationFilter, BusinessProfileWhereInput> | null
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currentStep?: SortOrder
    stepData?: SortOrder
    businessProfile?: BusinessProfileOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    currentStep?: StringFilter<"Session"> | string
    stepData?: StringFilter<"Session"> | string
    businessProfile?: XOR<BusinessProfileNullableRelationFilter, BusinessProfileWhereInput> | null
  }, "id">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currentStep?: SortOrder
    stepData?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    currentStep?: StringWithAggregatesFilter<"Session"> | string
    stepData?: StringWithAggregatesFilter<"Session"> | string
  }

  export type BusinessProfileWhereInput = {
    AND?: BusinessProfileWhereInput | BusinessProfileWhereInput[]
    OR?: BusinessProfileWhereInput[]
    NOT?: BusinessProfileWhereInput | BusinessProfileWhereInput[]
    id?: StringFilter<"BusinessProfile"> | string
    sessionId?: StringFilter<"BusinessProfile"> | string
    name?: StringFilter<"BusinessProfile"> | string
    industry?: StringFilter<"BusinessProfile"> | string
    size?: StringFilter<"BusinessProfile"> | string
    location?: StringFilter<"BusinessProfile"> | string
    session?: XOR<SessionRelationFilter, SessionWhereInput>
  }

  export type BusinessProfileOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    name?: SortOrder
    industry?: SortOrder
    size?: SortOrder
    location?: SortOrder
    session?: SessionOrderByWithRelationInput
  }

  export type BusinessProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionId?: string
    AND?: BusinessProfileWhereInput | BusinessProfileWhereInput[]
    OR?: BusinessProfileWhereInput[]
    NOT?: BusinessProfileWhereInput | BusinessProfileWhereInput[]
    name?: StringFilter<"BusinessProfile"> | string
    industry?: StringFilter<"BusinessProfile"> | string
    size?: StringFilter<"BusinessProfile"> | string
    location?: StringFilter<"BusinessProfile"> | string
    session?: XOR<SessionRelationFilter, SessionWhereInput>
  }, "id" | "sessionId">

  export type BusinessProfileOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    name?: SortOrder
    industry?: SortOrder
    size?: SortOrder
    location?: SortOrder
    _count?: BusinessProfileCountOrderByAggregateInput
    _max?: BusinessProfileMaxOrderByAggregateInput
    _min?: BusinessProfileMinOrderByAggregateInput
  }

  export type BusinessProfileScalarWhereWithAggregatesInput = {
    AND?: BusinessProfileScalarWhereWithAggregatesInput | BusinessProfileScalarWhereWithAggregatesInput[]
    OR?: BusinessProfileScalarWhereWithAggregatesInput[]
    NOT?: BusinessProfileScalarWhereWithAggregatesInput | BusinessProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BusinessProfile"> | string
    sessionId?: StringWithAggregatesFilter<"BusinessProfile"> | string
    name?: StringWithAggregatesFilter<"BusinessProfile"> | string
    industry?: StringWithAggregatesFilter<"BusinessProfile"> | string
    size?: StringWithAggregatesFilter<"BusinessProfile"> | string
    location?: StringWithAggregatesFilter<"BusinessProfile"> | string
  }

  export type ContactsInformationWhereInput = {
    AND?: ContactsInformationWhereInput | ContactsInformationWhereInput[]
    OR?: ContactsInformationWhereInput[]
    NOT?: ContactsInformationWhereInput | ContactsInformationWhereInput[]
    id?: StringFilter<"ContactsInformation"> | string
    planId?: StringFilter<"ContactsInformation"> | string
    staffContactInfo?: StringFilter<"ContactsInformation"> | string
    keyCustomerContacts?: StringFilter<"ContactsInformation"> | string
    supplierInformation?: StringFilter<"ContactsInformation"> | string
    emergencyServicesUtilities?: StringFilter<"ContactsInformation"> | string
    criticalBusinessInfo?: StringFilter<"ContactsInformation"> | string
    planDistributionList?: StringFilter<"ContactsInformation"> | string
    plan?: XOR<BusinessContinuityPlanRelationFilter, BusinessContinuityPlanWhereInput>
  }

  export type ContactsInformationOrderByWithRelationInput = {
    id?: SortOrder
    planId?: SortOrder
    staffContactInfo?: SortOrder
    keyCustomerContacts?: SortOrder
    supplierInformation?: SortOrder
    emergencyServicesUtilities?: SortOrder
    criticalBusinessInfo?: SortOrder
    planDistributionList?: SortOrder
    plan?: BusinessContinuityPlanOrderByWithRelationInput
  }

  export type ContactsInformationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    planId?: string
    AND?: ContactsInformationWhereInput | ContactsInformationWhereInput[]
    OR?: ContactsInformationWhereInput[]
    NOT?: ContactsInformationWhereInput | ContactsInformationWhereInput[]
    staffContactInfo?: StringFilter<"ContactsInformation"> | string
    keyCustomerContacts?: StringFilter<"ContactsInformation"> | string
    supplierInformation?: StringFilter<"ContactsInformation"> | string
    emergencyServicesUtilities?: StringFilter<"ContactsInformation"> | string
    criticalBusinessInfo?: StringFilter<"ContactsInformation"> | string
    planDistributionList?: StringFilter<"ContactsInformation"> | string
    plan?: XOR<BusinessContinuityPlanRelationFilter, BusinessContinuityPlanWhereInput>
  }, "id" | "planId">

  export type ContactsInformationOrderByWithAggregationInput = {
    id?: SortOrder
    planId?: SortOrder
    staffContactInfo?: SortOrder
    keyCustomerContacts?: SortOrder
    supplierInformation?: SortOrder
    emergencyServicesUtilities?: SortOrder
    criticalBusinessInfo?: SortOrder
    planDistributionList?: SortOrder
    _count?: ContactsInformationCountOrderByAggregateInput
    _max?: ContactsInformationMaxOrderByAggregateInput
    _min?: ContactsInformationMinOrderByAggregateInput
  }

  export type ContactsInformationScalarWhereWithAggregatesInput = {
    AND?: ContactsInformationScalarWhereWithAggregatesInput | ContactsInformationScalarWhereWithAggregatesInput[]
    OR?: ContactsInformationScalarWhereWithAggregatesInput[]
    NOT?: ContactsInformationScalarWhereWithAggregatesInput | ContactsInformationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContactsInformation"> | string
    planId?: StringWithAggregatesFilter<"ContactsInformation"> | string
    staffContactInfo?: StringWithAggregatesFilter<"ContactsInformation"> | string
    keyCustomerContacts?: StringWithAggregatesFilter<"ContactsInformation"> | string
    supplierInformation?: StringWithAggregatesFilter<"ContactsInformation"> | string
    emergencyServicesUtilities?: StringWithAggregatesFilter<"ContactsInformation"> | string
    criticalBusinessInfo?: StringWithAggregatesFilter<"ContactsInformation"> | string
    planDistributionList?: StringWithAggregatesFilter<"ContactsInformation"> | string
  }

  export type TestingMaintenanceWhereInput = {
    AND?: TestingMaintenanceWhereInput | TestingMaintenanceWhereInput[]
    OR?: TestingMaintenanceWhereInput[]
    NOT?: TestingMaintenanceWhereInput | TestingMaintenanceWhereInput[]
    id?: StringFilter<"TestingMaintenance"> | string
    planId?: StringFilter<"TestingMaintenance"> | string
    planTestingSchedule?: StringFilter<"TestingMaintenance"> | string
    planRevisionHistory?: StringFilter<"TestingMaintenance"> | string
    improvementTracking?: StringFilter<"TestingMaintenance"> | string
    annualReviewProcess?: StringFilter<"TestingMaintenance"> | string
    triggerEventsForUpdates?: StringFilter<"TestingMaintenance"> | string
    plan?: XOR<BusinessContinuityPlanRelationFilter, BusinessContinuityPlanWhereInput>
  }

  export type TestingMaintenanceOrderByWithRelationInput = {
    id?: SortOrder
    planId?: SortOrder
    planTestingSchedule?: SortOrder
    planRevisionHistory?: SortOrder
    improvementTracking?: SortOrder
    annualReviewProcess?: SortOrder
    triggerEventsForUpdates?: SortOrder
    plan?: BusinessContinuityPlanOrderByWithRelationInput
  }

  export type TestingMaintenanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    planId?: string
    AND?: TestingMaintenanceWhereInput | TestingMaintenanceWhereInput[]
    OR?: TestingMaintenanceWhereInput[]
    NOT?: TestingMaintenanceWhereInput | TestingMaintenanceWhereInput[]
    planTestingSchedule?: StringFilter<"TestingMaintenance"> | string
    planRevisionHistory?: StringFilter<"TestingMaintenance"> | string
    improvementTracking?: StringFilter<"TestingMaintenance"> | string
    annualReviewProcess?: StringFilter<"TestingMaintenance"> | string
    triggerEventsForUpdates?: StringFilter<"TestingMaintenance"> | string
    plan?: XOR<BusinessContinuityPlanRelationFilter, BusinessContinuityPlanWhereInput>
  }, "id" | "planId">

  export type TestingMaintenanceOrderByWithAggregationInput = {
    id?: SortOrder
    planId?: SortOrder
    planTestingSchedule?: SortOrder
    planRevisionHistory?: SortOrder
    improvementTracking?: SortOrder
    annualReviewProcess?: SortOrder
    triggerEventsForUpdates?: SortOrder
    _count?: TestingMaintenanceCountOrderByAggregateInput
    _max?: TestingMaintenanceMaxOrderByAggregateInput
    _min?: TestingMaintenanceMinOrderByAggregateInput
  }

  export type TestingMaintenanceScalarWhereWithAggregatesInput = {
    AND?: TestingMaintenanceScalarWhereWithAggregatesInput | TestingMaintenanceScalarWhereWithAggregatesInput[]
    OR?: TestingMaintenanceScalarWhereWithAggregatesInput[]
    NOT?: TestingMaintenanceScalarWhereWithAggregatesInput | TestingMaintenanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TestingMaintenance"> | string
    planId?: StringWithAggregatesFilter<"TestingMaintenance"> | string
    planTestingSchedule?: StringWithAggregatesFilter<"TestingMaintenance"> | string
    planRevisionHistory?: StringWithAggregatesFilter<"TestingMaintenance"> | string
    improvementTracking?: StringWithAggregatesFilter<"TestingMaintenance"> | string
    annualReviewProcess?: StringWithAggregatesFilter<"TestingMaintenance"> | string
    triggerEventsForUpdates?: StringWithAggregatesFilter<"TestingMaintenance"> | string
  }

  export type AnonymousSessionWhereInput = {
    AND?: AnonymousSessionWhereInput | AnonymousSessionWhereInput[]
    OR?: AnonymousSessionWhereInput[]
    NOT?: AnonymousSessionWhereInput | AnonymousSessionWhereInput[]
    id?: StringFilter<"AnonymousSession"> | string
    sessionId?: StringFilter<"AnonymousSession"> | string
    businessName?: StringFilter<"AnonymousSession"> | string
    displayBusinessName?: StringFilter<"AnonymousSession"> | string
    pin?: StringFilter<"AnonymousSession"> | string
    email?: StringNullableFilter<"AnonymousSession"> | string | null
    planData?: StringFilter<"AnonymousSession"> | string
    shareableId?: StringNullableFilter<"AnonymousSession"> | string | null
    allowSharing?: BoolFilter<"AnonymousSession"> | boolean
    createdAt?: DateTimeFilter<"AnonymousSession"> | Date | string
    lastAccessed?: DateTimeFilter<"AnonymousSession"> | Date | string
  }

  export type AnonymousSessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    businessName?: SortOrder
    displayBusinessName?: SortOrder
    pin?: SortOrder
    email?: SortOrderInput | SortOrder
    planData?: SortOrder
    shareableId?: SortOrderInput | SortOrder
    allowSharing?: SortOrder
    createdAt?: SortOrder
    lastAccessed?: SortOrder
  }

  export type AnonymousSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionId?: string
    businessName_pin?: AnonymousSessionBusinessNamePinCompoundUniqueInput
    AND?: AnonymousSessionWhereInput | AnonymousSessionWhereInput[]
    OR?: AnonymousSessionWhereInput[]
    NOT?: AnonymousSessionWhereInput | AnonymousSessionWhereInput[]
    businessName?: StringFilter<"AnonymousSession"> | string
    displayBusinessName?: StringFilter<"AnonymousSession"> | string
    pin?: StringFilter<"AnonymousSession"> | string
    email?: StringNullableFilter<"AnonymousSession"> | string | null
    planData?: StringFilter<"AnonymousSession"> | string
    shareableId?: StringNullableFilter<"AnonymousSession"> | string | null
    allowSharing?: BoolFilter<"AnonymousSession"> | boolean
    createdAt?: DateTimeFilter<"AnonymousSession"> | Date | string
    lastAccessed?: DateTimeFilter<"AnonymousSession"> | Date | string
  }, "id" | "sessionId" | "businessName_pin">

  export type AnonymousSessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    businessName?: SortOrder
    displayBusinessName?: SortOrder
    pin?: SortOrder
    email?: SortOrderInput | SortOrder
    planData?: SortOrder
    shareableId?: SortOrderInput | SortOrder
    allowSharing?: SortOrder
    createdAt?: SortOrder
    lastAccessed?: SortOrder
    _count?: AnonymousSessionCountOrderByAggregateInput
    _max?: AnonymousSessionMaxOrderByAggregateInput
    _min?: AnonymousSessionMinOrderByAggregateInput
  }

  export type AnonymousSessionScalarWhereWithAggregatesInput = {
    AND?: AnonymousSessionScalarWhereWithAggregatesInput | AnonymousSessionScalarWhereWithAggregatesInput[]
    OR?: AnonymousSessionScalarWhereWithAggregatesInput[]
    NOT?: AnonymousSessionScalarWhereWithAggregatesInput | AnonymousSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AnonymousSession"> | string
    sessionId?: StringWithAggregatesFilter<"AnonymousSession"> | string
    businessName?: StringWithAggregatesFilter<"AnonymousSession"> | string
    displayBusinessName?: StringWithAggregatesFilter<"AnonymousSession"> | string
    pin?: StringWithAggregatesFilter<"AnonymousSession"> | string
    email?: StringNullableWithAggregatesFilter<"AnonymousSession"> | string | null
    planData?: StringWithAggregatesFilter<"AnonymousSession"> | string
    shareableId?: StringNullableWithAggregatesFilter<"AnonymousSession"> | string | null
    allowSharing?: BoolWithAggregatesFilter<"AnonymousSession"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AnonymousSession"> | Date | string
    lastAccessed?: DateTimeWithAggregatesFilter<"AnonymousSession"> | Date | string
  }

  export type AdminBusinessTypeWhereInput = {
    AND?: AdminBusinessTypeWhereInput | AdminBusinessTypeWhereInput[]
    OR?: AdminBusinessTypeWhereInput[]
    NOT?: AdminBusinessTypeWhereInput | AdminBusinessTypeWhereInput[]
    id?: StringFilter<"AdminBusinessType"> | string
    businessTypeId?: StringFilter<"AdminBusinessType"> | string
    name?: StringFilter<"AdminBusinessType"> | string
    localName?: StringFilter<"AdminBusinessType"> | string
    category?: StringFilter<"AdminBusinessType"> | string
    description?: StringNullableFilter<"AdminBusinessType"> | string | null
    typicalOperatingHours?: StringNullableFilter<"AdminBusinessType"> | string | null
    minimumStaff?: StringNullableFilter<"AdminBusinessType"> | string | null
    minimumEquipment?: StringNullableFilter<"AdminBusinessType"> | string | null
    minimumUtilities?: StringNullableFilter<"AdminBusinessType"> | string | null
    minimumSpace?: StringNullableFilter<"AdminBusinessType"> | string | null
    essentialFunctions?: StringNullableFilter<"AdminBusinessType"> | string | null
    criticalSuppliers?: StringNullableFilter<"AdminBusinessType"> | string | null
    exampleBusinessPurposes?: StringNullableFilter<"AdminBusinessType"> | string | null
    exampleProducts?: StringNullableFilter<"AdminBusinessType"> | string | null
    exampleKeyPersonnel?: StringNullableFilter<"AdminBusinessType"> | string | null
    exampleCustomerBase?: StringNullableFilter<"AdminBusinessType"> | string | null
    dependencies?: StringNullableFilter<"AdminBusinessType"> | string | null
    vulnerabilityMatrix?: StringNullableFilter<"AdminBusinessType"> | string | null
    operationalThresholds?: StringNullableFilter<"AdminBusinessType"> | string | null
    isActive?: BoolFilter<"AdminBusinessType"> | boolean
    createdAt?: DateTimeFilter<"AdminBusinessType"> | Date | string
    updatedAt?: DateTimeFilter<"AdminBusinessType"> | Date | string
    businessTypeHazards?: AdminBusinessTypeHazardListRelationFilter
    riskProfiles?: AdminRiskProfileListRelationFilter
  }

  export type AdminBusinessTypeOrderByWithRelationInput = {
    id?: SortOrder
    businessTypeId?: SortOrder
    name?: SortOrder
    localName?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    typicalOperatingHours?: SortOrderInput | SortOrder
    minimumStaff?: SortOrderInput | SortOrder
    minimumEquipment?: SortOrderInput | SortOrder
    minimumUtilities?: SortOrderInput | SortOrder
    minimumSpace?: SortOrderInput | SortOrder
    essentialFunctions?: SortOrderInput | SortOrder
    criticalSuppliers?: SortOrderInput | SortOrder
    exampleBusinessPurposes?: SortOrderInput | SortOrder
    exampleProducts?: SortOrderInput | SortOrder
    exampleKeyPersonnel?: SortOrderInput | SortOrder
    exampleCustomerBase?: SortOrderInput | SortOrder
    dependencies?: SortOrderInput | SortOrder
    vulnerabilityMatrix?: SortOrderInput | SortOrder
    operationalThresholds?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    businessTypeHazards?: AdminBusinessTypeHazardOrderByRelationAggregateInput
    riskProfiles?: AdminRiskProfileOrderByRelationAggregateInput
  }

  export type AdminBusinessTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    businessTypeId?: string
    AND?: AdminBusinessTypeWhereInput | AdminBusinessTypeWhereInput[]
    OR?: AdminBusinessTypeWhereInput[]
    NOT?: AdminBusinessTypeWhereInput | AdminBusinessTypeWhereInput[]
    name?: StringFilter<"AdminBusinessType"> | string
    localName?: StringFilter<"AdminBusinessType"> | string
    category?: StringFilter<"AdminBusinessType"> | string
    description?: StringNullableFilter<"AdminBusinessType"> | string | null
    typicalOperatingHours?: StringNullableFilter<"AdminBusinessType"> | string | null
    minimumStaff?: StringNullableFilter<"AdminBusinessType"> | string | null
    minimumEquipment?: StringNullableFilter<"AdminBusinessType"> | string | null
    minimumUtilities?: StringNullableFilter<"AdminBusinessType"> | string | null
    minimumSpace?: StringNullableFilter<"AdminBusinessType"> | string | null
    essentialFunctions?: StringNullableFilter<"AdminBusinessType"> | string | null
    criticalSuppliers?: StringNullableFilter<"AdminBusinessType"> | string | null
    exampleBusinessPurposes?: StringNullableFilter<"AdminBusinessType"> | string | null
    exampleProducts?: StringNullableFilter<"AdminBusinessType"> | string | null
    exampleKeyPersonnel?: StringNullableFilter<"AdminBusinessType"> | string | null
    exampleCustomerBase?: StringNullableFilter<"AdminBusinessType"> | string | null
    dependencies?: StringNullableFilter<"AdminBusinessType"> | string | null
    vulnerabilityMatrix?: StringNullableFilter<"AdminBusinessType"> | string | null
    operationalThresholds?: StringNullableFilter<"AdminBusinessType"> | string | null
    isActive?: BoolFilter<"AdminBusinessType"> | boolean
    createdAt?: DateTimeFilter<"AdminBusinessType"> | Date | string
    updatedAt?: DateTimeFilter<"AdminBusinessType"> | Date | string
    businessTypeHazards?: AdminBusinessTypeHazardListRelationFilter
    riskProfiles?: AdminRiskProfileListRelationFilter
  }, "id" | "businessTypeId">

  export type AdminBusinessTypeOrderByWithAggregationInput = {
    id?: SortOrder
    businessTypeId?: SortOrder
    name?: SortOrder
    localName?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    typicalOperatingHours?: SortOrderInput | SortOrder
    minimumStaff?: SortOrderInput | SortOrder
    minimumEquipment?: SortOrderInput | SortOrder
    minimumUtilities?: SortOrderInput | SortOrder
    minimumSpace?: SortOrderInput | SortOrder
    essentialFunctions?: SortOrderInput | SortOrder
    criticalSuppliers?: SortOrderInput | SortOrder
    exampleBusinessPurposes?: SortOrderInput | SortOrder
    exampleProducts?: SortOrderInput | SortOrder
    exampleKeyPersonnel?: SortOrderInput | SortOrder
    exampleCustomerBase?: SortOrderInput | SortOrder
    dependencies?: SortOrderInput | SortOrder
    vulnerabilityMatrix?: SortOrderInput | SortOrder
    operationalThresholds?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdminBusinessTypeCountOrderByAggregateInput
    _max?: AdminBusinessTypeMaxOrderByAggregateInput
    _min?: AdminBusinessTypeMinOrderByAggregateInput
  }

  export type AdminBusinessTypeScalarWhereWithAggregatesInput = {
    AND?: AdminBusinessTypeScalarWhereWithAggregatesInput | AdminBusinessTypeScalarWhereWithAggregatesInput[]
    OR?: AdminBusinessTypeScalarWhereWithAggregatesInput[]
    NOT?: AdminBusinessTypeScalarWhereWithAggregatesInput | AdminBusinessTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminBusinessType"> | string
    businessTypeId?: StringWithAggregatesFilter<"AdminBusinessType"> | string
    name?: StringWithAggregatesFilter<"AdminBusinessType"> | string
    localName?: StringWithAggregatesFilter<"AdminBusinessType"> | string
    category?: StringWithAggregatesFilter<"AdminBusinessType"> | string
    description?: StringNullableWithAggregatesFilter<"AdminBusinessType"> | string | null
    typicalOperatingHours?: StringNullableWithAggregatesFilter<"AdminBusinessType"> | string | null
    minimumStaff?: StringNullableWithAggregatesFilter<"AdminBusinessType"> | string | null
    minimumEquipment?: StringNullableWithAggregatesFilter<"AdminBusinessType"> | string | null
    minimumUtilities?: StringNullableWithAggregatesFilter<"AdminBusinessType"> | string | null
    minimumSpace?: StringNullableWithAggregatesFilter<"AdminBusinessType"> | string | null
    essentialFunctions?: StringNullableWithAggregatesFilter<"AdminBusinessType"> | string | null
    criticalSuppliers?: StringNullableWithAggregatesFilter<"AdminBusinessType"> | string | null
    exampleBusinessPurposes?: StringNullableWithAggregatesFilter<"AdminBusinessType"> | string | null
    exampleProducts?: StringNullableWithAggregatesFilter<"AdminBusinessType"> | string | null
    exampleKeyPersonnel?: StringNullableWithAggregatesFilter<"AdminBusinessType"> | string | null
    exampleCustomerBase?: StringNullableWithAggregatesFilter<"AdminBusinessType"> | string | null
    dependencies?: StringNullableWithAggregatesFilter<"AdminBusinessType"> | string | null
    vulnerabilityMatrix?: StringNullableWithAggregatesFilter<"AdminBusinessType"> | string | null
    operationalThresholds?: StringNullableWithAggregatesFilter<"AdminBusinessType"> | string | null
    isActive?: BoolWithAggregatesFilter<"AdminBusinessType"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AdminBusinessType"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AdminBusinessType"> | Date | string
  }

  export type AdminHazardTypeWhereInput = {
    AND?: AdminHazardTypeWhereInput | AdminHazardTypeWhereInput[]
    OR?: AdminHazardTypeWhereInput[]
    NOT?: AdminHazardTypeWhereInput | AdminHazardTypeWhereInput[]
    id?: StringFilter<"AdminHazardType"> | string
    hazardId?: StringFilter<"AdminHazardType"> | string
    name?: StringFilter<"AdminHazardType"> | string
    category?: StringFilter<"AdminHazardType"> | string
    description?: StringNullableFilter<"AdminHazardType"> | string | null
    defaultFrequency?: StringFilter<"AdminHazardType"> | string
    defaultImpact?: StringFilter<"AdminHazardType"> | string
    seasonalPattern?: StringNullableFilter<"AdminHazardType"> | string | null
    peakMonths?: StringNullableFilter<"AdminHazardType"> | string | null
    warningTime?: StringNullableFilter<"AdminHazardType"> | string | null
    geographicScope?: StringNullableFilter<"AdminHazardType"> | string | null
    cascadingRisks?: StringNullableFilter<"AdminHazardType"> | string | null
    isActive?: BoolFilter<"AdminHazardType"> | boolean
    createdAt?: DateTimeFilter<"AdminHazardType"> | Date | string
    updatedAt?: DateTimeFilter<"AdminHazardType"> | Date | string
    businessTypeHazards?: AdminBusinessTypeHazardListRelationFilter
    locationHazards?: AdminLocationHazardListRelationFilter
    hazardStrategies?: AdminHazardStrategyListRelationFilter
    hazardActionPlans?: AdminHazardActionPlanListRelationFilter
    AdminActionPlan?: XOR<AdminActionPlanNullableRelationFilter, AdminActionPlanWhereInput> | null
    translations?: HazardTranslationListRelationFilter
  }

  export type AdminHazardTypeOrderByWithRelationInput = {
    id?: SortOrder
    hazardId?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    defaultFrequency?: SortOrder
    defaultImpact?: SortOrder
    seasonalPattern?: SortOrderInput | SortOrder
    peakMonths?: SortOrderInput | SortOrder
    warningTime?: SortOrderInput | SortOrder
    geographicScope?: SortOrderInput | SortOrder
    cascadingRisks?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    businessTypeHazards?: AdminBusinessTypeHazardOrderByRelationAggregateInput
    locationHazards?: AdminLocationHazardOrderByRelationAggregateInput
    hazardStrategies?: AdminHazardStrategyOrderByRelationAggregateInput
    hazardActionPlans?: AdminHazardActionPlanOrderByRelationAggregateInput
    AdminActionPlan?: AdminActionPlanOrderByWithRelationInput
    translations?: HazardTranslationOrderByRelationAggregateInput
  }

  export type AdminHazardTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    hazardId?: string
    AND?: AdminHazardTypeWhereInput | AdminHazardTypeWhereInput[]
    OR?: AdminHazardTypeWhereInput[]
    NOT?: AdminHazardTypeWhereInput | AdminHazardTypeWhereInput[]
    name?: StringFilter<"AdminHazardType"> | string
    category?: StringFilter<"AdminHazardType"> | string
    description?: StringNullableFilter<"AdminHazardType"> | string | null
    defaultFrequency?: StringFilter<"AdminHazardType"> | string
    defaultImpact?: StringFilter<"AdminHazardType"> | string
    seasonalPattern?: StringNullableFilter<"AdminHazardType"> | string | null
    peakMonths?: StringNullableFilter<"AdminHazardType"> | string | null
    warningTime?: StringNullableFilter<"AdminHazardType"> | string | null
    geographicScope?: StringNullableFilter<"AdminHazardType"> | string | null
    cascadingRisks?: StringNullableFilter<"AdminHazardType"> | string | null
    isActive?: BoolFilter<"AdminHazardType"> | boolean
    createdAt?: DateTimeFilter<"AdminHazardType"> | Date | string
    updatedAt?: DateTimeFilter<"AdminHazardType"> | Date | string
    businessTypeHazards?: AdminBusinessTypeHazardListRelationFilter
    locationHazards?: AdminLocationHazardListRelationFilter
    hazardStrategies?: AdminHazardStrategyListRelationFilter
    hazardActionPlans?: AdminHazardActionPlanListRelationFilter
    AdminActionPlan?: XOR<AdminActionPlanNullableRelationFilter, AdminActionPlanWhereInput> | null
    translations?: HazardTranslationListRelationFilter
  }, "id" | "hazardId">

  export type AdminHazardTypeOrderByWithAggregationInput = {
    id?: SortOrder
    hazardId?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    defaultFrequency?: SortOrder
    defaultImpact?: SortOrder
    seasonalPattern?: SortOrderInput | SortOrder
    peakMonths?: SortOrderInput | SortOrder
    warningTime?: SortOrderInput | SortOrder
    geographicScope?: SortOrderInput | SortOrder
    cascadingRisks?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdminHazardTypeCountOrderByAggregateInput
    _max?: AdminHazardTypeMaxOrderByAggregateInput
    _min?: AdminHazardTypeMinOrderByAggregateInput
  }

  export type AdminHazardTypeScalarWhereWithAggregatesInput = {
    AND?: AdminHazardTypeScalarWhereWithAggregatesInput | AdminHazardTypeScalarWhereWithAggregatesInput[]
    OR?: AdminHazardTypeScalarWhereWithAggregatesInput[]
    NOT?: AdminHazardTypeScalarWhereWithAggregatesInput | AdminHazardTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminHazardType"> | string
    hazardId?: StringWithAggregatesFilter<"AdminHazardType"> | string
    name?: StringWithAggregatesFilter<"AdminHazardType"> | string
    category?: StringWithAggregatesFilter<"AdminHazardType"> | string
    description?: StringNullableWithAggregatesFilter<"AdminHazardType"> | string | null
    defaultFrequency?: StringWithAggregatesFilter<"AdminHazardType"> | string
    defaultImpact?: StringWithAggregatesFilter<"AdminHazardType"> | string
    seasonalPattern?: StringNullableWithAggregatesFilter<"AdminHazardType"> | string | null
    peakMonths?: StringNullableWithAggregatesFilter<"AdminHazardType"> | string | null
    warningTime?: StringNullableWithAggregatesFilter<"AdminHazardType"> | string | null
    geographicScope?: StringNullableWithAggregatesFilter<"AdminHazardType"> | string | null
    cascadingRisks?: StringNullableWithAggregatesFilter<"AdminHazardType"> | string | null
    isActive?: BoolWithAggregatesFilter<"AdminHazardType"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AdminHazardType"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AdminHazardType"> | Date | string
  }

  export type AdminLocationWhereInput = {
    AND?: AdminLocationWhereInput | AdminLocationWhereInput[]
    OR?: AdminLocationWhereInput[]
    NOT?: AdminLocationWhereInput | AdminLocationWhereInput[]
    id?: StringFilter<"AdminLocation"> | string
    country?: StringFilter<"AdminLocation"> | string
    countryCode?: StringFilter<"AdminLocation"> | string
    parish?: StringNullableFilter<"AdminLocation"> | string | null
    isCoastal?: BoolFilter<"AdminLocation"> | boolean
    isUrban?: BoolFilter<"AdminLocation"> | boolean
    isActive?: BoolFilter<"AdminLocation"> | boolean
    createdAt?: DateTimeFilter<"AdminLocation"> | Date | string
    updatedAt?: DateTimeFilter<"AdminLocation"> | Date | string
    locationHazards?: AdminLocationHazardListRelationFilter
    riskProfiles?: AdminRiskProfileListRelationFilter
  }

  export type AdminLocationOrderByWithRelationInput = {
    id?: SortOrder
    country?: SortOrder
    countryCode?: SortOrder
    parish?: SortOrderInput | SortOrder
    isCoastal?: SortOrder
    isUrban?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    locationHazards?: AdminLocationHazardOrderByRelationAggregateInput
    riskProfiles?: AdminRiskProfileOrderByRelationAggregateInput
  }

  export type AdminLocationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    countryCode_parish?: AdminLocationCountryCodeParishCompoundUniqueInput
    AND?: AdminLocationWhereInput | AdminLocationWhereInput[]
    OR?: AdminLocationWhereInput[]
    NOT?: AdminLocationWhereInput | AdminLocationWhereInput[]
    country?: StringFilter<"AdminLocation"> | string
    countryCode?: StringFilter<"AdminLocation"> | string
    parish?: StringNullableFilter<"AdminLocation"> | string | null
    isCoastal?: BoolFilter<"AdminLocation"> | boolean
    isUrban?: BoolFilter<"AdminLocation"> | boolean
    isActive?: BoolFilter<"AdminLocation"> | boolean
    createdAt?: DateTimeFilter<"AdminLocation"> | Date | string
    updatedAt?: DateTimeFilter<"AdminLocation"> | Date | string
    locationHazards?: AdminLocationHazardListRelationFilter
    riskProfiles?: AdminRiskProfileListRelationFilter
  }, "id" | "countryCode_parish">

  export type AdminLocationOrderByWithAggregationInput = {
    id?: SortOrder
    country?: SortOrder
    countryCode?: SortOrder
    parish?: SortOrderInput | SortOrder
    isCoastal?: SortOrder
    isUrban?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdminLocationCountOrderByAggregateInput
    _max?: AdminLocationMaxOrderByAggregateInput
    _min?: AdminLocationMinOrderByAggregateInput
  }

  export type AdminLocationScalarWhereWithAggregatesInput = {
    AND?: AdminLocationScalarWhereWithAggregatesInput | AdminLocationScalarWhereWithAggregatesInput[]
    OR?: AdminLocationScalarWhereWithAggregatesInput[]
    NOT?: AdminLocationScalarWhereWithAggregatesInput | AdminLocationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminLocation"> | string
    country?: StringWithAggregatesFilter<"AdminLocation"> | string
    countryCode?: StringWithAggregatesFilter<"AdminLocation"> | string
    parish?: StringNullableWithAggregatesFilter<"AdminLocation"> | string | null
    isCoastal?: BoolWithAggregatesFilter<"AdminLocation"> | boolean
    isUrban?: BoolWithAggregatesFilter<"AdminLocation"> | boolean
    isActive?: BoolWithAggregatesFilter<"AdminLocation"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AdminLocation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AdminLocation"> | Date | string
  }

  export type AdminBusinessTypeHazardWhereInput = {
    AND?: AdminBusinessTypeHazardWhereInput | AdminBusinessTypeHazardWhereInput[]
    OR?: AdminBusinessTypeHazardWhereInput[]
    NOT?: AdminBusinessTypeHazardWhereInput | AdminBusinessTypeHazardWhereInput[]
    id?: StringFilter<"AdminBusinessTypeHazard"> | string
    businessTypeId?: StringFilter<"AdminBusinessTypeHazard"> | string
    hazardId?: StringFilter<"AdminBusinessTypeHazard"> | string
    riskLevel?: StringFilter<"AdminBusinessTypeHazard"> | string
    frequency?: StringNullableFilter<"AdminBusinessTypeHazard"> | string | null
    impact?: StringNullableFilter<"AdminBusinessTypeHazard"> | string | null
    notes?: StringNullableFilter<"AdminBusinessTypeHazard"> | string | null
    isActive?: BoolFilter<"AdminBusinessTypeHazard"> | boolean
    createdAt?: DateTimeFilter<"AdminBusinessTypeHazard"> | Date | string
    updatedAt?: DateTimeFilter<"AdminBusinessTypeHazard"> | Date | string
    businessType?: XOR<AdminBusinessTypeRelationFilter, AdminBusinessTypeWhereInput>
    hazard?: XOR<AdminHazardTypeRelationFilter, AdminHazardTypeWhereInput>
  }

  export type AdminBusinessTypeHazardOrderByWithRelationInput = {
    id?: SortOrder
    businessTypeId?: SortOrder
    hazardId?: SortOrder
    riskLevel?: SortOrder
    frequency?: SortOrderInput | SortOrder
    impact?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    businessType?: AdminBusinessTypeOrderByWithRelationInput
    hazard?: AdminHazardTypeOrderByWithRelationInput
  }

  export type AdminBusinessTypeHazardWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    businessTypeId_hazardId?: AdminBusinessTypeHazardBusinessTypeIdHazardIdCompoundUniqueInput
    AND?: AdminBusinessTypeHazardWhereInput | AdminBusinessTypeHazardWhereInput[]
    OR?: AdminBusinessTypeHazardWhereInput[]
    NOT?: AdminBusinessTypeHazardWhereInput | AdminBusinessTypeHazardWhereInput[]
    businessTypeId?: StringFilter<"AdminBusinessTypeHazard"> | string
    hazardId?: StringFilter<"AdminBusinessTypeHazard"> | string
    riskLevel?: StringFilter<"AdminBusinessTypeHazard"> | string
    frequency?: StringNullableFilter<"AdminBusinessTypeHazard"> | string | null
    impact?: StringNullableFilter<"AdminBusinessTypeHazard"> | string | null
    notes?: StringNullableFilter<"AdminBusinessTypeHazard"> | string | null
    isActive?: BoolFilter<"AdminBusinessTypeHazard"> | boolean
    createdAt?: DateTimeFilter<"AdminBusinessTypeHazard"> | Date | string
    updatedAt?: DateTimeFilter<"AdminBusinessTypeHazard"> | Date | string
    businessType?: XOR<AdminBusinessTypeRelationFilter, AdminBusinessTypeWhereInput>
    hazard?: XOR<AdminHazardTypeRelationFilter, AdminHazardTypeWhereInput>
  }, "id" | "businessTypeId_hazardId">

  export type AdminBusinessTypeHazardOrderByWithAggregationInput = {
    id?: SortOrder
    businessTypeId?: SortOrder
    hazardId?: SortOrder
    riskLevel?: SortOrder
    frequency?: SortOrderInput | SortOrder
    impact?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdminBusinessTypeHazardCountOrderByAggregateInput
    _max?: AdminBusinessTypeHazardMaxOrderByAggregateInput
    _min?: AdminBusinessTypeHazardMinOrderByAggregateInput
  }

  export type AdminBusinessTypeHazardScalarWhereWithAggregatesInput = {
    AND?: AdminBusinessTypeHazardScalarWhereWithAggregatesInput | AdminBusinessTypeHazardScalarWhereWithAggregatesInput[]
    OR?: AdminBusinessTypeHazardScalarWhereWithAggregatesInput[]
    NOT?: AdminBusinessTypeHazardScalarWhereWithAggregatesInput | AdminBusinessTypeHazardScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminBusinessTypeHazard"> | string
    businessTypeId?: StringWithAggregatesFilter<"AdminBusinessTypeHazard"> | string
    hazardId?: StringWithAggregatesFilter<"AdminBusinessTypeHazard"> | string
    riskLevel?: StringWithAggregatesFilter<"AdminBusinessTypeHazard"> | string
    frequency?: StringNullableWithAggregatesFilter<"AdminBusinessTypeHazard"> | string | null
    impact?: StringNullableWithAggregatesFilter<"AdminBusinessTypeHazard"> | string | null
    notes?: StringNullableWithAggregatesFilter<"AdminBusinessTypeHazard"> | string | null
    isActive?: BoolWithAggregatesFilter<"AdminBusinessTypeHazard"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AdminBusinessTypeHazard"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AdminBusinessTypeHazard"> | Date | string
  }

  export type AdminLocationHazardWhereInput = {
    AND?: AdminLocationHazardWhereInput | AdminLocationHazardWhereInput[]
    OR?: AdminLocationHazardWhereInput[]
    NOT?: AdminLocationHazardWhereInput | AdminLocationHazardWhereInput[]
    id?: StringFilter<"AdminLocationHazard"> | string
    locationId?: StringFilter<"AdminLocationHazard"> | string
    hazardId?: StringFilter<"AdminLocationHazard"> | string
    riskLevel?: StringFilter<"AdminLocationHazard"> | string
    frequency?: StringNullableFilter<"AdminLocationHazard"> | string | null
    impact?: StringNullableFilter<"AdminLocationHazard"> | string | null
    notes?: StringNullableFilter<"AdminLocationHazard"> | string | null
    isActive?: BoolFilter<"AdminLocationHazard"> | boolean
    createdAt?: DateTimeFilter<"AdminLocationHazard"> | Date | string
    updatedAt?: DateTimeFilter<"AdminLocationHazard"> | Date | string
    location?: XOR<AdminLocationRelationFilter, AdminLocationWhereInput>
    hazard?: XOR<AdminHazardTypeRelationFilter, AdminHazardTypeWhereInput>
  }

  export type AdminLocationHazardOrderByWithRelationInput = {
    id?: SortOrder
    locationId?: SortOrder
    hazardId?: SortOrder
    riskLevel?: SortOrder
    frequency?: SortOrderInput | SortOrder
    impact?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    location?: AdminLocationOrderByWithRelationInput
    hazard?: AdminHazardTypeOrderByWithRelationInput
  }

  export type AdminLocationHazardWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    locationId_hazardId?: AdminLocationHazardLocationIdHazardIdCompoundUniqueInput
    AND?: AdminLocationHazardWhereInput | AdminLocationHazardWhereInput[]
    OR?: AdminLocationHazardWhereInput[]
    NOT?: AdminLocationHazardWhereInput | AdminLocationHazardWhereInput[]
    locationId?: StringFilter<"AdminLocationHazard"> | string
    hazardId?: StringFilter<"AdminLocationHazard"> | string
    riskLevel?: StringFilter<"AdminLocationHazard"> | string
    frequency?: StringNullableFilter<"AdminLocationHazard"> | string | null
    impact?: StringNullableFilter<"AdminLocationHazard"> | string | null
    notes?: StringNullableFilter<"AdminLocationHazard"> | string | null
    isActive?: BoolFilter<"AdminLocationHazard"> | boolean
    createdAt?: DateTimeFilter<"AdminLocationHazard"> | Date | string
    updatedAt?: DateTimeFilter<"AdminLocationHazard"> | Date | string
    location?: XOR<AdminLocationRelationFilter, AdminLocationWhereInput>
    hazard?: XOR<AdminHazardTypeRelationFilter, AdminHazardTypeWhereInput>
  }, "id" | "locationId_hazardId">

  export type AdminLocationHazardOrderByWithAggregationInput = {
    id?: SortOrder
    locationId?: SortOrder
    hazardId?: SortOrder
    riskLevel?: SortOrder
    frequency?: SortOrderInput | SortOrder
    impact?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdminLocationHazardCountOrderByAggregateInput
    _max?: AdminLocationHazardMaxOrderByAggregateInput
    _min?: AdminLocationHazardMinOrderByAggregateInput
  }

  export type AdminLocationHazardScalarWhereWithAggregatesInput = {
    AND?: AdminLocationHazardScalarWhereWithAggregatesInput | AdminLocationHazardScalarWhereWithAggregatesInput[]
    OR?: AdminLocationHazardScalarWhereWithAggregatesInput[]
    NOT?: AdminLocationHazardScalarWhereWithAggregatesInput | AdminLocationHazardScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminLocationHazard"> | string
    locationId?: StringWithAggregatesFilter<"AdminLocationHazard"> | string
    hazardId?: StringWithAggregatesFilter<"AdminLocationHazard"> | string
    riskLevel?: StringWithAggregatesFilter<"AdminLocationHazard"> | string
    frequency?: StringNullableWithAggregatesFilter<"AdminLocationHazard"> | string | null
    impact?: StringNullableWithAggregatesFilter<"AdminLocationHazard"> | string | null
    notes?: StringNullableWithAggregatesFilter<"AdminLocationHazard"> | string | null
    isActive?: BoolWithAggregatesFilter<"AdminLocationHazard"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AdminLocationHazard"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AdminLocationHazard"> | Date | string
  }

  export type AdminStrategyWhereInput = {
    AND?: AdminStrategyWhereInput | AdminStrategyWhereInput[]
    OR?: AdminStrategyWhereInput[]
    NOT?: AdminStrategyWhereInput | AdminStrategyWhereInput[]
    id?: StringFilter<"AdminStrategy"> | string
    strategyId?: StringFilter<"AdminStrategy"> | string
    title?: StringFilter<"AdminStrategy"> | string
    description?: StringFilter<"AdminStrategy"> | string
    category?: StringFilter<"AdminStrategy"> | string
    reasoning?: StringNullableFilter<"AdminStrategy"> | string | null
    icon?: StringNullableFilter<"AdminStrategy"> | string | null
    isActive?: BoolFilter<"AdminStrategy"> | boolean
    createdAt?: DateTimeFilter<"AdminStrategy"> | Date | string
    updatedAt?: DateTimeFilter<"AdminStrategy"> | Date | string
    hazardStrategies?: AdminHazardStrategyListRelationFilter
  }

  export type AdminStrategyOrderByWithRelationInput = {
    id?: SortOrder
    strategyId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    reasoning?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hazardStrategies?: AdminHazardStrategyOrderByRelationAggregateInput
  }

  export type AdminStrategyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    strategyId?: string
    AND?: AdminStrategyWhereInput | AdminStrategyWhereInput[]
    OR?: AdminStrategyWhereInput[]
    NOT?: AdminStrategyWhereInput | AdminStrategyWhereInput[]
    title?: StringFilter<"AdminStrategy"> | string
    description?: StringFilter<"AdminStrategy"> | string
    category?: StringFilter<"AdminStrategy"> | string
    reasoning?: StringNullableFilter<"AdminStrategy"> | string | null
    icon?: StringNullableFilter<"AdminStrategy"> | string | null
    isActive?: BoolFilter<"AdminStrategy"> | boolean
    createdAt?: DateTimeFilter<"AdminStrategy"> | Date | string
    updatedAt?: DateTimeFilter<"AdminStrategy"> | Date | string
    hazardStrategies?: AdminHazardStrategyListRelationFilter
  }, "id" | "strategyId">

  export type AdminStrategyOrderByWithAggregationInput = {
    id?: SortOrder
    strategyId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    reasoning?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdminStrategyCountOrderByAggregateInput
    _max?: AdminStrategyMaxOrderByAggregateInput
    _min?: AdminStrategyMinOrderByAggregateInput
  }

  export type AdminStrategyScalarWhereWithAggregatesInput = {
    AND?: AdminStrategyScalarWhereWithAggregatesInput | AdminStrategyScalarWhereWithAggregatesInput[]
    OR?: AdminStrategyScalarWhereWithAggregatesInput[]
    NOT?: AdminStrategyScalarWhereWithAggregatesInput | AdminStrategyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminStrategy"> | string
    strategyId?: StringWithAggregatesFilter<"AdminStrategy"> | string
    title?: StringWithAggregatesFilter<"AdminStrategy"> | string
    description?: StringWithAggregatesFilter<"AdminStrategy"> | string
    category?: StringWithAggregatesFilter<"AdminStrategy"> | string
    reasoning?: StringNullableWithAggregatesFilter<"AdminStrategy"> | string | null
    icon?: StringNullableWithAggregatesFilter<"AdminStrategy"> | string | null
    isActive?: BoolWithAggregatesFilter<"AdminStrategy"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AdminStrategy"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AdminStrategy"> | Date | string
  }

  export type AdminHazardStrategyWhereInput = {
    AND?: AdminHazardStrategyWhereInput | AdminHazardStrategyWhereInput[]
    OR?: AdminHazardStrategyWhereInput[]
    NOT?: AdminHazardStrategyWhereInput | AdminHazardStrategyWhereInput[]
    id?: StringFilter<"AdminHazardStrategy"> | string
    hazardId?: StringFilter<"AdminHazardStrategy"> | string
    strategyId?: StringFilter<"AdminHazardStrategy"> | string
    businessTypes?: StringNullableFilter<"AdminHazardStrategy"> | string | null
    priority?: StringFilter<"AdminHazardStrategy"> | string
    isRecommended?: BoolFilter<"AdminHazardStrategy"> | boolean
    notes?: StringNullableFilter<"AdminHazardStrategy"> | string | null
    isActive?: BoolFilter<"AdminHazardStrategy"> | boolean
    createdAt?: DateTimeFilter<"AdminHazardStrategy"> | Date | string
    updatedAt?: DateTimeFilter<"AdminHazardStrategy"> | Date | string
    hazard?: XOR<AdminHazardTypeRelationFilter, AdminHazardTypeWhereInput>
    strategy?: XOR<AdminStrategyRelationFilter, AdminStrategyWhereInput>
  }

  export type AdminHazardStrategyOrderByWithRelationInput = {
    id?: SortOrder
    hazardId?: SortOrder
    strategyId?: SortOrder
    businessTypes?: SortOrderInput | SortOrder
    priority?: SortOrder
    isRecommended?: SortOrder
    notes?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hazard?: AdminHazardTypeOrderByWithRelationInput
    strategy?: AdminStrategyOrderByWithRelationInput
  }

  export type AdminHazardStrategyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    hazardId_strategyId?: AdminHazardStrategyHazardIdStrategyIdCompoundUniqueInput
    AND?: AdminHazardStrategyWhereInput | AdminHazardStrategyWhereInput[]
    OR?: AdminHazardStrategyWhereInput[]
    NOT?: AdminHazardStrategyWhereInput | AdminHazardStrategyWhereInput[]
    hazardId?: StringFilter<"AdminHazardStrategy"> | string
    strategyId?: StringFilter<"AdminHazardStrategy"> | string
    businessTypes?: StringNullableFilter<"AdminHazardStrategy"> | string | null
    priority?: StringFilter<"AdminHazardStrategy"> | string
    isRecommended?: BoolFilter<"AdminHazardStrategy"> | boolean
    notes?: StringNullableFilter<"AdminHazardStrategy"> | string | null
    isActive?: BoolFilter<"AdminHazardStrategy"> | boolean
    createdAt?: DateTimeFilter<"AdminHazardStrategy"> | Date | string
    updatedAt?: DateTimeFilter<"AdminHazardStrategy"> | Date | string
    hazard?: XOR<AdminHazardTypeRelationFilter, AdminHazardTypeWhereInput>
    strategy?: XOR<AdminStrategyRelationFilter, AdminStrategyWhereInput>
  }, "id" | "hazardId_strategyId">

  export type AdminHazardStrategyOrderByWithAggregationInput = {
    id?: SortOrder
    hazardId?: SortOrder
    strategyId?: SortOrder
    businessTypes?: SortOrderInput | SortOrder
    priority?: SortOrder
    isRecommended?: SortOrder
    notes?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdminHazardStrategyCountOrderByAggregateInput
    _max?: AdminHazardStrategyMaxOrderByAggregateInput
    _min?: AdminHazardStrategyMinOrderByAggregateInput
  }

  export type AdminHazardStrategyScalarWhereWithAggregatesInput = {
    AND?: AdminHazardStrategyScalarWhereWithAggregatesInput | AdminHazardStrategyScalarWhereWithAggregatesInput[]
    OR?: AdminHazardStrategyScalarWhereWithAggregatesInput[]
    NOT?: AdminHazardStrategyScalarWhereWithAggregatesInput | AdminHazardStrategyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminHazardStrategy"> | string
    hazardId?: StringWithAggregatesFilter<"AdminHazardStrategy"> | string
    strategyId?: StringWithAggregatesFilter<"AdminHazardStrategy"> | string
    businessTypes?: StringNullableWithAggregatesFilter<"AdminHazardStrategy"> | string | null
    priority?: StringWithAggregatesFilter<"AdminHazardStrategy"> | string
    isRecommended?: BoolWithAggregatesFilter<"AdminHazardStrategy"> | boolean
    notes?: StringNullableWithAggregatesFilter<"AdminHazardStrategy"> | string | null
    isActive?: BoolWithAggregatesFilter<"AdminHazardStrategy"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AdminHazardStrategy"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AdminHazardStrategy"> | Date | string
  }

  export type AdminActionPlanWhereInput = {
    AND?: AdminActionPlanWhereInput | AdminActionPlanWhereInput[]
    OR?: AdminActionPlanWhereInput[]
    NOT?: AdminActionPlanWhereInput | AdminActionPlanWhereInput[]
    id?: StringFilter<"AdminActionPlan"> | string
    hazardId?: StringFilter<"AdminActionPlan"> | string
    resourcesNeeded?: StringFilter<"AdminActionPlan"> | string
    immediateActions?: StringFilter<"AdminActionPlan"> | string
    shortTermActions?: StringFilter<"AdminActionPlan"> | string
    mediumTermActions?: StringFilter<"AdminActionPlan"> | string
    longTermReduction?: StringFilter<"AdminActionPlan"> | string
    businessTypeModifiers?: StringNullableFilter<"AdminActionPlan"> | string | null
    isActive?: BoolFilter<"AdminActionPlan"> | boolean
    createdAt?: DateTimeFilter<"AdminActionPlan"> | Date | string
    updatedAt?: DateTimeFilter<"AdminActionPlan"> | Date | string
    hazard?: XOR<AdminHazardTypeRelationFilter, AdminHazardTypeWhereInput>
    AdminHazardActionPlan?: AdminHazardActionPlanListRelationFilter
  }

  export type AdminActionPlanOrderByWithRelationInput = {
    id?: SortOrder
    hazardId?: SortOrder
    resourcesNeeded?: SortOrder
    immediateActions?: SortOrder
    shortTermActions?: SortOrder
    mediumTermActions?: SortOrder
    longTermReduction?: SortOrder
    businessTypeModifiers?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hazard?: AdminHazardTypeOrderByWithRelationInput
    AdminHazardActionPlan?: AdminHazardActionPlanOrderByRelationAggregateInput
  }

  export type AdminActionPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    hazardId?: string
    AND?: AdminActionPlanWhereInput | AdminActionPlanWhereInput[]
    OR?: AdminActionPlanWhereInput[]
    NOT?: AdminActionPlanWhereInput | AdminActionPlanWhereInput[]
    resourcesNeeded?: StringFilter<"AdminActionPlan"> | string
    immediateActions?: StringFilter<"AdminActionPlan"> | string
    shortTermActions?: StringFilter<"AdminActionPlan"> | string
    mediumTermActions?: StringFilter<"AdminActionPlan"> | string
    longTermReduction?: StringFilter<"AdminActionPlan"> | string
    businessTypeModifiers?: StringNullableFilter<"AdminActionPlan"> | string | null
    isActive?: BoolFilter<"AdminActionPlan"> | boolean
    createdAt?: DateTimeFilter<"AdminActionPlan"> | Date | string
    updatedAt?: DateTimeFilter<"AdminActionPlan"> | Date | string
    hazard?: XOR<AdminHazardTypeRelationFilter, AdminHazardTypeWhereInput>
    AdminHazardActionPlan?: AdminHazardActionPlanListRelationFilter
  }, "id" | "hazardId">

  export type AdminActionPlanOrderByWithAggregationInput = {
    id?: SortOrder
    hazardId?: SortOrder
    resourcesNeeded?: SortOrder
    immediateActions?: SortOrder
    shortTermActions?: SortOrder
    mediumTermActions?: SortOrder
    longTermReduction?: SortOrder
    businessTypeModifiers?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdminActionPlanCountOrderByAggregateInput
    _max?: AdminActionPlanMaxOrderByAggregateInput
    _min?: AdminActionPlanMinOrderByAggregateInput
  }

  export type AdminActionPlanScalarWhereWithAggregatesInput = {
    AND?: AdminActionPlanScalarWhereWithAggregatesInput | AdminActionPlanScalarWhereWithAggregatesInput[]
    OR?: AdminActionPlanScalarWhereWithAggregatesInput[]
    NOT?: AdminActionPlanScalarWhereWithAggregatesInput | AdminActionPlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminActionPlan"> | string
    hazardId?: StringWithAggregatesFilter<"AdminActionPlan"> | string
    resourcesNeeded?: StringWithAggregatesFilter<"AdminActionPlan"> | string
    immediateActions?: StringWithAggregatesFilter<"AdminActionPlan"> | string
    shortTermActions?: StringWithAggregatesFilter<"AdminActionPlan"> | string
    mediumTermActions?: StringWithAggregatesFilter<"AdminActionPlan"> | string
    longTermReduction?: StringWithAggregatesFilter<"AdminActionPlan"> | string
    businessTypeModifiers?: StringNullableWithAggregatesFilter<"AdminActionPlan"> | string | null
    isActive?: BoolWithAggregatesFilter<"AdminActionPlan"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AdminActionPlan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AdminActionPlan"> | Date | string
  }

  export type AdminHazardActionPlanWhereInput = {
    AND?: AdminHazardActionPlanWhereInput | AdminHazardActionPlanWhereInput[]
    OR?: AdminHazardActionPlanWhereInput[]
    NOT?: AdminHazardActionPlanWhereInput | AdminHazardActionPlanWhereInput[]
    id?: StringFilter<"AdminHazardActionPlan"> | string
    hazardId?: StringFilter<"AdminHazardActionPlan"> | string
    actionPlanId?: StringFilter<"AdminHazardActionPlan"> | string
    businessTypes?: StringNullableFilter<"AdminHazardActionPlan"> | string | null
    isActive?: BoolFilter<"AdminHazardActionPlan"> | boolean
    createdAt?: DateTimeFilter<"AdminHazardActionPlan"> | Date | string
    updatedAt?: DateTimeFilter<"AdminHazardActionPlan"> | Date | string
    hazard?: XOR<AdminHazardTypeRelationFilter, AdminHazardTypeWhereInput>
    actionPlan?: XOR<AdminActionPlanRelationFilter, AdminActionPlanWhereInput>
  }

  export type AdminHazardActionPlanOrderByWithRelationInput = {
    id?: SortOrder
    hazardId?: SortOrder
    actionPlanId?: SortOrder
    businessTypes?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hazard?: AdminHazardTypeOrderByWithRelationInput
    actionPlan?: AdminActionPlanOrderByWithRelationInput
  }

  export type AdminHazardActionPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    hazardId_actionPlanId?: AdminHazardActionPlanHazardIdActionPlanIdCompoundUniqueInput
    AND?: AdminHazardActionPlanWhereInput | AdminHazardActionPlanWhereInput[]
    OR?: AdminHazardActionPlanWhereInput[]
    NOT?: AdminHazardActionPlanWhereInput | AdminHazardActionPlanWhereInput[]
    hazardId?: StringFilter<"AdminHazardActionPlan"> | string
    actionPlanId?: StringFilter<"AdminHazardActionPlan"> | string
    businessTypes?: StringNullableFilter<"AdminHazardActionPlan"> | string | null
    isActive?: BoolFilter<"AdminHazardActionPlan"> | boolean
    createdAt?: DateTimeFilter<"AdminHazardActionPlan"> | Date | string
    updatedAt?: DateTimeFilter<"AdminHazardActionPlan"> | Date | string
    hazard?: XOR<AdminHazardTypeRelationFilter, AdminHazardTypeWhereInput>
    actionPlan?: XOR<AdminActionPlanRelationFilter, AdminActionPlanWhereInput>
  }, "id" | "hazardId_actionPlanId">

  export type AdminHazardActionPlanOrderByWithAggregationInput = {
    id?: SortOrder
    hazardId?: SortOrder
    actionPlanId?: SortOrder
    businessTypes?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdminHazardActionPlanCountOrderByAggregateInput
    _max?: AdminHazardActionPlanMaxOrderByAggregateInput
    _min?: AdminHazardActionPlanMinOrderByAggregateInput
  }

  export type AdminHazardActionPlanScalarWhereWithAggregatesInput = {
    AND?: AdminHazardActionPlanScalarWhereWithAggregatesInput | AdminHazardActionPlanScalarWhereWithAggregatesInput[]
    OR?: AdminHazardActionPlanScalarWhereWithAggregatesInput[]
    NOT?: AdminHazardActionPlanScalarWhereWithAggregatesInput | AdminHazardActionPlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminHazardActionPlan"> | string
    hazardId?: StringWithAggregatesFilter<"AdminHazardActionPlan"> | string
    actionPlanId?: StringWithAggregatesFilter<"AdminHazardActionPlan"> | string
    businessTypes?: StringNullableWithAggregatesFilter<"AdminHazardActionPlan"> | string | null
    isActive?: BoolWithAggregatesFilter<"AdminHazardActionPlan"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AdminHazardActionPlan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AdminHazardActionPlan"> | Date | string
  }

  export type AdminRiskProfileWhereInput = {
    AND?: AdminRiskProfileWhereInput | AdminRiskProfileWhereInput[]
    OR?: AdminRiskProfileWhereInput[]
    NOT?: AdminRiskProfileWhereInput | AdminRiskProfileWhereInput[]
    id?: StringFilter<"AdminRiskProfile"> | string
    createdAt?: DateTimeFilter<"AdminRiskProfile"> | Date | string
    updatedAt?: DateTimeFilter<"AdminRiskProfile"> | Date | string
    businessTypeId?: StringFilter<"AdminRiskProfile"> | string
    locationId?: StringFilter<"AdminRiskProfile"> | string
    calculatedRisks?: StringFilter<"AdminRiskProfile"> | string
    recommendedStrategies?: StringFilter<"AdminRiskProfile"> | string
    lastCalculated?: DateTimeFilter<"AdminRiskProfile"> | Date | string
    riskScore?: IntFilter<"AdminRiskProfile"> | number
    businessType?: XOR<AdminBusinessTypeRelationFilter, AdminBusinessTypeWhereInput>
    location?: XOR<AdminLocationRelationFilter, AdminLocationWhereInput>
  }

  export type AdminRiskProfileOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    businessTypeId?: SortOrder
    locationId?: SortOrder
    calculatedRisks?: SortOrder
    recommendedStrategies?: SortOrder
    lastCalculated?: SortOrder
    riskScore?: SortOrder
    businessType?: AdminBusinessTypeOrderByWithRelationInput
    location?: AdminLocationOrderByWithRelationInput
  }

  export type AdminRiskProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    businessTypeId_locationId?: AdminRiskProfileBusinessTypeIdLocationIdCompoundUniqueInput
    AND?: AdminRiskProfileWhereInput | AdminRiskProfileWhereInput[]
    OR?: AdminRiskProfileWhereInput[]
    NOT?: AdminRiskProfileWhereInput | AdminRiskProfileWhereInput[]
    createdAt?: DateTimeFilter<"AdminRiskProfile"> | Date | string
    updatedAt?: DateTimeFilter<"AdminRiskProfile"> | Date | string
    businessTypeId?: StringFilter<"AdminRiskProfile"> | string
    locationId?: StringFilter<"AdminRiskProfile"> | string
    calculatedRisks?: StringFilter<"AdminRiskProfile"> | string
    recommendedStrategies?: StringFilter<"AdminRiskProfile"> | string
    lastCalculated?: DateTimeFilter<"AdminRiskProfile"> | Date | string
    riskScore?: IntFilter<"AdminRiskProfile"> | number
    businessType?: XOR<AdminBusinessTypeRelationFilter, AdminBusinessTypeWhereInput>
    location?: XOR<AdminLocationRelationFilter, AdminLocationWhereInput>
  }, "id" | "businessTypeId_locationId">

  export type AdminRiskProfileOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    businessTypeId?: SortOrder
    locationId?: SortOrder
    calculatedRisks?: SortOrder
    recommendedStrategies?: SortOrder
    lastCalculated?: SortOrder
    riskScore?: SortOrder
    _count?: AdminRiskProfileCountOrderByAggregateInput
    _avg?: AdminRiskProfileAvgOrderByAggregateInput
    _max?: AdminRiskProfileMaxOrderByAggregateInput
    _min?: AdminRiskProfileMinOrderByAggregateInput
    _sum?: AdminRiskProfileSumOrderByAggregateInput
  }

  export type AdminRiskProfileScalarWhereWithAggregatesInput = {
    AND?: AdminRiskProfileScalarWhereWithAggregatesInput | AdminRiskProfileScalarWhereWithAggregatesInput[]
    OR?: AdminRiskProfileScalarWhereWithAggregatesInput[]
    NOT?: AdminRiskProfileScalarWhereWithAggregatesInput | AdminRiskProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminRiskProfile"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AdminRiskProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AdminRiskProfile"> | Date | string
    businessTypeId?: StringWithAggregatesFilter<"AdminRiskProfile"> | string
    locationId?: StringWithAggregatesFilter<"AdminRiskProfile"> | string
    calculatedRisks?: StringWithAggregatesFilter<"AdminRiskProfile"> | string
    recommendedStrategies?: StringWithAggregatesFilter<"AdminRiskProfile"> | string
    lastCalculated?: DateTimeWithAggregatesFilter<"AdminRiskProfile"> | Date | string
    riskScore?: IntWithAggregatesFilter<"AdminRiskProfile"> | number
  }

  export type CountryWhereInput = {
    AND?: CountryWhereInput | CountryWhereInput[]
    OR?: CountryWhereInput[]
    NOT?: CountryWhereInput | CountryWhereInput[]
    id?: StringFilter<"Country"> | string
    name?: StringFilter<"Country"> | string
    code?: StringFilter<"Country"> | string
    region?: StringNullableFilter<"Country"> | string | null
    isActive?: BoolFilter<"Country"> | boolean
    createdAt?: DateTimeFilter<"Country"> | Date | string
    updatedAt?: DateTimeFilter<"Country"> | Date | string
    adminUnits?: AdminUnitListRelationFilter
  }

  export type CountryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    region?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    adminUnits?: AdminUnitOrderByRelationAggregateInput
  }

  export type CountryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: CountryWhereInput | CountryWhereInput[]
    OR?: CountryWhereInput[]
    NOT?: CountryWhereInput | CountryWhereInput[]
    name?: StringFilter<"Country"> | string
    region?: StringNullableFilter<"Country"> | string | null
    isActive?: BoolFilter<"Country"> | boolean
    createdAt?: DateTimeFilter<"Country"> | Date | string
    updatedAt?: DateTimeFilter<"Country"> | Date | string
    adminUnits?: AdminUnitListRelationFilter
  }, "id" | "code">

  export type CountryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    region?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CountryCountOrderByAggregateInput
    _max?: CountryMaxOrderByAggregateInput
    _min?: CountryMinOrderByAggregateInput
  }

  export type CountryScalarWhereWithAggregatesInput = {
    AND?: CountryScalarWhereWithAggregatesInput | CountryScalarWhereWithAggregatesInput[]
    OR?: CountryScalarWhereWithAggregatesInput[]
    NOT?: CountryScalarWhereWithAggregatesInput | CountryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Country"> | string
    name?: StringWithAggregatesFilter<"Country"> | string
    code?: StringWithAggregatesFilter<"Country"> | string
    region?: StringNullableWithAggregatesFilter<"Country"> | string | null
    isActive?: BoolWithAggregatesFilter<"Country"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Country"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Country"> | Date | string
  }

  export type AdminUnitWhereInput = {
    AND?: AdminUnitWhereInput | AdminUnitWhereInput[]
    OR?: AdminUnitWhereInput[]
    NOT?: AdminUnitWhereInput | AdminUnitWhereInput[]
    id?: StringFilter<"AdminUnit"> | string
    name?: StringFilter<"AdminUnit"> | string
    localName?: StringNullableFilter<"AdminUnit"> | string | null
    type?: StringFilter<"AdminUnit"> | string
    region?: StringNullableFilter<"AdminUnit"> | string | null
    countryId?: StringFilter<"AdminUnit"> | string
    population?: IntFilter<"AdminUnit"> | number
    area?: FloatNullableFilter<"AdminUnit"> | number | null
    elevation?: FloatNullableFilter<"AdminUnit"> | number | null
    coordinates?: StringNullableFilter<"AdminUnit"> | string | null
    createdAt?: DateTimeFilter<"AdminUnit"> | Date | string
    updatedAt?: DateTimeFilter<"AdminUnit"> | Date | string
    isActive?: BoolFilter<"AdminUnit"> | boolean
    country?: XOR<CountryRelationFilter, CountryWhereInput>
    adminUnitRisk?: XOR<AdminUnitRiskNullableRelationFilter, AdminUnitRiskWhereInput> | null
  }

  export type AdminUnitOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    localName?: SortOrderInput | SortOrder
    type?: SortOrder
    region?: SortOrderInput | SortOrder
    countryId?: SortOrder
    population?: SortOrder
    area?: SortOrderInput | SortOrder
    elevation?: SortOrderInput | SortOrder
    coordinates?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
    country?: CountryOrderByWithRelationInput
    adminUnitRisk?: AdminUnitRiskOrderByWithRelationInput
  }

  export type AdminUnitWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    countryId_name?: AdminUnitCountryIdNameCompoundUniqueInput
    AND?: AdminUnitWhereInput | AdminUnitWhereInput[]
    OR?: AdminUnitWhereInput[]
    NOT?: AdminUnitWhereInput | AdminUnitWhereInput[]
    name?: StringFilter<"AdminUnit"> | string
    localName?: StringNullableFilter<"AdminUnit"> | string | null
    type?: StringFilter<"AdminUnit"> | string
    region?: StringNullableFilter<"AdminUnit"> | string | null
    countryId?: StringFilter<"AdminUnit"> | string
    population?: IntFilter<"AdminUnit"> | number
    area?: FloatNullableFilter<"AdminUnit"> | number | null
    elevation?: FloatNullableFilter<"AdminUnit"> | number | null
    coordinates?: StringNullableFilter<"AdminUnit"> | string | null
    createdAt?: DateTimeFilter<"AdminUnit"> | Date | string
    updatedAt?: DateTimeFilter<"AdminUnit"> | Date | string
    isActive?: BoolFilter<"AdminUnit"> | boolean
    country?: XOR<CountryRelationFilter, CountryWhereInput>
    adminUnitRisk?: XOR<AdminUnitRiskNullableRelationFilter, AdminUnitRiskWhereInput> | null
  }, "id" | "countryId_name">

  export type AdminUnitOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    localName?: SortOrderInput | SortOrder
    type?: SortOrder
    region?: SortOrderInput | SortOrder
    countryId?: SortOrder
    population?: SortOrder
    area?: SortOrderInput | SortOrder
    elevation?: SortOrderInput | SortOrder
    coordinates?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
    _count?: AdminUnitCountOrderByAggregateInput
    _avg?: AdminUnitAvgOrderByAggregateInput
    _max?: AdminUnitMaxOrderByAggregateInput
    _min?: AdminUnitMinOrderByAggregateInput
    _sum?: AdminUnitSumOrderByAggregateInput
  }

  export type AdminUnitScalarWhereWithAggregatesInput = {
    AND?: AdminUnitScalarWhereWithAggregatesInput | AdminUnitScalarWhereWithAggregatesInput[]
    OR?: AdminUnitScalarWhereWithAggregatesInput[]
    NOT?: AdminUnitScalarWhereWithAggregatesInput | AdminUnitScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminUnit"> | string
    name?: StringWithAggregatesFilter<"AdminUnit"> | string
    localName?: StringNullableWithAggregatesFilter<"AdminUnit"> | string | null
    type?: StringWithAggregatesFilter<"AdminUnit"> | string
    region?: StringNullableWithAggregatesFilter<"AdminUnit"> | string | null
    countryId?: StringWithAggregatesFilter<"AdminUnit"> | string
    population?: IntWithAggregatesFilter<"AdminUnit"> | number
    area?: FloatNullableWithAggregatesFilter<"AdminUnit"> | number | null
    elevation?: FloatNullableWithAggregatesFilter<"AdminUnit"> | number | null
    coordinates?: StringNullableWithAggregatesFilter<"AdminUnit"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AdminUnit"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AdminUnit"> | Date | string
    isActive?: BoolWithAggregatesFilter<"AdminUnit"> | boolean
  }

  export type ParishWhereInput = {
    AND?: ParishWhereInput | ParishWhereInput[]
    OR?: ParishWhereInput[]
    NOT?: ParishWhereInput | ParishWhereInput[]
    id?: StringFilter<"Parish"> | string
    name?: StringFilter<"Parish"> | string
    region?: StringFilter<"Parish"> | string
    countryCode?: StringFilter<"Parish"> | string
    population?: IntFilter<"Parish"> | number
    area?: FloatNullableFilter<"Parish"> | number | null
    elevation?: FloatNullableFilter<"Parish"> | number | null
    coordinates?: StringNullableFilter<"Parish"> | string | null
    createdAt?: DateTimeFilter<"Parish"> | Date | string
    updatedAt?: DateTimeFilter<"Parish"> | Date | string
    isActive?: BoolFilter<"Parish"> | boolean
    parishRisk?: XOR<ParishRiskNullableRelationFilter, ParishRiskWhereInput> | null
    businessRiskProfiles?: BusinessRiskProfileListRelationFilter
  }

  export type ParishOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    region?: SortOrder
    countryCode?: SortOrder
    population?: SortOrder
    area?: SortOrderInput | SortOrder
    elevation?: SortOrderInput | SortOrder
    coordinates?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
    parishRisk?: ParishRiskOrderByWithRelationInput
    businessRiskProfiles?: BusinessRiskProfileOrderByRelationAggregateInput
  }

  export type ParishWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ParishWhereInput | ParishWhereInput[]
    OR?: ParishWhereInput[]
    NOT?: ParishWhereInput | ParishWhereInput[]
    name?: StringFilter<"Parish"> | string
    region?: StringFilter<"Parish"> | string
    countryCode?: StringFilter<"Parish"> | string
    population?: IntFilter<"Parish"> | number
    area?: FloatNullableFilter<"Parish"> | number | null
    elevation?: FloatNullableFilter<"Parish"> | number | null
    coordinates?: StringNullableFilter<"Parish"> | string | null
    createdAt?: DateTimeFilter<"Parish"> | Date | string
    updatedAt?: DateTimeFilter<"Parish"> | Date | string
    isActive?: BoolFilter<"Parish"> | boolean
    parishRisk?: XOR<ParishRiskNullableRelationFilter, ParishRiskWhereInput> | null
    businessRiskProfiles?: BusinessRiskProfileListRelationFilter
  }, "id">

  export type ParishOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    region?: SortOrder
    countryCode?: SortOrder
    population?: SortOrder
    area?: SortOrderInput | SortOrder
    elevation?: SortOrderInput | SortOrder
    coordinates?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
    _count?: ParishCountOrderByAggregateInput
    _avg?: ParishAvgOrderByAggregateInput
    _max?: ParishMaxOrderByAggregateInput
    _min?: ParishMinOrderByAggregateInput
    _sum?: ParishSumOrderByAggregateInput
  }

  export type ParishScalarWhereWithAggregatesInput = {
    AND?: ParishScalarWhereWithAggregatesInput | ParishScalarWhereWithAggregatesInput[]
    OR?: ParishScalarWhereWithAggregatesInput[]
    NOT?: ParishScalarWhereWithAggregatesInput | ParishScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Parish"> | string
    name?: StringWithAggregatesFilter<"Parish"> | string
    region?: StringWithAggregatesFilter<"Parish"> | string
    countryCode?: StringWithAggregatesFilter<"Parish"> | string
    population?: IntWithAggregatesFilter<"Parish"> | number
    area?: FloatNullableWithAggregatesFilter<"Parish"> | number | null
    elevation?: FloatNullableWithAggregatesFilter<"Parish"> | number | null
    coordinates?: StringNullableWithAggregatesFilter<"Parish"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Parish"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Parish"> | Date | string
    isActive?: BoolWithAggregatesFilter<"Parish"> | boolean
  }

  export type AdminUnitRiskWhereInput = {
    AND?: AdminUnitRiskWhereInput | AdminUnitRiskWhereInput[]
    OR?: AdminUnitRiskWhereInput[]
    NOT?: AdminUnitRiskWhereInput | AdminUnitRiskWhereInput[]
    id?: StringFilter<"AdminUnitRisk"> | string
    adminUnitId?: StringFilter<"AdminUnitRisk"> | string
    createdAt?: DateTimeFilter<"AdminUnitRisk"> | Date | string
    updatedAt?: DateTimeFilter<"AdminUnitRisk"> | Date | string
    lastUpdated?: DateTimeFilter<"AdminUnitRisk"> | Date | string
    updatedBy?: StringFilter<"AdminUnitRisk"> | string
    hurricaneLevel?: IntFilter<"AdminUnitRisk"> | number
    hurricaneNotes?: StringFilter<"AdminUnitRisk"> | string
    floodLevel?: IntFilter<"AdminUnitRisk"> | number
    floodNotes?: StringFilter<"AdminUnitRisk"> | string
    earthquakeLevel?: IntFilter<"AdminUnitRisk"> | number
    earthquakeNotes?: StringFilter<"AdminUnitRisk"> | string
    droughtLevel?: IntFilter<"AdminUnitRisk"> | number
    droughtNotes?: StringFilter<"AdminUnitRisk"> | string
    landslideLevel?: IntFilter<"AdminUnitRisk"> | number
    landslideNotes?: StringFilter<"AdminUnitRisk"> | string
    powerOutageLevel?: IntFilter<"AdminUnitRisk"> | number
    powerOutageNotes?: StringFilter<"AdminUnitRisk"> | string
    riskProfileJson?: StringFilter<"AdminUnitRisk"> | string
    isActive?: BoolFilter<"AdminUnitRisk"> | boolean
    adminUnit?: XOR<AdminUnitRelationFilter, AdminUnitWhereInput>
    changeLogs?: AdminUnitRiskChangeLogListRelationFilter
  }

  export type AdminUnitRiskOrderByWithRelationInput = {
    id?: SortOrder
    adminUnitId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastUpdated?: SortOrder
    updatedBy?: SortOrder
    hurricaneLevel?: SortOrder
    hurricaneNotes?: SortOrder
    floodLevel?: SortOrder
    floodNotes?: SortOrder
    earthquakeLevel?: SortOrder
    earthquakeNotes?: SortOrder
    droughtLevel?: SortOrder
    droughtNotes?: SortOrder
    landslideLevel?: SortOrder
    landslideNotes?: SortOrder
    powerOutageLevel?: SortOrder
    powerOutageNotes?: SortOrder
    riskProfileJson?: SortOrder
    isActive?: SortOrder
    adminUnit?: AdminUnitOrderByWithRelationInput
    changeLogs?: AdminUnitRiskChangeLogOrderByRelationAggregateInput
  }

  export type AdminUnitRiskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    adminUnitId?: string
    AND?: AdminUnitRiskWhereInput | AdminUnitRiskWhereInput[]
    OR?: AdminUnitRiskWhereInput[]
    NOT?: AdminUnitRiskWhereInput | AdminUnitRiskWhereInput[]
    createdAt?: DateTimeFilter<"AdminUnitRisk"> | Date | string
    updatedAt?: DateTimeFilter<"AdminUnitRisk"> | Date | string
    lastUpdated?: DateTimeFilter<"AdminUnitRisk"> | Date | string
    updatedBy?: StringFilter<"AdminUnitRisk"> | string
    hurricaneLevel?: IntFilter<"AdminUnitRisk"> | number
    hurricaneNotes?: StringFilter<"AdminUnitRisk"> | string
    floodLevel?: IntFilter<"AdminUnitRisk"> | number
    floodNotes?: StringFilter<"AdminUnitRisk"> | string
    earthquakeLevel?: IntFilter<"AdminUnitRisk"> | number
    earthquakeNotes?: StringFilter<"AdminUnitRisk"> | string
    droughtLevel?: IntFilter<"AdminUnitRisk"> | number
    droughtNotes?: StringFilter<"AdminUnitRisk"> | string
    landslideLevel?: IntFilter<"AdminUnitRisk"> | number
    landslideNotes?: StringFilter<"AdminUnitRisk"> | string
    powerOutageLevel?: IntFilter<"AdminUnitRisk"> | number
    powerOutageNotes?: StringFilter<"AdminUnitRisk"> | string
    riskProfileJson?: StringFilter<"AdminUnitRisk"> | string
    isActive?: BoolFilter<"AdminUnitRisk"> | boolean
    adminUnit?: XOR<AdminUnitRelationFilter, AdminUnitWhereInput>
    changeLogs?: AdminUnitRiskChangeLogListRelationFilter
  }, "id" | "adminUnitId">

  export type AdminUnitRiskOrderByWithAggregationInput = {
    id?: SortOrder
    adminUnitId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastUpdated?: SortOrder
    updatedBy?: SortOrder
    hurricaneLevel?: SortOrder
    hurricaneNotes?: SortOrder
    floodLevel?: SortOrder
    floodNotes?: SortOrder
    earthquakeLevel?: SortOrder
    earthquakeNotes?: SortOrder
    droughtLevel?: SortOrder
    droughtNotes?: SortOrder
    landslideLevel?: SortOrder
    landslideNotes?: SortOrder
    powerOutageLevel?: SortOrder
    powerOutageNotes?: SortOrder
    riskProfileJson?: SortOrder
    isActive?: SortOrder
    _count?: AdminUnitRiskCountOrderByAggregateInput
    _avg?: AdminUnitRiskAvgOrderByAggregateInput
    _max?: AdminUnitRiskMaxOrderByAggregateInput
    _min?: AdminUnitRiskMinOrderByAggregateInput
    _sum?: AdminUnitRiskSumOrderByAggregateInput
  }

  export type AdminUnitRiskScalarWhereWithAggregatesInput = {
    AND?: AdminUnitRiskScalarWhereWithAggregatesInput | AdminUnitRiskScalarWhereWithAggregatesInput[]
    OR?: AdminUnitRiskScalarWhereWithAggregatesInput[]
    NOT?: AdminUnitRiskScalarWhereWithAggregatesInput | AdminUnitRiskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminUnitRisk"> | string
    adminUnitId?: StringWithAggregatesFilter<"AdminUnitRisk"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AdminUnitRisk"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AdminUnitRisk"> | Date | string
    lastUpdated?: DateTimeWithAggregatesFilter<"AdminUnitRisk"> | Date | string
    updatedBy?: StringWithAggregatesFilter<"AdminUnitRisk"> | string
    hurricaneLevel?: IntWithAggregatesFilter<"AdminUnitRisk"> | number
    hurricaneNotes?: StringWithAggregatesFilter<"AdminUnitRisk"> | string
    floodLevel?: IntWithAggregatesFilter<"AdminUnitRisk"> | number
    floodNotes?: StringWithAggregatesFilter<"AdminUnitRisk"> | string
    earthquakeLevel?: IntWithAggregatesFilter<"AdminUnitRisk"> | number
    earthquakeNotes?: StringWithAggregatesFilter<"AdminUnitRisk"> | string
    droughtLevel?: IntWithAggregatesFilter<"AdminUnitRisk"> | number
    droughtNotes?: StringWithAggregatesFilter<"AdminUnitRisk"> | string
    landslideLevel?: IntWithAggregatesFilter<"AdminUnitRisk"> | number
    landslideNotes?: StringWithAggregatesFilter<"AdminUnitRisk"> | string
    powerOutageLevel?: IntWithAggregatesFilter<"AdminUnitRisk"> | number
    powerOutageNotes?: StringWithAggregatesFilter<"AdminUnitRisk"> | string
    riskProfileJson?: StringWithAggregatesFilter<"AdminUnitRisk"> | string
    isActive?: BoolWithAggregatesFilter<"AdminUnitRisk"> | boolean
  }

  export type AdminUnitRiskChangeLogWhereInput = {
    AND?: AdminUnitRiskChangeLogWhereInput | AdminUnitRiskChangeLogWhereInput[]
    OR?: AdminUnitRiskChangeLogWhereInput[]
    NOT?: AdminUnitRiskChangeLogWhereInput | AdminUnitRiskChangeLogWhereInput[]
    id?: StringFilter<"AdminUnitRiskChangeLog"> | string
    adminUnitRiskId?: StringFilter<"AdminUnitRiskChangeLog"> | string
    riskType?: StringFilter<"AdminUnitRiskChangeLog"> | string
    oldLevel?: IntFilter<"AdminUnitRiskChangeLog"> | number
    newLevel?: IntFilter<"AdminUnitRiskChangeLog"> | number
    oldNotes?: StringFilter<"AdminUnitRiskChangeLog"> | string
    newNotes?: StringFilter<"AdminUnitRiskChangeLog"> | string
    changedBy?: StringFilter<"AdminUnitRiskChangeLog"> | string
    changeReason?: StringNullableFilter<"AdminUnitRiskChangeLog"> | string | null
    createdAt?: DateTimeFilter<"AdminUnitRiskChangeLog"> | Date | string
    adminUnitRisk?: XOR<AdminUnitRiskRelationFilter, AdminUnitRiskWhereInput>
  }

  export type AdminUnitRiskChangeLogOrderByWithRelationInput = {
    id?: SortOrder
    adminUnitRiskId?: SortOrder
    riskType?: SortOrder
    oldLevel?: SortOrder
    newLevel?: SortOrder
    oldNotes?: SortOrder
    newNotes?: SortOrder
    changedBy?: SortOrder
    changeReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    adminUnitRisk?: AdminUnitRiskOrderByWithRelationInput
  }

  export type AdminUnitRiskChangeLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdminUnitRiskChangeLogWhereInput | AdminUnitRiskChangeLogWhereInput[]
    OR?: AdminUnitRiskChangeLogWhereInput[]
    NOT?: AdminUnitRiskChangeLogWhereInput | AdminUnitRiskChangeLogWhereInput[]
    adminUnitRiskId?: StringFilter<"AdminUnitRiskChangeLog"> | string
    riskType?: StringFilter<"AdminUnitRiskChangeLog"> | string
    oldLevel?: IntFilter<"AdminUnitRiskChangeLog"> | number
    newLevel?: IntFilter<"AdminUnitRiskChangeLog"> | number
    oldNotes?: StringFilter<"AdminUnitRiskChangeLog"> | string
    newNotes?: StringFilter<"AdminUnitRiskChangeLog"> | string
    changedBy?: StringFilter<"AdminUnitRiskChangeLog"> | string
    changeReason?: StringNullableFilter<"AdminUnitRiskChangeLog"> | string | null
    createdAt?: DateTimeFilter<"AdminUnitRiskChangeLog"> | Date | string
    adminUnitRisk?: XOR<AdminUnitRiskRelationFilter, AdminUnitRiskWhereInput>
  }, "id">

  export type AdminUnitRiskChangeLogOrderByWithAggregationInput = {
    id?: SortOrder
    adminUnitRiskId?: SortOrder
    riskType?: SortOrder
    oldLevel?: SortOrder
    newLevel?: SortOrder
    oldNotes?: SortOrder
    newNotes?: SortOrder
    changedBy?: SortOrder
    changeReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AdminUnitRiskChangeLogCountOrderByAggregateInput
    _avg?: AdminUnitRiskChangeLogAvgOrderByAggregateInput
    _max?: AdminUnitRiskChangeLogMaxOrderByAggregateInput
    _min?: AdminUnitRiskChangeLogMinOrderByAggregateInput
    _sum?: AdminUnitRiskChangeLogSumOrderByAggregateInput
  }

  export type AdminUnitRiskChangeLogScalarWhereWithAggregatesInput = {
    AND?: AdminUnitRiskChangeLogScalarWhereWithAggregatesInput | AdminUnitRiskChangeLogScalarWhereWithAggregatesInput[]
    OR?: AdminUnitRiskChangeLogScalarWhereWithAggregatesInput[]
    NOT?: AdminUnitRiskChangeLogScalarWhereWithAggregatesInput | AdminUnitRiskChangeLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminUnitRiskChangeLog"> | string
    adminUnitRiskId?: StringWithAggregatesFilter<"AdminUnitRiskChangeLog"> | string
    riskType?: StringWithAggregatesFilter<"AdminUnitRiskChangeLog"> | string
    oldLevel?: IntWithAggregatesFilter<"AdminUnitRiskChangeLog"> | number
    newLevel?: IntWithAggregatesFilter<"AdminUnitRiskChangeLog"> | number
    oldNotes?: StringWithAggregatesFilter<"AdminUnitRiskChangeLog"> | string
    newNotes?: StringWithAggregatesFilter<"AdminUnitRiskChangeLog"> | string
    changedBy?: StringWithAggregatesFilter<"AdminUnitRiskChangeLog"> | string
    changeReason?: StringNullableWithAggregatesFilter<"AdminUnitRiskChangeLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AdminUnitRiskChangeLog"> | Date | string
  }

  export type ParishRiskWhereInput = {
    AND?: ParishRiskWhereInput | ParishRiskWhereInput[]
    OR?: ParishRiskWhereInput[]
    NOT?: ParishRiskWhereInput | ParishRiskWhereInput[]
    id?: StringFilter<"ParishRisk"> | string
    parishId?: StringFilter<"ParishRisk"> | string
    createdAt?: DateTimeFilter<"ParishRisk"> | Date | string
    updatedAt?: DateTimeFilter<"ParishRisk"> | Date | string
    lastUpdated?: DateTimeFilter<"ParishRisk"> | Date | string
    updatedBy?: StringFilter<"ParishRisk"> | string
    hurricaneLevel?: IntFilter<"ParishRisk"> | number
    hurricaneNotes?: StringFilter<"ParishRisk"> | string
    floodLevel?: IntFilter<"ParishRisk"> | number
    floodNotes?: StringFilter<"ParishRisk"> | string
    earthquakeLevel?: IntFilter<"ParishRisk"> | number
    earthquakeNotes?: StringFilter<"ParishRisk"> | string
    droughtLevel?: IntFilter<"ParishRisk"> | number
    droughtNotes?: StringFilter<"ParishRisk"> | string
    landslideLevel?: IntFilter<"ParishRisk"> | number
    landslideNotes?: StringFilter<"ParishRisk"> | string
    powerOutageLevel?: IntFilter<"ParishRisk"> | number
    powerOutageNotes?: StringFilter<"ParishRisk"> | string
    riskProfileJson?: StringFilter<"ParishRisk"> | string
    isActive?: BoolFilter<"ParishRisk"> | boolean
    parish?: XOR<ParishRelationFilter, ParishWhereInput>
    changeLogs?: RiskChangeLogListRelationFilter
  }

  export type ParishRiskOrderByWithRelationInput = {
    id?: SortOrder
    parishId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastUpdated?: SortOrder
    updatedBy?: SortOrder
    hurricaneLevel?: SortOrder
    hurricaneNotes?: SortOrder
    floodLevel?: SortOrder
    floodNotes?: SortOrder
    earthquakeLevel?: SortOrder
    earthquakeNotes?: SortOrder
    droughtLevel?: SortOrder
    droughtNotes?: SortOrder
    landslideLevel?: SortOrder
    landslideNotes?: SortOrder
    powerOutageLevel?: SortOrder
    powerOutageNotes?: SortOrder
    riskProfileJson?: SortOrder
    isActive?: SortOrder
    parish?: ParishOrderByWithRelationInput
    changeLogs?: RiskChangeLogOrderByRelationAggregateInput
  }

  export type ParishRiskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    parishId?: string
    AND?: ParishRiskWhereInput | ParishRiskWhereInput[]
    OR?: ParishRiskWhereInput[]
    NOT?: ParishRiskWhereInput | ParishRiskWhereInput[]
    createdAt?: DateTimeFilter<"ParishRisk"> | Date | string
    updatedAt?: DateTimeFilter<"ParishRisk"> | Date | string
    lastUpdated?: DateTimeFilter<"ParishRisk"> | Date | string
    updatedBy?: StringFilter<"ParishRisk"> | string
    hurricaneLevel?: IntFilter<"ParishRisk"> | number
    hurricaneNotes?: StringFilter<"ParishRisk"> | string
    floodLevel?: IntFilter<"ParishRisk"> | number
    floodNotes?: StringFilter<"ParishRisk"> | string
    earthquakeLevel?: IntFilter<"ParishRisk"> | number
    earthquakeNotes?: StringFilter<"ParishRisk"> | string
    droughtLevel?: IntFilter<"ParishRisk"> | number
    droughtNotes?: StringFilter<"ParishRisk"> | string
    landslideLevel?: IntFilter<"ParishRisk"> | number
    landslideNotes?: StringFilter<"ParishRisk"> | string
    powerOutageLevel?: IntFilter<"ParishRisk"> | number
    powerOutageNotes?: StringFilter<"ParishRisk"> | string
    riskProfileJson?: StringFilter<"ParishRisk"> | string
    isActive?: BoolFilter<"ParishRisk"> | boolean
    parish?: XOR<ParishRelationFilter, ParishWhereInput>
    changeLogs?: RiskChangeLogListRelationFilter
  }, "id" | "parishId">

  export type ParishRiskOrderByWithAggregationInput = {
    id?: SortOrder
    parishId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastUpdated?: SortOrder
    updatedBy?: SortOrder
    hurricaneLevel?: SortOrder
    hurricaneNotes?: SortOrder
    floodLevel?: SortOrder
    floodNotes?: SortOrder
    earthquakeLevel?: SortOrder
    earthquakeNotes?: SortOrder
    droughtLevel?: SortOrder
    droughtNotes?: SortOrder
    landslideLevel?: SortOrder
    landslideNotes?: SortOrder
    powerOutageLevel?: SortOrder
    powerOutageNotes?: SortOrder
    riskProfileJson?: SortOrder
    isActive?: SortOrder
    _count?: ParishRiskCountOrderByAggregateInput
    _avg?: ParishRiskAvgOrderByAggregateInput
    _max?: ParishRiskMaxOrderByAggregateInput
    _min?: ParishRiskMinOrderByAggregateInput
    _sum?: ParishRiskSumOrderByAggregateInput
  }

  export type ParishRiskScalarWhereWithAggregatesInput = {
    AND?: ParishRiskScalarWhereWithAggregatesInput | ParishRiskScalarWhereWithAggregatesInput[]
    OR?: ParishRiskScalarWhereWithAggregatesInput[]
    NOT?: ParishRiskScalarWhereWithAggregatesInput | ParishRiskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ParishRisk"> | string
    parishId?: StringWithAggregatesFilter<"ParishRisk"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ParishRisk"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ParishRisk"> | Date | string
    lastUpdated?: DateTimeWithAggregatesFilter<"ParishRisk"> | Date | string
    updatedBy?: StringWithAggregatesFilter<"ParishRisk"> | string
    hurricaneLevel?: IntWithAggregatesFilter<"ParishRisk"> | number
    hurricaneNotes?: StringWithAggregatesFilter<"ParishRisk"> | string
    floodLevel?: IntWithAggregatesFilter<"ParishRisk"> | number
    floodNotes?: StringWithAggregatesFilter<"ParishRisk"> | string
    earthquakeLevel?: IntWithAggregatesFilter<"ParishRisk"> | number
    earthquakeNotes?: StringWithAggregatesFilter<"ParishRisk"> | string
    droughtLevel?: IntWithAggregatesFilter<"ParishRisk"> | number
    droughtNotes?: StringWithAggregatesFilter<"ParishRisk"> | string
    landslideLevel?: IntWithAggregatesFilter<"ParishRisk"> | number
    landslideNotes?: StringWithAggregatesFilter<"ParishRisk"> | string
    powerOutageLevel?: IntWithAggregatesFilter<"ParishRisk"> | number
    powerOutageNotes?: StringWithAggregatesFilter<"ParishRisk"> | string
    riskProfileJson?: StringWithAggregatesFilter<"ParishRisk"> | string
    isActive?: BoolWithAggregatesFilter<"ParishRisk"> | boolean
  }

  export type RiskChangeLogWhereInput = {
    AND?: RiskChangeLogWhereInput | RiskChangeLogWhereInput[]
    OR?: RiskChangeLogWhereInput[]
    NOT?: RiskChangeLogWhereInput | RiskChangeLogWhereInput[]
    id?: StringFilter<"RiskChangeLog"> | string
    parishRiskId?: StringFilter<"RiskChangeLog"> | string
    riskType?: StringFilter<"RiskChangeLog"> | string
    oldLevel?: IntFilter<"RiskChangeLog"> | number
    newLevel?: IntFilter<"RiskChangeLog"> | number
    oldNotes?: StringFilter<"RiskChangeLog"> | string
    newNotes?: StringFilter<"RiskChangeLog"> | string
    changedBy?: StringFilter<"RiskChangeLog"> | string
    changeReason?: StringNullableFilter<"RiskChangeLog"> | string | null
    createdAt?: DateTimeFilter<"RiskChangeLog"> | Date | string
    parishRisk?: XOR<ParishRiskRelationFilter, ParishRiskWhereInput>
  }

  export type RiskChangeLogOrderByWithRelationInput = {
    id?: SortOrder
    parishRiskId?: SortOrder
    riskType?: SortOrder
    oldLevel?: SortOrder
    newLevel?: SortOrder
    oldNotes?: SortOrder
    newNotes?: SortOrder
    changedBy?: SortOrder
    changeReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    parishRisk?: ParishRiskOrderByWithRelationInput
  }

  export type RiskChangeLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RiskChangeLogWhereInput | RiskChangeLogWhereInput[]
    OR?: RiskChangeLogWhereInput[]
    NOT?: RiskChangeLogWhereInput | RiskChangeLogWhereInput[]
    parishRiskId?: StringFilter<"RiskChangeLog"> | string
    riskType?: StringFilter<"RiskChangeLog"> | string
    oldLevel?: IntFilter<"RiskChangeLog"> | number
    newLevel?: IntFilter<"RiskChangeLog"> | number
    oldNotes?: StringFilter<"RiskChangeLog"> | string
    newNotes?: StringFilter<"RiskChangeLog"> | string
    changedBy?: StringFilter<"RiskChangeLog"> | string
    changeReason?: StringNullableFilter<"RiskChangeLog"> | string | null
    createdAt?: DateTimeFilter<"RiskChangeLog"> | Date | string
    parishRisk?: XOR<ParishRiskRelationFilter, ParishRiskWhereInput>
  }, "id">

  export type RiskChangeLogOrderByWithAggregationInput = {
    id?: SortOrder
    parishRiskId?: SortOrder
    riskType?: SortOrder
    oldLevel?: SortOrder
    newLevel?: SortOrder
    oldNotes?: SortOrder
    newNotes?: SortOrder
    changedBy?: SortOrder
    changeReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: RiskChangeLogCountOrderByAggregateInput
    _avg?: RiskChangeLogAvgOrderByAggregateInput
    _max?: RiskChangeLogMaxOrderByAggregateInput
    _min?: RiskChangeLogMinOrderByAggregateInput
    _sum?: RiskChangeLogSumOrderByAggregateInput
  }

  export type RiskChangeLogScalarWhereWithAggregatesInput = {
    AND?: RiskChangeLogScalarWhereWithAggregatesInput | RiskChangeLogScalarWhereWithAggregatesInput[]
    OR?: RiskChangeLogScalarWhereWithAggregatesInput[]
    NOT?: RiskChangeLogScalarWhereWithAggregatesInput | RiskChangeLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RiskChangeLog"> | string
    parishRiskId?: StringWithAggregatesFilter<"RiskChangeLog"> | string
    riskType?: StringWithAggregatesFilter<"RiskChangeLog"> | string
    oldLevel?: IntWithAggregatesFilter<"RiskChangeLog"> | number
    newLevel?: IntWithAggregatesFilter<"RiskChangeLog"> | number
    oldNotes?: StringWithAggregatesFilter<"RiskChangeLog"> | string
    newNotes?: StringWithAggregatesFilter<"RiskChangeLog"> | string
    changedBy?: StringWithAggregatesFilter<"RiskChangeLog"> | string
    changeReason?: StringNullableWithAggregatesFilter<"RiskChangeLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RiskChangeLog"> | Date | string
  }

  export type BusinessTypeWhereInput = {
    AND?: BusinessTypeWhereInput | BusinessTypeWhereInput[]
    OR?: BusinessTypeWhereInput[]
    NOT?: BusinessTypeWhereInput | BusinessTypeWhereInput[]
    id?: StringFilter<"BusinessType"> | string
    businessTypeId?: StringFilter<"BusinessType"> | string
    name?: StringFilter<"BusinessType"> | string
    category?: StringFilter<"BusinessType"> | string
    subcategory?: StringNullableFilter<"BusinessType"> | string | null
    description?: StringNullableFilter<"BusinessType"> | string | null
    exampleBusinessPurposes?: StringNullableFilter<"BusinessType"> | string | null
    exampleProducts?: StringNullableFilter<"BusinessType"> | string | null
    exampleKeyPersonnel?: StringNullableFilter<"BusinessType"> | string | null
    exampleCustomerBase?: StringNullableFilter<"BusinessType"> | string | null
    minimumEquipment?: StringNullableFilter<"BusinessType"> | string | null
    isActive?: BoolFilter<"BusinessType"> | boolean
    createdAt?: DateTimeFilter<"BusinessType"> | Date | string
    updatedAt?: DateTimeFilter<"BusinessType"> | Date | string
    riskVulnerabilities?: BusinessRiskVulnerabilityListRelationFilter
    businessTypeStrategies?: BusinessTypeStrategyListRelationFilter
    businessRiskProfiles?: BusinessRiskProfileListRelationFilter
    translations?: BusinessTypeTranslationListRelationFilter
  }

  export type BusinessTypeOrderByWithRelationInput = {
    id?: SortOrder
    businessTypeId?: SortOrder
    name?: SortOrder
    category?: SortOrder
    subcategory?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    exampleBusinessPurposes?: SortOrderInput | SortOrder
    exampleProducts?: SortOrderInput | SortOrder
    exampleKeyPersonnel?: SortOrderInput | SortOrder
    exampleCustomerBase?: SortOrderInput | SortOrder
    minimumEquipment?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    riskVulnerabilities?: BusinessRiskVulnerabilityOrderByRelationAggregateInput
    businessTypeStrategies?: BusinessTypeStrategyOrderByRelationAggregateInput
    businessRiskProfiles?: BusinessRiskProfileOrderByRelationAggregateInput
    translations?: BusinessTypeTranslationOrderByRelationAggregateInput
  }

  export type BusinessTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    businessTypeId?: string
    AND?: BusinessTypeWhereInput | BusinessTypeWhereInput[]
    OR?: BusinessTypeWhereInput[]
    NOT?: BusinessTypeWhereInput | BusinessTypeWhereInput[]
    name?: StringFilter<"BusinessType"> | string
    category?: StringFilter<"BusinessType"> | string
    subcategory?: StringNullableFilter<"BusinessType"> | string | null
    description?: StringNullableFilter<"BusinessType"> | string | null
    exampleBusinessPurposes?: StringNullableFilter<"BusinessType"> | string | null
    exampleProducts?: StringNullableFilter<"BusinessType"> | string | null
    exampleKeyPersonnel?: StringNullableFilter<"BusinessType"> | string | null
    exampleCustomerBase?: StringNullableFilter<"BusinessType"> | string | null
    minimumEquipment?: StringNullableFilter<"BusinessType"> | string | null
    isActive?: BoolFilter<"BusinessType"> | boolean
    createdAt?: DateTimeFilter<"BusinessType"> | Date | string
    updatedAt?: DateTimeFilter<"BusinessType"> | Date | string
    riskVulnerabilities?: BusinessRiskVulnerabilityListRelationFilter
    businessTypeStrategies?: BusinessTypeStrategyListRelationFilter
    businessRiskProfiles?: BusinessRiskProfileListRelationFilter
    translations?: BusinessTypeTranslationListRelationFilter
  }, "id" | "businessTypeId">

  export type BusinessTypeOrderByWithAggregationInput = {
    id?: SortOrder
    businessTypeId?: SortOrder
    name?: SortOrder
    category?: SortOrder
    subcategory?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    exampleBusinessPurposes?: SortOrderInput | SortOrder
    exampleProducts?: SortOrderInput | SortOrder
    exampleKeyPersonnel?: SortOrderInput | SortOrder
    exampleCustomerBase?: SortOrderInput | SortOrder
    minimumEquipment?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BusinessTypeCountOrderByAggregateInput
    _max?: BusinessTypeMaxOrderByAggregateInput
    _min?: BusinessTypeMinOrderByAggregateInput
  }

  export type BusinessTypeScalarWhereWithAggregatesInput = {
    AND?: BusinessTypeScalarWhereWithAggregatesInput | BusinessTypeScalarWhereWithAggregatesInput[]
    OR?: BusinessTypeScalarWhereWithAggregatesInput[]
    NOT?: BusinessTypeScalarWhereWithAggregatesInput | BusinessTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BusinessType"> | string
    businessTypeId?: StringWithAggregatesFilter<"BusinessType"> | string
    name?: StringWithAggregatesFilter<"BusinessType"> | string
    category?: StringWithAggregatesFilter<"BusinessType"> | string
    subcategory?: StringNullableWithAggregatesFilter<"BusinessType"> | string | null
    description?: StringNullableWithAggregatesFilter<"BusinessType"> | string | null
    exampleBusinessPurposes?: StringNullableWithAggregatesFilter<"BusinessType"> | string | null
    exampleProducts?: StringNullableWithAggregatesFilter<"BusinessType"> | string | null
    exampleKeyPersonnel?: StringNullableWithAggregatesFilter<"BusinessType"> | string | null
    exampleCustomerBase?: StringNullableWithAggregatesFilter<"BusinessType"> | string | null
    minimumEquipment?: StringNullableWithAggregatesFilter<"BusinessType"> | string | null
    isActive?: BoolWithAggregatesFilter<"BusinessType"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"BusinessType"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BusinessType"> | Date | string
  }

  export type BusinessRiskVulnerabilityWhereInput = {
    AND?: BusinessRiskVulnerabilityWhereInput | BusinessRiskVulnerabilityWhereInput[]
    OR?: BusinessRiskVulnerabilityWhereInput[]
    NOT?: BusinessRiskVulnerabilityWhereInput | BusinessRiskVulnerabilityWhereInput[]
    id?: StringFilter<"BusinessRiskVulnerability"> | string
    businessTypeId?: StringFilter<"BusinessRiskVulnerability"> | string
    riskType?: StringFilter<"BusinessRiskVulnerability"> | string
    vulnerabilityLevel?: IntFilter<"BusinessRiskVulnerability"> | number
    impactSeverity?: IntFilter<"BusinessRiskVulnerability"> | number
    recoveryTime?: StringNullableFilter<"BusinessRiskVulnerability"> | string | null
    reasoning?: StringFilter<"BusinessRiskVulnerability"> | string
    mitigationDifficulty?: IntNullableFilter<"BusinessRiskVulnerability"> | number | null
    costToRecover?: StringNullableFilter<"BusinessRiskVulnerability"> | string | null
    businessImpactAreas?: StringNullableFilter<"BusinessRiskVulnerability"> | string | null
    criticalDependencies?: StringNullableFilter<"BusinessRiskVulnerability"> | string | null
    isActive?: BoolFilter<"BusinessRiskVulnerability"> | boolean
    createdAt?: DateTimeFilter<"BusinessRiskVulnerability"> | Date | string
    updatedAt?: DateTimeFilter<"BusinessRiskVulnerability"> | Date | string
    businessType?: XOR<BusinessTypeRelationFilter, BusinessTypeWhereInput>
  }

  export type BusinessRiskVulnerabilityOrderByWithRelationInput = {
    id?: SortOrder
    businessTypeId?: SortOrder
    riskType?: SortOrder
    vulnerabilityLevel?: SortOrder
    impactSeverity?: SortOrder
    recoveryTime?: SortOrderInput | SortOrder
    reasoning?: SortOrder
    mitigationDifficulty?: SortOrderInput | SortOrder
    costToRecover?: SortOrderInput | SortOrder
    businessImpactAreas?: SortOrderInput | SortOrder
    criticalDependencies?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    businessType?: BusinessTypeOrderByWithRelationInput
  }

  export type BusinessRiskVulnerabilityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    businessTypeId_riskType?: BusinessRiskVulnerabilityBusinessTypeIdRiskTypeCompoundUniqueInput
    AND?: BusinessRiskVulnerabilityWhereInput | BusinessRiskVulnerabilityWhereInput[]
    OR?: BusinessRiskVulnerabilityWhereInput[]
    NOT?: BusinessRiskVulnerabilityWhereInput | BusinessRiskVulnerabilityWhereInput[]
    businessTypeId?: StringFilter<"BusinessRiskVulnerability"> | string
    riskType?: StringFilter<"BusinessRiskVulnerability"> | string
    vulnerabilityLevel?: IntFilter<"BusinessRiskVulnerability"> | number
    impactSeverity?: IntFilter<"BusinessRiskVulnerability"> | number
    recoveryTime?: StringNullableFilter<"BusinessRiskVulnerability"> | string | null
    reasoning?: StringFilter<"BusinessRiskVulnerability"> | string
    mitigationDifficulty?: IntNullableFilter<"BusinessRiskVulnerability"> | number | null
    costToRecover?: StringNullableFilter<"BusinessRiskVulnerability"> | string | null
    businessImpactAreas?: StringNullableFilter<"BusinessRiskVulnerability"> | string | null
    criticalDependencies?: StringNullableFilter<"BusinessRiskVulnerability"> | string | null
    isActive?: BoolFilter<"BusinessRiskVulnerability"> | boolean
    createdAt?: DateTimeFilter<"BusinessRiskVulnerability"> | Date | string
    updatedAt?: DateTimeFilter<"BusinessRiskVulnerability"> | Date | string
    businessType?: XOR<BusinessTypeRelationFilter, BusinessTypeWhereInput>
  }, "id" | "businessTypeId_riskType">

  export type BusinessRiskVulnerabilityOrderByWithAggregationInput = {
    id?: SortOrder
    businessTypeId?: SortOrder
    riskType?: SortOrder
    vulnerabilityLevel?: SortOrder
    impactSeverity?: SortOrder
    recoveryTime?: SortOrderInput | SortOrder
    reasoning?: SortOrder
    mitigationDifficulty?: SortOrderInput | SortOrder
    costToRecover?: SortOrderInput | SortOrder
    businessImpactAreas?: SortOrderInput | SortOrder
    criticalDependencies?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BusinessRiskVulnerabilityCountOrderByAggregateInput
    _avg?: BusinessRiskVulnerabilityAvgOrderByAggregateInput
    _max?: BusinessRiskVulnerabilityMaxOrderByAggregateInput
    _min?: BusinessRiskVulnerabilityMinOrderByAggregateInput
    _sum?: BusinessRiskVulnerabilitySumOrderByAggregateInput
  }

  export type BusinessRiskVulnerabilityScalarWhereWithAggregatesInput = {
    AND?: BusinessRiskVulnerabilityScalarWhereWithAggregatesInput | BusinessRiskVulnerabilityScalarWhereWithAggregatesInput[]
    OR?: BusinessRiskVulnerabilityScalarWhereWithAggregatesInput[]
    NOT?: BusinessRiskVulnerabilityScalarWhereWithAggregatesInput | BusinessRiskVulnerabilityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BusinessRiskVulnerability"> | string
    businessTypeId?: StringWithAggregatesFilter<"BusinessRiskVulnerability"> | string
    riskType?: StringWithAggregatesFilter<"BusinessRiskVulnerability"> | string
    vulnerabilityLevel?: IntWithAggregatesFilter<"BusinessRiskVulnerability"> | number
    impactSeverity?: IntWithAggregatesFilter<"BusinessRiskVulnerability"> | number
    recoveryTime?: StringNullableWithAggregatesFilter<"BusinessRiskVulnerability"> | string | null
    reasoning?: StringWithAggregatesFilter<"BusinessRiskVulnerability"> | string
    mitigationDifficulty?: IntNullableWithAggregatesFilter<"BusinessRiskVulnerability"> | number | null
    costToRecover?: StringNullableWithAggregatesFilter<"BusinessRiskVulnerability"> | string | null
    businessImpactAreas?: StringNullableWithAggregatesFilter<"BusinessRiskVulnerability"> | string | null
    criticalDependencies?: StringNullableWithAggregatesFilter<"BusinessRiskVulnerability"> | string | null
    isActive?: BoolWithAggregatesFilter<"BusinessRiskVulnerability"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"BusinessRiskVulnerability"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BusinessRiskVulnerability"> | Date | string
  }

  export type RiskMitigationStrategyWhereInput = {
    AND?: RiskMitigationStrategyWhereInput | RiskMitigationStrategyWhereInput[]
    OR?: RiskMitigationStrategyWhereInput[]
    NOT?: RiskMitigationStrategyWhereInput | RiskMitigationStrategyWhereInput[]
    id?: StringFilter<"RiskMitigationStrategy"> | string
    strategyId?: StringFilter<"RiskMitigationStrategy"> | string
    name?: StringFilter<"RiskMitigationStrategy"> | string
    description?: StringFilter<"RiskMitigationStrategy"> | string
    smeTitle?: StringNullableFilter<"RiskMitigationStrategy"> | string | null
    smeSummary?: StringNullableFilter<"RiskMitigationStrategy"> | string | null
    smeDescription?: StringNullableFilter<"RiskMitigationStrategy"> | string | null
    whyImportant?: StringNullableFilter<"RiskMitigationStrategy"> | string | null
    benefitsBullets?: StringNullableFilter<"RiskMitigationStrategy"> | string | null
    realWorldExample?: StringNullableFilter<"RiskMitigationStrategy"> | string | null
    calculatedCostUSD?: DecimalNullableFilter<"RiskMitigationStrategy"> | Decimal | DecimalJsLike | number | string | null
    calculatedCostLocal?: DecimalNullableFilter<"RiskMitigationStrategy"> | Decimal | DecimalJsLike | number | string | null
    currencyCode?: StringNullableFilter<"RiskMitigationStrategy"> | string | null
    currencySymbol?: StringNullableFilter<"RiskMitigationStrategy"> | string | null
    totalEstimatedHours?: IntNullableFilter<"RiskMitigationStrategy"> | number | null
    selectionTier?: StringNullableFilter<"RiskMitigationStrategy"> | string | null
    requiredForRisks?: StringNullableFilter<"RiskMitigationStrategy"> | string | null
    helpfulTips?: StringNullableFilter<"RiskMitigationStrategy"> | string | null
    commonMistakes?: StringNullableFilter<"RiskMitigationStrategy"> | string | null
    successMetrics?: StringNullableFilter<"RiskMitigationStrategy"> | string | null
    lowBudgetAlternative?: StringNullableFilter<"RiskMitigationStrategy"> | string | null
    applicableRisks?: StringFilter<"RiskMitigationStrategy"> | string
    applicableBusinessTypes?: StringNullableFilter<"RiskMitigationStrategy"> | string | null
    isActive?: BoolFilter<"RiskMitigationStrategy"> | boolean
    createdAt?: DateTimeFilter<"RiskMitigationStrategy"> | Date | string
    updatedAt?: DateTimeFilter<"RiskMitigationStrategy"> | Date | string
    businessTypeStrategies?: BusinessTypeStrategyListRelationFilter
    actionSteps?: ActionStepListRelationFilter
    itemCosts?: StrategyItemCostListRelationFilter
    translations?: StrategyTranslationListRelationFilter
  }

  export type RiskMitigationStrategyOrderByWithRelationInput = {
    id?: SortOrder
    strategyId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    smeTitle?: SortOrderInput | SortOrder
    smeSummary?: SortOrderInput | SortOrder
    smeDescription?: SortOrderInput | SortOrder
    whyImportant?: SortOrderInput | SortOrder
    benefitsBullets?: SortOrderInput | SortOrder
    realWorldExample?: SortOrderInput | SortOrder
    calculatedCostUSD?: SortOrderInput | SortOrder
    calculatedCostLocal?: SortOrderInput | SortOrder
    currencyCode?: SortOrderInput | SortOrder
    currencySymbol?: SortOrderInput | SortOrder
    totalEstimatedHours?: SortOrderInput | SortOrder
    selectionTier?: SortOrderInput | SortOrder
    requiredForRisks?: SortOrderInput | SortOrder
    helpfulTips?: SortOrderInput | SortOrder
    commonMistakes?: SortOrderInput | SortOrder
    successMetrics?: SortOrderInput | SortOrder
    lowBudgetAlternative?: SortOrderInput | SortOrder
    applicableRisks?: SortOrder
    applicableBusinessTypes?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    businessTypeStrategies?: BusinessTypeStrategyOrderByRelationAggregateInput
    actionSteps?: ActionStepOrderByRelationAggregateInput
    itemCosts?: StrategyItemCostOrderByRelationAggregateInput
    translations?: StrategyTranslationOrderByRelationAggregateInput
  }

  export type RiskMitigationStrategyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    strategyId?: string
    AND?: RiskMitigationStrategyWhereInput | RiskMitigationStrategyWhereInput[]
    OR?: RiskMitigationStrategyWhereInput[]
    NOT?: RiskMitigationStrategyWhereInput | RiskMitigationStrategyWhereInput[]
    name?: StringFilter<"RiskMitigationStrategy"> | string
    description?: StringFilter<"RiskMitigationStrategy"> | string
    smeTitle?: StringNullableFilter<"RiskMitigationStrategy"> | string | null
    smeSummary?: StringNullableFilter<"RiskMitigationStrategy"> | string | null
    smeDescription?: StringNullableFilter<"RiskMitigationStrategy"> | string | null
    whyImportant?: StringNullableFilter<"RiskMitigationStrategy"> | string | null
    benefitsBullets?: StringNullableFilter<"RiskMitigationStrategy"> | string | null
    realWorldExample?: StringNullableFilter<"RiskMitigationStrategy"> | string | null
    calculatedCostUSD?: DecimalNullableFilter<"RiskMitigationStrategy"> | Decimal | DecimalJsLike | number | string | null
    calculatedCostLocal?: DecimalNullableFilter<"RiskMitigationStrategy"> | Decimal | DecimalJsLike | number | string | null
    currencyCode?: StringNullableFilter<"RiskMitigationStrategy"> | string | null
    currencySymbol?: StringNullableFilter<"RiskMitigationStrategy"> | string | null
    totalEstimatedHours?: IntNullableFilter<"RiskMitigationStrategy"> | number | null
    selectionTier?: StringNullableFilter<"RiskMitigationStrategy"> | string | null
    requiredForRisks?: StringNullableFilter<"RiskMitigationStrategy"> | string | null
    helpfulTips?: StringNullableFilter<"RiskMitigationStrategy"> | string | null
    commonMistakes?: StringNullableFilter<"RiskMitigationStrategy"> | string | null
    successMetrics?: StringNullableFilter<"RiskMitigationStrategy"> | string | null
    lowBudgetAlternative?: StringNullableFilter<"RiskMitigationStrategy"> | string | null
    applicableRisks?: StringFilter<"RiskMitigationStrategy"> | string
    applicableBusinessTypes?: StringNullableFilter<"RiskMitigationStrategy"> | string | null
    isActive?: BoolFilter<"RiskMitigationStrategy"> | boolean
    createdAt?: DateTimeFilter<"RiskMitigationStrategy"> | Date | string
    updatedAt?: DateTimeFilter<"RiskMitigationStrategy"> | Date | string
    businessTypeStrategies?: BusinessTypeStrategyListRelationFilter
    actionSteps?: ActionStepListRelationFilter
    itemCosts?: StrategyItemCostListRelationFilter
    translations?: StrategyTranslationListRelationFilter
  }, "id" | "strategyId">

  export type RiskMitigationStrategyOrderByWithAggregationInput = {
    id?: SortOrder
    strategyId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    smeTitle?: SortOrderInput | SortOrder
    smeSummary?: SortOrderInput | SortOrder
    smeDescription?: SortOrderInput | SortOrder
    whyImportant?: SortOrderInput | SortOrder
    benefitsBullets?: SortOrderInput | SortOrder
    realWorldExample?: SortOrderInput | SortOrder
    calculatedCostUSD?: SortOrderInput | SortOrder
    calculatedCostLocal?: SortOrderInput | SortOrder
    currencyCode?: SortOrderInput | SortOrder
    currencySymbol?: SortOrderInput | SortOrder
    totalEstimatedHours?: SortOrderInput | SortOrder
    selectionTier?: SortOrderInput | SortOrder
    requiredForRisks?: SortOrderInput | SortOrder
    helpfulTips?: SortOrderInput | SortOrder
    commonMistakes?: SortOrderInput | SortOrder
    successMetrics?: SortOrderInput | SortOrder
    lowBudgetAlternative?: SortOrderInput | SortOrder
    applicableRisks?: SortOrder
    applicableBusinessTypes?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RiskMitigationStrategyCountOrderByAggregateInput
    _avg?: RiskMitigationStrategyAvgOrderByAggregateInput
    _max?: RiskMitigationStrategyMaxOrderByAggregateInput
    _min?: RiskMitigationStrategyMinOrderByAggregateInput
    _sum?: RiskMitigationStrategySumOrderByAggregateInput
  }

  export type RiskMitigationStrategyScalarWhereWithAggregatesInput = {
    AND?: RiskMitigationStrategyScalarWhereWithAggregatesInput | RiskMitigationStrategyScalarWhereWithAggregatesInput[]
    OR?: RiskMitigationStrategyScalarWhereWithAggregatesInput[]
    NOT?: RiskMitigationStrategyScalarWhereWithAggregatesInput | RiskMitigationStrategyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RiskMitigationStrategy"> | string
    strategyId?: StringWithAggregatesFilter<"RiskMitigationStrategy"> | string
    name?: StringWithAggregatesFilter<"RiskMitigationStrategy"> | string
    description?: StringWithAggregatesFilter<"RiskMitigationStrategy"> | string
    smeTitle?: StringNullableWithAggregatesFilter<"RiskMitigationStrategy"> | string | null
    smeSummary?: StringNullableWithAggregatesFilter<"RiskMitigationStrategy"> | string | null
    smeDescription?: StringNullableWithAggregatesFilter<"RiskMitigationStrategy"> | string | null
    whyImportant?: StringNullableWithAggregatesFilter<"RiskMitigationStrategy"> | string | null
    benefitsBullets?: StringNullableWithAggregatesFilter<"RiskMitigationStrategy"> | string | null
    realWorldExample?: StringNullableWithAggregatesFilter<"RiskMitigationStrategy"> | string | null
    calculatedCostUSD?: DecimalNullableWithAggregatesFilter<"RiskMitigationStrategy"> | Decimal | DecimalJsLike | number | string | null
    calculatedCostLocal?: DecimalNullableWithAggregatesFilter<"RiskMitigationStrategy"> | Decimal | DecimalJsLike | number | string | null
    currencyCode?: StringNullableWithAggregatesFilter<"RiskMitigationStrategy"> | string | null
    currencySymbol?: StringNullableWithAggregatesFilter<"RiskMitigationStrategy"> | string | null
    totalEstimatedHours?: IntNullableWithAggregatesFilter<"RiskMitigationStrategy"> | number | null
    selectionTier?: StringNullableWithAggregatesFilter<"RiskMitigationStrategy"> | string | null
    requiredForRisks?: StringNullableWithAggregatesFilter<"RiskMitigationStrategy"> | string | null
    helpfulTips?: StringNullableWithAggregatesFilter<"RiskMitigationStrategy"> | string | null
    commonMistakes?: StringNullableWithAggregatesFilter<"RiskMitigationStrategy"> | string | null
    successMetrics?: StringNullableWithAggregatesFilter<"RiskMitigationStrategy"> | string | null
    lowBudgetAlternative?: StringNullableWithAggregatesFilter<"RiskMitigationStrategy"> | string | null
    applicableRisks?: StringWithAggregatesFilter<"RiskMitigationStrategy"> | string
    applicableBusinessTypes?: StringNullableWithAggregatesFilter<"RiskMitigationStrategy"> | string | null
    isActive?: BoolWithAggregatesFilter<"RiskMitigationStrategy"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"RiskMitigationStrategy"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RiskMitigationStrategy"> | Date | string
  }

  export type ActionStepWhereInput = {
    AND?: ActionStepWhereInput | ActionStepWhereInput[]
    OR?: ActionStepWhereInput[]
    NOT?: ActionStepWhereInput | ActionStepWhereInput[]
    id?: StringFilter<"ActionStep"> | string
    strategyId?: StringFilter<"ActionStep"> | string
    stepId?: StringFilter<"ActionStep"> | string
    phase?: StringFilter<"ActionStep"> | string
    title?: StringFilter<"ActionStep"> | string
    description?: StringFilter<"ActionStep"> | string
    smeAction?: StringNullableFilter<"ActionStep"> | string | null
    whyThisStepMatters?: StringNullableFilter<"ActionStep"> | string | null
    whatHappensIfSkipped?: StringNullableFilter<"ActionStep"> | string | null
    timeframe?: StringNullableFilter<"ActionStep"> | string | null
    estimatedMinutes?: IntNullableFilter<"ActionStep"> | number | null
    difficultyLevel?: StringNullableFilter<"ActionStep"> | string | null
    responsibility?: StringNullableFilter<"ActionStep"> | string | null
    estimatedCost?: StringNullableFilter<"ActionStep"> | string | null
    estimatedCostJMD?: StringNullableFilter<"ActionStep"> | string | null
    resources?: StringNullableFilter<"ActionStep"> | string | null
    checklist?: StringNullableFilter<"ActionStep"> | string | null
    howToKnowItsDone?: StringNullableFilter<"ActionStep"> | string | null
    exampleOutput?: StringNullableFilter<"ActionStep"> | string | null
    dependsOnSteps?: StringNullableFilter<"ActionStep"> | string | null
    isOptional?: BoolFilter<"ActionStep"> | boolean
    skipConditions?: StringNullableFilter<"ActionStep"> | string | null
    freeAlternative?: StringNullableFilter<"ActionStep"> | string | null
    lowTechOption?: StringNullableFilter<"ActionStep"> | string | null
    commonMistakesForStep?: StringNullableFilter<"ActionStep"> | string | null
    videoTutorialUrl?: StringNullableFilter<"ActionStep"> | string | null
    externalResourceUrl?: StringNullableFilter<"ActionStep"> | string | null
    sortOrder?: IntFilter<"ActionStep"> | number
    isActive?: BoolFilter<"ActionStep"> | boolean
    createdAt?: DateTimeFilter<"ActionStep"> | Date | string
    updatedAt?: DateTimeFilter<"ActionStep"> | Date | string
    strategy?: XOR<RiskMitigationStrategyRelationFilter, RiskMitigationStrategyWhereInput>
    itemCosts?: ActionStepItemCostListRelationFilter
    translations?: ActionStepTranslationListRelationFilter
  }

  export type ActionStepOrderByWithRelationInput = {
    id?: SortOrder
    strategyId?: SortOrder
    stepId?: SortOrder
    phase?: SortOrder
    title?: SortOrder
    description?: SortOrder
    smeAction?: SortOrderInput | SortOrder
    whyThisStepMatters?: SortOrderInput | SortOrder
    whatHappensIfSkipped?: SortOrderInput | SortOrder
    timeframe?: SortOrderInput | SortOrder
    estimatedMinutes?: SortOrderInput | SortOrder
    difficultyLevel?: SortOrderInput | SortOrder
    responsibility?: SortOrderInput | SortOrder
    estimatedCost?: SortOrderInput | SortOrder
    estimatedCostJMD?: SortOrderInput | SortOrder
    resources?: SortOrderInput | SortOrder
    checklist?: SortOrderInput | SortOrder
    howToKnowItsDone?: SortOrderInput | SortOrder
    exampleOutput?: SortOrderInput | SortOrder
    dependsOnSteps?: SortOrderInput | SortOrder
    isOptional?: SortOrder
    skipConditions?: SortOrderInput | SortOrder
    freeAlternative?: SortOrderInput | SortOrder
    lowTechOption?: SortOrderInput | SortOrder
    commonMistakesForStep?: SortOrderInput | SortOrder
    videoTutorialUrl?: SortOrderInput | SortOrder
    externalResourceUrl?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    strategy?: RiskMitigationStrategyOrderByWithRelationInput
    itemCosts?: ActionStepItemCostOrderByRelationAggregateInput
    translations?: ActionStepTranslationOrderByRelationAggregateInput
  }

  export type ActionStepWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    strategyId_stepId?: ActionStepStrategyIdStepIdCompoundUniqueInput
    AND?: ActionStepWhereInput | ActionStepWhereInput[]
    OR?: ActionStepWhereInput[]
    NOT?: ActionStepWhereInput | ActionStepWhereInput[]
    strategyId?: StringFilter<"ActionStep"> | string
    stepId?: StringFilter<"ActionStep"> | string
    phase?: StringFilter<"ActionStep"> | string
    title?: StringFilter<"ActionStep"> | string
    description?: StringFilter<"ActionStep"> | string
    smeAction?: StringNullableFilter<"ActionStep"> | string | null
    whyThisStepMatters?: StringNullableFilter<"ActionStep"> | string | null
    whatHappensIfSkipped?: StringNullableFilter<"ActionStep"> | string | null
    timeframe?: StringNullableFilter<"ActionStep"> | string | null
    estimatedMinutes?: IntNullableFilter<"ActionStep"> | number | null
    difficultyLevel?: StringNullableFilter<"ActionStep"> | string | null
    responsibility?: StringNullableFilter<"ActionStep"> | string | null
    estimatedCost?: StringNullableFilter<"ActionStep"> | string | null
    estimatedCostJMD?: StringNullableFilter<"ActionStep"> | string | null
    resources?: StringNullableFilter<"ActionStep"> | string | null
    checklist?: StringNullableFilter<"ActionStep"> | string | null
    howToKnowItsDone?: StringNullableFilter<"ActionStep"> | string | null
    exampleOutput?: StringNullableFilter<"ActionStep"> | string | null
    dependsOnSteps?: StringNullableFilter<"ActionStep"> | string | null
    isOptional?: BoolFilter<"ActionStep"> | boolean
    skipConditions?: StringNullableFilter<"ActionStep"> | string | null
    freeAlternative?: StringNullableFilter<"ActionStep"> | string | null
    lowTechOption?: StringNullableFilter<"ActionStep"> | string | null
    commonMistakesForStep?: StringNullableFilter<"ActionStep"> | string | null
    videoTutorialUrl?: StringNullableFilter<"ActionStep"> | string | null
    externalResourceUrl?: StringNullableFilter<"ActionStep"> | string | null
    sortOrder?: IntFilter<"ActionStep"> | number
    isActive?: BoolFilter<"ActionStep"> | boolean
    createdAt?: DateTimeFilter<"ActionStep"> | Date | string
    updatedAt?: DateTimeFilter<"ActionStep"> | Date | string
    strategy?: XOR<RiskMitigationStrategyRelationFilter, RiskMitigationStrategyWhereInput>
    itemCosts?: ActionStepItemCostListRelationFilter
    translations?: ActionStepTranslationListRelationFilter
  }, "id" | "strategyId_stepId">

  export type ActionStepOrderByWithAggregationInput = {
    id?: SortOrder
    strategyId?: SortOrder
    stepId?: SortOrder
    phase?: SortOrder
    title?: SortOrder
    description?: SortOrder
    smeAction?: SortOrderInput | SortOrder
    whyThisStepMatters?: SortOrderInput | SortOrder
    whatHappensIfSkipped?: SortOrderInput | SortOrder
    timeframe?: SortOrderInput | SortOrder
    estimatedMinutes?: SortOrderInput | SortOrder
    difficultyLevel?: SortOrderInput | SortOrder
    responsibility?: SortOrderInput | SortOrder
    estimatedCost?: SortOrderInput | SortOrder
    estimatedCostJMD?: SortOrderInput | SortOrder
    resources?: SortOrderInput | SortOrder
    checklist?: SortOrderInput | SortOrder
    howToKnowItsDone?: SortOrderInput | SortOrder
    exampleOutput?: SortOrderInput | SortOrder
    dependsOnSteps?: SortOrderInput | SortOrder
    isOptional?: SortOrder
    skipConditions?: SortOrderInput | SortOrder
    freeAlternative?: SortOrderInput | SortOrder
    lowTechOption?: SortOrderInput | SortOrder
    commonMistakesForStep?: SortOrderInput | SortOrder
    videoTutorialUrl?: SortOrderInput | SortOrder
    externalResourceUrl?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ActionStepCountOrderByAggregateInput
    _avg?: ActionStepAvgOrderByAggregateInput
    _max?: ActionStepMaxOrderByAggregateInput
    _min?: ActionStepMinOrderByAggregateInput
    _sum?: ActionStepSumOrderByAggregateInput
  }

  export type ActionStepScalarWhereWithAggregatesInput = {
    AND?: ActionStepScalarWhereWithAggregatesInput | ActionStepScalarWhereWithAggregatesInput[]
    OR?: ActionStepScalarWhereWithAggregatesInput[]
    NOT?: ActionStepScalarWhereWithAggregatesInput | ActionStepScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ActionStep"> | string
    strategyId?: StringWithAggregatesFilter<"ActionStep"> | string
    stepId?: StringWithAggregatesFilter<"ActionStep"> | string
    phase?: StringWithAggregatesFilter<"ActionStep"> | string
    title?: StringWithAggregatesFilter<"ActionStep"> | string
    description?: StringWithAggregatesFilter<"ActionStep"> | string
    smeAction?: StringNullableWithAggregatesFilter<"ActionStep"> | string | null
    whyThisStepMatters?: StringNullableWithAggregatesFilter<"ActionStep"> | string | null
    whatHappensIfSkipped?: StringNullableWithAggregatesFilter<"ActionStep"> | string | null
    timeframe?: StringNullableWithAggregatesFilter<"ActionStep"> | string | null
    estimatedMinutes?: IntNullableWithAggregatesFilter<"ActionStep"> | number | null
    difficultyLevel?: StringNullableWithAggregatesFilter<"ActionStep"> | string | null
    responsibility?: StringNullableWithAggregatesFilter<"ActionStep"> | string | null
    estimatedCost?: StringNullableWithAggregatesFilter<"ActionStep"> | string | null
    estimatedCostJMD?: StringNullableWithAggregatesFilter<"ActionStep"> | string | null
    resources?: StringNullableWithAggregatesFilter<"ActionStep"> | string | null
    checklist?: StringNullableWithAggregatesFilter<"ActionStep"> | string | null
    howToKnowItsDone?: StringNullableWithAggregatesFilter<"ActionStep"> | string | null
    exampleOutput?: StringNullableWithAggregatesFilter<"ActionStep"> | string | null
    dependsOnSteps?: StringNullableWithAggregatesFilter<"ActionStep"> | string | null
    isOptional?: BoolWithAggregatesFilter<"ActionStep"> | boolean
    skipConditions?: StringNullableWithAggregatesFilter<"ActionStep"> | string | null
    freeAlternative?: StringNullableWithAggregatesFilter<"ActionStep"> | string | null
    lowTechOption?: StringNullableWithAggregatesFilter<"ActionStep"> | string | null
    commonMistakesForStep?: StringNullableWithAggregatesFilter<"ActionStep"> | string | null
    videoTutorialUrl?: StringNullableWithAggregatesFilter<"ActionStep"> | string | null
    externalResourceUrl?: StringNullableWithAggregatesFilter<"ActionStep"> | string | null
    sortOrder?: IntWithAggregatesFilter<"ActionStep"> | number
    isActive?: BoolWithAggregatesFilter<"ActionStep"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ActionStep"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ActionStep"> | Date | string
  }

  export type BusinessTypeStrategyWhereInput = {
    AND?: BusinessTypeStrategyWhereInput | BusinessTypeStrategyWhereInput[]
    OR?: BusinessTypeStrategyWhereInput[]
    NOT?: BusinessTypeStrategyWhereInput | BusinessTypeStrategyWhereInput[]
    id?: StringFilter<"BusinessTypeStrategy"> | string
    businessTypeId?: StringFilter<"BusinessTypeStrategy"> | string
    strategyId?: StringFilter<"BusinessTypeStrategy"> | string
    relevanceScore?: IntNullableFilter<"BusinessTypeStrategy"> | number | null
    customNotes?: StringNullableFilter<"BusinessTypeStrategy"> | string | null
    isRecommended?: BoolNullableFilter<"BusinessTypeStrategy"> | boolean | null
    priority?: StringNullableFilter<"BusinessTypeStrategy"> | string | null
    createdAt?: DateTimeFilter<"BusinessTypeStrategy"> | Date | string
    updatedAt?: DateTimeFilter<"BusinessTypeStrategy"> | Date | string
    businessType?: XOR<BusinessTypeRelationFilter, BusinessTypeWhereInput>
    strategy?: XOR<RiskMitigationStrategyRelationFilter, RiskMitigationStrategyWhereInput>
  }

  export type BusinessTypeStrategyOrderByWithRelationInput = {
    id?: SortOrder
    businessTypeId?: SortOrder
    strategyId?: SortOrder
    relevanceScore?: SortOrderInput | SortOrder
    customNotes?: SortOrderInput | SortOrder
    isRecommended?: SortOrderInput | SortOrder
    priority?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    businessType?: BusinessTypeOrderByWithRelationInput
    strategy?: RiskMitigationStrategyOrderByWithRelationInput
  }

  export type BusinessTypeStrategyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    businessTypeId_strategyId?: BusinessTypeStrategyBusinessTypeIdStrategyIdCompoundUniqueInput
    AND?: BusinessTypeStrategyWhereInput | BusinessTypeStrategyWhereInput[]
    OR?: BusinessTypeStrategyWhereInput[]
    NOT?: BusinessTypeStrategyWhereInput | BusinessTypeStrategyWhereInput[]
    businessTypeId?: StringFilter<"BusinessTypeStrategy"> | string
    strategyId?: StringFilter<"BusinessTypeStrategy"> | string
    relevanceScore?: IntNullableFilter<"BusinessTypeStrategy"> | number | null
    customNotes?: StringNullableFilter<"BusinessTypeStrategy"> | string | null
    isRecommended?: BoolNullableFilter<"BusinessTypeStrategy"> | boolean | null
    priority?: StringNullableFilter<"BusinessTypeStrategy"> | string | null
    createdAt?: DateTimeFilter<"BusinessTypeStrategy"> | Date | string
    updatedAt?: DateTimeFilter<"BusinessTypeStrategy"> | Date | string
    businessType?: XOR<BusinessTypeRelationFilter, BusinessTypeWhereInput>
    strategy?: XOR<RiskMitigationStrategyRelationFilter, RiskMitigationStrategyWhereInput>
  }, "id" | "businessTypeId_strategyId">

  export type BusinessTypeStrategyOrderByWithAggregationInput = {
    id?: SortOrder
    businessTypeId?: SortOrder
    strategyId?: SortOrder
    relevanceScore?: SortOrderInput | SortOrder
    customNotes?: SortOrderInput | SortOrder
    isRecommended?: SortOrderInput | SortOrder
    priority?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BusinessTypeStrategyCountOrderByAggregateInput
    _avg?: BusinessTypeStrategyAvgOrderByAggregateInput
    _max?: BusinessTypeStrategyMaxOrderByAggregateInput
    _min?: BusinessTypeStrategyMinOrderByAggregateInput
    _sum?: BusinessTypeStrategySumOrderByAggregateInput
  }

  export type BusinessTypeStrategyScalarWhereWithAggregatesInput = {
    AND?: BusinessTypeStrategyScalarWhereWithAggregatesInput | BusinessTypeStrategyScalarWhereWithAggregatesInput[]
    OR?: BusinessTypeStrategyScalarWhereWithAggregatesInput[]
    NOT?: BusinessTypeStrategyScalarWhereWithAggregatesInput | BusinessTypeStrategyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BusinessTypeStrategy"> | string
    businessTypeId?: StringWithAggregatesFilter<"BusinessTypeStrategy"> | string
    strategyId?: StringWithAggregatesFilter<"BusinessTypeStrategy"> | string
    relevanceScore?: IntNullableWithAggregatesFilter<"BusinessTypeStrategy"> | number | null
    customNotes?: StringNullableWithAggregatesFilter<"BusinessTypeStrategy"> | string | null
    isRecommended?: BoolNullableWithAggregatesFilter<"BusinessTypeStrategy"> | boolean | null
    priority?: StringNullableWithAggregatesFilter<"BusinessTypeStrategy"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BusinessTypeStrategy"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BusinessTypeStrategy"> | Date | string
  }

  export type BusinessRiskProfileWhereInput = {
    AND?: BusinessRiskProfileWhereInput | BusinessRiskProfileWhereInput[]
    OR?: BusinessRiskProfileWhereInput[]
    NOT?: BusinessRiskProfileWhereInput | BusinessRiskProfileWhereInput[]
    id?: StringFilter<"BusinessRiskProfile"> | string
    businessTypeId?: StringFilter<"BusinessRiskProfile"> | string
    parishId?: StringFilter<"BusinessRiskProfile"> | string
    combinedRisks?: StringFilter<"BusinessRiskProfile"> | string
    recommendedStrategies?: StringFilter<"BusinessRiskProfile"> | string
    overallRiskScore?: IntFilter<"BusinessRiskProfile"> | number
    priorityActions?: StringNullableFilter<"BusinessRiskProfile"> | string | null
    calculatedAt?: DateTimeFilter<"BusinessRiskProfile"> | Date | string
    calculatedBy?: StringNullableFilter<"BusinessRiskProfile"> | string | null
    isActive?: BoolFilter<"BusinessRiskProfile"> | boolean
    businessType?: XOR<BusinessTypeRelationFilter, BusinessTypeWhereInput>
    parish?: XOR<ParishRelationFilter, ParishWhereInput>
  }

  export type BusinessRiskProfileOrderByWithRelationInput = {
    id?: SortOrder
    businessTypeId?: SortOrder
    parishId?: SortOrder
    combinedRisks?: SortOrder
    recommendedStrategies?: SortOrder
    overallRiskScore?: SortOrder
    priorityActions?: SortOrderInput | SortOrder
    calculatedAt?: SortOrder
    calculatedBy?: SortOrderInput | SortOrder
    isActive?: SortOrder
    businessType?: BusinessTypeOrderByWithRelationInput
    parish?: ParishOrderByWithRelationInput
  }

  export type BusinessRiskProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    businessTypeId_parishId?: BusinessRiskProfileBusinessTypeIdParishIdCompoundUniqueInput
    AND?: BusinessRiskProfileWhereInput | BusinessRiskProfileWhereInput[]
    OR?: BusinessRiskProfileWhereInput[]
    NOT?: BusinessRiskProfileWhereInput | BusinessRiskProfileWhereInput[]
    businessTypeId?: StringFilter<"BusinessRiskProfile"> | string
    parishId?: StringFilter<"BusinessRiskProfile"> | string
    combinedRisks?: StringFilter<"BusinessRiskProfile"> | string
    recommendedStrategies?: StringFilter<"BusinessRiskProfile"> | string
    overallRiskScore?: IntFilter<"BusinessRiskProfile"> | number
    priorityActions?: StringNullableFilter<"BusinessRiskProfile"> | string | null
    calculatedAt?: DateTimeFilter<"BusinessRiskProfile"> | Date | string
    calculatedBy?: StringNullableFilter<"BusinessRiskProfile"> | string | null
    isActive?: BoolFilter<"BusinessRiskProfile"> | boolean
    businessType?: XOR<BusinessTypeRelationFilter, BusinessTypeWhereInput>
    parish?: XOR<ParishRelationFilter, ParishWhereInput>
  }, "id" | "businessTypeId_parishId">

  export type BusinessRiskProfileOrderByWithAggregationInput = {
    id?: SortOrder
    businessTypeId?: SortOrder
    parishId?: SortOrder
    combinedRisks?: SortOrder
    recommendedStrategies?: SortOrder
    overallRiskScore?: SortOrder
    priorityActions?: SortOrderInput | SortOrder
    calculatedAt?: SortOrder
    calculatedBy?: SortOrderInput | SortOrder
    isActive?: SortOrder
    _count?: BusinessRiskProfileCountOrderByAggregateInput
    _avg?: BusinessRiskProfileAvgOrderByAggregateInput
    _max?: BusinessRiskProfileMaxOrderByAggregateInput
    _min?: BusinessRiskProfileMinOrderByAggregateInput
    _sum?: BusinessRiskProfileSumOrderByAggregateInput
  }

  export type BusinessRiskProfileScalarWhereWithAggregatesInput = {
    AND?: BusinessRiskProfileScalarWhereWithAggregatesInput | BusinessRiskProfileScalarWhereWithAggregatesInput[]
    OR?: BusinessRiskProfileScalarWhereWithAggregatesInput[]
    NOT?: BusinessRiskProfileScalarWhereWithAggregatesInput | BusinessRiskProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BusinessRiskProfile"> | string
    businessTypeId?: StringWithAggregatesFilter<"BusinessRiskProfile"> | string
    parishId?: StringWithAggregatesFilter<"BusinessRiskProfile"> | string
    combinedRisks?: StringWithAggregatesFilter<"BusinessRiskProfile"> | string
    recommendedStrategies?: StringWithAggregatesFilter<"BusinessRiskProfile"> | string
    overallRiskScore?: IntWithAggregatesFilter<"BusinessRiskProfile"> | number
    priorityActions?: StringNullableWithAggregatesFilter<"BusinessRiskProfile"> | string | null
    calculatedAt?: DateTimeWithAggregatesFilter<"BusinessRiskProfile"> | Date | string
    calculatedBy?: StringNullableWithAggregatesFilter<"BusinessRiskProfile"> | string | null
    isActive?: BoolWithAggregatesFilter<"BusinessRiskProfile"> | boolean
  }

  export type RiskMultiplierWhereInput = {
    AND?: RiskMultiplierWhereInput | RiskMultiplierWhereInput[]
    OR?: RiskMultiplierWhereInput[]
    NOT?: RiskMultiplierWhereInput | RiskMultiplierWhereInput[]
    id?: StringFilter<"RiskMultiplier"> | string
    name?: StringFilter<"RiskMultiplier"> | string
    description?: StringFilter<"RiskMultiplier"> | string
    characteristicType?: StringFilter<"RiskMultiplier"> | string
    conditionType?: StringFilter<"RiskMultiplier"> | string
    thresholdValue?: FloatNullableFilter<"RiskMultiplier"> | number | null
    minValue?: FloatNullableFilter<"RiskMultiplier"> | number | null
    maxValue?: FloatNullableFilter<"RiskMultiplier"> | number | null
    multiplierFactor?: FloatFilter<"RiskMultiplier"> | number
    applicableHazards?: StringFilter<"RiskMultiplier"> | string
    wizardQuestion?: StringNullableFilter<"RiskMultiplier"> | string | null
    wizardAnswerOptions?: StringNullableFilter<"RiskMultiplier"> | string | null
    wizardHelpText?: StringNullableFilter<"RiskMultiplier"> | string | null
    isActive?: BoolFilter<"RiskMultiplier"> | boolean
    priority?: IntFilter<"RiskMultiplier"> | number
    reasoning?: StringNullableFilter<"RiskMultiplier"> | string | null
    createdAt?: DateTimeFilter<"RiskMultiplier"> | Date | string
    updatedAt?: DateTimeFilter<"RiskMultiplier"> | Date | string
    createdBy?: StringFilter<"RiskMultiplier"> | string
    translations?: RiskMultiplierTranslationListRelationFilter
  }

  export type RiskMultiplierOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    characteristicType?: SortOrder
    conditionType?: SortOrder
    thresholdValue?: SortOrderInput | SortOrder
    minValue?: SortOrderInput | SortOrder
    maxValue?: SortOrderInput | SortOrder
    multiplierFactor?: SortOrder
    applicableHazards?: SortOrder
    wizardQuestion?: SortOrderInput | SortOrder
    wizardAnswerOptions?: SortOrderInput | SortOrder
    wizardHelpText?: SortOrderInput | SortOrder
    isActive?: SortOrder
    priority?: SortOrder
    reasoning?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    translations?: RiskMultiplierTranslationOrderByRelationAggregateInput
  }

  export type RiskMultiplierWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RiskMultiplierWhereInput | RiskMultiplierWhereInput[]
    OR?: RiskMultiplierWhereInput[]
    NOT?: RiskMultiplierWhereInput | RiskMultiplierWhereInput[]
    name?: StringFilter<"RiskMultiplier"> | string
    description?: StringFilter<"RiskMultiplier"> | string
    characteristicType?: StringFilter<"RiskMultiplier"> | string
    conditionType?: StringFilter<"RiskMultiplier"> | string
    thresholdValue?: FloatNullableFilter<"RiskMultiplier"> | number | null
    minValue?: FloatNullableFilter<"RiskMultiplier"> | number | null
    maxValue?: FloatNullableFilter<"RiskMultiplier"> | number | null
    multiplierFactor?: FloatFilter<"RiskMultiplier"> | number
    applicableHazards?: StringFilter<"RiskMultiplier"> | string
    wizardQuestion?: StringNullableFilter<"RiskMultiplier"> | string | null
    wizardAnswerOptions?: StringNullableFilter<"RiskMultiplier"> | string | null
    wizardHelpText?: StringNullableFilter<"RiskMultiplier"> | string | null
    isActive?: BoolFilter<"RiskMultiplier"> | boolean
    priority?: IntFilter<"RiskMultiplier"> | number
    reasoning?: StringNullableFilter<"RiskMultiplier"> | string | null
    createdAt?: DateTimeFilter<"RiskMultiplier"> | Date | string
    updatedAt?: DateTimeFilter<"RiskMultiplier"> | Date | string
    createdBy?: StringFilter<"RiskMultiplier"> | string
    translations?: RiskMultiplierTranslationListRelationFilter
  }, "id">

  export type RiskMultiplierOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    characteristicType?: SortOrder
    conditionType?: SortOrder
    thresholdValue?: SortOrderInput | SortOrder
    minValue?: SortOrderInput | SortOrder
    maxValue?: SortOrderInput | SortOrder
    multiplierFactor?: SortOrder
    applicableHazards?: SortOrder
    wizardQuestion?: SortOrderInput | SortOrder
    wizardAnswerOptions?: SortOrderInput | SortOrder
    wizardHelpText?: SortOrderInput | SortOrder
    isActive?: SortOrder
    priority?: SortOrder
    reasoning?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    _count?: RiskMultiplierCountOrderByAggregateInput
    _avg?: RiskMultiplierAvgOrderByAggregateInput
    _max?: RiskMultiplierMaxOrderByAggregateInput
    _min?: RiskMultiplierMinOrderByAggregateInput
    _sum?: RiskMultiplierSumOrderByAggregateInput
  }

  export type RiskMultiplierScalarWhereWithAggregatesInput = {
    AND?: RiskMultiplierScalarWhereWithAggregatesInput | RiskMultiplierScalarWhereWithAggregatesInput[]
    OR?: RiskMultiplierScalarWhereWithAggregatesInput[]
    NOT?: RiskMultiplierScalarWhereWithAggregatesInput | RiskMultiplierScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RiskMultiplier"> | string
    name?: StringWithAggregatesFilter<"RiskMultiplier"> | string
    description?: StringWithAggregatesFilter<"RiskMultiplier"> | string
    characteristicType?: StringWithAggregatesFilter<"RiskMultiplier"> | string
    conditionType?: StringWithAggregatesFilter<"RiskMultiplier"> | string
    thresholdValue?: FloatNullableWithAggregatesFilter<"RiskMultiplier"> | number | null
    minValue?: FloatNullableWithAggregatesFilter<"RiskMultiplier"> | number | null
    maxValue?: FloatNullableWithAggregatesFilter<"RiskMultiplier"> | number | null
    multiplierFactor?: FloatWithAggregatesFilter<"RiskMultiplier"> | number
    applicableHazards?: StringWithAggregatesFilter<"RiskMultiplier"> | string
    wizardQuestion?: StringNullableWithAggregatesFilter<"RiskMultiplier"> | string | null
    wizardAnswerOptions?: StringNullableWithAggregatesFilter<"RiskMultiplier"> | string | null
    wizardHelpText?: StringNullableWithAggregatesFilter<"RiskMultiplier"> | string | null
    isActive?: BoolWithAggregatesFilter<"RiskMultiplier"> | boolean
    priority?: IntWithAggregatesFilter<"RiskMultiplier"> | number
    reasoning?: StringNullableWithAggregatesFilter<"RiskMultiplier"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RiskMultiplier"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RiskMultiplier"> | Date | string
    createdBy?: StringWithAggregatesFilter<"RiskMultiplier"> | string
  }

  export type CostItemWhereInput = {
    AND?: CostItemWhereInput | CostItemWhereInput[]
    OR?: CostItemWhereInput[]
    NOT?: CostItemWhereInput | CostItemWhereInput[]
    id?: StringFilter<"CostItem"> | string
    itemId?: StringFilter<"CostItem"> | string
    name?: StringFilter<"CostItem"> | string
    description?: StringNullableFilter<"CostItem"> | string | null
    category?: StringFilter<"CostItem"> | string
    baseUSD?: FloatFilter<"CostItem"> | number
    baseUSDMin?: FloatNullableFilter<"CostItem"> | number | null
    baseUSDMax?: FloatNullableFilter<"CostItem"> | number | null
    unit?: StringNullableFilter<"CostItem"> | string | null
    complexity?: StringFilter<"CostItem"> | string
    notes?: StringNullableFilter<"CostItem"> | string | null
    tags?: StringNullableFilter<"CostItem"> | string | null
    budgetAlternativeId?: StringNullableFilter<"CostItem"> | string | null
    premiumAlternativeId?: StringNullableFilter<"CostItem"> | string | null
    isActive?: BoolFilter<"CostItem"> | boolean
    createdAt?: DateTimeFilter<"CostItem"> | Date | string
    updatedAt?: DateTimeFilter<"CostItem"> | Date | string
    strategyItems?: StrategyItemCostListRelationFilter
    actionStepItems?: ActionStepItemCostListRelationFilter
  }

  export type CostItemOrderByWithRelationInput = {
    id?: SortOrder
    itemId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    baseUSD?: SortOrder
    baseUSDMin?: SortOrderInput | SortOrder
    baseUSDMax?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    complexity?: SortOrder
    notes?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    budgetAlternativeId?: SortOrderInput | SortOrder
    premiumAlternativeId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    strategyItems?: StrategyItemCostOrderByRelationAggregateInput
    actionStepItems?: ActionStepItemCostOrderByRelationAggregateInput
  }

  export type CostItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    itemId?: string
    AND?: CostItemWhereInput | CostItemWhereInput[]
    OR?: CostItemWhereInput[]
    NOT?: CostItemWhereInput | CostItemWhereInput[]
    name?: StringFilter<"CostItem"> | string
    description?: StringNullableFilter<"CostItem"> | string | null
    category?: StringFilter<"CostItem"> | string
    baseUSD?: FloatFilter<"CostItem"> | number
    baseUSDMin?: FloatNullableFilter<"CostItem"> | number | null
    baseUSDMax?: FloatNullableFilter<"CostItem"> | number | null
    unit?: StringNullableFilter<"CostItem"> | string | null
    complexity?: StringFilter<"CostItem"> | string
    notes?: StringNullableFilter<"CostItem"> | string | null
    tags?: StringNullableFilter<"CostItem"> | string | null
    budgetAlternativeId?: StringNullableFilter<"CostItem"> | string | null
    premiumAlternativeId?: StringNullableFilter<"CostItem"> | string | null
    isActive?: BoolFilter<"CostItem"> | boolean
    createdAt?: DateTimeFilter<"CostItem"> | Date | string
    updatedAt?: DateTimeFilter<"CostItem"> | Date | string
    strategyItems?: StrategyItemCostListRelationFilter
    actionStepItems?: ActionStepItemCostListRelationFilter
  }, "id" | "itemId">

  export type CostItemOrderByWithAggregationInput = {
    id?: SortOrder
    itemId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    baseUSD?: SortOrder
    baseUSDMin?: SortOrderInput | SortOrder
    baseUSDMax?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    complexity?: SortOrder
    notes?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    budgetAlternativeId?: SortOrderInput | SortOrder
    premiumAlternativeId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CostItemCountOrderByAggregateInput
    _avg?: CostItemAvgOrderByAggregateInput
    _max?: CostItemMaxOrderByAggregateInput
    _min?: CostItemMinOrderByAggregateInput
    _sum?: CostItemSumOrderByAggregateInput
  }

  export type CostItemScalarWhereWithAggregatesInput = {
    AND?: CostItemScalarWhereWithAggregatesInput | CostItemScalarWhereWithAggregatesInput[]
    OR?: CostItemScalarWhereWithAggregatesInput[]
    NOT?: CostItemScalarWhereWithAggregatesInput | CostItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CostItem"> | string
    itemId?: StringWithAggregatesFilter<"CostItem"> | string
    name?: StringWithAggregatesFilter<"CostItem"> | string
    description?: StringNullableWithAggregatesFilter<"CostItem"> | string | null
    category?: StringWithAggregatesFilter<"CostItem"> | string
    baseUSD?: FloatWithAggregatesFilter<"CostItem"> | number
    baseUSDMin?: FloatNullableWithAggregatesFilter<"CostItem"> | number | null
    baseUSDMax?: FloatNullableWithAggregatesFilter<"CostItem"> | number | null
    unit?: StringNullableWithAggregatesFilter<"CostItem"> | string | null
    complexity?: StringWithAggregatesFilter<"CostItem"> | string
    notes?: StringNullableWithAggregatesFilter<"CostItem"> | string | null
    tags?: StringNullableWithAggregatesFilter<"CostItem"> | string | null
    budgetAlternativeId?: StringNullableWithAggregatesFilter<"CostItem"> | string | null
    premiumAlternativeId?: StringNullableWithAggregatesFilter<"CostItem"> | string | null
    isActive?: BoolWithAggregatesFilter<"CostItem"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CostItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CostItem"> | Date | string
  }

  export type CountryCostMultiplierWhereInput = {
    AND?: CountryCostMultiplierWhereInput | CountryCostMultiplierWhereInput[]
    OR?: CountryCostMultiplierWhereInput[]
    NOT?: CountryCostMultiplierWhereInput | CountryCostMultiplierWhereInput[]
    id?: StringFilter<"CountryCostMultiplier"> | string
    countryCode?: StringFilter<"CountryCostMultiplier"> | string
    construction?: FloatFilter<"CountryCostMultiplier"> | number
    equipment?: FloatFilter<"CountryCostMultiplier"> | number
    service?: FloatFilter<"CountryCostMultiplier"> | number
    supplies?: FloatFilter<"CountryCostMultiplier"> | number
    currency?: StringFilter<"CountryCostMultiplier"> | string
    currencySymbol?: StringNullableFilter<"CountryCostMultiplier"> | string | null
    exchangeRateUSD?: FloatFilter<"CountryCostMultiplier"> | number
    lastUpdated?: DateTimeFilter<"CountryCostMultiplier"> | Date | string
    updatedBy?: StringNullableFilter<"CountryCostMultiplier"> | string | null
    dataSource?: StringNullableFilter<"CountryCostMultiplier"> | string | null
    confidenceLevel?: StringFilter<"CountryCostMultiplier"> | string
    notes?: StringNullableFilter<"CountryCostMultiplier"> | string | null
  }

  export type CountryCostMultiplierOrderByWithRelationInput = {
    id?: SortOrder
    countryCode?: SortOrder
    construction?: SortOrder
    equipment?: SortOrder
    service?: SortOrder
    supplies?: SortOrder
    currency?: SortOrder
    currencySymbol?: SortOrderInput | SortOrder
    exchangeRateUSD?: SortOrder
    lastUpdated?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    dataSource?: SortOrderInput | SortOrder
    confidenceLevel?: SortOrder
    notes?: SortOrderInput | SortOrder
  }

  export type CountryCostMultiplierWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    countryCode?: string
    AND?: CountryCostMultiplierWhereInput | CountryCostMultiplierWhereInput[]
    OR?: CountryCostMultiplierWhereInput[]
    NOT?: CountryCostMultiplierWhereInput | CountryCostMultiplierWhereInput[]
    construction?: FloatFilter<"CountryCostMultiplier"> | number
    equipment?: FloatFilter<"CountryCostMultiplier"> | number
    service?: FloatFilter<"CountryCostMultiplier"> | number
    supplies?: FloatFilter<"CountryCostMultiplier"> | number
    currency?: StringFilter<"CountryCostMultiplier"> | string
    currencySymbol?: StringNullableFilter<"CountryCostMultiplier"> | string | null
    exchangeRateUSD?: FloatFilter<"CountryCostMultiplier"> | number
    lastUpdated?: DateTimeFilter<"CountryCostMultiplier"> | Date | string
    updatedBy?: StringNullableFilter<"CountryCostMultiplier"> | string | null
    dataSource?: StringNullableFilter<"CountryCostMultiplier"> | string | null
    confidenceLevel?: StringFilter<"CountryCostMultiplier"> | string
    notes?: StringNullableFilter<"CountryCostMultiplier"> | string | null
  }, "id" | "countryCode">

  export type CountryCostMultiplierOrderByWithAggregationInput = {
    id?: SortOrder
    countryCode?: SortOrder
    construction?: SortOrder
    equipment?: SortOrder
    service?: SortOrder
    supplies?: SortOrder
    currency?: SortOrder
    currencySymbol?: SortOrderInput | SortOrder
    exchangeRateUSD?: SortOrder
    lastUpdated?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    dataSource?: SortOrderInput | SortOrder
    confidenceLevel?: SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: CountryCostMultiplierCountOrderByAggregateInput
    _avg?: CountryCostMultiplierAvgOrderByAggregateInput
    _max?: CountryCostMultiplierMaxOrderByAggregateInput
    _min?: CountryCostMultiplierMinOrderByAggregateInput
    _sum?: CountryCostMultiplierSumOrderByAggregateInput
  }

  export type CountryCostMultiplierScalarWhereWithAggregatesInput = {
    AND?: CountryCostMultiplierScalarWhereWithAggregatesInput | CountryCostMultiplierScalarWhereWithAggregatesInput[]
    OR?: CountryCostMultiplierScalarWhereWithAggregatesInput[]
    NOT?: CountryCostMultiplierScalarWhereWithAggregatesInput | CountryCostMultiplierScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CountryCostMultiplier"> | string
    countryCode?: StringWithAggregatesFilter<"CountryCostMultiplier"> | string
    construction?: FloatWithAggregatesFilter<"CountryCostMultiplier"> | number
    equipment?: FloatWithAggregatesFilter<"CountryCostMultiplier"> | number
    service?: FloatWithAggregatesFilter<"CountryCostMultiplier"> | number
    supplies?: FloatWithAggregatesFilter<"CountryCostMultiplier"> | number
    currency?: StringWithAggregatesFilter<"CountryCostMultiplier"> | string
    currencySymbol?: StringNullableWithAggregatesFilter<"CountryCostMultiplier"> | string | null
    exchangeRateUSD?: FloatWithAggregatesFilter<"CountryCostMultiplier"> | number
    lastUpdated?: DateTimeWithAggregatesFilter<"CountryCostMultiplier"> | Date | string
    updatedBy?: StringNullableWithAggregatesFilter<"CountryCostMultiplier"> | string | null
    dataSource?: StringNullableWithAggregatesFilter<"CountryCostMultiplier"> | string | null
    confidenceLevel?: StringWithAggregatesFilter<"CountryCostMultiplier"> | string
    notes?: StringNullableWithAggregatesFilter<"CountryCostMultiplier"> | string | null
  }

  export type StrategyItemCostWhereInput = {
    AND?: StrategyItemCostWhereInput | StrategyItemCostWhereInput[]
    OR?: StrategyItemCostWhereInput[]
    NOT?: StrategyItemCostWhereInput | StrategyItemCostWhereInput[]
    id?: StringFilter<"StrategyItemCost"> | string
    strategyId?: StringFilter<"StrategyItemCost"> | string
    itemId?: StringFilter<"StrategyItemCost"> | string
    quantity?: IntFilter<"StrategyItemCost"> | number
    customNotes?: StringNullableFilter<"StrategyItemCost"> | string | null
    countryOverrides?: StringNullableFilter<"StrategyItemCost"> | string | null
    isRequired?: BoolFilter<"StrategyItemCost"> | boolean
    displayOrder?: IntFilter<"StrategyItemCost"> | number
    createdAt?: DateTimeFilter<"StrategyItemCost"> | Date | string
    updatedAt?: DateTimeFilter<"StrategyItemCost"> | Date | string
    strategy?: XOR<RiskMitigationStrategyRelationFilter, RiskMitigationStrategyWhereInput>
    item?: XOR<CostItemRelationFilter, CostItemWhereInput>
  }

  export type StrategyItemCostOrderByWithRelationInput = {
    id?: SortOrder
    strategyId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    customNotes?: SortOrderInput | SortOrder
    countryOverrides?: SortOrderInput | SortOrder
    isRequired?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    strategy?: RiskMitigationStrategyOrderByWithRelationInput
    item?: CostItemOrderByWithRelationInput
  }

  export type StrategyItemCostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    strategyId_itemId?: StrategyItemCostStrategyIdItemIdCompoundUniqueInput
    AND?: StrategyItemCostWhereInput | StrategyItemCostWhereInput[]
    OR?: StrategyItemCostWhereInput[]
    NOT?: StrategyItemCostWhereInput | StrategyItemCostWhereInput[]
    strategyId?: StringFilter<"StrategyItemCost"> | string
    itemId?: StringFilter<"StrategyItemCost"> | string
    quantity?: IntFilter<"StrategyItemCost"> | number
    customNotes?: StringNullableFilter<"StrategyItemCost"> | string | null
    countryOverrides?: StringNullableFilter<"StrategyItemCost"> | string | null
    isRequired?: BoolFilter<"StrategyItemCost"> | boolean
    displayOrder?: IntFilter<"StrategyItemCost"> | number
    createdAt?: DateTimeFilter<"StrategyItemCost"> | Date | string
    updatedAt?: DateTimeFilter<"StrategyItemCost"> | Date | string
    strategy?: XOR<RiskMitigationStrategyRelationFilter, RiskMitigationStrategyWhereInput>
    item?: XOR<CostItemRelationFilter, CostItemWhereInput>
  }, "id" | "strategyId_itemId">

  export type StrategyItemCostOrderByWithAggregationInput = {
    id?: SortOrder
    strategyId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    customNotes?: SortOrderInput | SortOrder
    countryOverrides?: SortOrderInput | SortOrder
    isRequired?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StrategyItemCostCountOrderByAggregateInput
    _avg?: StrategyItemCostAvgOrderByAggregateInput
    _max?: StrategyItemCostMaxOrderByAggregateInput
    _min?: StrategyItemCostMinOrderByAggregateInput
    _sum?: StrategyItemCostSumOrderByAggregateInput
  }

  export type StrategyItemCostScalarWhereWithAggregatesInput = {
    AND?: StrategyItemCostScalarWhereWithAggregatesInput | StrategyItemCostScalarWhereWithAggregatesInput[]
    OR?: StrategyItemCostScalarWhereWithAggregatesInput[]
    NOT?: StrategyItemCostScalarWhereWithAggregatesInput | StrategyItemCostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StrategyItemCost"> | string
    strategyId?: StringWithAggregatesFilter<"StrategyItemCost"> | string
    itemId?: StringWithAggregatesFilter<"StrategyItemCost"> | string
    quantity?: IntWithAggregatesFilter<"StrategyItemCost"> | number
    customNotes?: StringNullableWithAggregatesFilter<"StrategyItemCost"> | string | null
    countryOverrides?: StringNullableWithAggregatesFilter<"StrategyItemCost"> | string | null
    isRequired?: BoolWithAggregatesFilter<"StrategyItemCost"> | boolean
    displayOrder?: IntWithAggregatesFilter<"StrategyItemCost"> | number
    createdAt?: DateTimeWithAggregatesFilter<"StrategyItemCost"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StrategyItemCost"> | Date | string
  }

  export type ActionStepItemCostWhereInput = {
    AND?: ActionStepItemCostWhereInput | ActionStepItemCostWhereInput[]
    OR?: ActionStepItemCostWhereInput[]
    NOT?: ActionStepItemCostWhereInput | ActionStepItemCostWhereInput[]
    id?: StringFilter<"ActionStepItemCost"> | string
    actionStepId?: StringFilter<"ActionStepItemCost"> | string
    itemId?: StringFilter<"ActionStepItemCost"> | string
    quantity?: IntFilter<"ActionStepItemCost"> | number
    customNotes?: StringNullableFilter<"ActionStepItemCost"> | string | null
    countryOverrides?: StringNullableFilter<"ActionStepItemCost"> | string | null
    displayOrder?: IntFilter<"ActionStepItemCost"> | number
    createdAt?: DateTimeFilter<"ActionStepItemCost"> | Date | string
    updatedAt?: DateTimeFilter<"ActionStepItemCost"> | Date | string
    actionStep?: XOR<ActionStepRelationFilter, ActionStepWhereInput>
    item?: XOR<CostItemRelationFilter, CostItemWhereInput>
  }

  export type ActionStepItemCostOrderByWithRelationInput = {
    id?: SortOrder
    actionStepId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    customNotes?: SortOrderInput | SortOrder
    countryOverrides?: SortOrderInput | SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    actionStep?: ActionStepOrderByWithRelationInput
    item?: CostItemOrderByWithRelationInput
  }

  export type ActionStepItemCostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    actionStepId_itemId?: ActionStepItemCostActionStepIdItemIdCompoundUniqueInput
    AND?: ActionStepItemCostWhereInput | ActionStepItemCostWhereInput[]
    OR?: ActionStepItemCostWhereInput[]
    NOT?: ActionStepItemCostWhereInput | ActionStepItemCostWhereInput[]
    actionStepId?: StringFilter<"ActionStepItemCost"> | string
    itemId?: StringFilter<"ActionStepItemCost"> | string
    quantity?: IntFilter<"ActionStepItemCost"> | number
    customNotes?: StringNullableFilter<"ActionStepItemCost"> | string | null
    countryOverrides?: StringNullableFilter<"ActionStepItemCost"> | string | null
    displayOrder?: IntFilter<"ActionStepItemCost"> | number
    createdAt?: DateTimeFilter<"ActionStepItemCost"> | Date | string
    updatedAt?: DateTimeFilter<"ActionStepItemCost"> | Date | string
    actionStep?: XOR<ActionStepRelationFilter, ActionStepWhereInput>
    item?: XOR<CostItemRelationFilter, CostItemWhereInput>
  }, "id" | "actionStepId_itemId">

  export type ActionStepItemCostOrderByWithAggregationInput = {
    id?: SortOrder
    actionStepId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    customNotes?: SortOrderInput | SortOrder
    countryOverrides?: SortOrderInput | SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ActionStepItemCostCountOrderByAggregateInput
    _avg?: ActionStepItemCostAvgOrderByAggregateInput
    _max?: ActionStepItemCostMaxOrderByAggregateInput
    _min?: ActionStepItemCostMinOrderByAggregateInput
    _sum?: ActionStepItemCostSumOrderByAggregateInput
  }

  export type ActionStepItemCostScalarWhereWithAggregatesInput = {
    AND?: ActionStepItemCostScalarWhereWithAggregatesInput | ActionStepItemCostScalarWhereWithAggregatesInput[]
    OR?: ActionStepItemCostScalarWhereWithAggregatesInput[]
    NOT?: ActionStepItemCostScalarWhereWithAggregatesInput | ActionStepItemCostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ActionStepItemCost"> | string
    actionStepId?: StringWithAggregatesFilter<"ActionStepItemCost"> | string
    itemId?: StringWithAggregatesFilter<"ActionStepItemCost"> | string
    quantity?: IntWithAggregatesFilter<"ActionStepItemCost"> | number
    customNotes?: StringNullableWithAggregatesFilter<"ActionStepItemCost"> | string | null
    countryOverrides?: StringNullableWithAggregatesFilter<"ActionStepItemCost"> | string | null
    displayOrder?: IntWithAggregatesFilter<"ActionStepItemCost"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ActionStepItemCost"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ActionStepItemCost"> | Date | string
  }

  export type BusinessTypeTranslationWhereInput = {
    AND?: BusinessTypeTranslationWhereInput | BusinessTypeTranslationWhereInput[]
    OR?: BusinessTypeTranslationWhereInput[]
    NOT?: BusinessTypeTranslationWhereInput | BusinessTypeTranslationWhereInput[]
    id?: StringFilter<"BusinessTypeTranslation"> | string
    businessTypeId?: StringFilter<"BusinessTypeTranslation"> | string
    locale?: StringFilter<"BusinessTypeTranslation"> | string
    name?: StringFilter<"BusinessTypeTranslation"> | string
    description?: StringNullableFilter<"BusinessTypeTranslation"> | string | null
    exampleBusinessPurposes?: JsonNullableFilter<"BusinessTypeTranslation">
    exampleProducts?: JsonNullableFilter<"BusinessTypeTranslation">
    exampleKeyPersonnel?: JsonNullableFilter<"BusinessTypeTranslation">
    exampleCustomerBase?: JsonNullableFilter<"BusinessTypeTranslation">
    minimumEquipment?: JsonNullableFilter<"BusinessTypeTranslation">
    createdAt?: DateTimeFilter<"BusinessTypeTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"BusinessTypeTranslation"> | Date | string
    businessType?: XOR<BusinessTypeRelationFilter, BusinessTypeWhereInput>
  }

  export type BusinessTypeTranslationOrderByWithRelationInput = {
    id?: SortOrder
    businessTypeId?: SortOrder
    locale?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    exampleBusinessPurposes?: SortOrderInput | SortOrder
    exampleProducts?: SortOrderInput | SortOrder
    exampleKeyPersonnel?: SortOrderInput | SortOrder
    exampleCustomerBase?: SortOrderInput | SortOrder
    minimumEquipment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    businessType?: BusinessTypeOrderByWithRelationInput
  }

  export type BusinessTypeTranslationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    businessTypeId_locale?: BusinessTypeTranslationBusinessTypeIdLocaleCompoundUniqueInput
    AND?: BusinessTypeTranslationWhereInput | BusinessTypeTranslationWhereInput[]
    OR?: BusinessTypeTranslationWhereInput[]
    NOT?: BusinessTypeTranslationWhereInput | BusinessTypeTranslationWhereInput[]
    businessTypeId?: StringFilter<"BusinessTypeTranslation"> | string
    locale?: StringFilter<"BusinessTypeTranslation"> | string
    name?: StringFilter<"BusinessTypeTranslation"> | string
    description?: StringNullableFilter<"BusinessTypeTranslation"> | string | null
    exampleBusinessPurposes?: JsonNullableFilter<"BusinessTypeTranslation">
    exampleProducts?: JsonNullableFilter<"BusinessTypeTranslation">
    exampleKeyPersonnel?: JsonNullableFilter<"BusinessTypeTranslation">
    exampleCustomerBase?: JsonNullableFilter<"BusinessTypeTranslation">
    minimumEquipment?: JsonNullableFilter<"BusinessTypeTranslation">
    createdAt?: DateTimeFilter<"BusinessTypeTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"BusinessTypeTranslation"> | Date | string
    businessType?: XOR<BusinessTypeRelationFilter, BusinessTypeWhereInput>
  }, "id" | "businessTypeId_locale">

  export type BusinessTypeTranslationOrderByWithAggregationInput = {
    id?: SortOrder
    businessTypeId?: SortOrder
    locale?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    exampleBusinessPurposes?: SortOrderInput | SortOrder
    exampleProducts?: SortOrderInput | SortOrder
    exampleKeyPersonnel?: SortOrderInput | SortOrder
    exampleCustomerBase?: SortOrderInput | SortOrder
    minimumEquipment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BusinessTypeTranslationCountOrderByAggregateInput
    _max?: BusinessTypeTranslationMaxOrderByAggregateInput
    _min?: BusinessTypeTranslationMinOrderByAggregateInput
  }

  export type BusinessTypeTranslationScalarWhereWithAggregatesInput = {
    AND?: BusinessTypeTranslationScalarWhereWithAggregatesInput | BusinessTypeTranslationScalarWhereWithAggregatesInput[]
    OR?: BusinessTypeTranslationScalarWhereWithAggregatesInput[]
    NOT?: BusinessTypeTranslationScalarWhereWithAggregatesInput | BusinessTypeTranslationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BusinessTypeTranslation"> | string
    businessTypeId?: StringWithAggregatesFilter<"BusinessTypeTranslation"> | string
    locale?: StringWithAggregatesFilter<"BusinessTypeTranslation"> | string
    name?: StringWithAggregatesFilter<"BusinessTypeTranslation"> | string
    description?: StringNullableWithAggregatesFilter<"BusinessTypeTranslation"> | string | null
    exampleBusinessPurposes?: JsonNullableWithAggregatesFilter<"BusinessTypeTranslation">
    exampleProducts?: JsonNullableWithAggregatesFilter<"BusinessTypeTranslation">
    exampleKeyPersonnel?: JsonNullableWithAggregatesFilter<"BusinessTypeTranslation">
    exampleCustomerBase?: JsonNullableWithAggregatesFilter<"BusinessTypeTranslation">
    minimumEquipment?: JsonNullableWithAggregatesFilter<"BusinessTypeTranslation">
    createdAt?: DateTimeWithAggregatesFilter<"BusinessTypeTranslation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BusinessTypeTranslation"> | Date | string
  }

  export type StrategyTranslationWhereInput = {
    AND?: StrategyTranslationWhereInput | StrategyTranslationWhereInput[]
    OR?: StrategyTranslationWhereInput[]
    NOT?: StrategyTranslationWhereInput | StrategyTranslationWhereInput[]
    id?: StringFilter<"StrategyTranslation"> | string
    strategyId?: StringFilter<"StrategyTranslation"> | string
    locale?: StringFilter<"StrategyTranslation"> | string
    name?: StringFilter<"StrategyTranslation"> | string
    description?: StringFilter<"StrategyTranslation"> | string
    smeTitle?: StringNullableFilter<"StrategyTranslation"> | string | null
    smeSummary?: StringNullableFilter<"StrategyTranslation"> | string | null
    realWorldExample?: StringNullableFilter<"StrategyTranslation"> | string | null
    whyImportant?: StringNullableFilter<"StrategyTranslation"> | string | null
    whenToImplement?: StringNullableFilter<"StrategyTranslation"> | string | null
    expectedOutcome?: StringNullableFilter<"StrategyTranslation"> | string | null
    benefitsBullets?: JsonNullableFilter<"StrategyTranslation">
    helpfulTips?: JsonNullableFilter<"StrategyTranslation">
    commonMistakes?: JsonNullableFilter<"StrategyTranslation">
    successMetrics?: JsonNullableFilter<"StrategyTranslation">
    requiredResources?: JsonNullableFilter<"StrategyTranslation">
    lowBudgetAlternative?: StringNullableFilter<"StrategyTranslation"> | string | null
    diyApproach?: StringNullableFilter<"StrategyTranslation"> | string | null
    bcpTemplateText?: StringNullableFilter<"StrategyTranslation"> | string | null
    createdAt?: DateTimeFilter<"StrategyTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"StrategyTranslation"> | Date | string
    strategy?: XOR<RiskMitigationStrategyRelationFilter, RiskMitigationStrategyWhereInput>
  }

  export type StrategyTranslationOrderByWithRelationInput = {
    id?: SortOrder
    strategyId?: SortOrder
    locale?: SortOrder
    name?: SortOrder
    description?: SortOrder
    smeTitle?: SortOrderInput | SortOrder
    smeSummary?: SortOrderInput | SortOrder
    realWorldExample?: SortOrderInput | SortOrder
    whyImportant?: SortOrderInput | SortOrder
    whenToImplement?: SortOrderInput | SortOrder
    expectedOutcome?: SortOrderInput | SortOrder
    benefitsBullets?: SortOrderInput | SortOrder
    helpfulTips?: SortOrderInput | SortOrder
    commonMistakes?: SortOrderInput | SortOrder
    successMetrics?: SortOrderInput | SortOrder
    requiredResources?: SortOrderInput | SortOrder
    lowBudgetAlternative?: SortOrderInput | SortOrder
    diyApproach?: SortOrderInput | SortOrder
    bcpTemplateText?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    strategy?: RiskMitigationStrategyOrderByWithRelationInput
  }

  export type StrategyTranslationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    strategyId_locale?: StrategyTranslationStrategyIdLocaleCompoundUniqueInput
    AND?: StrategyTranslationWhereInput | StrategyTranslationWhereInput[]
    OR?: StrategyTranslationWhereInput[]
    NOT?: StrategyTranslationWhereInput | StrategyTranslationWhereInput[]
    strategyId?: StringFilter<"StrategyTranslation"> | string
    locale?: StringFilter<"StrategyTranslation"> | string
    name?: StringFilter<"StrategyTranslation"> | string
    description?: StringFilter<"StrategyTranslation"> | string
    smeTitle?: StringNullableFilter<"StrategyTranslation"> | string | null
    smeSummary?: StringNullableFilter<"StrategyTranslation"> | string | null
    realWorldExample?: StringNullableFilter<"StrategyTranslation"> | string | null
    whyImportant?: StringNullableFilter<"StrategyTranslation"> | string | null
    whenToImplement?: StringNullableFilter<"StrategyTranslation"> | string | null
    expectedOutcome?: StringNullableFilter<"StrategyTranslation"> | string | null
    benefitsBullets?: JsonNullableFilter<"StrategyTranslation">
    helpfulTips?: JsonNullableFilter<"StrategyTranslation">
    commonMistakes?: JsonNullableFilter<"StrategyTranslation">
    successMetrics?: JsonNullableFilter<"StrategyTranslation">
    requiredResources?: JsonNullableFilter<"StrategyTranslation">
    lowBudgetAlternative?: StringNullableFilter<"StrategyTranslation"> | string | null
    diyApproach?: StringNullableFilter<"StrategyTranslation"> | string | null
    bcpTemplateText?: StringNullableFilter<"StrategyTranslation"> | string | null
    createdAt?: DateTimeFilter<"StrategyTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"StrategyTranslation"> | Date | string
    strategy?: XOR<RiskMitigationStrategyRelationFilter, RiskMitigationStrategyWhereInput>
  }, "id" | "strategyId_locale">

  export type StrategyTranslationOrderByWithAggregationInput = {
    id?: SortOrder
    strategyId?: SortOrder
    locale?: SortOrder
    name?: SortOrder
    description?: SortOrder
    smeTitle?: SortOrderInput | SortOrder
    smeSummary?: SortOrderInput | SortOrder
    realWorldExample?: SortOrderInput | SortOrder
    whyImportant?: SortOrderInput | SortOrder
    whenToImplement?: SortOrderInput | SortOrder
    expectedOutcome?: SortOrderInput | SortOrder
    benefitsBullets?: SortOrderInput | SortOrder
    helpfulTips?: SortOrderInput | SortOrder
    commonMistakes?: SortOrderInput | SortOrder
    successMetrics?: SortOrderInput | SortOrder
    requiredResources?: SortOrderInput | SortOrder
    lowBudgetAlternative?: SortOrderInput | SortOrder
    diyApproach?: SortOrderInput | SortOrder
    bcpTemplateText?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StrategyTranslationCountOrderByAggregateInput
    _max?: StrategyTranslationMaxOrderByAggregateInput
    _min?: StrategyTranslationMinOrderByAggregateInput
  }

  export type StrategyTranslationScalarWhereWithAggregatesInput = {
    AND?: StrategyTranslationScalarWhereWithAggregatesInput | StrategyTranslationScalarWhereWithAggregatesInput[]
    OR?: StrategyTranslationScalarWhereWithAggregatesInput[]
    NOT?: StrategyTranslationScalarWhereWithAggregatesInput | StrategyTranslationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StrategyTranslation"> | string
    strategyId?: StringWithAggregatesFilter<"StrategyTranslation"> | string
    locale?: StringWithAggregatesFilter<"StrategyTranslation"> | string
    name?: StringWithAggregatesFilter<"StrategyTranslation"> | string
    description?: StringWithAggregatesFilter<"StrategyTranslation"> | string
    smeTitle?: StringNullableWithAggregatesFilter<"StrategyTranslation"> | string | null
    smeSummary?: StringNullableWithAggregatesFilter<"StrategyTranslation"> | string | null
    realWorldExample?: StringNullableWithAggregatesFilter<"StrategyTranslation"> | string | null
    whyImportant?: StringNullableWithAggregatesFilter<"StrategyTranslation"> | string | null
    whenToImplement?: StringNullableWithAggregatesFilter<"StrategyTranslation"> | string | null
    expectedOutcome?: StringNullableWithAggregatesFilter<"StrategyTranslation"> | string | null
    benefitsBullets?: JsonNullableWithAggregatesFilter<"StrategyTranslation">
    helpfulTips?: JsonNullableWithAggregatesFilter<"StrategyTranslation">
    commonMistakes?: JsonNullableWithAggregatesFilter<"StrategyTranslation">
    successMetrics?: JsonNullableWithAggregatesFilter<"StrategyTranslation">
    requiredResources?: JsonNullableWithAggregatesFilter<"StrategyTranslation">
    lowBudgetAlternative?: StringNullableWithAggregatesFilter<"StrategyTranslation"> | string | null
    diyApproach?: StringNullableWithAggregatesFilter<"StrategyTranslation"> | string | null
    bcpTemplateText?: StringNullableWithAggregatesFilter<"StrategyTranslation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"StrategyTranslation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StrategyTranslation"> | Date | string
  }

  export type ActionStepTranslationWhereInput = {
    AND?: ActionStepTranslationWhereInput | ActionStepTranslationWhereInput[]
    OR?: ActionStepTranslationWhereInput[]
    NOT?: ActionStepTranslationWhereInput | ActionStepTranslationWhereInput[]
    id?: StringFilter<"ActionStepTranslation"> | string
    actionStepId?: StringFilter<"ActionStepTranslation"> | string
    locale?: StringFilter<"ActionStepTranslation"> | string
    title?: StringFilter<"ActionStepTranslation"> | string
    description?: StringNullableFilter<"ActionStepTranslation"> | string | null
    smeAction?: StringNullableFilter<"ActionStepTranslation"> | string | null
    timeframe?: StringNullableFilter<"ActionStepTranslation"> | string | null
    whyThisStepMatters?: StringNullableFilter<"ActionStepTranslation"> | string | null
    howToKnowItsDone?: StringNullableFilter<"ActionStepTranslation"> | string | null
    whatHappensIfSkipped?: StringNullableFilter<"ActionStepTranslation"> | string | null
    exampleOutput?: StringNullableFilter<"ActionStepTranslation"> | string | null
    freeAlternative?: StringNullableFilter<"ActionStepTranslation"> | string | null
    lowTechOption?: StringNullableFilter<"ActionStepTranslation"> | string | null
    commonMistakesForStep?: JsonNullableFilter<"ActionStepTranslation">
    createdAt?: DateTimeFilter<"ActionStepTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"ActionStepTranslation"> | Date | string
    actionStep?: XOR<ActionStepRelationFilter, ActionStepWhereInput>
  }

  export type ActionStepTranslationOrderByWithRelationInput = {
    id?: SortOrder
    actionStepId?: SortOrder
    locale?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    smeAction?: SortOrderInput | SortOrder
    timeframe?: SortOrderInput | SortOrder
    whyThisStepMatters?: SortOrderInput | SortOrder
    howToKnowItsDone?: SortOrderInput | SortOrder
    whatHappensIfSkipped?: SortOrderInput | SortOrder
    exampleOutput?: SortOrderInput | SortOrder
    freeAlternative?: SortOrderInput | SortOrder
    lowTechOption?: SortOrderInput | SortOrder
    commonMistakesForStep?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    actionStep?: ActionStepOrderByWithRelationInput
  }

  export type ActionStepTranslationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    actionStepId_locale?: ActionStepTranslationActionStepIdLocaleCompoundUniqueInput
    AND?: ActionStepTranslationWhereInput | ActionStepTranslationWhereInput[]
    OR?: ActionStepTranslationWhereInput[]
    NOT?: ActionStepTranslationWhereInput | ActionStepTranslationWhereInput[]
    actionStepId?: StringFilter<"ActionStepTranslation"> | string
    locale?: StringFilter<"ActionStepTranslation"> | string
    title?: StringFilter<"ActionStepTranslation"> | string
    description?: StringNullableFilter<"ActionStepTranslation"> | string | null
    smeAction?: StringNullableFilter<"ActionStepTranslation"> | string | null
    timeframe?: StringNullableFilter<"ActionStepTranslation"> | string | null
    whyThisStepMatters?: StringNullableFilter<"ActionStepTranslation"> | string | null
    howToKnowItsDone?: StringNullableFilter<"ActionStepTranslation"> | string | null
    whatHappensIfSkipped?: StringNullableFilter<"ActionStepTranslation"> | string | null
    exampleOutput?: StringNullableFilter<"ActionStepTranslation"> | string | null
    freeAlternative?: StringNullableFilter<"ActionStepTranslation"> | string | null
    lowTechOption?: StringNullableFilter<"ActionStepTranslation"> | string | null
    commonMistakesForStep?: JsonNullableFilter<"ActionStepTranslation">
    createdAt?: DateTimeFilter<"ActionStepTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"ActionStepTranslation"> | Date | string
    actionStep?: XOR<ActionStepRelationFilter, ActionStepWhereInput>
  }, "id" | "actionStepId_locale">

  export type ActionStepTranslationOrderByWithAggregationInput = {
    id?: SortOrder
    actionStepId?: SortOrder
    locale?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    smeAction?: SortOrderInput | SortOrder
    timeframe?: SortOrderInput | SortOrder
    whyThisStepMatters?: SortOrderInput | SortOrder
    howToKnowItsDone?: SortOrderInput | SortOrder
    whatHappensIfSkipped?: SortOrderInput | SortOrder
    exampleOutput?: SortOrderInput | SortOrder
    freeAlternative?: SortOrderInput | SortOrder
    lowTechOption?: SortOrderInput | SortOrder
    commonMistakesForStep?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ActionStepTranslationCountOrderByAggregateInput
    _max?: ActionStepTranslationMaxOrderByAggregateInput
    _min?: ActionStepTranslationMinOrderByAggregateInput
  }

  export type ActionStepTranslationScalarWhereWithAggregatesInput = {
    AND?: ActionStepTranslationScalarWhereWithAggregatesInput | ActionStepTranslationScalarWhereWithAggregatesInput[]
    OR?: ActionStepTranslationScalarWhereWithAggregatesInput[]
    NOT?: ActionStepTranslationScalarWhereWithAggregatesInput | ActionStepTranslationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ActionStepTranslation"> | string
    actionStepId?: StringWithAggregatesFilter<"ActionStepTranslation"> | string
    locale?: StringWithAggregatesFilter<"ActionStepTranslation"> | string
    title?: StringWithAggregatesFilter<"ActionStepTranslation"> | string
    description?: StringNullableWithAggregatesFilter<"ActionStepTranslation"> | string | null
    smeAction?: StringNullableWithAggregatesFilter<"ActionStepTranslation"> | string | null
    timeframe?: StringNullableWithAggregatesFilter<"ActionStepTranslation"> | string | null
    whyThisStepMatters?: StringNullableWithAggregatesFilter<"ActionStepTranslation"> | string | null
    howToKnowItsDone?: StringNullableWithAggregatesFilter<"ActionStepTranslation"> | string | null
    whatHappensIfSkipped?: StringNullableWithAggregatesFilter<"ActionStepTranslation"> | string | null
    exampleOutput?: StringNullableWithAggregatesFilter<"ActionStepTranslation"> | string | null
    freeAlternative?: StringNullableWithAggregatesFilter<"ActionStepTranslation"> | string | null
    lowTechOption?: StringNullableWithAggregatesFilter<"ActionStepTranslation"> | string | null
    commonMistakesForStep?: JsonNullableWithAggregatesFilter<"ActionStepTranslation">
    createdAt?: DateTimeWithAggregatesFilter<"ActionStepTranslation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ActionStepTranslation"> | Date | string
  }

  export type HazardTranslationWhereInput = {
    AND?: HazardTranslationWhereInput | HazardTranslationWhereInput[]
    OR?: HazardTranslationWhereInput[]
    NOT?: HazardTranslationWhereInput | HazardTranslationWhereInput[]
    id?: StringFilter<"HazardTranslation"> | string
    hazardId?: StringFilter<"HazardTranslation"> | string
    locale?: StringFilter<"HazardTranslation"> | string
    name?: StringFilter<"HazardTranslation"> | string
    description?: StringNullableFilter<"HazardTranslation"> | string | null
    impact?: StringNullableFilter<"HazardTranslation"> | string | null
    createdAt?: DateTimeFilter<"HazardTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"HazardTranslation"> | Date | string
    hazard?: XOR<AdminHazardTypeRelationFilter, AdminHazardTypeWhereInput>
  }

  export type HazardTranslationOrderByWithRelationInput = {
    id?: SortOrder
    hazardId?: SortOrder
    locale?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    impact?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hazard?: AdminHazardTypeOrderByWithRelationInput
  }

  export type HazardTranslationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    hazardId_locale?: HazardTranslationHazardIdLocaleCompoundUniqueInput
    AND?: HazardTranslationWhereInput | HazardTranslationWhereInput[]
    OR?: HazardTranslationWhereInput[]
    NOT?: HazardTranslationWhereInput | HazardTranslationWhereInput[]
    hazardId?: StringFilter<"HazardTranslation"> | string
    locale?: StringFilter<"HazardTranslation"> | string
    name?: StringFilter<"HazardTranslation"> | string
    description?: StringNullableFilter<"HazardTranslation"> | string | null
    impact?: StringNullableFilter<"HazardTranslation"> | string | null
    createdAt?: DateTimeFilter<"HazardTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"HazardTranslation"> | Date | string
    hazard?: XOR<AdminHazardTypeRelationFilter, AdminHazardTypeWhereInput>
  }, "id" | "hazardId_locale">

  export type HazardTranslationOrderByWithAggregationInput = {
    id?: SortOrder
    hazardId?: SortOrder
    locale?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    impact?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HazardTranslationCountOrderByAggregateInput
    _max?: HazardTranslationMaxOrderByAggregateInput
    _min?: HazardTranslationMinOrderByAggregateInput
  }

  export type HazardTranslationScalarWhereWithAggregatesInput = {
    AND?: HazardTranslationScalarWhereWithAggregatesInput | HazardTranslationScalarWhereWithAggregatesInput[]
    OR?: HazardTranslationScalarWhereWithAggregatesInput[]
    NOT?: HazardTranslationScalarWhereWithAggregatesInput | HazardTranslationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HazardTranslation"> | string
    hazardId?: StringWithAggregatesFilter<"HazardTranslation"> | string
    locale?: StringWithAggregatesFilter<"HazardTranslation"> | string
    name?: StringWithAggregatesFilter<"HazardTranslation"> | string
    description?: StringNullableWithAggregatesFilter<"HazardTranslation"> | string | null
    impact?: StringNullableWithAggregatesFilter<"HazardTranslation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"HazardTranslation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"HazardTranslation"> | Date | string
  }

  export type RiskMultiplierTranslationWhereInput = {
    AND?: RiskMultiplierTranslationWhereInput | RiskMultiplierTranslationWhereInput[]
    OR?: RiskMultiplierTranslationWhereInput[]
    NOT?: RiskMultiplierTranslationWhereInput | RiskMultiplierTranslationWhereInput[]
    id?: StringFilter<"RiskMultiplierTranslation"> | string
    riskMultiplierId?: StringFilter<"RiskMultiplierTranslation"> | string
    locale?: StringFilter<"RiskMultiplierTranslation"> | string
    name?: StringFilter<"RiskMultiplierTranslation"> | string
    description?: StringNullableFilter<"RiskMultiplierTranslation"> | string | null
    reasoning?: StringNullableFilter<"RiskMultiplierTranslation"> | string | null
    wizardQuestion?: StringNullableFilter<"RiskMultiplierTranslation"> | string | null
    wizardHelpText?: StringNullableFilter<"RiskMultiplierTranslation"> | string | null
    wizardAnswerOptions?: JsonNullableFilter<"RiskMultiplierTranslation">
    createdAt?: DateTimeFilter<"RiskMultiplierTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"RiskMultiplierTranslation"> | Date | string
    riskMultiplier?: XOR<RiskMultiplierRelationFilter, RiskMultiplierWhereInput>
  }

  export type RiskMultiplierTranslationOrderByWithRelationInput = {
    id?: SortOrder
    riskMultiplierId?: SortOrder
    locale?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    reasoning?: SortOrderInput | SortOrder
    wizardQuestion?: SortOrderInput | SortOrder
    wizardHelpText?: SortOrderInput | SortOrder
    wizardAnswerOptions?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    riskMultiplier?: RiskMultiplierOrderByWithRelationInput
  }

  export type RiskMultiplierTranslationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    riskMultiplierId_locale?: RiskMultiplierTranslationRiskMultiplierIdLocaleCompoundUniqueInput
    AND?: RiskMultiplierTranslationWhereInput | RiskMultiplierTranslationWhereInput[]
    OR?: RiskMultiplierTranslationWhereInput[]
    NOT?: RiskMultiplierTranslationWhereInput | RiskMultiplierTranslationWhereInput[]
    riskMultiplierId?: StringFilter<"RiskMultiplierTranslation"> | string
    locale?: StringFilter<"RiskMultiplierTranslation"> | string
    name?: StringFilter<"RiskMultiplierTranslation"> | string
    description?: StringNullableFilter<"RiskMultiplierTranslation"> | string | null
    reasoning?: StringNullableFilter<"RiskMultiplierTranslation"> | string | null
    wizardQuestion?: StringNullableFilter<"RiskMultiplierTranslation"> | string | null
    wizardHelpText?: StringNullableFilter<"RiskMultiplierTranslation"> | string | null
    wizardAnswerOptions?: JsonNullableFilter<"RiskMultiplierTranslation">
    createdAt?: DateTimeFilter<"RiskMultiplierTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"RiskMultiplierTranslation"> | Date | string
    riskMultiplier?: XOR<RiskMultiplierRelationFilter, RiskMultiplierWhereInput>
  }, "id" | "riskMultiplierId_locale">

  export type RiskMultiplierTranslationOrderByWithAggregationInput = {
    id?: SortOrder
    riskMultiplierId?: SortOrder
    locale?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    reasoning?: SortOrderInput | SortOrder
    wizardQuestion?: SortOrderInput | SortOrder
    wizardHelpText?: SortOrderInput | SortOrder
    wizardAnswerOptions?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RiskMultiplierTranslationCountOrderByAggregateInput
    _max?: RiskMultiplierTranslationMaxOrderByAggregateInput
    _min?: RiskMultiplierTranslationMinOrderByAggregateInput
  }

  export type RiskMultiplierTranslationScalarWhereWithAggregatesInput = {
    AND?: RiskMultiplierTranslationScalarWhereWithAggregatesInput | RiskMultiplierTranslationScalarWhereWithAggregatesInput[]
    OR?: RiskMultiplierTranslationScalarWhereWithAggregatesInput[]
    NOT?: RiskMultiplierTranslationScalarWhereWithAggregatesInput | RiskMultiplierTranslationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RiskMultiplierTranslation"> | string
    riskMultiplierId?: StringWithAggregatesFilter<"RiskMultiplierTranslation"> | string
    locale?: StringWithAggregatesFilter<"RiskMultiplierTranslation"> | string
    name?: StringWithAggregatesFilter<"RiskMultiplierTranslation"> | string
    description?: StringNullableWithAggregatesFilter<"RiskMultiplierTranslation"> | string | null
    reasoning?: StringNullableWithAggregatesFilter<"RiskMultiplierTranslation"> | string | null
    wizardQuestion?: StringNullableWithAggregatesFilter<"RiskMultiplierTranslation"> | string | null
    wizardHelpText?: StringNullableWithAggregatesFilter<"RiskMultiplierTranslation"> | string | null
    wizardAnswerOptions?: JsonNullableWithAggregatesFilter<"RiskMultiplierTranslation">
    createdAt?: DateTimeWithAggregatesFilter<"RiskMultiplierTranslation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RiskMultiplierTranslation"> | Date | string
  }

  export type BusinessContinuityPlanCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    planInformation?: PlanInformationCreateNestedOneWithoutPlanInput
    businessOverview?: BusinessOverviewCreateNestedOneWithoutPlanInput
    essentialFunction?: EssentialFunctionCreateNestedOneWithoutPlanInput
    riskAssessment?: RiskAssessmentCreateNestedOneWithoutPlanInput
    strategy?: StrategyCreateNestedOneWithoutPlanInput
    actionPlan?: ActionPlanCreateNestedOneWithoutPlanInput
    contactsInformation?: ContactsInformationCreateNestedOneWithoutPlanInput
    testingMaintenance?: TestingMaintenanceCreateNestedOneWithoutPlanInput
  }

  export type BusinessContinuityPlanUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    planInformation?: PlanInformationUncheckedCreateNestedOneWithoutPlanInput
    businessOverview?: BusinessOverviewUncheckedCreateNestedOneWithoutPlanInput
    essentialFunction?: EssentialFunctionUncheckedCreateNestedOneWithoutPlanInput
    riskAssessment?: RiskAssessmentUncheckedCreateNestedOneWithoutPlanInput
    strategy?: StrategyUncheckedCreateNestedOneWithoutPlanInput
    actionPlan?: ActionPlanUncheckedCreateNestedOneWithoutPlanInput
    contactsInformation?: ContactsInformationUncheckedCreateNestedOneWithoutPlanInput
    testingMaintenance?: TestingMaintenanceUncheckedCreateNestedOneWithoutPlanInput
  }

  export type BusinessContinuityPlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planInformation?: PlanInformationUpdateOneWithoutPlanNestedInput
    businessOverview?: BusinessOverviewUpdateOneWithoutPlanNestedInput
    essentialFunction?: EssentialFunctionUpdateOneWithoutPlanNestedInput
    riskAssessment?: RiskAssessmentUpdateOneWithoutPlanNestedInput
    strategy?: StrategyUpdateOneWithoutPlanNestedInput
    actionPlan?: ActionPlanUpdateOneWithoutPlanNestedInput
    contactsInformation?: ContactsInformationUpdateOneWithoutPlanNestedInput
    testingMaintenance?: TestingMaintenanceUpdateOneWithoutPlanNestedInput
  }

  export type BusinessContinuityPlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planInformation?: PlanInformationUncheckedUpdateOneWithoutPlanNestedInput
    businessOverview?: BusinessOverviewUncheckedUpdateOneWithoutPlanNestedInput
    essentialFunction?: EssentialFunctionUncheckedUpdateOneWithoutPlanNestedInput
    riskAssessment?: RiskAssessmentUncheckedUpdateOneWithoutPlanNestedInput
    strategy?: StrategyUncheckedUpdateOneWithoutPlanNestedInput
    actionPlan?: ActionPlanUncheckedUpdateOneWithoutPlanNestedInput
    contactsInformation?: ContactsInformationUncheckedUpdateOneWithoutPlanNestedInput
    testingMaintenance?: TestingMaintenanceUncheckedUpdateOneWithoutPlanNestedInput
  }

  export type BusinessContinuityPlanCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusinessContinuityPlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessContinuityPlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanInformationCreateInput = {
    id?: string
    companyName: string
    planManager: string
    alternateManager?: string | null
    physicalPlanLocation: string
    digitalPlanLocation?: string | null
    plan: BusinessContinuityPlanCreateNestedOneWithoutPlanInformationInput
  }

  export type PlanInformationUncheckedCreateInput = {
    id?: string
    planId: string
    companyName: string
    planManager: string
    alternateManager?: string | null
    physicalPlanLocation: string
    digitalPlanLocation?: string | null
  }

  export type PlanInformationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    planManager?: StringFieldUpdateOperationsInput | string
    alternateManager?: NullableStringFieldUpdateOperationsInput | string | null
    physicalPlanLocation?: StringFieldUpdateOperationsInput | string
    digitalPlanLocation?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: BusinessContinuityPlanUpdateOneRequiredWithoutPlanInformationNestedInput
  }

  export type PlanInformationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    planManager?: StringFieldUpdateOperationsInput | string
    alternateManager?: NullableStringFieldUpdateOperationsInput | string | null
    physicalPlanLocation?: StringFieldUpdateOperationsInput | string
    digitalPlanLocation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlanInformationCreateManyInput = {
    id?: string
    planId: string
    companyName: string
    planManager: string
    alternateManager?: string | null
    physicalPlanLocation: string
    digitalPlanLocation?: string | null
  }

  export type PlanInformationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    planManager?: StringFieldUpdateOperationsInput | string
    alternateManager?: NullableStringFieldUpdateOperationsInput | string | null
    physicalPlanLocation?: StringFieldUpdateOperationsInput | string
    digitalPlanLocation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlanInformationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    planManager?: StringFieldUpdateOperationsInput | string
    alternateManager?: NullableStringFieldUpdateOperationsInput | string | null
    physicalPlanLocation?: StringFieldUpdateOperationsInput | string
    digitalPlanLocation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BusinessOverviewCreateInput = {
    id?: string
    businessLicenseNumber: string
    businessPurpose: string
    productsAndServices: string
    serviceDeliveryMethods: string
    operatingHours: string
    keyPersonnel: string
    minimumResources: string
    customerBase: string
    serviceProviderBCP: string
    plan: BusinessContinuityPlanCreateNestedOneWithoutBusinessOverviewInput
  }

  export type BusinessOverviewUncheckedCreateInput = {
    id?: string
    planId: string
    businessLicenseNumber: string
    businessPurpose: string
    productsAndServices: string
    serviceDeliveryMethods: string
    operatingHours: string
    keyPersonnel: string
    minimumResources: string
    customerBase: string
    serviceProviderBCP: string
  }

  export type BusinessOverviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessLicenseNumber?: StringFieldUpdateOperationsInput | string
    businessPurpose?: StringFieldUpdateOperationsInput | string
    productsAndServices?: StringFieldUpdateOperationsInput | string
    serviceDeliveryMethods?: StringFieldUpdateOperationsInput | string
    operatingHours?: StringFieldUpdateOperationsInput | string
    keyPersonnel?: StringFieldUpdateOperationsInput | string
    minimumResources?: StringFieldUpdateOperationsInput | string
    customerBase?: StringFieldUpdateOperationsInput | string
    serviceProviderBCP?: StringFieldUpdateOperationsInput | string
    plan?: BusinessContinuityPlanUpdateOneRequiredWithoutBusinessOverviewNestedInput
  }

  export type BusinessOverviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    businessLicenseNumber?: StringFieldUpdateOperationsInput | string
    businessPurpose?: StringFieldUpdateOperationsInput | string
    productsAndServices?: StringFieldUpdateOperationsInput | string
    serviceDeliveryMethods?: StringFieldUpdateOperationsInput | string
    operatingHours?: StringFieldUpdateOperationsInput | string
    keyPersonnel?: StringFieldUpdateOperationsInput | string
    minimumResources?: StringFieldUpdateOperationsInput | string
    customerBase?: StringFieldUpdateOperationsInput | string
    serviceProviderBCP?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessOverviewCreateManyInput = {
    id?: string
    planId: string
    businessLicenseNumber: string
    businessPurpose: string
    productsAndServices: string
    serviceDeliveryMethods: string
    operatingHours: string
    keyPersonnel: string
    minimumResources: string
    customerBase: string
    serviceProviderBCP: string
  }

  export type BusinessOverviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessLicenseNumber?: StringFieldUpdateOperationsInput | string
    businessPurpose?: StringFieldUpdateOperationsInput | string
    productsAndServices?: StringFieldUpdateOperationsInput | string
    serviceDeliveryMethods?: StringFieldUpdateOperationsInput | string
    operatingHours?: StringFieldUpdateOperationsInput | string
    keyPersonnel?: StringFieldUpdateOperationsInput | string
    minimumResources?: StringFieldUpdateOperationsInput | string
    customerBase?: StringFieldUpdateOperationsInput | string
    serviceProviderBCP?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessOverviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    businessLicenseNumber?: StringFieldUpdateOperationsInput | string
    businessPurpose?: StringFieldUpdateOperationsInput | string
    productsAndServices?: StringFieldUpdateOperationsInput | string
    serviceDeliveryMethods?: StringFieldUpdateOperationsInput | string
    operatingHours?: StringFieldUpdateOperationsInput | string
    keyPersonnel?: StringFieldUpdateOperationsInput | string
    minimumResources?: StringFieldUpdateOperationsInput | string
    customerBase?: StringFieldUpdateOperationsInput | string
    serviceProviderBCP?: StringFieldUpdateOperationsInput | string
  }

  export type EssentialFunctionCreateInput = {
    id?: string
    supplyChainManagement: string
    staffManagement: string
    technology: string
    productsServices: string
    infrastructureFacilities: string
    sales: string
    administration: string
    plan: BusinessContinuityPlanCreateNestedOneWithoutEssentialFunctionInput
  }

  export type EssentialFunctionUncheckedCreateInput = {
    id?: string
    planId: string
    supplyChainManagement: string
    staffManagement: string
    technology: string
    productsServices: string
    infrastructureFacilities: string
    sales: string
    administration: string
  }

  export type EssentialFunctionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplyChainManagement?: StringFieldUpdateOperationsInput | string
    staffManagement?: StringFieldUpdateOperationsInput | string
    technology?: StringFieldUpdateOperationsInput | string
    productsServices?: StringFieldUpdateOperationsInput | string
    infrastructureFacilities?: StringFieldUpdateOperationsInput | string
    sales?: StringFieldUpdateOperationsInput | string
    administration?: StringFieldUpdateOperationsInput | string
    plan?: BusinessContinuityPlanUpdateOneRequiredWithoutEssentialFunctionNestedInput
  }

  export type EssentialFunctionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    supplyChainManagement?: StringFieldUpdateOperationsInput | string
    staffManagement?: StringFieldUpdateOperationsInput | string
    technology?: StringFieldUpdateOperationsInput | string
    productsServices?: StringFieldUpdateOperationsInput | string
    infrastructureFacilities?: StringFieldUpdateOperationsInput | string
    sales?: StringFieldUpdateOperationsInput | string
    administration?: StringFieldUpdateOperationsInput | string
  }

  export type EssentialFunctionCreateManyInput = {
    id?: string
    planId: string
    supplyChainManagement: string
    staffManagement: string
    technology: string
    productsServices: string
    infrastructureFacilities: string
    sales: string
    administration: string
  }

  export type EssentialFunctionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplyChainManagement?: StringFieldUpdateOperationsInput | string
    staffManagement?: StringFieldUpdateOperationsInput | string
    technology?: StringFieldUpdateOperationsInput | string
    productsServices?: StringFieldUpdateOperationsInput | string
    infrastructureFacilities?: StringFieldUpdateOperationsInput | string
    sales?: StringFieldUpdateOperationsInput | string
    administration?: StringFieldUpdateOperationsInput | string
  }

  export type EssentialFunctionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    supplyChainManagement?: StringFieldUpdateOperationsInput | string
    staffManagement?: StringFieldUpdateOperationsInput | string
    technology?: StringFieldUpdateOperationsInput | string
    productsServices?: StringFieldUpdateOperationsInput | string
    infrastructureFacilities?: StringFieldUpdateOperationsInput | string
    sales?: StringFieldUpdateOperationsInput | string
    administration?: StringFieldUpdateOperationsInput | string
  }

  export type RiskAssessmentCreateInput = {
    id?: string
    potentialHazards: string
    hazards: string
    plan: BusinessContinuityPlanCreateNestedOneWithoutRiskAssessmentInput
  }

  export type RiskAssessmentUncheckedCreateInput = {
    id?: string
    planId: string
    potentialHazards: string
    hazards: string
  }

  export type RiskAssessmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    potentialHazards?: StringFieldUpdateOperationsInput | string
    hazards?: StringFieldUpdateOperationsInput | string
    plan?: BusinessContinuityPlanUpdateOneRequiredWithoutRiskAssessmentNestedInput
  }

  export type RiskAssessmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    potentialHazards?: StringFieldUpdateOperationsInput | string
    hazards?: StringFieldUpdateOperationsInput | string
  }

  export type RiskAssessmentCreateManyInput = {
    id?: string
    planId: string
    potentialHazards: string
    hazards: string
  }

  export type RiskAssessmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    potentialHazards?: StringFieldUpdateOperationsInput | string
    hazards?: StringFieldUpdateOperationsInput | string
  }

  export type RiskAssessmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    potentialHazards?: StringFieldUpdateOperationsInput | string
    hazards?: StringFieldUpdateOperationsInput | string
  }

  export type StrategyCreateInput = {
    id?: string
    preventionStrategies: string
    responseStrategies: string
    recoveryStrategies: string
    longTermRiskReduction: string
    plan: BusinessContinuityPlanCreateNestedOneWithoutStrategyInput
  }

  export type StrategyUncheckedCreateInput = {
    id?: string
    planId: string
    preventionStrategies: string
    responseStrategies: string
    recoveryStrategies: string
    longTermRiskReduction: string
  }

  export type StrategyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    preventionStrategies?: StringFieldUpdateOperationsInput | string
    responseStrategies?: StringFieldUpdateOperationsInput | string
    recoveryStrategies?: StringFieldUpdateOperationsInput | string
    longTermRiskReduction?: StringFieldUpdateOperationsInput | string
    plan?: BusinessContinuityPlanUpdateOneRequiredWithoutStrategyNestedInput
  }

  export type StrategyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    preventionStrategies?: StringFieldUpdateOperationsInput | string
    responseStrategies?: StringFieldUpdateOperationsInput | string
    recoveryStrategies?: StringFieldUpdateOperationsInput | string
    longTermRiskReduction?: StringFieldUpdateOperationsInput | string
  }

  export type StrategyCreateManyInput = {
    id?: string
    planId: string
    preventionStrategies: string
    responseStrategies: string
    recoveryStrategies: string
    longTermRiskReduction: string
  }

  export type StrategyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    preventionStrategies?: StringFieldUpdateOperationsInput | string
    responseStrategies?: StringFieldUpdateOperationsInput | string
    recoveryStrategies?: StringFieldUpdateOperationsInput | string
    longTermRiskReduction?: StringFieldUpdateOperationsInput | string
  }

  export type StrategyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    preventionStrategies?: StringFieldUpdateOperationsInput | string
    responseStrategies?: StringFieldUpdateOperationsInput | string
    recoveryStrategies?: StringFieldUpdateOperationsInput | string
    longTermRiskReduction?: StringFieldUpdateOperationsInput | string
  }

  export type ActionPlanCreateInput = {
    id?: string
    actionPlanByRisk: string
    implementationTimeline: string
    resourceRequirements: string
    responsibleParties: string
    reviewUpdateSchedule: string
    testingAssessmentPlan: string
    plan: BusinessContinuityPlanCreateNestedOneWithoutActionPlanInput
  }

  export type ActionPlanUncheckedCreateInput = {
    id?: string
    planId: string
    actionPlanByRisk: string
    implementationTimeline: string
    resourceRequirements: string
    responsibleParties: string
    reviewUpdateSchedule: string
    testingAssessmentPlan: string
  }

  export type ActionPlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionPlanByRisk?: StringFieldUpdateOperationsInput | string
    implementationTimeline?: StringFieldUpdateOperationsInput | string
    resourceRequirements?: StringFieldUpdateOperationsInput | string
    responsibleParties?: StringFieldUpdateOperationsInput | string
    reviewUpdateSchedule?: StringFieldUpdateOperationsInput | string
    testingAssessmentPlan?: StringFieldUpdateOperationsInput | string
    plan?: BusinessContinuityPlanUpdateOneRequiredWithoutActionPlanNestedInput
  }

  export type ActionPlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    actionPlanByRisk?: StringFieldUpdateOperationsInput | string
    implementationTimeline?: StringFieldUpdateOperationsInput | string
    resourceRequirements?: StringFieldUpdateOperationsInput | string
    responsibleParties?: StringFieldUpdateOperationsInput | string
    reviewUpdateSchedule?: StringFieldUpdateOperationsInput | string
    testingAssessmentPlan?: StringFieldUpdateOperationsInput | string
  }

  export type ActionPlanCreateManyInput = {
    id?: string
    planId: string
    actionPlanByRisk: string
    implementationTimeline: string
    resourceRequirements: string
    responsibleParties: string
    reviewUpdateSchedule: string
    testingAssessmentPlan: string
  }

  export type ActionPlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionPlanByRisk?: StringFieldUpdateOperationsInput | string
    implementationTimeline?: StringFieldUpdateOperationsInput | string
    resourceRequirements?: StringFieldUpdateOperationsInput | string
    responsibleParties?: StringFieldUpdateOperationsInput | string
    reviewUpdateSchedule?: StringFieldUpdateOperationsInput | string
    testingAssessmentPlan?: StringFieldUpdateOperationsInput | string
  }

  export type ActionPlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    actionPlanByRisk?: StringFieldUpdateOperationsInput | string
    implementationTimeline?: StringFieldUpdateOperationsInput | string
    resourceRequirements?: StringFieldUpdateOperationsInput | string
    responsibleParties?: StringFieldUpdateOperationsInput | string
    reviewUpdateSchedule?: StringFieldUpdateOperationsInput | string
    testingAssessmentPlan?: StringFieldUpdateOperationsInput | string
  }

  export type SessionCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    currentStep: string
    stepData: string
    businessProfile?: BusinessProfileCreateNestedOneWithoutSessionInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    currentStep: string
    stepData: string
    businessProfile?: BusinessProfileUncheckedCreateNestedOneWithoutSessionInput
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentStep?: StringFieldUpdateOperationsInput | string
    stepData?: StringFieldUpdateOperationsInput | string
    businessProfile?: BusinessProfileUpdateOneWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentStep?: StringFieldUpdateOperationsInput | string
    stepData?: StringFieldUpdateOperationsInput | string
    businessProfile?: BusinessProfileUncheckedUpdateOneWithoutSessionNestedInput
  }

  export type SessionCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    currentStep: string
    stepData: string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentStep?: StringFieldUpdateOperationsInput | string
    stepData?: StringFieldUpdateOperationsInput | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentStep?: StringFieldUpdateOperationsInput | string
    stepData?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessProfileCreateInput = {
    id?: string
    name: string
    industry: string
    size: string
    location: string
    session: SessionCreateNestedOneWithoutBusinessProfileInput
  }

  export type BusinessProfileUncheckedCreateInput = {
    id?: string
    sessionId: string
    name: string
    industry: string
    size: string
    location: string
  }

  export type BusinessProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    session?: SessionUpdateOneRequiredWithoutBusinessProfileNestedInput
  }

  export type BusinessProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessProfileCreateManyInput = {
    id?: string
    sessionId: string
    name: string
    industry: string
    size: string
    location: string
  }

  export type BusinessProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
  }

  export type ContactsInformationCreateInput = {
    id?: string
    staffContactInfo: string
    keyCustomerContacts: string
    supplierInformation: string
    emergencyServicesUtilities: string
    criticalBusinessInfo: string
    planDistributionList: string
    plan: BusinessContinuityPlanCreateNestedOneWithoutContactsInformationInput
  }

  export type ContactsInformationUncheckedCreateInput = {
    id?: string
    planId: string
    staffContactInfo: string
    keyCustomerContacts: string
    supplierInformation: string
    emergencyServicesUtilities: string
    criticalBusinessInfo: string
    planDistributionList: string
  }

  export type ContactsInformationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffContactInfo?: StringFieldUpdateOperationsInput | string
    keyCustomerContacts?: StringFieldUpdateOperationsInput | string
    supplierInformation?: StringFieldUpdateOperationsInput | string
    emergencyServicesUtilities?: StringFieldUpdateOperationsInput | string
    criticalBusinessInfo?: StringFieldUpdateOperationsInput | string
    planDistributionList?: StringFieldUpdateOperationsInput | string
    plan?: BusinessContinuityPlanUpdateOneRequiredWithoutContactsInformationNestedInput
  }

  export type ContactsInformationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    staffContactInfo?: StringFieldUpdateOperationsInput | string
    keyCustomerContacts?: StringFieldUpdateOperationsInput | string
    supplierInformation?: StringFieldUpdateOperationsInput | string
    emergencyServicesUtilities?: StringFieldUpdateOperationsInput | string
    criticalBusinessInfo?: StringFieldUpdateOperationsInput | string
    planDistributionList?: StringFieldUpdateOperationsInput | string
  }

  export type ContactsInformationCreateManyInput = {
    id?: string
    planId: string
    staffContactInfo: string
    keyCustomerContacts: string
    supplierInformation: string
    emergencyServicesUtilities: string
    criticalBusinessInfo: string
    planDistributionList: string
  }

  export type ContactsInformationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffContactInfo?: StringFieldUpdateOperationsInput | string
    keyCustomerContacts?: StringFieldUpdateOperationsInput | string
    supplierInformation?: StringFieldUpdateOperationsInput | string
    emergencyServicesUtilities?: StringFieldUpdateOperationsInput | string
    criticalBusinessInfo?: StringFieldUpdateOperationsInput | string
    planDistributionList?: StringFieldUpdateOperationsInput | string
  }

  export type ContactsInformationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    staffContactInfo?: StringFieldUpdateOperationsInput | string
    keyCustomerContacts?: StringFieldUpdateOperationsInput | string
    supplierInformation?: StringFieldUpdateOperationsInput | string
    emergencyServicesUtilities?: StringFieldUpdateOperationsInput | string
    criticalBusinessInfo?: StringFieldUpdateOperationsInput | string
    planDistributionList?: StringFieldUpdateOperationsInput | string
  }

  export type TestingMaintenanceCreateInput = {
    id?: string
    planTestingSchedule: string
    planRevisionHistory: string
    improvementTracking: string
    annualReviewProcess: string
    triggerEventsForUpdates: string
    plan: BusinessContinuityPlanCreateNestedOneWithoutTestingMaintenanceInput
  }

  export type TestingMaintenanceUncheckedCreateInput = {
    id?: string
    planId: string
    planTestingSchedule: string
    planRevisionHistory: string
    improvementTracking: string
    annualReviewProcess: string
    triggerEventsForUpdates: string
  }

  export type TestingMaintenanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    planTestingSchedule?: StringFieldUpdateOperationsInput | string
    planRevisionHistory?: StringFieldUpdateOperationsInput | string
    improvementTracking?: StringFieldUpdateOperationsInput | string
    annualReviewProcess?: StringFieldUpdateOperationsInput | string
    triggerEventsForUpdates?: StringFieldUpdateOperationsInput | string
    plan?: BusinessContinuityPlanUpdateOneRequiredWithoutTestingMaintenanceNestedInput
  }

  export type TestingMaintenanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    planTestingSchedule?: StringFieldUpdateOperationsInput | string
    planRevisionHistory?: StringFieldUpdateOperationsInput | string
    improvementTracking?: StringFieldUpdateOperationsInput | string
    annualReviewProcess?: StringFieldUpdateOperationsInput | string
    triggerEventsForUpdates?: StringFieldUpdateOperationsInput | string
  }

  export type TestingMaintenanceCreateManyInput = {
    id?: string
    planId: string
    planTestingSchedule: string
    planRevisionHistory: string
    improvementTracking: string
    annualReviewProcess: string
    triggerEventsForUpdates: string
  }

  export type TestingMaintenanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    planTestingSchedule?: StringFieldUpdateOperationsInput | string
    planRevisionHistory?: StringFieldUpdateOperationsInput | string
    improvementTracking?: StringFieldUpdateOperationsInput | string
    annualReviewProcess?: StringFieldUpdateOperationsInput | string
    triggerEventsForUpdates?: StringFieldUpdateOperationsInput | string
  }

  export type TestingMaintenanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    planTestingSchedule?: StringFieldUpdateOperationsInput | string
    planRevisionHistory?: StringFieldUpdateOperationsInput | string
    improvementTracking?: StringFieldUpdateOperationsInput | string
    annualReviewProcess?: StringFieldUpdateOperationsInput | string
    triggerEventsForUpdates?: StringFieldUpdateOperationsInput | string
  }

  export type AnonymousSessionCreateInput = {
    id?: string
    sessionId: string
    businessName: string
    displayBusinessName: string
    pin: string
    email?: string | null
    planData: string
    shareableId?: string | null
    allowSharing?: boolean
    createdAt?: Date | string
    lastAccessed?: Date | string
  }

  export type AnonymousSessionUncheckedCreateInput = {
    id?: string
    sessionId: string
    businessName: string
    displayBusinessName: string
    pin: string
    email?: string | null
    planData: string
    shareableId?: string | null
    allowSharing?: boolean
    createdAt?: Date | string
    lastAccessed?: Date | string
  }

  export type AnonymousSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    businessName?: StringFieldUpdateOperationsInput | string
    displayBusinessName?: StringFieldUpdateOperationsInput | string
    pin?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    planData?: StringFieldUpdateOperationsInput | string
    shareableId?: NullableStringFieldUpdateOperationsInput | string | null
    allowSharing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAccessed?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnonymousSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    businessName?: StringFieldUpdateOperationsInput | string
    displayBusinessName?: StringFieldUpdateOperationsInput | string
    pin?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    planData?: StringFieldUpdateOperationsInput | string
    shareableId?: NullableStringFieldUpdateOperationsInput | string | null
    allowSharing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAccessed?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnonymousSessionCreateManyInput = {
    id?: string
    sessionId: string
    businessName: string
    displayBusinessName: string
    pin: string
    email?: string | null
    planData: string
    shareableId?: string | null
    allowSharing?: boolean
    createdAt?: Date | string
    lastAccessed?: Date | string
  }

  export type AnonymousSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    businessName?: StringFieldUpdateOperationsInput | string
    displayBusinessName?: StringFieldUpdateOperationsInput | string
    pin?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    planData?: StringFieldUpdateOperationsInput | string
    shareableId?: NullableStringFieldUpdateOperationsInput | string | null
    allowSharing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAccessed?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnonymousSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    businessName?: StringFieldUpdateOperationsInput | string
    displayBusinessName?: StringFieldUpdateOperationsInput | string
    pin?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    planData?: StringFieldUpdateOperationsInput | string
    shareableId?: NullableStringFieldUpdateOperationsInput | string | null
    allowSharing?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAccessed?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminBusinessTypeCreateInput = {
    id?: string
    businessTypeId: string
    name: string
    localName: string
    category: string
    description?: string | null
    typicalOperatingHours?: string | null
    minimumStaff?: string | null
    minimumEquipment?: string | null
    minimumUtilities?: string | null
    minimumSpace?: string | null
    essentialFunctions?: string | null
    criticalSuppliers?: string | null
    exampleBusinessPurposes?: string | null
    exampleProducts?: string | null
    exampleKeyPersonnel?: string | null
    exampleCustomerBase?: string | null
    dependencies?: string | null
    vulnerabilityMatrix?: string | null
    operationalThresholds?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    businessTypeHazards?: AdminBusinessTypeHazardCreateNestedManyWithoutBusinessTypeInput
    riskProfiles?: AdminRiskProfileCreateNestedManyWithoutBusinessTypeInput
  }

  export type AdminBusinessTypeUncheckedCreateInput = {
    id?: string
    businessTypeId: string
    name: string
    localName: string
    category: string
    description?: string | null
    typicalOperatingHours?: string | null
    minimumStaff?: string | null
    minimumEquipment?: string | null
    minimumUtilities?: string | null
    minimumSpace?: string | null
    essentialFunctions?: string | null
    criticalSuppliers?: string | null
    exampleBusinessPurposes?: string | null
    exampleProducts?: string | null
    exampleKeyPersonnel?: string | null
    exampleCustomerBase?: string | null
    dependencies?: string | null
    vulnerabilityMatrix?: string | null
    operationalThresholds?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    businessTypeHazards?: AdminBusinessTypeHazardUncheckedCreateNestedManyWithoutBusinessTypeInput
    riskProfiles?: AdminRiskProfileUncheckedCreateNestedManyWithoutBusinessTypeInput
  }

  export type AdminBusinessTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessTypeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    localName?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    typicalOperatingHours?: NullableStringFieldUpdateOperationsInput | string | null
    minimumStaff?: NullableStringFieldUpdateOperationsInput | string | null
    minimumEquipment?: NullableStringFieldUpdateOperationsInput | string | null
    minimumUtilities?: NullableStringFieldUpdateOperationsInput | string | null
    minimumSpace?: NullableStringFieldUpdateOperationsInput | string | null
    essentialFunctions?: NullableStringFieldUpdateOperationsInput | string | null
    criticalSuppliers?: NullableStringFieldUpdateOperationsInput | string | null
    exampleBusinessPurposes?: NullableStringFieldUpdateOperationsInput | string | null
    exampleProducts?: NullableStringFieldUpdateOperationsInput | string | null
    exampleKeyPersonnel?: NullableStringFieldUpdateOperationsInput | string | null
    exampleCustomerBase?: NullableStringFieldUpdateOperationsInput | string | null
    dependencies?: NullableStringFieldUpdateOperationsInput | string | null
    vulnerabilityMatrix?: NullableStringFieldUpdateOperationsInput | string | null
    operationalThresholds?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessTypeHazards?: AdminBusinessTypeHazardUpdateManyWithoutBusinessTypeNestedInput
    riskProfiles?: AdminRiskProfileUpdateManyWithoutBusinessTypeNestedInput
  }

  export type AdminBusinessTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessTypeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    localName?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    typicalOperatingHours?: NullableStringFieldUpdateOperationsInput | string | null
    minimumStaff?: NullableStringFieldUpdateOperationsInput | string | null
    minimumEquipment?: NullableStringFieldUpdateOperationsInput | string | null
    minimumUtilities?: NullableStringFieldUpdateOperationsInput | string | null
    minimumSpace?: NullableStringFieldUpdateOperationsInput | string | null
    essentialFunctions?: NullableStringFieldUpdateOperationsInput | string | null
    criticalSuppliers?: NullableStringFieldUpdateOperationsInput | string | null
    exampleBusinessPurposes?: NullableStringFieldUpdateOperationsInput | string | null
    exampleProducts?: NullableStringFieldUpdateOperationsInput | string | null
    exampleKeyPersonnel?: NullableStringFieldUpdateOperationsInput | string | null
    exampleCustomerBase?: NullableStringFieldUpdateOperationsInput | string | null
    dependencies?: NullableStringFieldUpdateOperationsInput | string | null
    vulnerabilityMatrix?: NullableStringFieldUpdateOperationsInput | string | null
    operationalThresholds?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessTypeHazards?: AdminBusinessTypeHazardUncheckedUpdateManyWithoutBusinessTypeNestedInput
    riskProfiles?: AdminRiskProfileUncheckedUpdateManyWithoutBusinessTypeNestedInput
  }

  export type AdminBusinessTypeCreateManyInput = {
    id?: string
    businessTypeId: string
    name: string
    localName: string
    category: string
    description?: string | null
    typicalOperatingHours?: string | null
    minimumStaff?: string | null
    minimumEquipment?: string | null
    minimumUtilities?: string | null
    minimumSpace?: string | null
    essentialFunctions?: string | null
    criticalSuppliers?: string | null
    exampleBusinessPurposes?: string | null
    exampleProducts?: string | null
    exampleKeyPersonnel?: string | null
    exampleCustomerBase?: string | null
    dependencies?: string | null
    vulnerabilityMatrix?: string | null
    operationalThresholds?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminBusinessTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessTypeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    localName?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    typicalOperatingHours?: NullableStringFieldUpdateOperationsInput | string | null
    minimumStaff?: NullableStringFieldUpdateOperationsInput | string | null
    minimumEquipment?: NullableStringFieldUpdateOperationsInput | string | null
    minimumUtilities?: NullableStringFieldUpdateOperationsInput | string | null
    minimumSpace?: NullableStringFieldUpdateOperationsInput | string | null
    essentialFunctions?: NullableStringFieldUpdateOperationsInput | string | null
    criticalSuppliers?: NullableStringFieldUpdateOperationsInput | string | null
    exampleBusinessPurposes?: NullableStringFieldUpdateOperationsInput | string | null
    exampleProducts?: NullableStringFieldUpdateOperationsInput | string | null
    exampleKeyPersonnel?: NullableStringFieldUpdateOperationsInput | string | null
    exampleCustomerBase?: NullableStringFieldUpdateOperationsInput | string | null
    dependencies?: NullableStringFieldUpdateOperationsInput | string | null
    vulnerabilityMatrix?: NullableStringFieldUpdateOperationsInput | string | null
    operationalThresholds?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminBusinessTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessTypeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    localName?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    typicalOperatingHours?: NullableStringFieldUpdateOperationsInput | string | null
    minimumStaff?: NullableStringFieldUpdateOperationsInput | string | null
    minimumEquipment?: NullableStringFieldUpdateOperationsInput | string | null
    minimumUtilities?: NullableStringFieldUpdateOperationsInput | string | null
    minimumSpace?: NullableStringFieldUpdateOperationsInput | string | null
    essentialFunctions?: NullableStringFieldUpdateOperationsInput | string | null
    criticalSuppliers?: NullableStringFieldUpdateOperationsInput | string | null
    exampleBusinessPurposes?: NullableStringFieldUpdateOperationsInput | string | null
    exampleProducts?: NullableStringFieldUpdateOperationsInput | string | null
    exampleKeyPersonnel?: NullableStringFieldUpdateOperationsInput | string | null
    exampleCustomerBase?: NullableStringFieldUpdateOperationsInput | string | null
    dependencies?: NullableStringFieldUpdateOperationsInput | string | null
    vulnerabilityMatrix?: NullableStringFieldUpdateOperationsInput | string | null
    operationalThresholds?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminHazardTypeCreateInput = {
    id?: string
    hazardId: string
    name: string
    category: string
    description?: string | null
    defaultFrequency: string
    defaultImpact: string
    seasonalPattern?: string | null
    peakMonths?: string | null
    warningTime?: string | null
    geographicScope?: string | null
    cascadingRisks?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    businessTypeHazards?: AdminBusinessTypeHazardCreateNestedManyWithoutHazardInput
    locationHazards?: AdminLocationHazardCreateNestedManyWithoutHazardInput
    hazardStrategies?: AdminHazardStrategyCreateNestedManyWithoutHazardInput
    hazardActionPlans?: AdminHazardActionPlanCreateNestedManyWithoutHazardInput
    AdminActionPlan?: AdminActionPlanCreateNestedOneWithoutHazardInput
    translations?: HazardTranslationCreateNestedManyWithoutHazardInput
  }

  export type AdminHazardTypeUncheckedCreateInput = {
    id?: string
    hazardId: string
    name: string
    category: string
    description?: string | null
    defaultFrequency: string
    defaultImpact: string
    seasonalPattern?: string | null
    peakMonths?: string | null
    warningTime?: string | null
    geographicScope?: string | null
    cascadingRisks?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    businessTypeHazards?: AdminBusinessTypeHazardUncheckedCreateNestedManyWithoutHazardInput
    locationHazards?: AdminLocationHazardUncheckedCreateNestedManyWithoutHazardInput
    hazardStrategies?: AdminHazardStrategyUncheckedCreateNestedManyWithoutHazardInput
    hazardActionPlans?: AdminHazardActionPlanUncheckedCreateNestedManyWithoutHazardInput
    AdminActionPlan?: AdminActionPlanUncheckedCreateNestedOneWithoutHazardInput
    translations?: HazardTranslationUncheckedCreateNestedManyWithoutHazardInput
  }

  export type AdminHazardTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hazardId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultFrequency?: StringFieldUpdateOperationsInput | string
    defaultImpact?: StringFieldUpdateOperationsInput | string
    seasonalPattern?: NullableStringFieldUpdateOperationsInput | string | null
    peakMonths?: NullableStringFieldUpdateOperationsInput | string | null
    warningTime?: NullableStringFieldUpdateOperationsInput | string | null
    geographicScope?: NullableStringFieldUpdateOperationsInput | string | null
    cascadingRisks?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessTypeHazards?: AdminBusinessTypeHazardUpdateManyWithoutHazardNestedInput
    locationHazards?: AdminLocationHazardUpdateManyWithoutHazardNestedInput
    hazardStrategies?: AdminHazardStrategyUpdateManyWithoutHazardNestedInput
    hazardActionPlans?: AdminHazardActionPlanUpdateManyWithoutHazardNestedInput
    AdminActionPlan?: AdminActionPlanUpdateOneWithoutHazardNestedInput
    translations?: HazardTranslationUpdateManyWithoutHazardNestedInput
  }

  export type AdminHazardTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hazardId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultFrequency?: StringFieldUpdateOperationsInput | string
    defaultImpact?: StringFieldUpdateOperationsInput | string
    seasonalPattern?: NullableStringFieldUpdateOperationsInput | string | null
    peakMonths?: NullableStringFieldUpdateOperationsInput | string | null
    warningTime?: NullableStringFieldUpdateOperationsInput | string | null
    geographicScope?: NullableStringFieldUpdateOperationsInput | string | null
    cascadingRisks?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessTypeHazards?: AdminBusinessTypeHazardUncheckedUpdateManyWithoutHazardNestedInput
    locationHazards?: AdminLocationHazardUncheckedUpdateManyWithoutHazardNestedInput
    hazardStrategies?: AdminHazardStrategyUncheckedUpdateManyWithoutHazardNestedInput
    hazardActionPlans?: AdminHazardActionPlanUncheckedUpdateManyWithoutHazardNestedInput
    AdminActionPlan?: AdminActionPlanUncheckedUpdateOneWithoutHazardNestedInput
    translations?: HazardTranslationUncheckedUpdateManyWithoutHazardNestedInput
  }

  export type AdminHazardTypeCreateManyInput = {
    id?: string
    hazardId: string
    name: string
    category: string
    description?: string | null
    defaultFrequency: string
    defaultImpact: string
    seasonalPattern?: string | null
    peakMonths?: string | null
    warningTime?: string | null
    geographicScope?: string | null
    cascadingRisks?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminHazardTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    hazardId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultFrequency?: StringFieldUpdateOperationsInput | string
    defaultImpact?: StringFieldUpdateOperationsInput | string
    seasonalPattern?: NullableStringFieldUpdateOperationsInput | string | null
    peakMonths?: NullableStringFieldUpdateOperationsInput | string | null
    warningTime?: NullableStringFieldUpdateOperationsInput | string | null
    geographicScope?: NullableStringFieldUpdateOperationsInput | string | null
    cascadingRisks?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminHazardTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    hazardId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultFrequency?: StringFieldUpdateOperationsInput | string
    defaultImpact?: StringFieldUpdateOperationsInput | string
    seasonalPattern?: NullableStringFieldUpdateOperationsInput | string | null
    peakMonths?: NullableStringFieldUpdateOperationsInput | string | null
    warningTime?: NullableStringFieldUpdateOperationsInput | string | null
    geographicScope?: NullableStringFieldUpdateOperationsInput | string | null
    cascadingRisks?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminLocationCreateInput = {
    id?: string
    country: string
    countryCode: string
    parish?: string | null
    isCoastal?: boolean
    isUrban?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    locationHazards?: AdminLocationHazardCreateNestedManyWithoutLocationInput
    riskProfiles?: AdminRiskProfileCreateNestedManyWithoutLocationInput
  }

  export type AdminLocationUncheckedCreateInput = {
    id?: string
    country: string
    countryCode: string
    parish?: string | null
    isCoastal?: boolean
    isUrban?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    locationHazards?: AdminLocationHazardUncheckedCreateNestedManyWithoutLocationInput
    riskProfiles?: AdminRiskProfileUncheckedCreateNestedManyWithoutLocationInput
  }

  export type AdminLocationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    parish?: NullableStringFieldUpdateOperationsInput | string | null
    isCoastal?: BoolFieldUpdateOperationsInput | boolean
    isUrban?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationHazards?: AdminLocationHazardUpdateManyWithoutLocationNestedInput
    riskProfiles?: AdminRiskProfileUpdateManyWithoutLocationNestedInput
  }

  export type AdminLocationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    parish?: NullableStringFieldUpdateOperationsInput | string | null
    isCoastal?: BoolFieldUpdateOperationsInput | boolean
    isUrban?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationHazards?: AdminLocationHazardUncheckedUpdateManyWithoutLocationNestedInput
    riskProfiles?: AdminRiskProfileUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type AdminLocationCreateManyInput = {
    id?: string
    country: string
    countryCode: string
    parish?: string | null
    isCoastal?: boolean
    isUrban?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminLocationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    parish?: NullableStringFieldUpdateOperationsInput | string | null
    isCoastal?: BoolFieldUpdateOperationsInput | boolean
    isUrban?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminLocationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    parish?: NullableStringFieldUpdateOperationsInput | string | null
    isCoastal?: BoolFieldUpdateOperationsInput | boolean
    isUrban?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminBusinessTypeHazardCreateInput = {
    id?: string
    riskLevel: string
    frequency?: string | null
    impact?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    businessType: AdminBusinessTypeCreateNestedOneWithoutBusinessTypeHazardsInput
    hazard: AdminHazardTypeCreateNestedOneWithoutBusinessTypeHazardsInput
  }

  export type AdminBusinessTypeHazardUncheckedCreateInput = {
    id?: string
    businessTypeId: string
    hazardId: string
    riskLevel: string
    frequency?: string | null
    impact?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminBusinessTypeHazardUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    riskLevel?: StringFieldUpdateOperationsInput | string
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    impact?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessType?: AdminBusinessTypeUpdateOneRequiredWithoutBusinessTypeHazardsNestedInput
    hazard?: AdminHazardTypeUpdateOneRequiredWithoutBusinessTypeHazardsNestedInput
  }

  export type AdminBusinessTypeHazardUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessTypeId?: StringFieldUpdateOperationsInput | string
    hazardId?: StringFieldUpdateOperationsInput | string
    riskLevel?: StringFieldUpdateOperationsInput | string
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    impact?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminBusinessTypeHazardCreateManyInput = {
    id?: string
    businessTypeId: string
    hazardId: string
    riskLevel: string
    frequency?: string | null
    impact?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminBusinessTypeHazardUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    riskLevel?: StringFieldUpdateOperationsInput | string
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    impact?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminBusinessTypeHazardUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessTypeId?: StringFieldUpdateOperationsInput | string
    hazardId?: StringFieldUpdateOperationsInput | string
    riskLevel?: StringFieldUpdateOperationsInput | string
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    impact?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminLocationHazardCreateInput = {
    id?: string
    riskLevel: string
    frequency?: string | null
    impact?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    location: AdminLocationCreateNestedOneWithoutLocationHazardsInput
    hazard: AdminHazardTypeCreateNestedOneWithoutLocationHazardsInput
  }

  export type AdminLocationHazardUncheckedCreateInput = {
    id?: string
    locationId: string
    hazardId: string
    riskLevel: string
    frequency?: string | null
    impact?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminLocationHazardUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    riskLevel?: StringFieldUpdateOperationsInput | string
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    impact?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: AdminLocationUpdateOneRequiredWithoutLocationHazardsNestedInput
    hazard?: AdminHazardTypeUpdateOneRequiredWithoutLocationHazardsNestedInput
  }

  export type AdminLocationHazardUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    hazardId?: StringFieldUpdateOperationsInput | string
    riskLevel?: StringFieldUpdateOperationsInput | string
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    impact?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminLocationHazardCreateManyInput = {
    id?: string
    locationId: string
    hazardId: string
    riskLevel: string
    frequency?: string | null
    impact?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminLocationHazardUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    riskLevel?: StringFieldUpdateOperationsInput | string
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    impact?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminLocationHazardUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    hazardId?: StringFieldUpdateOperationsInput | string
    riskLevel?: StringFieldUpdateOperationsInput | string
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    impact?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminStrategyCreateInput = {
    id?: string
    strategyId: string
    title: string
    description: string
    category: string
    reasoning?: string | null
    icon?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    hazardStrategies?: AdminHazardStrategyCreateNestedManyWithoutStrategyInput
  }

  export type AdminStrategyUncheckedCreateInput = {
    id?: string
    strategyId: string
    title: string
    description: string
    category: string
    reasoning?: string | null
    icon?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    hazardStrategies?: AdminHazardStrategyUncheckedCreateNestedManyWithoutStrategyInput
  }

  export type AdminStrategyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    strategyId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hazardStrategies?: AdminHazardStrategyUpdateManyWithoutStrategyNestedInput
  }

  export type AdminStrategyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    strategyId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hazardStrategies?: AdminHazardStrategyUncheckedUpdateManyWithoutStrategyNestedInput
  }

  export type AdminStrategyCreateManyInput = {
    id?: string
    strategyId: string
    title: string
    description: string
    category: string
    reasoning?: string | null
    icon?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminStrategyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    strategyId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminStrategyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    strategyId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminHazardStrategyCreateInput = {
    id?: string
    businessTypes?: string | null
    priority?: string
    isRecommended?: boolean
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    hazard: AdminHazardTypeCreateNestedOneWithoutHazardStrategiesInput
    strategy: AdminStrategyCreateNestedOneWithoutHazardStrategiesInput
  }

  export type AdminHazardStrategyUncheckedCreateInput = {
    id?: string
    hazardId: string
    strategyId: string
    businessTypes?: string | null
    priority?: string
    isRecommended?: boolean
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminHazardStrategyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessTypes?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    isRecommended?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hazard?: AdminHazardTypeUpdateOneRequiredWithoutHazardStrategiesNestedInput
    strategy?: AdminStrategyUpdateOneRequiredWithoutHazardStrategiesNestedInput
  }

  export type AdminHazardStrategyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hazardId?: StringFieldUpdateOperationsInput | string
    strategyId?: StringFieldUpdateOperationsInput | string
    businessTypes?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    isRecommended?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminHazardStrategyCreateManyInput = {
    id?: string
    hazardId: string
    strategyId: string
    businessTypes?: string | null
    priority?: string
    isRecommended?: boolean
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminHazardStrategyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessTypes?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    isRecommended?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminHazardStrategyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    hazardId?: StringFieldUpdateOperationsInput | string
    strategyId?: StringFieldUpdateOperationsInput | string
    businessTypes?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    isRecommended?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminActionPlanCreateInput = {
    id?: string
    resourcesNeeded: string
    immediateActions: string
    shortTermActions: string
    mediumTermActions: string
    longTermReduction: string
    businessTypeModifiers?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    hazard: AdminHazardTypeCreateNestedOneWithoutAdminActionPlanInput
    AdminHazardActionPlan?: AdminHazardActionPlanCreateNestedManyWithoutActionPlanInput
  }

  export type AdminActionPlanUncheckedCreateInput = {
    id?: string
    hazardId: string
    resourcesNeeded: string
    immediateActions: string
    shortTermActions: string
    mediumTermActions: string
    longTermReduction: string
    businessTypeModifiers?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    AdminHazardActionPlan?: AdminHazardActionPlanUncheckedCreateNestedManyWithoutActionPlanInput
  }

  export type AdminActionPlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    resourcesNeeded?: StringFieldUpdateOperationsInput | string
    immediateActions?: StringFieldUpdateOperationsInput | string
    shortTermActions?: StringFieldUpdateOperationsInput | string
    mediumTermActions?: StringFieldUpdateOperationsInput | string
    longTermReduction?: StringFieldUpdateOperationsInput | string
    businessTypeModifiers?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hazard?: AdminHazardTypeUpdateOneRequiredWithoutAdminActionPlanNestedInput
    AdminHazardActionPlan?: AdminHazardActionPlanUpdateManyWithoutActionPlanNestedInput
  }

  export type AdminActionPlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hazardId?: StringFieldUpdateOperationsInput | string
    resourcesNeeded?: StringFieldUpdateOperationsInput | string
    immediateActions?: StringFieldUpdateOperationsInput | string
    shortTermActions?: StringFieldUpdateOperationsInput | string
    mediumTermActions?: StringFieldUpdateOperationsInput | string
    longTermReduction?: StringFieldUpdateOperationsInput | string
    businessTypeModifiers?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AdminHazardActionPlan?: AdminHazardActionPlanUncheckedUpdateManyWithoutActionPlanNestedInput
  }

  export type AdminActionPlanCreateManyInput = {
    id?: string
    hazardId: string
    resourcesNeeded: string
    immediateActions: string
    shortTermActions: string
    mediumTermActions: string
    longTermReduction: string
    businessTypeModifiers?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminActionPlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    resourcesNeeded?: StringFieldUpdateOperationsInput | string
    immediateActions?: StringFieldUpdateOperationsInput | string
    shortTermActions?: StringFieldUpdateOperationsInput | string
    mediumTermActions?: StringFieldUpdateOperationsInput | string
    longTermReduction?: StringFieldUpdateOperationsInput | string
    businessTypeModifiers?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminActionPlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    hazardId?: StringFieldUpdateOperationsInput | string
    resourcesNeeded?: StringFieldUpdateOperationsInput | string
    immediateActions?: StringFieldUpdateOperationsInput | string
    shortTermActions?: StringFieldUpdateOperationsInput | string
    mediumTermActions?: StringFieldUpdateOperationsInput | string
    longTermReduction?: StringFieldUpdateOperationsInput | string
    businessTypeModifiers?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminHazardActionPlanCreateInput = {
    id?: string
    businessTypes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    hazard: AdminHazardTypeCreateNestedOneWithoutHazardActionPlansInput
    actionPlan: AdminActionPlanCreateNestedOneWithoutAdminHazardActionPlanInput
  }

  export type AdminHazardActionPlanUncheckedCreateInput = {
    id?: string
    hazardId: string
    actionPlanId: string
    businessTypes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminHazardActionPlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessTypes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hazard?: AdminHazardTypeUpdateOneRequiredWithoutHazardActionPlansNestedInput
    actionPlan?: AdminActionPlanUpdateOneRequiredWithoutAdminHazardActionPlanNestedInput
  }

  export type AdminHazardActionPlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hazardId?: StringFieldUpdateOperationsInput | string
    actionPlanId?: StringFieldUpdateOperationsInput | string
    businessTypes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminHazardActionPlanCreateManyInput = {
    id?: string
    hazardId: string
    actionPlanId: string
    businessTypes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminHazardActionPlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessTypes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminHazardActionPlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    hazardId?: StringFieldUpdateOperationsInput | string
    actionPlanId?: StringFieldUpdateOperationsInput | string
    businessTypes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminRiskProfileCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    calculatedRisks: string
    recommendedStrategies: string
    lastCalculated?: Date | string
    riskScore: number
    businessType: AdminBusinessTypeCreateNestedOneWithoutRiskProfilesInput
    location: AdminLocationCreateNestedOneWithoutRiskProfilesInput
  }

  export type AdminRiskProfileUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    businessTypeId: string
    locationId: string
    calculatedRisks: string
    recommendedStrategies: string
    lastCalculated?: Date | string
    riskScore: number
  }

  export type AdminRiskProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calculatedRisks?: StringFieldUpdateOperationsInput | string
    recommendedStrategies?: StringFieldUpdateOperationsInput | string
    lastCalculated?: DateTimeFieldUpdateOperationsInput | Date | string
    riskScore?: IntFieldUpdateOperationsInput | number
    businessType?: AdminBusinessTypeUpdateOneRequiredWithoutRiskProfilesNestedInput
    location?: AdminLocationUpdateOneRequiredWithoutRiskProfilesNestedInput
  }

  export type AdminRiskProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessTypeId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    calculatedRisks?: StringFieldUpdateOperationsInput | string
    recommendedStrategies?: StringFieldUpdateOperationsInput | string
    lastCalculated?: DateTimeFieldUpdateOperationsInput | Date | string
    riskScore?: IntFieldUpdateOperationsInput | number
  }

  export type AdminRiskProfileCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    businessTypeId: string
    locationId: string
    calculatedRisks: string
    recommendedStrategies: string
    lastCalculated?: Date | string
    riskScore: number
  }

  export type AdminRiskProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calculatedRisks?: StringFieldUpdateOperationsInput | string
    recommendedStrategies?: StringFieldUpdateOperationsInput | string
    lastCalculated?: DateTimeFieldUpdateOperationsInput | Date | string
    riskScore?: IntFieldUpdateOperationsInput | number
  }

  export type AdminRiskProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessTypeId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    calculatedRisks?: StringFieldUpdateOperationsInput | string
    recommendedStrategies?: StringFieldUpdateOperationsInput | string
    lastCalculated?: DateTimeFieldUpdateOperationsInput | Date | string
    riskScore?: IntFieldUpdateOperationsInput | number
  }

  export type CountryCreateInput = {
    id?: string
    name: string
    code: string
    region?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    adminUnits?: AdminUnitCreateNestedManyWithoutCountryInput
  }

  export type CountryUncheckedCreateInput = {
    id?: string
    name: string
    code: string
    region?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    adminUnits?: AdminUnitUncheckedCreateNestedManyWithoutCountryInput
  }

  export type CountryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminUnits?: AdminUnitUpdateManyWithoutCountryNestedInput
  }

  export type CountryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminUnits?: AdminUnitUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type CountryCreateManyInput = {
    id?: string
    name: string
    code: string
    region?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CountryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CountryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUnitCreateInput = {
    id?: string
    name: string
    localName?: string | null
    type?: string
    region?: string | null
    population?: number
    area?: number | null
    elevation?: number | null
    coordinates?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    country: CountryCreateNestedOneWithoutAdminUnitsInput
    adminUnitRisk?: AdminUnitRiskCreateNestedOneWithoutAdminUnitInput
  }

  export type AdminUnitUncheckedCreateInput = {
    id?: string
    name: string
    localName?: string | null
    type?: string
    region?: string | null
    countryId: string
    population?: number
    area?: number | null
    elevation?: number | null
    coordinates?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    adminUnitRisk?: AdminUnitRiskUncheckedCreateNestedOneWithoutAdminUnitInput
  }

  export type AdminUnitUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    localName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    population?: IntFieldUpdateOperationsInput | number
    area?: NullableFloatFieldUpdateOperationsInput | number | null
    elevation?: NullableFloatFieldUpdateOperationsInput | number | null
    coordinates?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    country?: CountryUpdateOneRequiredWithoutAdminUnitsNestedInput
    adminUnitRisk?: AdminUnitRiskUpdateOneWithoutAdminUnitNestedInput
  }

  export type AdminUnitUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    localName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    countryId?: StringFieldUpdateOperationsInput | string
    population?: IntFieldUpdateOperationsInput | number
    area?: NullableFloatFieldUpdateOperationsInput | number | null
    elevation?: NullableFloatFieldUpdateOperationsInput | number | null
    coordinates?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    adminUnitRisk?: AdminUnitRiskUncheckedUpdateOneWithoutAdminUnitNestedInput
  }

  export type AdminUnitCreateManyInput = {
    id?: string
    name: string
    localName?: string | null
    type?: string
    region?: string | null
    countryId: string
    population?: number
    area?: number | null
    elevation?: number | null
    coordinates?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
  }

  export type AdminUnitUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    localName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    population?: IntFieldUpdateOperationsInput | number
    area?: NullableFloatFieldUpdateOperationsInput | number | null
    elevation?: NullableFloatFieldUpdateOperationsInput | number | null
    coordinates?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AdminUnitUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    localName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    countryId?: StringFieldUpdateOperationsInput | string
    population?: IntFieldUpdateOperationsInput | number
    area?: NullableFloatFieldUpdateOperationsInput | number | null
    elevation?: NullableFloatFieldUpdateOperationsInput | number | null
    coordinates?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ParishCreateInput = {
    id?: string
    name: string
    region: string
    countryCode?: string
    population?: number
    area?: number | null
    elevation?: number | null
    coordinates?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    parishRisk?: ParishRiskCreateNestedOneWithoutParishInput
    businessRiskProfiles?: BusinessRiskProfileCreateNestedManyWithoutParishInput
  }

  export type ParishUncheckedCreateInput = {
    id?: string
    name: string
    region: string
    countryCode?: string
    population?: number
    area?: number | null
    elevation?: number | null
    coordinates?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    parishRisk?: ParishRiskUncheckedCreateNestedOneWithoutParishInput
    businessRiskProfiles?: BusinessRiskProfileUncheckedCreateNestedManyWithoutParishInput
  }

  export type ParishUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    population?: IntFieldUpdateOperationsInput | number
    area?: NullableFloatFieldUpdateOperationsInput | number | null
    elevation?: NullableFloatFieldUpdateOperationsInput | number | null
    coordinates?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    parishRisk?: ParishRiskUpdateOneWithoutParishNestedInput
    businessRiskProfiles?: BusinessRiskProfileUpdateManyWithoutParishNestedInput
  }

  export type ParishUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    population?: IntFieldUpdateOperationsInput | number
    area?: NullableFloatFieldUpdateOperationsInput | number | null
    elevation?: NullableFloatFieldUpdateOperationsInput | number | null
    coordinates?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    parishRisk?: ParishRiskUncheckedUpdateOneWithoutParishNestedInput
    businessRiskProfiles?: BusinessRiskProfileUncheckedUpdateManyWithoutParishNestedInput
  }

  export type ParishCreateManyInput = {
    id?: string
    name: string
    region: string
    countryCode?: string
    population?: number
    area?: number | null
    elevation?: number | null
    coordinates?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
  }

  export type ParishUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    population?: IntFieldUpdateOperationsInput | number
    area?: NullableFloatFieldUpdateOperationsInput | number | null
    elevation?: NullableFloatFieldUpdateOperationsInput | number | null
    coordinates?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ParishUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    population?: IntFieldUpdateOperationsInput | number
    area?: NullableFloatFieldUpdateOperationsInput | number | null
    elevation?: NullableFloatFieldUpdateOperationsInput | number | null
    coordinates?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AdminUnitRiskCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUpdated?: Date | string
    updatedBy?: string
    hurricaneLevel?: number
    hurricaneNotes?: string
    floodLevel?: number
    floodNotes?: string
    earthquakeLevel?: number
    earthquakeNotes?: string
    droughtLevel?: number
    droughtNotes?: string
    landslideLevel?: number
    landslideNotes?: string
    powerOutageLevel?: number
    powerOutageNotes?: string
    riskProfileJson?: string
    isActive?: boolean
    adminUnit: AdminUnitCreateNestedOneWithoutAdminUnitRiskInput
    changeLogs?: AdminUnitRiskChangeLogCreateNestedManyWithoutAdminUnitRiskInput
  }

  export type AdminUnitRiskUncheckedCreateInput = {
    id?: string
    adminUnitId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUpdated?: Date | string
    updatedBy?: string
    hurricaneLevel?: number
    hurricaneNotes?: string
    floodLevel?: number
    floodNotes?: string
    earthquakeLevel?: number
    earthquakeNotes?: string
    droughtLevel?: number
    droughtNotes?: string
    landslideLevel?: number
    landslideNotes?: string
    powerOutageLevel?: number
    powerOutageNotes?: string
    riskProfileJson?: string
    isActive?: boolean
    changeLogs?: AdminUnitRiskChangeLogUncheckedCreateNestedManyWithoutAdminUnitRiskInput
  }

  export type AdminUnitRiskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    hurricaneLevel?: IntFieldUpdateOperationsInput | number
    hurricaneNotes?: StringFieldUpdateOperationsInput | string
    floodLevel?: IntFieldUpdateOperationsInput | number
    floodNotes?: StringFieldUpdateOperationsInput | string
    earthquakeLevel?: IntFieldUpdateOperationsInput | number
    earthquakeNotes?: StringFieldUpdateOperationsInput | string
    droughtLevel?: IntFieldUpdateOperationsInput | number
    droughtNotes?: StringFieldUpdateOperationsInput | string
    landslideLevel?: IntFieldUpdateOperationsInput | number
    landslideNotes?: StringFieldUpdateOperationsInput | string
    powerOutageLevel?: IntFieldUpdateOperationsInput | number
    powerOutageNotes?: StringFieldUpdateOperationsInput | string
    riskProfileJson?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    adminUnit?: AdminUnitUpdateOneRequiredWithoutAdminUnitRiskNestedInput
    changeLogs?: AdminUnitRiskChangeLogUpdateManyWithoutAdminUnitRiskNestedInput
  }

  export type AdminUnitRiskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminUnitId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    hurricaneLevel?: IntFieldUpdateOperationsInput | number
    hurricaneNotes?: StringFieldUpdateOperationsInput | string
    floodLevel?: IntFieldUpdateOperationsInput | number
    floodNotes?: StringFieldUpdateOperationsInput | string
    earthquakeLevel?: IntFieldUpdateOperationsInput | number
    earthquakeNotes?: StringFieldUpdateOperationsInput | string
    droughtLevel?: IntFieldUpdateOperationsInput | number
    droughtNotes?: StringFieldUpdateOperationsInput | string
    landslideLevel?: IntFieldUpdateOperationsInput | number
    landslideNotes?: StringFieldUpdateOperationsInput | string
    powerOutageLevel?: IntFieldUpdateOperationsInput | number
    powerOutageNotes?: StringFieldUpdateOperationsInput | string
    riskProfileJson?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    changeLogs?: AdminUnitRiskChangeLogUncheckedUpdateManyWithoutAdminUnitRiskNestedInput
  }

  export type AdminUnitRiskCreateManyInput = {
    id?: string
    adminUnitId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUpdated?: Date | string
    updatedBy?: string
    hurricaneLevel?: number
    hurricaneNotes?: string
    floodLevel?: number
    floodNotes?: string
    earthquakeLevel?: number
    earthquakeNotes?: string
    droughtLevel?: number
    droughtNotes?: string
    landslideLevel?: number
    landslideNotes?: string
    powerOutageLevel?: number
    powerOutageNotes?: string
    riskProfileJson?: string
    isActive?: boolean
  }

  export type AdminUnitRiskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    hurricaneLevel?: IntFieldUpdateOperationsInput | number
    hurricaneNotes?: StringFieldUpdateOperationsInput | string
    floodLevel?: IntFieldUpdateOperationsInput | number
    floodNotes?: StringFieldUpdateOperationsInput | string
    earthquakeLevel?: IntFieldUpdateOperationsInput | number
    earthquakeNotes?: StringFieldUpdateOperationsInput | string
    droughtLevel?: IntFieldUpdateOperationsInput | number
    droughtNotes?: StringFieldUpdateOperationsInput | string
    landslideLevel?: IntFieldUpdateOperationsInput | number
    landslideNotes?: StringFieldUpdateOperationsInput | string
    powerOutageLevel?: IntFieldUpdateOperationsInput | number
    powerOutageNotes?: StringFieldUpdateOperationsInput | string
    riskProfileJson?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AdminUnitRiskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminUnitId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    hurricaneLevel?: IntFieldUpdateOperationsInput | number
    hurricaneNotes?: StringFieldUpdateOperationsInput | string
    floodLevel?: IntFieldUpdateOperationsInput | number
    floodNotes?: StringFieldUpdateOperationsInput | string
    earthquakeLevel?: IntFieldUpdateOperationsInput | number
    earthquakeNotes?: StringFieldUpdateOperationsInput | string
    droughtLevel?: IntFieldUpdateOperationsInput | number
    droughtNotes?: StringFieldUpdateOperationsInput | string
    landslideLevel?: IntFieldUpdateOperationsInput | number
    landslideNotes?: StringFieldUpdateOperationsInput | string
    powerOutageLevel?: IntFieldUpdateOperationsInput | number
    powerOutageNotes?: StringFieldUpdateOperationsInput | string
    riskProfileJson?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AdminUnitRiskChangeLogCreateInput = {
    id?: string
    riskType: string
    oldLevel: number
    newLevel: number
    oldNotes?: string
    newNotes?: string
    changedBy: string
    changeReason?: string | null
    createdAt?: Date | string
    adminUnitRisk: AdminUnitRiskCreateNestedOneWithoutChangeLogsInput
  }

  export type AdminUnitRiskChangeLogUncheckedCreateInput = {
    id?: string
    adminUnitRiskId: string
    riskType: string
    oldLevel: number
    newLevel: number
    oldNotes?: string
    newNotes?: string
    changedBy: string
    changeReason?: string | null
    createdAt?: Date | string
  }

  export type AdminUnitRiskChangeLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    riskType?: StringFieldUpdateOperationsInput | string
    oldLevel?: IntFieldUpdateOperationsInput | number
    newLevel?: IntFieldUpdateOperationsInput | number
    oldNotes?: StringFieldUpdateOperationsInput | string
    newNotes?: StringFieldUpdateOperationsInput | string
    changedBy?: StringFieldUpdateOperationsInput | string
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminUnitRisk?: AdminUnitRiskUpdateOneRequiredWithoutChangeLogsNestedInput
  }

  export type AdminUnitRiskChangeLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminUnitRiskId?: StringFieldUpdateOperationsInput | string
    riskType?: StringFieldUpdateOperationsInput | string
    oldLevel?: IntFieldUpdateOperationsInput | number
    newLevel?: IntFieldUpdateOperationsInput | number
    oldNotes?: StringFieldUpdateOperationsInput | string
    newNotes?: StringFieldUpdateOperationsInput | string
    changedBy?: StringFieldUpdateOperationsInput | string
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUnitRiskChangeLogCreateManyInput = {
    id?: string
    adminUnitRiskId: string
    riskType: string
    oldLevel: number
    newLevel: number
    oldNotes?: string
    newNotes?: string
    changedBy: string
    changeReason?: string | null
    createdAt?: Date | string
  }

  export type AdminUnitRiskChangeLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    riskType?: StringFieldUpdateOperationsInput | string
    oldLevel?: IntFieldUpdateOperationsInput | number
    newLevel?: IntFieldUpdateOperationsInput | number
    oldNotes?: StringFieldUpdateOperationsInput | string
    newNotes?: StringFieldUpdateOperationsInput | string
    changedBy?: StringFieldUpdateOperationsInput | string
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUnitRiskChangeLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminUnitRiskId?: StringFieldUpdateOperationsInput | string
    riskType?: StringFieldUpdateOperationsInput | string
    oldLevel?: IntFieldUpdateOperationsInput | number
    newLevel?: IntFieldUpdateOperationsInput | number
    oldNotes?: StringFieldUpdateOperationsInput | string
    newNotes?: StringFieldUpdateOperationsInput | string
    changedBy?: StringFieldUpdateOperationsInput | string
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParishRiskCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUpdated?: Date | string
    updatedBy?: string
    hurricaneLevel?: number
    hurricaneNotes?: string
    floodLevel?: number
    floodNotes?: string
    earthquakeLevel?: number
    earthquakeNotes?: string
    droughtLevel?: number
    droughtNotes?: string
    landslideLevel?: number
    landslideNotes?: string
    powerOutageLevel?: number
    powerOutageNotes?: string
    riskProfileJson?: string
    isActive?: boolean
    parish: ParishCreateNestedOneWithoutParishRiskInput
    changeLogs?: RiskChangeLogCreateNestedManyWithoutParishRiskInput
  }

  export type ParishRiskUncheckedCreateInput = {
    id?: string
    parishId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUpdated?: Date | string
    updatedBy?: string
    hurricaneLevel?: number
    hurricaneNotes?: string
    floodLevel?: number
    floodNotes?: string
    earthquakeLevel?: number
    earthquakeNotes?: string
    droughtLevel?: number
    droughtNotes?: string
    landslideLevel?: number
    landslideNotes?: string
    powerOutageLevel?: number
    powerOutageNotes?: string
    riskProfileJson?: string
    isActive?: boolean
    changeLogs?: RiskChangeLogUncheckedCreateNestedManyWithoutParishRiskInput
  }

  export type ParishRiskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    hurricaneLevel?: IntFieldUpdateOperationsInput | number
    hurricaneNotes?: StringFieldUpdateOperationsInput | string
    floodLevel?: IntFieldUpdateOperationsInput | number
    floodNotes?: StringFieldUpdateOperationsInput | string
    earthquakeLevel?: IntFieldUpdateOperationsInput | number
    earthquakeNotes?: StringFieldUpdateOperationsInput | string
    droughtLevel?: IntFieldUpdateOperationsInput | number
    droughtNotes?: StringFieldUpdateOperationsInput | string
    landslideLevel?: IntFieldUpdateOperationsInput | number
    landslideNotes?: StringFieldUpdateOperationsInput | string
    powerOutageLevel?: IntFieldUpdateOperationsInput | number
    powerOutageNotes?: StringFieldUpdateOperationsInput | string
    riskProfileJson?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    parish?: ParishUpdateOneRequiredWithoutParishRiskNestedInput
    changeLogs?: RiskChangeLogUpdateManyWithoutParishRiskNestedInput
  }

  export type ParishRiskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    parishId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    hurricaneLevel?: IntFieldUpdateOperationsInput | number
    hurricaneNotes?: StringFieldUpdateOperationsInput | string
    floodLevel?: IntFieldUpdateOperationsInput | number
    floodNotes?: StringFieldUpdateOperationsInput | string
    earthquakeLevel?: IntFieldUpdateOperationsInput | number
    earthquakeNotes?: StringFieldUpdateOperationsInput | string
    droughtLevel?: IntFieldUpdateOperationsInput | number
    droughtNotes?: StringFieldUpdateOperationsInput | string
    landslideLevel?: IntFieldUpdateOperationsInput | number
    landslideNotes?: StringFieldUpdateOperationsInput | string
    powerOutageLevel?: IntFieldUpdateOperationsInput | number
    powerOutageNotes?: StringFieldUpdateOperationsInput | string
    riskProfileJson?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    changeLogs?: RiskChangeLogUncheckedUpdateManyWithoutParishRiskNestedInput
  }

  export type ParishRiskCreateManyInput = {
    id?: string
    parishId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUpdated?: Date | string
    updatedBy?: string
    hurricaneLevel?: number
    hurricaneNotes?: string
    floodLevel?: number
    floodNotes?: string
    earthquakeLevel?: number
    earthquakeNotes?: string
    droughtLevel?: number
    droughtNotes?: string
    landslideLevel?: number
    landslideNotes?: string
    powerOutageLevel?: number
    powerOutageNotes?: string
    riskProfileJson?: string
    isActive?: boolean
  }

  export type ParishRiskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    hurricaneLevel?: IntFieldUpdateOperationsInput | number
    hurricaneNotes?: StringFieldUpdateOperationsInput | string
    floodLevel?: IntFieldUpdateOperationsInput | number
    floodNotes?: StringFieldUpdateOperationsInput | string
    earthquakeLevel?: IntFieldUpdateOperationsInput | number
    earthquakeNotes?: StringFieldUpdateOperationsInput | string
    droughtLevel?: IntFieldUpdateOperationsInput | number
    droughtNotes?: StringFieldUpdateOperationsInput | string
    landslideLevel?: IntFieldUpdateOperationsInput | number
    landslideNotes?: StringFieldUpdateOperationsInput | string
    powerOutageLevel?: IntFieldUpdateOperationsInput | number
    powerOutageNotes?: StringFieldUpdateOperationsInput | string
    riskProfileJson?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ParishRiskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    parishId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    hurricaneLevel?: IntFieldUpdateOperationsInput | number
    hurricaneNotes?: StringFieldUpdateOperationsInput | string
    floodLevel?: IntFieldUpdateOperationsInput | number
    floodNotes?: StringFieldUpdateOperationsInput | string
    earthquakeLevel?: IntFieldUpdateOperationsInput | number
    earthquakeNotes?: StringFieldUpdateOperationsInput | string
    droughtLevel?: IntFieldUpdateOperationsInput | number
    droughtNotes?: StringFieldUpdateOperationsInput | string
    landslideLevel?: IntFieldUpdateOperationsInput | number
    landslideNotes?: StringFieldUpdateOperationsInput | string
    powerOutageLevel?: IntFieldUpdateOperationsInput | number
    powerOutageNotes?: StringFieldUpdateOperationsInput | string
    riskProfileJson?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RiskChangeLogCreateInput = {
    id?: string
    riskType: string
    oldLevel: number
    newLevel: number
    oldNotes?: string
    newNotes?: string
    changedBy: string
    changeReason?: string | null
    createdAt?: Date | string
    parishRisk: ParishRiskCreateNestedOneWithoutChangeLogsInput
  }

  export type RiskChangeLogUncheckedCreateInput = {
    id?: string
    parishRiskId: string
    riskType: string
    oldLevel: number
    newLevel: number
    oldNotes?: string
    newNotes?: string
    changedBy: string
    changeReason?: string | null
    createdAt?: Date | string
  }

  export type RiskChangeLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    riskType?: StringFieldUpdateOperationsInput | string
    oldLevel?: IntFieldUpdateOperationsInput | number
    newLevel?: IntFieldUpdateOperationsInput | number
    oldNotes?: StringFieldUpdateOperationsInput | string
    newNotes?: StringFieldUpdateOperationsInput | string
    changedBy?: StringFieldUpdateOperationsInput | string
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parishRisk?: ParishRiskUpdateOneRequiredWithoutChangeLogsNestedInput
  }

  export type RiskChangeLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    parishRiskId?: StringFieldUpdateOperationsInput | string
    riskType?: StringFieldUpdateOperationsInput | string
    oldLevel?: IntFieldUpdateOperationsInput | number
    newLevel?: IntFieldUpdateOperationsInput | number
    oldNotes?: StringFieldUpdateOperationsInput | string
    newNotes?: StringFieldUpdateOperationsInput | string
    changedBy?: StringFieldUpdateOperationsInput | string
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RiskChangeLogCreateManyInput = {
    id?: string
    parishRiskId: string
    riskType: string
    oldLevel: number
    newLevel: number
    oldNotes?: string
    newNotes?: string
    changedBy: string
    changeReason?: string | null
    createdAt?: Date | string
  }

  export type RiskChangeLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    riskType?: StringFieldUpdateOperationsInput | string
    oldLevel?: IntFieldUpdateOperationsInput | number
    newLevel?: IntFieldUpdateOperationsInput | number
    oldNotes?: StringFieldUpdateOperationsInput | string
    newNotes?: StringFieldUpdateOperationsInput | string
    changedBy?: StringFieldUpdateOperationsInput | string
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RiskChangeLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    parishRiskId?: StringFieldUpdateOperationsInput | string
    riskType?: StringFieldUpdateOperationsInput | string
    oldLevel?: IntFieldUpdateOperationsInput | number
    newLevel?: IntFieldUpdateOperationsInput | number
    oldNotes?: StringFieldUpdateOperationsInput | string
    newNotes?: StringFieldUpdateOperationsInput | string
    changedBy?: StringFieldUpdateOperationsInput | string
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessTypeCreateInput = {
    id?: string
    businessTypeId: string
    name: string
    category: string
    subcategory?: string | null
    description?: string | null
    exampleBusinessPurposes?: string | null
    exampleProducts?: string | null
    exampleKeyPersonnel?: string | null
    exampleCustomerBase?: string | null
    minimumEquipment?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    riskVulnerabilities?: BusinessRiskVulnerabilityCreateNestedManyWithoutBusinessTypeInput
    businessTypeStrategies?: BusinessTypeStrategyCreateNestedManyWithoutBusinessTypeInput
    businessRiskProfiles?: BusinessRiskProfileCreateNestedManyWithoutBusinessTypeInput
    translations?: BusinessTypeTranslationCreateNestedManyWithoutBusinessTypeInput
  }

  export type BusinessTypeUncheckedCreateInput = {
    id?: string
    businessTypeId: string
    name: string
    category: string
    subcategory?: string | null
    description?: string | null
    exampleBusinessPurposes?: string | null
    exampleProducts?: string | null
    exampleKeyPersonnel?: string | null
    exampleCustomerBase?: string | null
    minimumEquipment?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    riskVulnerabilities?: BusinessRiskVulnerabilityUncheckedCreateNestedManyWithoutBusinessTypeInput
    businessTypeStrategies?: BusinessTypeStrategyUncheckedCreateNestedManyWithoutBusinessTypeInput
    businessRiskProfiles?: BusinessRiskProfileUncheckedCreateNestedManyWithoutBusinessTypeInput
    translations?: BusinessTypeTranslationUncheckedCreateNestedManyWithoutBusinessTypeInput
  }

  export type BusinessTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessTypeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    exampleBusinessPurposes?: NullableStringFieldUpdateOperationsInput | string | null
    exampleProducts?: NullableStringFieldUpdateOperationsInput | string | null
    exampleKeyPersonnel?: NullableStringFieldUpdateOperationsInput | string | null
    exampleCustomerBase?: NullableStringFieldUpdateOperationsInput | string | null
    minimumEquipment?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    riskVulnerabilities?: BusinessRiskVulnerabilityUpdateManyWithoutBusinessTypeNestedInput
    businessTypeStrategies?: BusinessTypeStrategyUpdateManyWithoutBusinessTypeNestedInput
    businessRiskProfiles?: BusinessRiskProfileUpdateManyWithoutBusinessTypeNestedInput
    translations?: BusinessTypeTranslationUpdateManyWithoutBusinessTypeNestedInput
  }

  export type BusinessTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessTypeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    exampleBusinessPurposes?: NullableStringFieldUpdateOperationsInput | string | null
    exampleProducts?: NullableStringFieldUpdateOperationsInput | string | null
    exampleKeyPersonnel?: NullableStringFieldUpdateOperationsInput | string | null
    exampleCustomerBase?: NullableStringFieldUpdateOperationsInput | string | null
    minimumEquipment?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    riskVulnerabilities?: BusinessRiskVulnerabilityUncheckedUpdateManyWithoutBusinessTypeNestedInput
    businessTypeStrategies?: BusinessTypeStrategyUncheckedUpdateManyWithoutBusinessTypeNestedInput
    businessRiskProfiles?: BusinessRiskProfileUncheckedUpdateManyWithoutBusinessTypeNestedInput
    translations?: BusinessTypeTranslationUncheckedUpdateManyWithoutBusinessTypeNestedInput
  }

  export type BusinessTypeCreateManyInput = {
    id?: string
    businessTypeId: string
    name: string
    category: string
    subcategory?: string | null
    description?: string | null
    exampleBusinessPurposes?: string | null
    exampleProducts?: string | null
    exampleKeyPersonnel?: string | null
    exampleCustomerBase?: string | null
    minimumEquipment?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusinessTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessTypeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    exampleBusinessPurposes?: NullableStringFieldUpdateOperationsInput | string | null
    exampleProducts?: NullableStringFieldUpdateOperationsInput | string | null
    exampleKeyPersonnel?: NullableStringFieldUpdateOperationsInput | string | null
    exampleCustomerBase?: NullableStringFieldUpdateOperationsInput | string | null
    minimumEquipment?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessTypeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    exampleBusinessPurposes?: NullableStringFieldUpdateOperationsInput | string | null
    exampleProducts?: NullableStringFieldUpdateOperationsInput | string | null
    exampleKeyPersonnel?: NullableStringFieldUpdateOperationsInput | string | null
    exampleCustomerBase?: NullableStringFieldUpdateOperationsInput | string | null
    minimumEquipment?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessRiskVulnerabilityCreateInput = {
    id?: string
    riskType: string
    vulnerabilityLevel?: number
    impactSeverity?: number
    recoveryTime?: string | null
    reasoning?: string
    mitigationDifficulty?: number | null
    costToRecover?: string | null
    businessImpactAreas?: string | null
    criticalDependencies?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    businessType: BusinessTypeCreateNestedOneWithoutRiskVulnerabilitiesInput
  }

  export type BusinessRiskVulnerabilityUncheckedCreateInput = {
    id?: string
    businessTypeId: string
    riskType: string
    vulnerabilityLevel?: number
    impactSeverity?: number
    recoveryTime?: string | null
    reasoning?: string
    mitigationDifficulty?: number | null
    costToRecover?: string | null
    businessImpactAreas?: string | null
    criticalDependencies?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusinessRiskVulnerabilityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    riskType?: StringFieldUpdateOperationsInput | string
    vulnerabilityLevel?: IntFieldUpdateOperationsInput | number
    impactSeverity?: IntFieldUpdateOperationsInput | number
    recoveryTime?: NullableStringFieldUpdateOperationsInput | string | null
    reasoning?: StringFieldUpdateOperationsInput | string
    mitigationDifficulty?: NullableIntFieldUpdateOperationsInput | number | null
    costToRecover?: NullableStringFieldUpdateOperationsInput | string | null
    businessImpactAreas?: NullableStringFieldUpdateOperationsInput | string | null
    criticalDependencies?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessType?: BusinessTypeUpdateOneRequiredWithoutRiskVulnerabilitiesNestedInput
  }

  export type BusinessRiskVulnerabilityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessTypeId?: StringFieldUpdateOperationsInput | string
    riskType?: StringFieldUpdateOperationsInput | string
    vulnerabilityLevel?: IntFieldUpdateOperationsInput | number
    impactSeverity?: IntFieldUpdateOperationsInput | number
    recoveryTime?: NullableStringFieldUpdateOperationsInput | string | null
    reasoning?: StringFieldUpdateOperationsInput | string
    mitigationDifficulty?: NullableIntFieldUpdateOperationsInput | number | null
    costToRecover?: NullableStringFieldUpdateOperationsInput | string | null
    businessImpactAreas?: NullableStringFieldUpdateOperationsInput | string | null
    criticalDependencies?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessRiskVulnerabilityCreateManyInput = {
    id?: string
    businessTypeId: string
    riskType: string
    vulnerabilityLevel?: number
    impactSeverity?: number
    recoveryTime?: string | null
    reasoning?: string
    mitigationDifficulty?: number | null
    costToRecover?: string | null
    businessImpactAreas?: string | null
    criticalDependencies?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusinessRiskVulnerabilityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    riskType?: StringFieldUpdateOperationsInput | string
    vulnerabilityLevel?: IntFieldUpdateOperationsInput | number
    impactSeverity?: IntFieldUpdateOperationsInput | number
    recoveryTime?: NullableStringFieldUpdateOperationsInput | string | null
    reasoning?: StringFieldUpdateOperationsInput | string
    mitigationDifficulty?: NullableIntFieldUpdateOperationsInput | number | null
    costToRecover?: NullableStringFieldUpdateOperationsInput | string | null
    businessImpactAreas?: NullableStringFieldUpdateOperationsInput | string | null
    criticalDependencies?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessRiskVulnerabilityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessTypeId?: StringFieldUpdateOperationsInput | string
    riskType?: StringFieldUpdateOperationsInput | string
    vulnerabilityLevel?: IntFieldUpdateOperationsInput | number
    impactSeverity?: IntFieldUpdateOperationsInput | number
    recoveryTime?: NullableStringFieldUpdateOperationsInput | string | null
    reasoning?: StringFieldUpdateOperationsInput | string
    mitigationDifficulty?: NullableIntFieldUpdateOperationsInput | number | null
    costToRecover?: NullableStringFieldUpdateOperationsInput | string | null
    businessImpactAreas?: NullableStringFieldUpdateOperationsInput | string | null
    criticalDependencies?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RiskMitigationStrategyCreateInput = {
    id?: string
    strategyId: string
    name: string
    description: string
    smeTitle?: string | null
    smeSummary?: string | null
    smeDescription?: string | null
    whyImportant?: string | null
    benefitsBullets?: string | null
    realWorldExample?: string | null
    calculatedCostUSD?: Decimal | DecimalJsLike | number | string | null
    calculatedCostLocal?: Decimal | DecimalJsLike | number | string | null
    currencyCode?: string | null
    currencySymbol?: string | null
    totalEstimatedHours?: number | null
    selectionTier?: string | null
    requiredForRisks?: string | null
    helpfulTips?: string | null
    commonMistakes?: string | null
    successMetrics?: string | null
    lowBudgetAlternative?: string | null
    applicableRisks: string
    applicableBusinessTypes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    businessTypeStrategies?: BusinessTypeStrategyCreateNestedManyWithoutStrategyInput
    actionSteps?: ActionStepCreateNestedManyWithoutStrategyInput
    itemCosts?: StrategyItemCostCreateNestedManyWithoutStrategyInput
    translations?: StrategyTranslationCreateNestedManyWithoutStrategyInput
  }

  export type RiskMitigationStrategyUncheckedCreateInput = {
    id?: string
    strategyId: string
    name: string
    description: string
    smeTitle?: string | null
    smeSummary?: string | null
    smeDescription?: string | null
    whyImportant?: string | null
    benefitsBullets?: string | null
    realWorldExample?: string | null
    calculatedCostUSD?: Decimal | DecimalJsLike | number | string | null
    calculatedCostLocal?: Decimal | DecimalJsLike | number | string | null
    currencyCode?: string | null
    currencySymbol?: string | null
    totalEstimatedHours?: number | null
    selectionTier?: string | null
    requiredForRisks?: string | null
    helpfulTips?: string | null
    commonMistakes?: string | null
    successMetrics?: string | null
    lowBudgetAlternative?: string | null
    applicableRisks: string
    applicableBusinessTypes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    businessTypeStrategies?: BusinessTypeStrategyUncheckedCreateNestedManyWithoutStrategyInput
    actionSteps?: ActionStepUncheckedCreateNestedManyWithoutStrategyInput
    itemCosts?: StrategyItemCostUncheckedCreateNestedManyWithoutStrategyInput
    translations?: StrategyTranslationUncheckedCreateNestedManyWithoutStrategyInput
  }

  export type RiskMitigationStrategyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    strategyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    smeTitle?: NullableStringFieldUpdateOperationsInput | string | null
    smeSummary?: NullableStringFieldUpdateOperationsInput | string | null
    smeDescription?: NullableStringFieldUpdateOperationsInput | string | null
    whyImportant?: NullableStringFieldUpdateOperationsInput | string | null
    benefitsBullets?: NullableStringFieldUpdateOperationsInput | string | null
    realWorldExample?: NullableStringFieldUpdateOperationsInput | string | null
    calculatedCostUSD?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    calculatedCostLocal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currencyCode?: NullableStringFieldUpdateOperationsInput | string | null
    currencySymbol?: NullableStringFieldUpdateOperationsInput | string | null
    totalEstimatedHours?: NullableIntFieldUpdateOperationsInput | number | null
    selectionTier?: NullableStringFieldUpdateOperationsInput | string | null
    requiredForRisks?: NullableStringFieldUpdateOperationsInput | string | null
    helpfulTips?: NullableStringFieldUpdateOperationsInput | string | null
    commonMistakes?: NullableStringFieldUpdateOperationsInput | string | null
    successMetrics?: NullableStringFieldUpdateOperationsInput | string | null
    lowBudgetAlternative?: NullableStringFieldUpdateOperationsInput | string | null
    applicableRisks?: StringFieldUpdateOperationsInput | string
    applicableBusinessTypes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessTypeStrategies?: BusinessTypeStrategyUpdateManyWithoutStrategyNestedInput
    actionSteps?: ActionStepUpdateManyWithoutStrategyNestedInput
    itemCosts?: StrategyItemCostUpdateManyWithoutStrategyNestedInput
    translations?: StrategyTranslationUpdateManyWithoutStrategyNestedInput
  }

  export type RiskMitigationStrategyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    strategyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    smeTitle?: NullableStringFieldUpdateOperationsInput | string | null
    smeSummary?: NullableStringFieldUpdateOperationsInput | string | null
    smeDescription?: NullableStringFieldUpdateOperationsInput | string | null
    whyImportant?: NullableStringFieldUpdateOperationsInput | string | null
    benefitsBullets?: NullableStringFieldUpdateOperationsInput | string | null
    realWorldExample?: NullableStringFieldUpdateOperationsInput | string | null
    calculatedCostUSD?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    calculatedCostLocal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currencyCode?: NullableStringFieldUpdateOperationsInput | string | null
    currencySymbol?: NullableStringFieldUpdateOperationsInput | string | null
    totalEstimatedHours?: NullableIntFieldUpdateOperationsInput | number | null
    selectionTier?: NullableStringFieldUpdateOperationsInput | string | null
    requiredForRisks?: NullableStringFieldUpdateOperationsInput | string | null
    helpfulTips?: NullableStringFieldUpdateOperationsInput | string | null
    commonMistakes?: NullableStringFieldUpdateOperationsInput | string | null
    successMetrics?: NullableStringFieldUpdateOperationsInput | string | null
    lowBudgetAlternative?: NullableStringFieldUpdateOperationsInput | string | null
    applicableRisks?: StringFieldUpdateOperationsInput | string
    applicableBusinessTypes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessTypeStrategies?: BusinessTypeStrategyUncheckedUpdateManyWithoutStrategyNestedInput
    actionSteps?: ActionStepUncheckedUpdateManyWithoutStrategyNestedInput
    itemCosts?: StrategyItemCostUncheckedUpdateManyWithoutStrategyNestedInput
    translations?: StrategyTranslationUncheckedUpdateManyWithoutStrategyNestedInput
  }

  export type RiskMitigationStrategyCreateManyInput = {
    id?: string
    strategyId: string
    name: string
    description: string
    smeTitle?: string | null
    smeSummary?: string | null
    smeDescription?: string | null
    whyImportant?: string | null
    benefitsBullets?: string | null
    realWorldExample?: string | null
    calculatedCostUSD?: Decimal | DecimalJsLike | number | string | null
    calculatedCostLocal?: Decimal | DecimalJsLike | number | string | null
    currencyCode?: string | null
    currencySymbol?: string | null
    totalEstimatedHours?: number | null
    selectionTier?: string | null
    requiredForRisks?: string | null
    helpfulTips?: string | null
    commonMistakes?: string | null
    successMetrics?: string | null
    lowBudgetAlternative?: string | null
    applicableRisks: string
    applicableBusinessTypes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RiskMitigationStrategyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    strategyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    smeTitle?: NullableStringFieldUpdateOperationsInput | string | null
    smeSummary?: NullableStringFieldUpdateOperationsInput | string | null
    smeDescription?: NullableStringFieldUpdateOperationsInput | string | null
    whyImportant?: NullableStringFieldUpdateOperationsInput | string | null
    benefitsBullets?: NullableStringFieldUpdateOperationsInput | string | null
    realWorldExample?: NullableStringFieldUpdateOperationsInput | string | null
    calculatedCostUSD?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    calculatedCostLocal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currencyCode?: NullableStringFieldUpdateOperationsInput | string | null
    currencySymbol?: NullableStringFieldUpdateOperationsInput | string | null
    totalEstimatedHours?: NullableIntFieldUpdateOperationsInput | number | null
    selectionTier?: NullableStringFieldUpdateOperationsInput | string | null
    requiredForRisks?: NullableStringFieldUpdateOperationsInput | string | null
    helpfulTips?: NullableStringFieldUpdateOperationsInput | string | null
    commonMistakes?: NullableStringFieldUpdateOperationsInput | string | null
    successMetrics?: NullableStringFieldUpdateOperationsInput | string | null
    lowBudgetAlternative?: NullableStringFieldUpdateOperationsInput | string | null
    applicableRisks?: StringFieldUpdateOperationsInput | string
    applicableBusinessTypes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RiskMitigationStrategyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    strategyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    smeTitle?: NullableStringFieldUpdateOperationsInput | string | null
    smeSummary?: NullableStringFieldUpdateOperationsInput | string | null
    smeDescription?: NullableStringFieldUpdateOperationsInput | string | null
    whyImportant?: NullableStringFieldUpdateOperationsInput | string | null
    benefitsBullets?: NullableStringFieldUpdateOperationsInput | string | null
    realWorldExample?: NullableStringFieldUpdateOperationsInput | string | null
    calculatedCostUSD?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    calculatedCostLocal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currencyCode?: NullableStringFieldUpdateOperationsInput | string | null
    currencySymbol?: NullableStringFieldUpdateOperationsInput | string | null
    totalEstimatedHours?: NullableIntFieldUpdateOperationsInput | number | null
    selectionTier?: NullableStringFieldUpdateOperationsInput | string | null
    requiredForRisks?: NullableStringFieldUpdateOperationsInput | string | null
    helpfulTips?: NullableStringFieldUpdateOperationsInput | string | null
    commonMistakes?: NullableStringFieldUpdateOperationsInput | string | null
    successMetrics?: NullableStringFieldUpdateOperationsInput | string | null
    lowBudgetAlternative?: NullableStringFieldUpdateOperationsInput | string | null
    applicableRisks?: StringFieldUpdateOperationsInput | string
    applicableBusinessTypes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActionStepCreateInput = {
    id?: string
    stepId: string
    phase?: string
    title: string
    description: string
    smeAction?: string | null
    whyThisStepMatters?: string | null
    whatHappensIfSkipped?: string | null
    timeframe?: string | null
    estimatedMinutes?: number | null
    difficultyLevel?: string | null
    responsibility?: string | null
    estimatedCost?: string | null
    estimatedCostJMD?: string | null
    resources?: string | null
    checklist?: string | null
    howToKnowItsDone?: string | null
    exampleOutput?: string | null
    dependsOnSteps?: string | null
    isOptional?: boolean
    skipConditions?: string | null
    freeAlternative?: string | null
    lowTechOption?: string | null
    commonMistakesForStep?: string | null
    videoTutorialUrl?: string | null
    externalResourceUrl?: string | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    strategy: RiskMitigationStrategyCreateNestedOneWithoutActionStepsInput
    itemCosts?: ActionStepItemCostCreateNestedManyWithoutActionStepInput
    translations?: ActionStepTranslationCreateNestedManyWithoutActionStepInput
  }

  export type ActionStepUncheckedCreateInput = {
    id?: string
    strategyId: string
    stepId: string
    phase?: string
    title: string
    description: string
    smeAction?: string | null
    whyThisStepMatters?: string | null
    whatHappensIfSkipped?: string | null
    timeframe?: string | null
    estimatedMinutes?: number | null
    difficultyLevel?: string | null
    responsibility?: string | null
    estimatedCost?: string | null
    estimatedCostJMD?: string | null
    resources?: string | null
    checklist?: string | null
    howToKnowItsDone?: string | null
    exampleOutput?: string | null
    dependsOnSteps?: string | null
    isOptional?: boolean
    skipConditions?: string | null
    freeAlternative?: string | null
    lowTechOption?: string | null
    commonMistakesForStep?: string | null
    videoTutorialUrl?: string | null
    externalResourceUrl?: string | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    itemCosts?: ActionStepItemCostUncheckedCreateNestedManyWithoutActionStepInput
    translations?: ActionStepTranslationUncheckedCreateNestedManyWithoutActionStepInput
  }

  export type ActionStepUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepId?: StringFieldUpdateOperationsInput | string
    phase?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    smeAction?: NullableStringFieldUpdateOperationsInput | string | null
    whyThisStepMatters?: NullableStringFieldUpdateOperationsInput | string | null
    whatHappensIfSkipped?: NullableStringFieldUpdateOperationsInput | string | null
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    difficultyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    responsibility?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCost?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCostJMD?: NullableStringFieldUpdateOperationsInput | string | null
    resources?: NullableStringFieldUpdateOperationsInput | string | null
    checklist?: NullableStringFieldUpdateOperationsInput | string | null
    howToKnowItsDone?: NullableStringFieldUpdateOperationsInput | string | null
    exampleOutput?: NullableStringFieldUpdateOperationsInput | string | null
    dependsOnSteps?: NullableStringFieldUpdateOperationsInput | string | null
    isOptional?: BoolFieldUpdateOperationsInput | boolean
    skipConditions?: NullableStringFieldUpdateOperationsInput | string | null
    freeAlternative?: NullableStringFieldUpdateOperationsInput | string | null
    lowTechOption?: NullableStringFieldUpdateOperationsInput | string | null
    commonMistakesForStep?: NullableStringFieldUpdateOperationsInput | string | null
    videoTutorialUrl?: NullableStringFieldUpdateOperationsInput | string | null
    externalResourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    strategy?: RiskMitigationStrategyUpdateOneRequiredWithoutActionStepsNestedInput
    itemCosts?: ActionStepItemCostUpdateManyWithoutActionStepNestedInput
    translations?: ActionStepTranslationUpdateManyWithoutActionStepNestedInput
  }

  export type ActionStepUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    strategyId?: StringFieldUpdateOperationsInput | string
    stepId?: StringFieldUpdateOperationsInput | string
    phase?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    smeAction?: NullableStringFieldUpdateOperationsInput | string | null
    whyThisStepMatters?: NullableStringFieldUpdateOperationsInput | string | null
    whatHappensIfSkipped?: NullableStringFieldUpdateOperationsInput | string | null
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    difficultyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    responsibility?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCost?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCostJMD?: NullableStringFieldUpdateOperationsInput | string | null
    resources?: NullableStringFieldUpdateOperationsInput | string | null
    checklist?: NullableStringFieldUpdateOperationsInput | string | null
    howToKnowItsDone?: NullableStringFieldUpdateOperationsInput | string | null
    exampleOutput?: NullableStringFieldUpdateOperationsInput | string | null
    dependsOnSteps?: NullableStringFieldUpdateOperationsInput | string | null
    isOptional?: BoolFieldUpdateOperationsInput | boolean
    skipConditions?: NullableStringFieldUpdateOperationsInput | string | null
    freeAlternative?: NullableStringFieldUpdateOperationsInput | string | null
    lowTechOption?: NullableStringFieldUpdateOperationsInput | string | null
    commonMistakesForStep?: NullableStringFieldUpdateOperationsInput | string | null
    videoTutorialUrl?: NullableStringFieldUpdateOperationsInput | string | null
    externalResourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itemCosts?: ActionStepItemCostUncheckedUpdateManyWithoutActionStepNestedInput
    translations?: ActionStepTranslationUncheckedUpdateManyWithoutActionStepNestedInput
  }

  export type ActionStepCreateManyInput = {
    id?: string
    strategyId: string
    stepId: string
    phase?: string
    title: string
    description: string
    smeAction?: string | null
    whyThisStepMatters?: string | null
    whatHappensIfSkipped?: string | null
    timeframe?: string | null
    estimatedMinutes?: number | null
    difficultyLevel?: string | null
    responsibility?: string | null
    estimatedCost?: string | null
    estimatedCostJMD?: string | null
    resources?: string | null
    checklist?: string | null
    howToKnowItsDone?: string | null
    exampleOutput?: string | null
    dependsOnSteps?: string | null
    isOptional?: boolean
    skipConditions?: string | null
    freeAlternative?: string | null
    lowTechOption?: string | null
    commonMistakesForStep?: string | null
    videoTutorialUrl?: string | null
    externalResourceUrl?: string | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActionStepUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepId?: StringFieldUpdateOperationsInput | string
    phase?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    smeAction?: NullableStringFieldUpdateOperationsInput | string | null
    whyThisStepMatters?: NullableStringFieldUpdateOperationsInput | string | null
    whatHappensIfSkipped?: NullableStringFieldUpdateOperationsInput | string | null
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    difficultyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    responsibility?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCost?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCostJMD?: NullableStringFieldUpdateOperationsInput | string | null
    resources?: NullableStringFieldUpdateOperationsInput | string | null
    checklist?: NullableStringFieldUpdateOperationsInput | string | null
    howToKnowItsDone?: NullableStringFieldUpdateOperationsInput | string | null
    exampleOutput?: NullableStringFieldUpdateOperationsInput | string | null
    dependsOnSteps?: NullableStringFieldUpdateOperationsInput | string | null
    isOptional?: BoolFieldUpdateOperationsInput | boolean
    skipConditions?: NullableStringFieldUpdateOperationsInput | string | null
    freeAlternative?: NullableStringFieldUpdateOperationsInput | string | null
    lowTechOption?: NullableStringFieldUpdateOperationsInput | string | null
    commonMistakesForStep?: NullableStringFieldUpdateOperationsInput | string | null
    videoTutorialUrl?: NullableStringFieldUpdateOperationsInput | string | null
    externalResourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActionStepUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    strategyId?: StringFieldUpdateOperationsInput | string
    stepId?: StringFieldUpdateOperationsInput | string
    phase?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    smeAction?: NullableStringFieldUpdateOperationsInput | string | null
    whyThisStepMatters?: NullableStringFieldUpdateOperationsInput | string | null
    whatHappensIfSkipped?: NullableStringFieldUpdateOperationsInput | string | null
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    difficultyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    responsibility?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCost?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCostJMD?: NullableStringFieldUpdateOperationsInput | string | null
    resources?: NullableStringFieldUpdateOperationsInput | string | null
    checklist?: NullableStringFieldUpdateOperationsInput | string | null
    howToKnowItsDone?: NullableStringFieldUpdateOperationsInput | string | null
    exampleOutput?: NullableStringFieldUpdateOperationsInput | string | null
    dependsOnSteps?: NullableStringFieldUpdateOperationsInput | string | null
    isOptional?: BoolFieldUpdateOperationsInput | boolean
    skipConditions?: NullableStringFieldUpdateOperationsInput | string | null
    freeAlternative?: NullableStringFieldUpdateOperationsInput | string | null
    lowTechOption?: NullableStringFieldUpdateOperationsInput | string | null
    commonMistakesForStep?: NullableStringFieldUpdateOperationsInput | string | null
    videoTutorialUrl?: NullableStringFieldUpdateOperationsInput | string | null
    externalResourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessTypeStrategyCreateInput = {
    id?: string
    relevanceScore?: number | null
    customNotes?: string | null
    isRecommended?: boolean | null
    priority?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    businessType: BusinessTypeCreateNestedOneWithoutBusinessTypeStrategiesInput
    strategy: RiskMitigationStrategyCreateNestedOneWithoutBusinessTypeStrategiesInput
  }

  export type BusinessTypeStrategyUncheckedCreateInput = {
    id?: string
    businessTypeId: string
    strategyId: string
    relevanceScore?: number | null
    customNotes?: string | null
    isRecommended?: boolean | null
    priority?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusinessTypeStrategyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    relevanceScore?: NullableIntFieldUpdateOperationsInput | number | null
    customNotes?: NullableStringFieldUpdateOperationsInput | string | null
    isRecommended?: NullableBoolFieldUpdateOperationsInput | boolean | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessType?: BusinessTypeUpdateOneRequiredWithoutBusinessTypeStrategiesNestedInput
    strategy?: RiskMitigationStrategyUpdateOneRequiredWithoutBusinessTypeStrategiesNestedInput
  }

  export type BusinessTypeStrategyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessTypeId?: StringFieldUpdateOperationsInput | string
    strategyId?: StringFieldUpdateOperationsInput | string
    relevanceScore?: NullableIntFieldUpdateOperationsInput | number | null
    customNotes?: NullableStringFieldUpdateOperationsInput | string | null
    isRecommended?: NullableBoolFieldUpdateOperationsInput | boolean | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessTypeStrategyCreateManyInput = {
    id?: string
    businessTypeId: string
    strategyId: string
    relevanceScore?: number | null
    customNotes?: string | null
    isRecommended?: boolean | null
    priority?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusinessTypeStrategyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    relevanceScore?: NullableIntFieldUpdateOperationsInput | number | null
    customNotes?: NullableStringFieldUpdateOperationsInput | string | null
    isRecommended?: NullableBoolFieldUpdateOperationsInput | boolean | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessTypeStrategyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessTypeId?: StringFieldUpdateOperationsInput | string
    strategyId?: StringFieldUpdateOperationsInput | string
    relevanceScore?: NullableIntFieldUpdateOperationsInput | number | null
    customNotes?: NullableStringFieldUpdateOperationsInput | string | null
    isRecommended?: NullableBoolFieldUpdateOperationsInput | boolean | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessRiskProfileCreateInput = {
    id?: string
    combinedRisks: string
    recommendedStrategies: string
    overallRiskScore: number
    priorityActions?: string | null
    calculatedAt?: Date | string
    calculatedBy?: string | null
    isActive?: boolean
    businessType: BusinessTypeCreateNestedOneWithoutBusinessRiskProfilesInput
    parish: ParishCreateNestedOneWithoutBusinessRiskProfilesInput
  }

  export type BusinessRiskProfileUncheckedCreateInput = {
    id?: string
    businessTypeId: string
    parishId: string
    combinedRisks: string
    recommendedStrategies: string
    overallRiskScore: number
    priorityActions?: string | null
    calculatedAt?: Date | string
    calculatedBy?: string | null
    isActive?: boolean
  }

  export type BusinessRiskProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    combinedRisks?: StringFieldUpdateOperationsInput | string
    recommendedStrategies?: StringFieldUpdateOperationsInput | string
    overallRiskScore?: IntFieldUpdateOperationsInput | number
    priorityActions?: NullableStringFieldUpdateOperationsInput | string | null
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calculatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    businessType?: BusinessTypeUpdateOneRequiredWithoutBusinessRiskProfilesNestedInput
    parish?: ParishUpdateOneRequiredWithoutBusinessRiskProfilesNestedInput
  }

  export type BusinessRiskProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessTypeId?: StringFieldUpdateOperationsInput | string
    parishId?: StringFieldUpdateOperationsInput | string
    combinedRisks?: StringFieldUpdateOperationsInput | string
    recommendedStrategies?: StringFieldUpdateOperationsInput | string
    overallRiskScore?: IntFieldUpdateOperationsInput | number
    priorityActions?: NullableStringFieldUpdateOperationsInput | string | null
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calculatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BusinessRiskProfileCreateManyInput = {
    id?: string
    businessTypeId: string
    parishId: string
    combinedRisks: string
    recommendedStrategies: string
    overallRiskScore: number
    priorityActions?: string | null
    calculatedAt?: Date | string
    calculatedBy?: string | null
    isActive?: boolean
  }

  export type BusinessRiskProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    combinedRisks?: StringFieldUpdateOperationsInput | string
    recommendedStrategies?: StringFieldUpdateOperationsInput | string
    overallRiskScore?: IntFieldUpdateOperationsInput | number
    priorityActions?: NullableStringFieldUpdateOperationsInput | string | null
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calculatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BusinessRiskProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessTypeId?: StringFieldUpdateOperationsInput | string
    parishId?: StringFieldUpdateOperationsInput | string
    combinedRisks?: StringFieldUpdateOperationsInput | string
    recommendedStrategies?: StringFieldUpdateOperationsInput | string
    overallRiskScore?: IntFieldUpdateOperationsInput | number
    priorityActions?: NullableStringFieldUpdateOperationsInput | string | null
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calculatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RiskMultiplierCreateInput = {
    id?: string
    name: string
    description: string
    characteristicType: string
    conditionType: string
    thresholdValue?: number | null
    minValue?: number | null
    maxValue?: number | null
    multiplierFactor: number
    applicableHazards: string
    wizardQuestion?: string | null
    wizardAnswerOptions?: string | null
    wizardHelpText?: string | null
    isActive?: boolean
    priority?: number
    reasoning?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string
    translations?: RiskMultiplierTranslationCreateNestedManyWithoutRiskMultiplierInput
  }

  export type RiskMultiplierUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    characteristicType: string
    conditionType: string
    thresholdValue?: number | null
    minValue?: number | null
    maxValue?: number | null
    multiplierFactor: number
    applicableHazards: string
    wizardQuestion?: string | null
    wizardAnswerOptions?: string | null
    wizardHelpText?: string | null
    isActive?: boolean
    priority?: number
    reasoning?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string
    translations?: RiskMultiplierTranslationUncheckedCreateNestedManyWithoutRiskMultiplierInput
  }

  export type RiskMultiplierUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    characteristicType?: StringFieldUpdateOperationsInput | string
    conditionType?: StringFieldUpdateOperationsInput | string
    thresholdValue?: NullableFloatFieldUpdateOperationsInput | number | null
    minValue?: NullableFloatFieldUpdateOperationsInput | number | null
    maxValue?: NullableFloatFieldUpdateOperationsInput | number | null
    multiplierFactor?: FloatFieldUpdateOperationsInput | number
    applicableHazards?: StringFieldUpdateOperationsInput | string
    wizardQuestion?: NullableStringFieldUpdateOperationsInput | string | null
    wizardAnswerOptions?: NullableStringFieldUpdateOperationsInput | string | null
    wizardHelpText?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    translations?: RiskMultiplierTranslationUpdateManyWithoutRiskMultiplierNestedInput
  }

  export type RiskMultiplierUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    characteristicType?: StringFieldUpdateOperationsInput | string
    conditionType?: StringFieldUpdateOperationsInput | string
    thresholdValue?: NullableFloatFieldUpdateOperationsInput | number | null
    minValue?: NullableFloatFieldUpdateOperationsInput | number | null
    maxValue?: NullableFloatFieldUpdateOperationsInput | number | null
    multiplierFactor?: FloatFieldUpdateOperationsInput | number
    applicableHazards?: StringFieldUpdateOperationsInput | string
    wizardQuestion?: NullableStringFieldUpdateOperationsInput | string | null
    wizardAnswerOptions?: NullableStringFieldUpdateOperationsInput | string | null
    wizardHelpText?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    translations?: RiskMultiplierTranslationUncheckedUpdateManyWithoutRiskMultiplierNestedInput
  }

  export type RiskMultiplierCreateManyInput = {
    id?: string
    name: string
    description: string
    characteristicType: string
    conditionType: string
    thresholdValue?: number | null
    minValue?: number | null
    maxValue?: number | null
    multiplierFactor: number
    applicableHazards: string
    wizardQuestion?: string | null
    wizardAnswerOptions?: string | null
    wizardHelpText?: string | null
    isActive?: boolean
    priority?: number
    reasoning?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string
  }

  export type RiskMultiplierUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    characteristicType?: StringFieldUpdateOperationsInput | string
    conditionType?: StringFieldUpdateOperationsInput | string
    thresholdValue?: NullableFloatFieldUpdateOperationsInput | number | null
    minValue?: NullableFloatFieldUpdateOperationsInput | number | null
    maxValue?: NullableFloatFieldUpdateOperationsInput | number | null
    multiplierFactor?: FloatFieldUpdateOperationsInput | number
    applicableHazards?: StringFieldUpdateOperationsInput | string
    wizardQuestion?: NullableStringFieldUpdateOperationsInput | string | null
    wizardAnswerOptions?: NullableStringFieldUpdateOperationsInput | string | null
    wizardHelpText?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type RiskMultiplierUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    characteristicType?: StringFieldUpdateOperationsInput | string
    conditionType?: StringFieldUpdateOperationsInput | string
    thresholdValue?: NullableFloatFieldUpdateOperationsInput | number | null
    minValue?: NullableFloatFieldUpdateOperationsInput | number | null
    maxValue?: NullableFloatFieldUpdateOperationsInput | number | null
    multiplierFactor?: FloatFieldUpdateOperationsInput | number
    applicableHazards?: StringFieldUpdateOperationsInput | string
    wizardQuestion?: NullableStringFieldUpdateOperationsInput | string | null
    wizardAnswerOptions?: NullableStringFieldUpdateOperationsInput | string | null
    wizardHelpText?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type CostItemCreateInput = {
    id?: string
    itemId: string
    name: string
    description?: string | null
    category: string
    baseUSD: number
    baseUSDMin?: number | null
    baseUSDMax?: number | null
    unit?: string | null
    complexity?: string
    notes?: string | null
    tags?: string | null
    budgetAlternativeId?: string | null
    premiumAlternativeId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    strategyItems?: StrategyItemCostCreateNestedManyWithoutItemInput
    actionStepItems?: ActionStepItemCostCreateNestedManyWithoutItemInput
  }

  export type CostItemUncheckedCreateInput = {
    id?: string
    itemId: string
    name: string
    description?: string | null
    category: string
    baseUSD: number
    baseUSDMin?: number | null
    baseUSDMax?: number | null
    unit?: string | null
    complexity?: string
    notes?: string | null
    tags?: string | null
    budgetAlternativeId?: string | null
    premiumAlternativeId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    strategyItems?: StrategyItemCostUncheckedCreateNestedManyWithoutItemInput
    actionStepItems?: ActionStepItemCostUncheckedCreateNestedManyWithoutItemInput
  }

  export type CostItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    baseUSD?: FloatFieldUpdateOperationsInput | number
    baseUSDMin?: NullableFloatFieldUpdateOperationsInput | number | null
    baseUSDMax?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    complexity?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    budgetAlternativeId?: NullableStringFieldUpdateOperationsInput | string | null
    premiumAlternativeId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    strategyItems?: StrategyItemCostUpdateManyWithoutItemNestedInput
    actionStepItems?: ActionStepItemCostUpdateManyWithoutItemNestedInput
  }

  export type CostItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    baseUSD?: FloatFieldUpdateOperationsInput | number
    baseUSDMin?: NullableFloatFieldUpdateOperationsInput | number | null
    baseUSDMax?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    complexity?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    budgetAlternativeId?: NullableStringFieldUpdateOperationsInput | string | null
    premiumAlternativeId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    strategyItems?: StrategyItemCostUncheckedUpdateManyWithoutItemNestedInput
    actionStepItems?: ActionStepItemCostUncheckedUpdateManyWithoutItemNestedInput
  }

  export type CostItemCreateManyInput = {
    id?: string
    itemId: string
    name: string
    description?: string | null
    category: string
    baseUSD: number
    baseUSDMin?: number | null
    baseUSDMax?: number | null
    unit?: string | null
    complexity?: string
    notes?: string | null
    tags?: string | null
    budgetAlternativeId?: string | null
    premiumAlternativeId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CostItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    baseUSD?: FloatFieldUpdateOperationsInput | number
    baseUSDMin?: NullableFloatFieldUpdateOperationsInput | number | null
    baseUSDMax?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    complexity?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    budgetAlternativeId?: NullableStringFieldUpdateOperationsInput | string | null
    premiumAlternativeId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CostItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    baseUSD?: FloatFieldUpdateOperationsInput | number
    baseUSDMin?: NullableFloatFieldUpdateOperationsInput | number | null
    baseUSDMax?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    complexity?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    budgetAlternativeId?: NullableStringFieldUpdateOperationsInput | string | null
    premiumAlternativeId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CountryCostMultiplierCreateInput = {
    id?: string
    countryCode: string
    construction?: number
    equipment?: number
    service?: number
    supplies?: number
    currency: string
    currencySymbol?: string | null
    exchangeRateUSD: number
    lastUpdated?: Date | string
    updatedBy?: string | null
    dataSource?: string | null
    confidenceLevel?: string
    notes?: string | null
  }

  export type CountryCostMultiplierUncheckedCreateInput = {
    id?: string
    countryCode: string
    construction?: number
    equipment?: number
    service?: number
    supplies?: number
    currency: string
    currencySymbol?: string | null
    exchangeRateUSD: number
    lastUpdated?: Date | string
    updatedBy?: string | null
    dataSource?: string | null
    confidenceLevel?: string
    notes?: string | null
  }

  export type CountryCostMultiplierUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    construction?: FloatFieldUpdateOperationsInput | number
    equipment?: FloatFieldUpdateOperationsInput | number
    service?: FloatFieldUpdateOperationsInput | number
    supplies?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    currencySymbol?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRateUSD?: FloatFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    dataSource?: NullableStringFieldUpdateOperationsInput | string | null
    confidenceLevel?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CountryCostMultiplierUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    construction?: FloatFieldUpdateOperationsInput | number
    equipment?: FloatFieldUpdateOperationsInput | number
    service?: FloatFieldUpdateOperationsInput | number
    supplies?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    currencySymbol?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRateUSD?: FloatFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    dataSource?: NullableStringFieldUpdateOperationsInput | string | null
    confidenceLevel?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CountryCostMultiplierCreateManyInput = {
    id?: string
    countryCode: string
    construction?: number
    equipment?: number
    service?: number
    supplies?: number
    currency: string
    currencySymbol?: string | null
    exchangeRateUSD: number
    lastUpdated?: Date | string
    updatedBy?: string | null
    dataSource?: string | null
    confidenceLevel?: string
    notes?: string | null
  }

  export type CountryCostMultiplierUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    construction?: FloatFieldUpdateOperationsInput | number
    equipment?: FloatFieldUpdateOperationsInput | number
    service?: FloatFieldUpdateOperationsInput | number
    supplies?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    currencySymbol?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRateUSD?: FloatFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    dataSource?: NullableStringFieldUpdateOperationsInput | string | null
    confidenceLevel?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CountryCostMultiplierUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    construction?: FloatFieldUpdateOperationsInput | number
    equipment?: FloatFieldUpdateOperationsInput | number
    service?: FloatFieldUpdateOperationsInput | number
    supplies?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    currencySymbol?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRateUSD?: FloatFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    dataSource?: NullableStringFieldUpdateOperationsInput | string | null
    confidenceLevel?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StrategyItemCostCreateInput = {
    id?: string
    quantity?: number
    customNotes?: string | null
    countryOverrides?: string | null
    isRequired?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    strategy: RiskMitigationStrategyCreateNestedOneWithoutItemCostsInput
    item: CostItemCreateNestedOneWithoutStrategyItemsInput
  }

  export type StrategyItemCostUncheckedCreateInput = {
    id?: string
    strategyId: string
    itemId: string
    quantity?: number
    customNotes?: string | null
    countryOverrides?: string | null
    isRequired?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StrategyItemCostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    customNotes?: NullableStringFieldUpdateOperationsInput | string | null
    countryOverrides?: NullableStringFieldUpdateOperationsInput | string | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    strategy?: RiskMitigationStrategyUpdateOneRequiredWithoutItemCostsNestedInput
    item?: CostItemUpdateOneRequiredWithoutStrategyItemsNestedInput
  }

  export type StrategyItemCostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    strategyId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    customNotes?: NullableStringFieldUpdateOperationsInput | string | null
    countryOverrides?: NullableStringFieldUpdateOperationsInput | string | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StrategyItemCostCreateManyInput = {
    id?: string
    strategyId: string
    itemId: string
    quantity?: number
    customNotes?: string | null
    countryOverrides?: string | null
    isRequired?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StrategyItemCostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    customNotes?: NullableStringFieldUpdateOperationsInput | string | null
    countryOverrides?: NullableStringFieldUpdateOperationsInput | string | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StrategyItemCostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    strategyId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    customNotes?: NullableStringFieldUpdateOperationsInput | string | null
    countryOverrides?: NullableStringFieldUpdateOperationsInput | string | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActionStepItemCostCreateInput = {
    id?: string
    quantity?: number
    customNotes?: string | null
    countryOverrides?: string | null
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    actionStep: ActionStepCreateNestedOneWithoutItemCostsInput
    item: CostItemCreateNestedOneWithoutActionStepItemsInput
  }

  export type ActionStepItemCostUncheckedCreateInput = {
    id?: string
    actionStepId: string
    itemId: string
    quantity?: number
    customNotes?: string | null
    countryOverrides?: string | null
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActionStepItemCostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    customNotes?: NullableStringFieldUpdateOperationsInput | string | null
    countryOverrides?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actionStep?: ActionStepUpdateOneRequiredWithoutItemCostsNestedInput
    item?: CostItemUpdateOneRequiredWithoutActionStepItemsNestedInput
  }

  export type ActionStepItemCostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionStepId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    customNotes?: NullableStringFieldUpdateOperationsInput | string | null
    countryOverrides?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActionStepItemCostCreateManyInput = {
    id?: string
    actionStepId: string
    itemId: string
    quantity?: number
    customNotes?: string | null
    countryOverrides?: string | null
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActionStepItemCostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    customNotes?: NullableStringFieldUpdateOperationsInput | string | null
    countryOverrides?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActionStepItemCostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionStepId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    customNotes?: NullableStringFieldUpdateOperationsInput | string | null
    countryOverrides?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessTypeTranslationCreateInput = {
    id?: string
    locale: string
    name: string
    description?: string | null
    exampleBusinessPurposes?: NullableJsonNullValueInput | InputJsonValue
    exampleProducts?: NullableJsonNullValueInput | InputJsonValue
    exampleKeyPersonnel?: NullableJsonNullValueInput | InputJsonValue
    exampleCustomerBase?: NullableJsonNullValueInput | InputJsonValue
    minimumEquipment?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    businessType: BusinessTypeCreateNestedOneWithoutTranslationsInput
  }

  export type BusinessTypeTranslationUncheckedCreateInput = {
    id?: string
    businessTypeId: string
    locale: string
    name: string
    description?: string | null
    exampleBusinessPurposes?: NullableJsonNullValueInput | InputJsonValue
    exampleProducts?: NullableJsonNullValueInput | InputJsonValue
    exampleKeyPersonnel?: NullableJsonNullValueInput | InputJsonValue
    exampleCustomerBase?: NullableJsonNullValueInput | InputJsonValue
    minimumEquipment?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusinessTypeTranslationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    exampleBusinessPurposes?: NullableJsonNullValueInput | InputJsonValue
    exampleProducts?: NullableJsonNullValueInput | InputJsonValue
    exampleKeyPersonnel?: NullableJsonNullValueInput | InputJsonValue
    exampleCustomerBase?: NullableJsonNullValueInput | InputJsonValue
    minimumEquipment?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessType?: BusinessTypeUpdateOneRequiredWithoutTranslationsNestedInput
  }

  export type BusinessTypeTranslationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessTypeId?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    exampleBusinessPurposes?: NullableJsonNullValueInput | InputJsonValue
    exampleProducts?: NullableJsonNullValueInput | InputJsonValue
    exampleKeyPersonnel?: NullableJsonNullValueInput | InputJsonValue
    exampleCustomerBase?: NullableJsonNullValueInput | InputJsonValue
    minimumEquipment?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessTypeTranslationCreateManyInput = {
    id?: string
    businessTypeId: string
    locale: string
    name: string
    description?: string | null
    exampleBusinessPurposes?: NullableJsonNullValueInput | InputJsonValue
    exampleProducts?: NullableJsonNullValueInput | InputJsonValue
    exampleKeyPersonnel?: NullableJsonNullValueInput | InputJsonValue
    exampleCustomerBase?: NullableJsonNullValueInput | InputJsonValue
    minimumEquipment?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusinessTypeTranslationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    exampleBusinessPurposes?: NullableJsonNullValueInput | InputJsonValue
    exampleProducts?: NullableJsonNullValueInput | InputJsonValue
    exampleKeyPersonnel?: NullableJsonNullValueInput | InputJsonValue
    exampleCustomerBase?: NullableJsonNullValueInput | InputJsonValue
    minimumEquipment?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessTypeTranslationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessTypeId?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    exampleBusinessPurposes?: NullableJsonNullValueInput | InputJsonValue
    exampleProducts?: NullableJsonNullValueInput | InputJsonValue
    exampleKeyPersonnel?: NullableJsonNullValueInput | InputJsonValue
    exampleCustomerBase?: NullableJsonNullValueInput | InputJsonValue
    minimumEquipment?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StrategyTranslationCreateInput = {
    id?: string
    locale: string
    name: string
    description: string
    smeTitle?: string | null
    smeSummary?: string | null
    realWorldExample?: string | null
    whyImportant?: string | null
    whenToImplement?: string | null
    expectedOutcome?: string | null
    benefitsBullets?: NullableJsonNullValueInput | InputJsonValue
    helpfulTips?: NullableJsonNullValueInput | InputJsonValue
    commonMistakes?: NullableJsonNullValueInput | InputJsonValue
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    requiredResources?: NullableJsonNullValueInput | InputJsonValue
    lowBudgetAlternative?: string | null
    diyApproach?: string | null
    bcpTemplateText?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    strategy: RiskMitigationStrategyCreateNestedOneWithoutTranslationsInput
  }

  export type StrategyTranslationUncheckedCreateInput = {
    id?: string
    strategyId: string
    locale: string
    name: string
    description: string
    smeTitle?: string | null
    smeSummary?: string | null
    realWorldExample?: string | null
    whyImportant?: string | null
    whenToImplement?: string | null
    expectedOutcome?: string | null
    benefitsBullets?: NullableJsonNullValueInput | InputJsonValue
    helpfulTips?: NullableJsonNullValueInput | InputJsonValue
    commonMistakes?: NullableJsonNullValueInput | InputJsonValue
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    requiredResources?: NullableJsonNullValueInput | InputJsonValue
    lowBudgetAlternative?: string | null
    diyApproach?: string | null
    bcpTemplateText?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StrategyTranslationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    smeTitle?: NullableStringFieldUpdateOperationsInput | string | null
    smeSummary?: NullableStringFieldUpdateOperationsInput | string | null
    realWorldExample?: NullableStringFieldUpdateOperationsInput | string | null
    whyImportant?: NullableStringFieldUpdateOperationsInput | string | null
    whenToImplement?: NullableStringFieldUpdateOperationsInput | string | null
    expectedOutcome?: NullableStringFieldUpdateOperationsInput | string | null
    benefitsBullets?: NullableJsonNullValueInput | InputJsonValue
    helpfulTips?: NullableJsonNullValueInput | InputJsonValue
    commonMistakes?: NullableJsonNullValueInput | InputJsonValue
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    requiredResources?: NullableJsonNullValueInput | InputJsonValue
    lowBudgetAlternative?: NullableStringFieldUpdateOperationsInput | string | null
    diyApproach?: NullableStringFieldUpdateOperationsInput | string | null
    bcpTemplateText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    strategy?: RiskMitigationStrategyUpdateOneRequiredWithoutTranslationsNestedInput
  }

  export type StrategyTranslationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    strategyId?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    smeTitle?: NullableStringFieldUpdateOperationsInput | string | null
    smeSummary?: NullableStringFieldUpdateOperationsInput | string | null
    realWorldExample?: NullableStringFieldUpdateOperationsInput | string | null
    whyImportant?: NullableStringFieldUpdateOperationsInput | string | null
    whenToImplement?: NullableStringFieldUpdateOperationsInput | string | null
    expectedOutcome?: NullableStringFieldUpdateOperationsInput | string | null
    benefitsBullets?: NullableJsonNullValueInput | InputJsonValue
    helpfulTips?: NullableJsonNullValueInput | InputJsonValue
    commonMistakes?: NullableJsonNullValueInput | InputJsonValue
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    requiredResources?: NullableJsonNullValueInput | InputJsonValue
    lowBudgetAlternative?: NullableStringFieldUpdateOperationsInput | string | null
    diyApproach?: NullableStringFieldUpdateOperationsInput | string | null
    bcpTemplateText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StrategyTranslationCreateManyInput = {
    id?: string
    strategyId: string
    locale: string
    name: string
    description: string
    smeTitle?: string | null
    smeSummary?: string | null
    realWorldExample?: string | null
    whyImportant?: string | null
    whenToImplement?: string | null
    expectedOutcome?: string | null
    benefitsBullets?: NullableJsonNullValueInput | InputJsonValue
    helpfulTips?: NullableJsonNullValueInput | InputJsonValue
    commonMistakes?: NullableJsonNullValueInput | InputJsonValue
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    requiredResources?: NullableJsonNullValueInput | InputJsonValue
    lowBudgetAlternative?: string | null
    diyApproach?: string | null
    bcpTemplateText?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StrategyTranslationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    smeTitle?: NullableStringFieldUpdateOperationsInput | string | null
    smeSummary?: NullableStringFieldUpdateOperationsInput | string | null
    realWorldExample?: NullableStringFieldUpdateOperationsInput | string | null
    whyImportant?: NullableStringFieldUpdateOperationsInput | string | null
    whenToImplement?: NullableStringFieldUpdateOperationsInput | string | null
    expectedOutcome?: NullableStringFieldUpdateOperationsInput | string | null
    benefitsBullets?: NullableJsonNullValueInput | InputJsonValue
    helpfulTips?: NullableJsonNullValueInput | InputJsonValue
    commonMistakes?: NullableJsonNullValueInput | InputJsonValue
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    requiredResources?: NullableJsonNullValueInput | InputJsonValue
    lowBudgetAlternative?: NullableStringFieldUpdateOperationsInput | string | null
    diyApproach?: NullableStringFieldUpdateOperationsInput | string | null
    bcpTemplateText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StrategyTranslationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    strategyId?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    smeTitle?: NullableStringFieldUpdateOperationsInput | string | null
    smeSummary?: NullableStringFieldUpdateOperationsInput | string | null
    realWorldExample?: NullableStringFieldUpdateOperationsInput | string | null
    whyImportant?: NullableStringFieldUpdateOperationsInput | string | null
    whenToImplement?: NullableStringFieldUpdateOperationsInput | string | null
    expectedOutcome?: NullableStringFieldUpdateOperationsInput | string | null
    benefitsBullets?: NullableJsonNullValueInput | InputJsonValue
    helpfulTips?: NullableJsonNullValueInput | InputJsonValue
    commonMistakes?: NullableJsonNullValueInput | InputJsonValue
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    requiredResources?: NullableJsonNullValueInput | InputJsonValue
    lowBudgetAlternative?: NullableStringFieldUpdateOperationsInput | string | null
    diyApproach?: NullableStringFieldUpdateOperationsInput | string | null
    bcpTemplateText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActionStepTranslationCreateInput = {
    id?: string
    locale: string
    title: string
    description?: string | null
    smeAction?: string | null
    timeframe?: string | null
    whyThisStepMatters?: string | null
    howToKnowItsDone?: string | null
    whatHappensIfSkipped?: string | null
    exampleOutput?: string | null
    freeAlternative?: string | null
    lowTechOption?: string | null
    commonMistakesForStep?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    actionStep: ActionStepCreateNestedOneWithoutTranslationsInput
  }

  export type ActionStepTranslationUncheckedCreateInput = {
    id?: string
    actionStepId: string
    locale: string
    title: string
    description?: string | null
    smeAction?: string | null
    timeframe?: string | null
    whyThisStepMatters?: string | null
    howToKnowItsDone?: string | null
    whatHappensIfSkipped?: string | null
    exampleOutput?: string | null
    freeAlternative?: string | null
    lowTechOption?: string | null
    commonMistakesForStep?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActionStepTranslationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    smeAction?: NullableStringFieldUpdateOperationsInput | string | null
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null
    whyThisStepMatters?: NullableStringFieldUpdateOperationsInput | string | null
    howToKnowItsDone?: NullableStringFieldUpdateOperationsInput | string | null
    whatHappensIfSkipped?: NullableStringFieldUpdateOperationsInput | string | null
    exampleOutput?: NullableStringFieldUpdateOperationsInput | string | null
    freeAlternative?: NullableStringFieldUpdateOperationsInput | string | null
    lowTechOption?: NullableStringFieldUpdateOperationsInput | string | null
    commonMistakesForStep?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actionStep?: ActionStepUpdateOneRequiredWithoutTranslationsNestedInput
  }

  export type ActionStepTranslationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionStepId?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    smeAction?: NullableStringFieldUpdateOperationsInput | string | null
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null
    whyThisStepMatters?: NullableStringFieldUpdateOperationsInput | string | null
    howToKnowItsDone?: NullableStringFieldUpdateOperationsInput | string | null
    whatHappensIfSkipped?: NullableStringFieldUpdateOperationsInput | string | null
    exampleOutput?: NullableStringFieldUpdateOperationsInput | string | null
    freeAlternative?: NullableStringFieldUpdateOperationsInput | string | null
    lowTechOption?: NullableStringFieldUpdateOperationsInput | string | null
    commonMistakesForStep?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActionStepTranslationCreateManyInput = {
    id?: string
    actionStepId: string
    locale: string
    title: string
    description?: string | null
    smeAction?: string | null
    timeframe?: string | null
    whyThisStepMatters?: string | null
    howToKnowItsDone?: string | null
    whatHappensIfSkipped?: string | null
    exampleOutput?: string | null
    freeAlternative?: string | null
    lowTechOption?: string | null
    commonMistakesForStep?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActionStepTranslationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    smeAction?: NullableStringFieldUpdateOperationsInput | string | null
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null
    whyThisStepMatters?: NullableStringFieldUpdateOperationsInput | string | null
    howToKnowItsDone?: NullableStringFieldUpdateOperationsInput | string | null
    whatHappensIfSkipped?: NullableStringFieldUpdateOperationsInput | string | null
    exampleOutput?: NullableStringFieldUpdateOperationsInput | string | null
    freeAlternative?: NullableStringFieldUpdateOperationsInput | string | null
    lowTechOption?: NullableStringFieldUpdateOperationsInput | string | null
    commonMistakesForStep?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActionStepTranslationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionStepId?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    smeAction?: NullableStringFieldUpdateOperationsInput | string | null
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null
    whyThisStepMatters?: NullableStringFieldUpdateOperationsInput | string | null
    howToKnowItsDone?: NullableStringFieldUpdateOperationsInput | string | null
    whatHappensIfSkipped?: NullableStringFieldUpdateOperationsInput | string | null
    exampleOutput?: NullableStringFieldUpdateOperationsInput | string | null
    freeAlternative?: NullableStringFieldUpdateOperationsInput | string | null
    lowTechOption?: NullableStringFieldUpdateOperationsInput | string | null
    commonMistakesForStep?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HazardTranslationCreateInput = {
    id?: string
    locale: string
    name: string
    description?: string | null
    impact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    hazard: AdminHazardTypeCreateNestedOneWithoutTranslationsInput
  }

  export type HazardTranslationUncheckedCreateInput = {
    id?: string
    hazardId: string
    locale: string
    name: string
    description?: string | null
    impact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HazardTranslationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    impact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hazard?: AdminHazardTypeUpdateOneRequiredWithoutTranslationsNestedInput
  }

  export type HazardTranslationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hazardId?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    impact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HazardTranslationCreateManyInput = {
    id?: string
    hazardId: string
    locale: string
    name: string
    description?: string | null
    impact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HazardTranslationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    impact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HazardTranslationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    hazardId?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    impact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RiskMultiplierTranslationCreateInput = {
    id?: string
    locale: string
    name: string
    description?: string | null
    reasoning?: string | null
    wizardQuestion?: string | null
    wizardHelpText?: string | null
    wizardAnswerOptions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    riskMultiplier: RiskMultiplierCreateNestedOneWithoutTranslationsInput
  }

  export type RiskMultiplierTranslationUncheckedCreateInput = {
    id?: string
    riskMultiplierId: string
    locale: string
    name: string
    description?: string | null
    reasoning?: string | null
    wizardQuestion?: string | null
    wizardHelpText?: string | null
    wizardAnswerOptions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RiskMultiplierTranslationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    wizardQuestion?: NullableStringFieldUpdateOperationsInput | string | null
    wizardHelpText?: NullableStringFieldUpdateOperationsInput | string | null
    wizardAnswerOptions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    riskMultiplier?: RiskMultiplierUpdateOneRequiredWithoutTranslationsNestedInput
  }

  export type RiskMultiplierTranslationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    riskMultiplierId?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    wizardQuestion?: NullableStringFieldUpdateOperationsInput | string | null
    wizardHelpText?: NullableStringFieldUpdateOperationsInput | string | null
    wizardAnswerOptions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RiskMultiplierTranslationCreateManyInput = {
    id?: string
    riskMultiplierId: string
    locale: string
    name: string
    description?: string | null
    reasoning?: string | null
    wizardQuestion?: string | null
    wizardHelpText?: string | null
    wizardAnswerOptions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RiskMultiplierTranslationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    wizardQuestion?: NullableStringFieldUpdateOperationsInput | string | null
    wizardHelpText?: NullableStringFieldUpdateOperationsInput | string | null
    wizardAnswerOptions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RiskMultiplierTranslationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    riskMultiplierId?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    wizardQuestion?: NullableStringFieldUpdateOperationsInput | string | null
    wizardHelpText?: NullableStringFieldUpdateOperationsInput | string | null
    wizardAnswerOptions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type PlanInformationNullableRelationFilter = {
    is?: PlanInformationWhereInput | null
    isNot?: PlanInformationWhereInput | null
  }

  export type BusinessOverviewNullableRelationFilter = {
    is?: BusinessOverviewWhereInput | null
    isNot?: BusinessOverviewWhereInput | null
  }

  export type EssentialFunctionNullableRelationFilter = {
    is?: EssentialFunctionWhereInput | null
    isNot?: EssentialFunctionWhereInput | null
  }

  export type RiskAssessmentNullableRelationFilter = {
    is?: RiskAssessmentWhereInput | null
    isNot?: RiskAssessmentWhereInput | null
  }

  export type StrategyNullableRelationFilter = {
    is?: StrategyWhereInput | null
    isNot?: StrategyWhereInput | null
  }

  export type ActionPlanNullableRelationFilter = {
    is?: ActionPlanWhereInput | null
    isNot?: ActionPlanWhereInput | null
  }

  export type ContactsInformationNullableRelationFilter = {
    is?: ContactsInformationWhereInput | null
    isNot?: ContactsInformationWhereInput | null
  }

  export type TestingMaintenanceNullableRelationFilter = {
    is?: TestingMaintenanceWhereInput | null
    isNot?: TestingMaintenanceWhereInput | null
  }

  export type BusinessContinuityPlanCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BusinessContinuityPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BusinessContinuityPlanMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BusinessContinuityPlanRelationFilter = {
    is?: BusinessContinuityPlanWhereInput
    isNot?: BusinessContinuityPlanWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type PlanInformationCountOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    companyName?: SortOrder
    planManager?: SortOrder
    alternateManager?: SortOrder
    physicalPlanLocation?: SortOrder
    digitalPlanLocation?: SortOrder
  }

  export type PlanInformationMaxOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    companyName?: SortOrder
    planManager?: SortOrder
    alternateManager?: SortOrder
    physicalPlanLocation?: SortOrder
    digitalPlanLocation?: SortOrder
  }

  export type PlanInformationMinOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    companyName?: SortOrder
    planManager?: SortOrder
    alternateManager?: SortOrder
    physicalPlanLocation?: SortOrder
    digitalPlanLocation?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BusinessOverviewCountOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    businessLicenseNumber?: SortOrder
    businessPurpose?: SortOrder
    productsAndServices?: SortOrder
    serviceDeliveryMethods?: SortOrder
    operatingHours?: SortOrder
    keyPersonnel?: SortOrder
    minimumResources?: SortOrder
    customerBase?: SortOrder
    serviceProviderBCP?: SortOrder
  }

  export type BusinessOverviewMaxOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    businessLicenseNumber?: SortOrder
    businessPurpose?: SortOrder
    productsAndServices?: SortOrder
    serviceDeliveryMethods?: SortOrder
    operatingHours?: SortOrder
    keyPersonnel?: SortOrder
    minimumResources?: SortOrder
    customerBase?: SortOrder
    serviceProviderBCP?: SortOrder
  }

  export type BusinessOverviewMinOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    businessLicenseNumber?: SortOrder
    businessPurpose?: SortOrder
    productsAndServices?: SortOrder
    serviceDeliveryMethods?: SortOrder
    operatingHours?: SortOrder
    keyPersonnel?: SortOrder
    minimumResources?: SortOrder
    customerBase?: SortOrder
    serviceProviderBCP?: SortOrder
  }

  export type EssentialFunctionCountOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    supplyChainManagement?: SortOrder
    staffManagement?: SortOrder
    technology?: SortOrder
    productsServices?: SortOrder
    infrastructureFacilities?: SortOrder
    sales?: SortOrder
    administration?: SortOrder
  }

  export type EssentialFunctionMaxOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    supplyChainManagement?: SortOrder
    staffManagement?: SortOrder
    technology?: SortOrder
    productsServices?: SortOrder
    infrastructureFacilities?: SortOrder
    sales?: SortOrder
    administration?: SortOrder
  }

  export type EssentialFunctionMinOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    supplyChainManagement?: SortOrder
    staffManagement?: SortOrder
    technology?: SortOrder
    productsServices?: SortOrder
    infrastructureFacilities?: SortOrder
    sales?: SortOrder
    administration?: SortOrder
  }

  export type RiskAssessmentCountOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    potentialHazards?: SortOrder
    hazards?: SortOrder
  }

  export type RiskAssessmentMaxOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    potentialHazards?: SortOrder
    hazards?: SortOrder
  }

  export type RiskAssessmentMinOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    potentialHazards?: SortOrder
    hazards?: SortOrder
  }

  export type StrategyCountOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    preventionStrategies?: SortOrder
    responseStrategies?: SortOrder
    recoveryStrategies?: SortOrder
    longTermRiskReduction?: SortOrder
  }

  export type StrategyMaxOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    preventionStrategies?: SortOrder
    responseStrategies?: SortOrder
    recoveryStrategies?: SortOrder
    longTermRiskReduction?: SortOrder
  }

  export type StrategyMinOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    preventionStrategies?: SortOrder
    responseStrategies?: SortOrder
    recoveryStrategies?: SortOrder
    longTermRiskReduction?: SortOrder
  }

  export type ActionPlanCountOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    actionPlanByRisk?: SortOrder
    implementationTimeline?: SortOrder
    resourceRequirements?: SortOrder
    responsibleParties?: SortOrder
    reviewUpdateSchedule?: SortOrder
    testingAssessmentPlan?: SortOrder
  }

  export type ActionPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    actionPlanByRisk?: SortOrder
    implementationTimeline?: SortOrder
    resourceRequirements?: SortOrder
    responsibleParties?: SortOrder
    reviewUpdateSchedule?: SortOrder
    testingAssessmentPlan?: SortOrder
  }

  export type ActionPlanMinOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    actionPlanByRisk?: SortOrder
    implementationTimeline?: SortOrder
    resourceRequirements?: SortOrder
    responsibleParties?: SortOrder
    reviewUpdateSchedule?: SortOrder
    testingAssessmentPlan?: SortOrder
  }

  export type BusinessProfileNullableRelationFilter = {
    is?: BusinessProfileWhereInput | null
    isNot?: BusinessProfileWhereInput | null
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currentStep?: SortOrder
    stepData?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currentStep?: SortOrder
    stepData?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currentStep?: SortOrder
    stepData?: SortOrder
  }

  export type SessionRelationFilter = {
    is?: SessionWhereInput
    isNot?: SessionWhereInput
  }

  export type BusinessProfileCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    name?: SortOrder
    industry?: SortOrder
    size?: SortOrder
    location?: SortOrder
  }

  export type BusinessProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    name?: SortOrder
    industry?: SortOrder
    size?: SortOrder
    location?: SortOrder
  }

  export type BusinessProfileMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    name?: SortOrder
    industry?: SortOrder
    size?: SortOrder
    location?: SortOrder
  }

  export type ContactsInformationCountOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    staffContactInfo?: SortOrder
    keyCustomerContacts?: SortOrder
    supplierInformation?: SortOrder
    emergencyServicesUtilities?: SortOrder
    criticalBusinessInfo?: SortOrder
    planDistributionList?: SortOrder
  }

  export type ContactsInformationMaxOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    staffContactInfo?: SortOrder
    keyCustomerContacts?: SortOrder
    supplierInformation?: SortOrder
    emergencyServicesUtilities?: SortOrder
    criticalBusinessInfo?: SortOrder
    planDistributionList?: SortOrder
  }

  export type ContactsInformationMinOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    staffContactInfo?: SortOrder
    keyCustomerContacts?: SortOrder
    supplierInformation?: SortOrder
    emergencyServicesUtilities?: SortOrder
    criticalBusinessInfo?: SortOrder
    planDistributionList?: SortOrder
  }

  export type TestingMaintenanceCountOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    planTestingSchedule?: SortOrder
    planRevisionHistory?: SortOrder
    improvementTracking?: SortOrder
    annualReviewProcess?: SortOrder
    triggerEventsForUpdates?: SortOrder
  }

  export type TestingMaintenanceMaxOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    planTestingSchedule?: SortOrder
    planRevisionHistory?: SortOrder
    improvementTracking?: SortOrder
    annualReviewProcess?: SortOrder
    triggerEventsForUpdates?: SortOrder
  }

  export type TestingMaintenanceMinOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    planTestingSchedule?: SortOrder
    planRevisionHistory?: SortOrder
    improvementTracking?: SortOrder
    annualReviewProcess?: SortOrder
    triggerEventsForUpdates?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type AnonymousSessionBusinessNamePinCompoundUniqueInput = {
    businessName: string
    pin: string
  }

  export type AnonymousSessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    businessName?: SortOrder
    displayBusinessName?: SortOrder
    pin?: SortOrder
    email?: SortOrder
    planData?: SortOrder
    shareableId?: SortOrder
    allowSharing?: SortOrder
    createdAt?: SortOrder
    lastAccessed?: SortOrder
  }

  export type AnonymousSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    businessName?: SortOrder
    displayBusinessName?: SortOrder
    pin?: SortOrder
    email?: SortOrder
    planData?: SortOrder
    shareableId?: SortOrder
    allowSharing?: SortOrder
    createdAt?: SortOrder
    lastAccessed?: SortOrder
  }

  export type AnonymousSessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    businessName?: SortOrder
    displayBusinessName?: SortOrder
    pin?: SortOrder
    email?: SortOrder
    planData?: SortOrder
    shareableId?: SortOrder
    allowSharing?: SortOrder
    createdAt?: SortOrder
    lastAccessed?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type AdminBusinessTypeHazardListRelationFilter = {
    every?: AdminBusinessTypeHazardWhereInput
    some?: AdminBusinessTypeHazardWhereInput
    none?: AdminBusinessTypeHazardWhereInput
  }

  export type AdminRiskProfileListRelationFilter = {
    every?: AdminRiskProfileWhereInput
    some?: AdminRiskProfileWhereInput
    none?: AdminRiskProfileWhereInput
  }

  export type AdminBusinessTypeHazardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminRiskProfileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminBusinessTypeCountOrderByAggregateInput = {
    id?: SortOrder
    businessTypeId?: SortOrder
    name?: SortOrder
    localName?: SortOrder
    category?: SortOrder
    description?: SortOrder
    typicalOperatingHours?: SortOrder
    minimumStaff?: SortOrder
    minimumEquipment?: SortOrder
    minimumUtilities?: SortOrder
    minimumSpace?: SortOrder
    essentialFunctions?: SortOrder
    criticalSuppliers?: SortOrder
    exampleBusinessPurposes?: SortOrder
    exampleProducts?: SortOrder
    exampleKeyPersonnel?: SortOrder
    exampleCustomerBase?: SortOrder
    dependencies?: SortOrder
    vulnerabilityMatrix?: SortOrder
    operationalThresholds?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminBusinessTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    businessTypeId?: SortOrder
    name?: SortOrder
    localName?: SortOrder
    category?: SortOrder
    description?: SortOrder
    typicalOperatingHours?: SortOrder
    minimumStaff?: SortOrder
    minimumEquipment?: SortOrder
    minimumUtilities?: SortOrder
    minimumSpace?: SortOrder
    essentialFunctions?: SortOrder
    criticalSuppliers?: SortOrder
    exampleBusinessPurposes?: SortOrder
    exampleProducts?: SortOrder
    exampleKeyPersonnel?: SortOrder
    exampleCustomerBase?: SortOrder
    dependencies?: SortOrder
    vulnerabilityMatrix?: SortOrder
    operationalThresholds?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminBusinessTypeMinOrderByAggregateInput = {
    id?: SortOrder
    businessTypeId?: SortOrder
    name?: SortOrder
    localName?: SortOrder
    category?: SortOrder
    description?: SortOrder
    typicalOperatingHours?: SortOrder
    minimumStaff?: SortOrder
    minimumEquipment?: SortOrder
    minimumUtilities?: SortOrder
    minimumSpace?: SortOrder
    essentialFunctions?: SortOrder
    criticalSuppliers?: SortOrder
    exampleBusinessPurposes?: SortOrder
    exampleProducts?: SortOrder
    exampleKeyPersonnel?: SortOrder
    exampleCustomerBase?: SortOrder
    dependencies?: SortOrder
    vulnerabilityMatrix?: SortOrder
    operationalThresholds?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminLocationHazardListRelationFilter = {
    every?: AdminLocationHazardWhereInput
    some?: AdminLocationHazardWhereInput
    none?: AdminLocationHazardWhereInput
  }

  export type AdminHazardStrategyListRelationFilter = {
    every?: AdminHazardStrategyWhereInput
    some?: AdminHazardStrategyWhereInput
    none?: AdminHazardStrategyWhereInput
  }

  export type AdminHazardActionPlanListRelationFilter = {
    every?: AdminHazardActionPlanWhereInput
    some?: AdminHazardActionPlanWhereInput
    none?: AdminHazardActionPlanWhereInput
  }

  export type AdminActionPlanNullableRelationFilter = {
    is?: AdminActionPlanWhereInput | null
    isNot?: AdminActionPlanWhereInput | null
  }

  export type HazardTranslationListRelationFilter = {
    every?: HazardTranslationWhereInput
    some?: HazardTranslationWhereInput
    none?: HazardTranslationWhereInput
  }

  export type AdminLocationHazardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminHazardStrategyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminHazardActionPlanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HazardTranslationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminHazardTypeCountOrderByAggregateInput = {
    id?: SortOrder
    hazardId?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrder
    defaultFrequency?: SortOrder
    defaultImpact?: SortOrder
    seasonalPattern?: SortOrder
    peakMonths?: SortOrder
    warningTime?: SortOrder
    geographicScope?: SortOrder
    cascadingRisks?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminHazardTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    hazardId?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrder
    defaultFrequency?: SortOrder
    defaultImpact?: SortOrder
    seasonalPattern?: SortOrder
    peakMonths?: SortOrder
    warningTime?: SortOrder
    geographicScope?: SortOrder
    cascadingRisks?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminHazardTypeMinOrderByAggregateInput = {
    id?: SortOrder
    hazardId?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrder
    defaultFrequency?: SortOrder
    defaultImpact?: SortOrder
    seasonalPattern?: SortOrder
    peakMonths?: SortOrder
    warningTime?: SortOrder
    geographicScope?: SortOrder
    cascadingRisks?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminLocationCountryCodeParishCompoundUniqueInput = {
    countryCode: string
    parish: string
  }

  export type AdminLocationCountOrderByAggregateInput = {
    id?: SortOrder
    country?: SortOrder
    countryCode?: SortOrder
    parish?: SortOrder
    isCoastal?: SortOrder
    isUrban?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminLocationMaxOrderByAggregateInput = {
    id?: SortOrder
    country?: SortOrder
    countryCode?: SortOrder
    parish?: SortOrder
    isCoastal?: SortOrder
    isUrban?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminLocationMinOrderByAggregateInput = {
    id?: SortOrder
    country?: SortOrder
    countryCode?: SortOrder
    parish?: SortOrder
    isCoastal?: SortOrder
    isUrban?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminBusinessTypeRelationFilter = {
    is?: AdminBusinessTypeWhereInput
    isNot?: AdminBusinessTypeWhereInput
  }

  export type AdminHazardTypeRelationFilter = {
    is?: AdminHazardTypeWhereInput
    isNot?: AdminHazardTypeWhereInput
  }

  export type AdminBusinessTypeHazardBusinessTypeIdHazardIdCompoundUniqueInput = {
    businessTypeId: string
    hazardId: string
  }

  export type AdminBusinessTypeHazardCountOrderByAggregateInput = {
    id?: SortOrder
    businessTypeId?: SortOrder
    hazardId?: SortOrder
    riskLevel?: SortOrder
    frequency?: SortOrder
    impact?: SortOrder
    notes?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminBusinessTypeHazardMaxOrderByAggregateInput = {
    id?: SortOrder
    businessTypeId?: SortOrder
    hazardId?: SortOrder
    riskLevel?: SortOrder
    frequency?: SortOrder
    impact?: SortOrder
    notes?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminBusinessTypeHazardMinOrderByAggregateInput = {
    id?: SortOrder
    businessTypeId?: SortOrder
    hazardId?: SortOrder
    riskLevel?: SortOrder
    frequency?: SortOrder
    impact?: SortOrder
    notes?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminLocationRelationFilter = {
    is?: AdminLocationWhereInput
    isNot?: AdminLocationWhereInput
  }

  export type AdminLocationHazardLocationIdHazardIdCompoundUniqueInput = {
    locationId: string
    hazardId: string
  }

  export type AdminLocationHazardCountOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    hazardId?: SortOrder
    riskLevel?: SortOrder
    frequency?: SortOrder
    impact?: SortOrder
    notes?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminLocationHazardMaxOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    hazardId?: SortOrder
    riskLevel?: SortOrder
    frequency?: SortOrder
    impact?: SortOrder
    notes?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminLocationHazardMinOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    hazardId?: SortOrder
    riskLevel?: SortOrder
    frequency?: SortOrder
    impact?: SortOrder
    notes?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminStrategyCountOrderByAggregateInput = {
    id?: SortOrder
    strategyId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    reasoning?: SortOrder
    icon?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminStrategyMaxOrderByAggregateInput = {
    id?: SortOrder
    strategyId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    reasoning?: SortOrder
    icon?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminStrategyMinOrderByAggregateInput = {
    id?: SortOrder
    strategyId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    reasoning?: SortOrder
    icon?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminStrategyRelationFilter = {
    is?: AdminStrategyWhereInput
    isNot?: AdminStrategyWhereInput
  }

  export type AdminHazardStrategyHazardIdStrategyIdCompoundUniqueInput = {
    hazardId: string
    strategyId: string
  }

  export type AdminHazardStrategyCountOrderByAggregateInput = {
    id?: SortOrder
    hazardId?: SortOrder
    strategyId?: SortOrder
    businessTypes?: SortOrder
    priority?: SortOrder
    isRecommended?: SortOrder
    notes?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminHazardStrategyMaxOrderByAggregateInput = {
    id?: SortOrder
    hazardId?: SortOrder
    strategyId?: SortOrder
    businessTypes?: SortOrder
    priority?: SortOrder
    isRecommended?: SortOrder
    notes?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminHazardStrategyMinOrderByAggregateInput = {
    id?: SortOrder
    hazardId?: SortOrder
    strategyId?: SortOrder
    businessTypes?: SortOrder
    priority?: SortOrder
    isRecommended?: SortOrder
    notes?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminActionPlanCountOrderByAggregateInput = {
    id?: SortOrder
    hazardId?: SortOrder
    resourcesNeeded?: SortOrder
    immediateActions?: SortOrder
    shortTermActions?: SortOrder
    mediumTermActions?: SortOrder
    longTermReduction?: SortOrder
    businessTypeModifiers?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminActionPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    hazardId?: SortOrder
    resourcesNeeded?: SortOrder
    immediateActions?: SortOrder
    shortTermActions?: SortOrder
    mediumTermActions?: SortOrder
    longTermReduction?: SortOrder
    businessTypeModifiers?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminActionPlanMinOrderByAggregateInput = {
    id?: SortOrder
    hazardId?: SortOrder
    resourcesNeeded?: SortOrder
    immediateActions?: SortOrder
    shortTermActions?: SortOrder
    mediumTermActions?: SortOrder
    longTermReduction?: SortOrder
    businessTypeModifiers?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminActionPlanRelationFilter = {
    is?: AdminActionPlanWhereInput
    isNot?: AdminActionPlanWhereInput
  }

  export type AdminHazardActionPlanHazardIdActionPlanIdCompoundUniqueInput = {
    hazardId: string
    actionPlanId: string
  }

  export type AdminHazardActionPlanCountOrderByAggregateInput = {
    id?: SortOrder
    hazardId?: SortOrder
    actionPlanId?: SortOrder
    businessTypes?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminHazardActionPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    hazardId?: SortOrder
    actionPlanId?: SortOrder
    businessTypes?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminHazardActionPlanMinOrderByAggregateInput = {
    id?: SortOrder
    hazardId?: SortOrder
    actionPlanId?: SortOrder
    businessTypes?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type AdminRiskProfileBusinessTypeIdLocationIdCompoundUniqueInput = {
    businessTypeId: string
    locationId: string
  }

  export type AdminRiskProfileCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    businessTypeId?: SortOrder
    locationId?: SortOrder
    calculatedRisks?: SortOrder
    recommendedStrategies?: SortOrder
    lastCalculated?: SortOrder
    riskScore?: SortOrder
  }

  export type AdminRiskProfileAvgOrderByAggregateInput = {
    riskScore?: SortOrder
  }

  export type AdminRiskProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    businessTypeId?: SortOrder
    locationId?: SortOrder
    calculatedRisks?: SortOrder
    recommendedStrategies?: SortOrder
    lastCalculated?: SortOrder
    riskScore?: SortOrder
  }

  export type AdminRiskProfileMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    businessTypeId?: SortOrder
    locationId?: SortOrder
    calculatedRisks?: SortOrder
    recommendedStrategies?: SortOrder
    lastCalculated?: SortOrder
    riskScore?: SortOrder
  }

  export type AdminRiskProfileSumOrderByAggregateInput = {
    riskScore?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type AdminUnitListRelationFilter = {
    every?: AdminUnitWhereInput
    some?: AdminUnitWhereInput
    none?: AdminUnitWhereInput
  }

  export type AdminUnitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CountryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    region?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CountryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    region?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CountryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    region?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type CountryRelationFilter = {
    is?: CountryWhereInput
    isNot?: CountryWhereInput
  }

  export type AdminUnitRiskNullableRelationFilter = {
    is?: AdminUnitRiskWhereInput | null
    isNot?: AdminUnitRiskWhereInput | null
  }

  export type AdminUnitCountryIdNameCompoundUniqueInput = {
    countryId: string
    name: string
  }

  export type AdminUnitCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    localName?: SortOrder
    type?: SortOrder
    region?: SortOrder
    countryId?: SortOrder
    population?: SortOrder
    area?: SortOrder
    elevation?: SortOrder
    coordinates?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
  }

  export type AdminUnitAvgOrderByAggregateInput = {
    population?: SortOrder
    area?: SortOrder
    elevation?: SortOrder
  }

  export type AdminUnitMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    localName?: SortOrder
    type?: SortOrder
    region?: SortOrder
    countryId?: SortOrder
    population?: SortOrder
    area?: SortOrder
    elevation?: SortOrder
    coordinates?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
  }

  export type AdminUnitMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    localName?: SortOrder
    type?: SortOrder
    region?: SortOrder
    countryId?: SortOrder
    population?: SortOrder
    area?: SortOrder
    elevation?: SortOrder
    coordinates?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
  }

  export type AdminUnitSumOrderByAggregateInput = {
    population?: SortOrder
    area?: SortOrder
    elevation?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type ParishRiskNullableRelationFilter = {
    is?: ParishRiskWhereInput | null
    isNot?: ParishRiskWhereInput | null
  }

  export type BusinessRiskProfileListRelationFilter = {
    every?: BusinessRiskProfileWhereInput
    some?: BusinessRiskProfileWhereInput
    none?: BusinessRiskProfileWhereInput
  }

  export type BusinessRiskProfileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ParishCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    region?: SortOrder
    countryCode?: SortOrder
    population?: SortOrder
    area?: SortOrder
    elevation?: SortOrder
    coordinates?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
  }

  export type ParishAvgOrderByAggregateInput = {
    population?: SortOrder
    area?: SortOrder
    elevation?: SortOrder
  }

  export type ParishMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    region?: SortOrder
    countryCode?: SortOrder
    population?: SortOrder
    area?: SortOrder
    elevation?: SortOrder
    coordinates?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
  }

  export type ParishMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    region?: SortOrder
    countryCode?: SortOrder
    population?: SortOrder
    area?: SortOrder
    elevation?: SortOrder
    coordinates?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
  }

  export type ParishSumOrderByAggregateInput = {
    population?: SortOrder
    area?: SortOrder
    elevation?: SortOrder
  }

  export type AdminUnitRelationFilter = {
    is?: AdminUnitWhereInput
    isNot?: AdminUnitWhereInput
  }

  export type AdminUnitRiskChangeLogListRelationFilter = {
    every?: AdminUnitRiskChangeLogWhereInput
    some?: AdminUnitRiskChangeLogWhereInput
    none?: AdminUnitRiskChangeLogWhereInput
  }

  export type AdminUnitRiskChangeLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminUnitRiskCountOrderByAggregateInput = {
    id?: SortOrder
    adminUnitId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastUpdated?: SortOrder
    updatedBy?: SortOrder
    hurricaneLevel?: SortOrder
    hurricaneNotes?: SortOrder
    floodLevel?: SortOrder
    floodNotes?: SortOrder
    earthquakeLevel?: SortOrder
    earthquakeNotes?: SortOrder
    droughtLevel?: SortOrder
    droughtNotes?: SortOrder
    landslideLevel?: SortOrder
    landslideNotes?: SortOrder
    powerOutageLevel?: SortOrder
    powerOutageNotes?: SortOrder
    riskProfileJson?: SortOrder
    isActive?: SortOrder
  }

  export type AdminUnitRiskAvgOrderByAggregateInput = {
    hurricaneLevel?: SortOrder
    floodLevel?: SortOrder
    earthquakeLevel?: SortOrder
    droughtLevel?: SortOrder
    landslideLevel?: SortOrder
    powerOutageLevel?: SortOrder
  }

  export type AdminUnitRiskMaxOrderByAggregateInput = {
    id?: SortOrder
    adminUnitId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastUpdated?: SortOrder
    updatedBy?: SortOrder
    hurricaneLevel?: SortOrder
    hurricaneNotes?: SortOrder
    floodLevel?: SortOrder
    floodNotes?: SortOrder
    earthquakeLevel?: SortOrder
    earthquakeNotes?: SortOrder
    droughtLevel?: SortOrder
    droughtNotes?: SortOrder
    landslideLevel?: SortOrder
    landslideNotes?: SortOrder
    powerOutageLevel?: SortOrder
    powerOutageNotes?: SortOrder
    riskProfileJson?: SortOrder
    isActive?: SortOrder
  }

  export type AdminUnitRiskMinOrderByAggregateInput = {
    id?: SortOrder
    adminUnitId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastUpdated?: SortOrder
    updatedBy?: SortOrder
    hurricaneLevel?: SortOrder
    hurricaneNotes?: SortOrder
    floodLevel?: SortOrder
    floodNotes?: SortOrder
    earthquakeLevel?: SortOrder
    earthquakeNotes?: SortOrder
    droughtLevel?: SortOrder
    droughtNotes?: SortOrder
    landslideLevel?: SortOrder
    landslideNotes?: SortOrder
    powerOutageLevel?: SortOrder
    powerOutageNotes?: SortOrder
    riskProfileJson?: SortOrder
    isActive?: SortOrder
  }

  export type AdminUnitRiskSumOrderByAggregateInput = {
    hurricaneLevel?: SortOrder
    floodLevel?: SortOrder
    earthquakeLevel?: SortOrder
    droughtLevel?: SortOrder
    landslideLevel?: SortOrder
    powerOutageLevel?: SortOrder
  }

  export type AdminUnitRiskRelationFilter = {
    is?: AdminUnitRiskWhereInput
    isNot?: AdminUnitRiskWhereInput
  }

  export type AdminUnitRiskChangeLogCountOrderByAggregateInput = {
    id?: SortOrder
    adminUnitRiskId?: SortOrder
    riskType?: SortOrder
    oldLevel?: SortOrder
    newLevel?: SortOrder
    oldNotes?: SortOrder
    newNotes?: SortOrder
    changedBy?: SortOrder
    changeReason?: SortOrder
    createdAt?: SortOrder
  }

  export type AdminUnitRiskChangeLogAvgOrderByAggregateInput = {
    oldLevel?: SortOrder
    newLevel?: SortOrder
  }

  export type AdminUnitRiskChangeLogMaxOrderByAggregateInput = {
    id?: SortOrder
    adminUnitRiskId?: SortOrder
    riskType?: SortOrder
    oldLevel?: SortOrder
    newLevel?: SortOrder
    oldNotes?: SortOrder
    newNotes?: SortOrder
    changedBy?: SortOrder
    changeReason?: SortOrder
    createdAt?: SortOrder
  }

  export type AdminUnitRiskChangeLogMinOrderByAggregateInput = {
    id?: SortOrder
    adminUnitRiskId?: SortOrder
    riskType?: SortOrder
    oldLevel?: SortOrder
    newLevel?: SortOrder
    oldNotes?: SortOrder
    newNotes?: SortOrder
    changedBy?: SortOrder
    changeReason?: SortOrder
    createdAt?: SortOrder
  }

  export type AdminUnitRiskChangeLogSumOrderByAggregateInput = {
    oldLevel?: SortOrder
    newLevel?: SortOrder
  }

  export type ParishRelationFilter = {
    is?: ParishWhereInput
    isNot?: ParishWhereInput
  }

  export type RiskChangeLogListRelationFilter = {
    every?: RiskChangeLogWhereInput
    some?: RiskChangeLogWhereInput
    none?: RiskChangeLogWhereInput
  }

  export type RiskChangeLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ParishRiskCountOrderByAggregateInput = {
    id?: SortOrder
    parishId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastUpdated?: SortOrder
    updatedBy?: SortOrder
    hurricaneLevel?: SortOrder
    hurricaneNotes?: SortOrder
    floodLevel?: SortOrder
    floodNotes?: SortOrder
    earthquakeLevel?: SortOrder
    earthquakeNotes?: SortOrder
    droughtLevel?: SortOrder
    droughtNotes?: SortOrder
    landslideLevel?: SortOrder
    landslideNotes?: SortOrder
    powerOutageLevel?: SortOrder
    powerOutageNotes?: SortOrder
    riskProfileJson?: SortOrder
    isActive?: SortOrder
  }

  export type ParishRiskAvgOrderByAggregateInput = {
    hurricaneLevel?: SortOrder
    floodLevel?: SortOrder
    earthquakeLevel?: SortOrder
    droughtLevel?: SortOrder
    landslideLevel?: SortOrder
    powerOutageLevel?: SortOrder
  }

  export type ParishRiskMaxOrderByAggregateInput = {
    id?: SortOrder
    parishId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastUpdated?: SortOrder
    updatedBy?: SortOrder
    hurricaneLevel?: SortOrder
    hurricaneNotes?: SortOrder
    floodLevel?: SortOrder
    floodNotes?: SortOrder
    earthquakeLevel?: SortOrder
    earthquakeNotes?: SortOrder
    droughtLevel?: SortOrder
    droughtNotes?: SortOrder
    landslideLevel?: SortOrder
    landslideNotes?: SortOrder
    powerOutageLevel?: SortOrder
    powerOutageNotes?: SortOrder
    riskProfileJson?: SortOrder
    isActive?: SortOrder
  }

  export type ParishRiskMinOrderByAggregateInput = {
    id?: SortOrder
    parishId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastUpdated?: SortOrder
    updatedBy?: SortOrder
    hurricaneLevel?: SortOrder
    hurricaneNotes?: SortOrder
    floodLevel?: SortOrder
    floodNotes?: SortOrder
    earthquakeLevel?: SortOrder
    earthquakeNotes?: SortOrder
    droughtLevel?: SortOrder
    droughtNotes?: SortOrder
    landslideLevel?: SortOrder
    landslideNotes?: SortOrder
    powerOutageLevel?: SortOrder
    powerOutageNotes?: SortOrder
    riskProfileJson?: SortOrder
    isActive?: SortOrder
  }

  export type ParishRiskSumOrderByAggregateInput = {
    hurricaneLevel?: SortOrder
    floodLevel?: SortOrder
    earthquakeLevel?: SortOrder
    droughtLevel?: SortOrder
    landslideLevel?: SortOrder
    powerOutageLevel?: SortOrder
  }

  export type ParishRiskRelationFilter = {
    is?: ParishRiskWhereInput
    isNot?: ParishRiskWhereInput
  }

  export type RiskChangeLogCountOrderByAggregateInput = {
    id?: SortOrder
    parishRiskId?: SortOrder
    riskType?: SortOrder
    oldLevel?: SortOrder
    newLevel?: SortOrder
    oldNotes?: SortOrder
    newNotes?: SortOrder
    changedBy?: SortOrder
    changeReason?: SortOrder
    createdAt?: SortOrder
  }

  export type RiskChangeLogAvgOrderByAggregateInput = {
    oldLevel?: SortOrder
    newLevel?: SortOrder
  }

  export type RiskChangeLogMaxOrderByAggregateInput = {
    id?: SortOrder
    parishRiskId?: SortOrder
    riskType?: SortOrder
    oldLevel?: SortOrder
    newLevel?: SortOrder
    oldNotes?: SortOrder
    newNotes?: SortOrder
    changedBy?: SortOrder
    changeReason?: SortOrder
    createdAt?: SortOrder
  }

  export type RiskChangeLogMinOrderByAggregateInput = {
    id?: SortOrder
    parishRiskId?: SortOrder
    riskType?: SortOrder
    oldLevel?: SortOrder
    newLevel?: SortOrder
    oldNotes?: SortOrder
    newNotes?: SortOrder
    changedBy?: SortOrder
    changeReason?: SortOrder
    createdAt?: SortOrder
  }

  export type RiskChangeLogSumOrderByAggregateInput = {
    oldLevel?: SortOrder
    newLevel?: SortOrder
  }

  export type BusinessRiskVulnerabilityListRelationFilter = {
    every?: BusinessRiskVulnerabilityWhereInput
    some?: BusinessRiskVulnerabilityWhereInput
    none?: BusinessRiskVulnerabilityWhereInput
  }

  export type BusinessTypeStrategyListRelationFilter = {
    every?: BusinessTypeStrategyWhereInput
    some?: BusinessTypeStrategyWhereInput
    none?: BusinessTypeStrategyWhereInput
  }

  export type BusinessTypeTranslationListRelationFilter = {
    every?: BusinessTypeTranslationWhereInput
    some?: BusinessTypeTranslationWhereInput
    none?: BusinessTypeTranslationWhereInput
  }

  export type BusinessRiskVulnerabilityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BusinessTypeStrategyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BusinessTypeTranslationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BusinessTypeCountOrderByAggregateInput = {
    id?: SortOrder
    businessTypeId?: SortOrder
    name?: SortOrder
    category?: SortOrder
    subcategory?: SortOrder
    description?: SortOrder
    exampleBusinessPurposes?: SortOrder
    exampleProducts?: SortOrder
    exampleKeyPersonnel?: SortOrder
    exampleCustomerBase?: SortOrder
    minimumEquipment?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BusinessTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    businessTypeId?: SortOrder
    name?: SortOrder
    category?: SortOrder
    subcategory?: SortOrder
    description?: SortOrder
    exampleBusinessPurposes?: SortOrder
    exampleProducts?: SortOrder
    exampleKeyPersonnel?: SortOrder
    exampleCustomerBase?: SortOrder
    minimumEquipment?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BusinessTypeMinOrderByAggregateInput = {
    id?: SortOrder
    businessTypeId?: SortOrder
    name?: SortOrder
    category?: SortOrder
    subcategory?: SortOrder
    description?: SortOrder
    exampleBusinessPurposes?: SortOrder
    exampleProducts?: SortOrder
    exampleKeyPersonnel?: SortOrder
    exampleCustomerBase?: SortOrder
    minimumEquipment?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BusinessTypeRelationFilter = {
    is?: BusinessTypeWhereInput
    isNot?: BusinessTypeWhereInput
  }

  export type BusinessRiskVulnerabilityBusinessTypeIdRiskTypeCompoundUniqueInput = {
    businessTypeId: string
    riskType: string
  }

  export type BusinessRiskVulnerabilityCountOrderByAggregateInput = {
    id?: SortOrder
    businessTypeId?: SortOrder
    riskType?: SortOrder
    vulnerabilityLevel?: SortOrder
    impactSeverity?: SortOrder
    recoveryTime?: SortOrder
    reasoning?: SortOrder
    mitigationDifficulty?: SortOrder
    costToRecover?: SortOrder
    businessImpactAreas?: SortOrder
    criticalDependencies?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BusinessRiskVulnerabilityAvgOrderByAggregateInput = {
    vulnerabilityLevel?: SortOrder
    impactSeverity?: SortOrder
    mitigationDifficulty?: SortOrder
  }

  export type BusinessRiskVulnerabilityMaxOrderByAggregateInput = {
    id?: SortOrder
    businessTypeId?: SortOrder
    riskType?: SortOrder
    vulnerabilityLevel?: SortOrder
    impactSeverity?: SortOrder
    recoveryTime?: SortOrder
    reasoning?: SortOrder
    mitigationDifficulty?: SortOrder
    costToRecover?: SortOrder
    businessImpactAreas?: SortOrder
    criticalDependencies?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BusinessRiskVulnerabilityMinOrderByAggregateInput = {
    id?: SortOrder
    businessTypeId?: SortOrder
    riskType?: SortOrder
    vulnerabilityLevel?: SortOrder
    impactSeverity?: SortOrder
    recoveryTime?: SortOrder
    reasoning?: SortOrder
    mitigationDifficulty?: SortOrder
    costToRecover?: SortOrder
    businessImpactAreas?: SortOrder
    criticalDependencies?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BusinessRiskVulnerabilitySumOrderByAggregateInput = {
    vulnerabilityLevel?: SortOrder
    impactSeverity?: SortOrder
    mitigationDifficulty?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type ActionStepListRelationFilter = {
    every?: ActionStepWhereInput
    some?: ActionStepWhereInput
    none?: ActionStepWhereInput
  }

  export type StrategyItemCostListRelationFilter = {
    every?: StrategyItemCostWhereInput
    some?: StrategyItemCostWhereInput
    none?: StrategyItemCostWhereInput
  }

  export type StrategyTranslationListRelationFilter = {
    every?: StrategyTranslationWhereInput
    some?: StrategyTranslationWhereInput
    none?: StrategyTranslationWhereInput
  }

  export type ActionStepOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StrategyItemCostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StrategyTranslationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RiskMitigationStrategyCountOrderByAggregateInput = {
    id?: SortOrder
    strategyId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    smeTitle?: SortOrder
    smeSummary?: SortOrder
    smeDescription?: SortOrder
    whyImportant?: SortOrder
    benefitsBullets?: SortOrder
    realWorldExample?: SortOrder
    calculatedCostUSD?: SortOrder
    calculatedCostLocal?: SortOrder
    currencyCode?: SortOrder
    currencySymbol?: SortOrder
    totalEstimatedHours?: SortOrder
    selectionTier?: SortOrder
    requiredForRisks?: SortOrder
    helpfulTips?: SortOrder
    commonMistakes?: SortOrder
    successMetrics?: SortOrder
    lowBudgetAlternative?: SortOrder
    applicableRisks?: SortOrder
    applicableBusinessTypes?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RiskMitigationStrategyAvgOrderByAggregateInput = {
    calculatedCostUSD?: SortOrder
    calculatedCostLocal?: SortOrder
    totalEstimatedHours?: SortOrder
  }

  export type RiskMitigationStrategyMaxOrderByAggregateInput = {
    id?: SortOrder
    strategyId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    smeTitle?: SortOrder
    smeSummary?: SortOrder
    smeDescription?: SortOrder
    whyImportant?: SortOrder
    benefitsBullets?: SortOrder
    realWorldExample?: SortOrder
    calculatedCostUSD?: SortOrder
    calculatedCostLocal?: SortOrder
    currencyCode?: SortOrder
    currencySymbol?: SortOrder
    totalEstimatedHours?: SortOrder
    selectionTier?: SortOrder
    requiredForRisks?: SortOrder
    helpfulTips?: SortOrder
    commonMistakes?: SortOrder
    successMetrics?: SortOrder
    lowBudgetAlternative?: SortOrder
    applicableRisks?: SortOrder
    applicableBusinessTypes?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RiskMitigationStrategyMinOrderByAggregateInput = {
    id?: SortOrder
    strategyId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    smeTitle?: SortOrder
    smeSummary?: SortOrder
    smeDescription?: SortOrder
    whyImportant?: SortOrder
    benefitsBullets?: SortOrder
    realWorldExample?: SortOrder
    calculatedCostUSD?: SortOrder
    calculatedCostLocal?: SortOrder
    currencyCode?: SortOrder
    currencySymbol?: SortOrder
    totalEstimatedHours?: SortOrder
    selectionTier?: SortOrder
    requiredForRisks?: SortOrder
    helpfulTips?: SortOrder
    commonMistakes?: SortOrder
    successMetrics?: SortOrder
    lowBudgetAlternative?: SortOrder
    applicableRisks?: SortOrder
    applicableBusinessTypes?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RiskMitigationStrategySumOrderByAggregateInput = {
    calculatedCostUSD?: SortOrder
    calculatedCostLocal?: SortOrder
    totalEstimatedHours?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type RiskMitigationStrategyRelationFilter = {
    is?: RiskMitigationStrategyWhereInput
    isNot?: RiskMitigationStrategyWhereInput
  }

  export type ActionStepItemCostListRelationFilter = {
    every?: ActionStepItemCostWhereInput
    some?: ActionStepItemCostWhereInput
    none?: ActionStepItemCostWhereInput
  }

  export type ActionStepTranslationListRelationFilter = {
    every?: ActionStepTranslationWhereInput
    some?: ActionStepTranslationWhereInput
    none?: ActionStepTranslationWhereInput
  }

  export type ActionStepItemCostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActionStepTranslationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActionStepStrategyIdStepIdCompoundUniqueInput = {
    strategyId: string
    stepId: string
  }

  export type ActionStepCountOrderByAggregateInput = {
    id?: SortOrder
    strategyId?: SortOrder
    stepId?: SortOrder
    phase?: SortOrder
    title?: SortOrder
    description?: SortOrder
    smeAction?: SortOrder
    whyThisStepMatters?: SortOrder
    whatHappensIfSkipped?: SortOrder
    timeframe?: SortOrder
    estimatedMinutes?: SortOrder
    difficultyLevel?: SortOrder
    responsibility?: SortOrder
    estimatedCost?: SortOrder
    estimatedCostJMD?: SortOrder
    resources?: SortOrder
    checklist?: SortOrder
    howToKnowItsDone?: SortOrder
    exampleOutput?: SortOrder
    dependsOnSteps?: SortOrder
    isOptional?: SortOrder
    skipConditions?: SortOrder
    freeAlternative?: SortOrder
    lowTechOption?: SortOrder
    commonMistakesForStep?: SortOrder
    videoTutorialUrl?: SortOrder
    externalResourceUrl?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ActionStepAvgOrderByAggregateInput = {
    estimatedMinutes?: SortOrder
    sortOrder?: SortOrder
  }

  export type ActionStepMaxOrderByAggregateInput = {
    id?: SortOrder
    strategyId?: SortOrder
    stepId?: SortOrder
    phase?: SortOrder
    title?: SortOrder
    description?: SortOrder
    smeAction?: SortOrder
    whyThisStepMatters?: SortOrder
    whatHappensIfSkipped?: SortOrder
    timeframe?: SortOrder
    estimatedMinutes?: SortOrder
    difficultyLevel?: SortOrder
    responsibility?: SortOrder
    estimatedCost?: SortOrder
    estimatedCostJMD?: SortOrder
    resources?: SortOrder
    checklist?: SortOrder
    howToKnowItsDone?: SortOrder
    exampleOutput?: SortOrder
    dependsOnSteps?: SortOrder
    isOptional?: SortOrder
    skipConditions?: SortOrder
    freeAlternative?: SortOrder
    lowTechOption?: SortOrder
    commonMistakesForStep?: SortOrder
    videoTutorialUrl?: SortOrder
    externalResourceUrl?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ActionStepMinOrderByAggregateInput = {
    id?: SortOrder
    strategyId?: SortOrder
    stepId?: SortOrder
    phase?: SortOrder
    title?: SortOrder
    description?: SortOrder
    smeAction?: SortOrder
    whyThisStepMatters?: SortOrder
    whatHappensIfSkipped?: SortOrder
    timeframe?: SortOrder
    estimatedMinutes?: SortOrder
    difficultyLevel?: SortOrder
    responsibility?: SortOrder
    estimatedCost?: SortOrder
    estimatedCostJMD?: SortOrder
    resources?: SortOrder
    checklist?: SortOrder
    howToKnowItsDone?: SortOrder
    exampleOutput?: SortOrder
    dependsOnSteps?: SortOrder
    isOptional?: SortOrder
    skipConditions?: SortOrder
    freeAlternative?: SortOrder
    lowTechOption?: SortOrder
    commonMistakesForStep?: SortOrder
    videoTutorialUrl?: SortOrder
    externalResourceUrl?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ActionStepSumOrderByAggregateInput = {
    estimatedMinutes?: SortOrder
    sortOrder?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type BusinessTypeStrategyBusinessTypeIdStrategyIdCompoundUniqueInput = {
    businessTypeId: string
    strategyId: string
  }

  export type BusinessTypeStrategyCountOrderByAggregateInput = {
    id?: SortOrder
    businessTypeId?: SortOrder
    strategyId?: SortOrder
    relevanceScore?: SortOrder
    customNotes?: SortOrder
    isRecommended?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BusinessTypeStrategyAvgOrderByAggregateInput = {
    relevanceScore?: SortOrder
  }

  export type BusinessTypeStrategyMaxOrderByAggregateInput = {
    id?: SortOrder
    businessTypeId?: SortOrder
    strategyId?: SortOrder
    relevanceScore?: SortOrder
    customNotes?: SortOrder
    isRecommended?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BusinessTypeStrategyMinOrderByAggregateInput = {
    id?: SortOrder
    businessTypeId?: SortOrder
    strategyId?: SortOrder
    relevanceScore?: SortOrder
    customNotes?: SortOrder
    isRecommended?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BusinessTypeStrategySumOrderByAggregateInput = {
    relevanceScore?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type BusinessRiskProfileBusinessTypeIdParishIdCompoundUniqueInput = {
    businessTypeId: string
    parishId: string
  }

  export type BusinessRiskProfileCountOrderByAggregateInput = {
    id?: SortOrder
    businessTypeId?: SortOrder
    parishId?: SortOrder
    combinedRisks?: SortOrder
    recommendedStrategies?: SortOrder
    overallRiskScore?: SortOrder
    priorityActions?: SortOrder
    calculatedAt?: SortOrder
    calculatedBy?: SortOrder
    isActive?: SortOrder
  }

  export type BusinessRiskProfileAvgOrderByAggregateInput = {
    overallRiskScore?: SortOrder
  }

  export type BusinessRiskProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    businessTypeId?: SortOrder
    parishId?: SortOrder
    combinedRisks?: SortOrder
    recommendedStrategies?: SortOrder
    overallRiskScore?: SortOrder
    priorityActions?: SortOrder
    calculatedAt?: SortOrder
    calculatedBy?: SortOrder
    isActive?: SortOrder
  }

  export type BusinessRiskProfileMinOrderByAggregateInput = {
    id?: SortOrder
    businessTypeId?: SortOrder
    parishId?: SortOrder
    combinedRisks?: SortOrder
    recommendedStrategies?: SortOrder
    overallRiskScore?: SortOrder
    priorityActions?: SortOrder
    calculatedAt?: SortOrder
    calculatedBy?: SortOrder
    isActive?: SortOrder
  }

  export type BusinessRiskProfileSumOrderByAggregateInput = {
    overallRiskScore?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type RiskMultiplierTranslationListRelationFilter = {
    every?: RiskMultiplierTranslationWhereInput
    some?: RiskMultiplierTranslationWhereInput
    none?: RiskMultiplierTranslationWhereInput
  }

  export type RiskMultiplierTranslationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RiskMultiplierCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    characteristicType?: SortOrder
    conditionType?: SortOrder
    thresholdValue?: SortOrder
    minValue?: SortOrder
    maxValue?: SortOrder
    multiplierFactor?: SortOrder
    applicableHazards?: SortOrder
    wizardQuestion?: SortOrder
    wizardAnswerOptions?: SortOrder
    wizardHelpText?: SortOrder
    isActive?: SortOrder
    priority?: SortOrder
    reasoning?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type RiskMultiplierAvgOrderByAggregateInput = {
    thresholdValue?: SortOrder
    minValue?: SortOrder
    maxValue?: SortOrder
    multiplierFactor?: SortOrder
    priority?: SortOrder
  }

  export type RiskMultiplierMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    characteristicType?: SortOrder
    conditionType?: SortOrder
    thresholdValue?: SortOrder
    minValue?: SortOrder
    maxValue?: SortOrder
    multiplierFactor?: SortOrder
    applicableHazards?: SortOrder
    wizardQuestion?: SortOrder
    wizardAnswerOptions?: SortOrder
    wizardHelpText?: SortOrder
    isActive?: SortOrder
    priority?: SortOrder
    reasoning?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type RiskMultiplierMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    characteristicType?: SortOrder
    conditionType?: SortOrder
    thresholdValue?: SortOrder
    minValue?: SortOrder
    maxValue?: SortOrder
    multiplierFactor?: SortOrder
    applicableHazards?: SortOrder
    wizardQuestion?: SortOrder
    wizardAnswerOptions?: SortOrder
    wizardHelpText?: SortOrder
    isActive?: SortOrder
    priority?: SortOrder
    reasoning?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type RiskMultiplierSumOrderByAggregateInput = {
    thresholdValue?: SortOrder
    minValue?: SortOrder
    maxValue?: SortOrder
    multiplierFactor?: SortOrder
    priority?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type CostItemCountOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    baseUSD?: SortOrder
    baseUSDMin?: SortOrder
    baseUSDMax?: SortOrder
    unit?: SortOrder
    complexity?: SortOrder
    notes?: SortOrder
    tags?: SortOrder
    budgetAlternativeId?: SortOrder
    premiumAlternativeId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CostItemAvgOrderByAggregateInput = {
    baseUSD?: SortOrder
    baseUSDMin?: SortOrder
    baseUSDMax?: SortOrder
  }

  export type CostItemMaxOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    baseUSD?: SortOrder
    baseUSDMin?: SortOrder
    baseUSDMax?: SortOrder
    unit?: SortOrder
    complexity?: SortOrder
    notes?: SortOrder
    tags?: SortOrder
    budgetAlternativeId?: SortOrder
    premiumAlternativeId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CostItemMinOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    baseUSD?: SortOrder
    baseUSDMin?: SortOrder
    baseUSDMax?: SortOrder
    unit?: SortOrder
    complexity?: SortOrder
    notes?: SortOrder
    tags?: SortOrder
    budgetAlternativeId?: SortOrder
    premiumAlternativeId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CostItemSumOrderByAggregateInput = {
    baseUSD?: SortOrder
    baseUSDMin?: SortOrder
    baseUSDMax?: SortOrder
  }

  export type CountryCostMultiplierCountOrderByAggregateInput = {
    id?: SortOrder
    countryCode?: SortOrder
    construction?: SortOrder
    equipment?: SortOrder
    service?: SortOrder
    supplies?: SortOrder
    currency?: SortOrder
    currencySymbol?: SortOrder
    exchangeRateUSD?: SortOrder
    lastUpdated?: SortOrder
    updatedBy?: SortOrder
    dataSource?: SortOrder
    confidenceLevel?: SortOrder
    notes?: SortOrder
  }

  export type CountryCostMultiplierAvgOrderByAggregateInput = {
    construction?: SortOrder
    equipment?: SortOrder
    service?: SortOrder
    supplies?: SortOrder
    exchangeRateUSD?: SortOrder
  }

  export type CountryCostMultiplierMaxOrderByAggregateInput = {
    id?: SortOrder
    countryCode?: SortOrder
    construction?: SortOrder
    equipment?: SortOrder
    service?: SortOrder
    supplies?: SortOrder
    currency?: SortOrder
    currencySymbol?: SortOrder
    exchangeRateUSD?: SortOrder
    lastUpdated?: SortOrder
    updatedBy?: SortOrder
    dataSource?: SortOrder
    confidenceLevel?: SortOrder
    notes?: SortOrder
  }

  export type CountryCostMultiplierMinOrderByAggregateInput = {
    id?: SortOrder
    countryCode?: SortOrder
    construction?: SortOrder
    equipment?: SortOrder
    service?: SortOrder
    supplies?: SortOrder
    currency?: SortOrder
    currencySymbol?: SortOrder
    exchangeRateUSD?: SortOrder
    lastUpdated?: SortOrder
    updatedBy?: SortOrder
    dataSource?: SortOrder
    confidenceLevel?: SortOrder
    notes?: SortOrder
  }

  export type CountryCostMultiplierSumOrderByAggregateInput = {
    construction?: SortOrder
    equipment?: SortOrder
    service?: SortOrder
    supplies?: SortOrder
    exchangeRateUSD?: SortOrder
  }

  export type CostItemRelationFilter = {
    is?: CostItemWhereInput
    isNot?: CostItemWhereInput
  }

  export type StrategyItemCostStrategyIdItemIdCompoundUniqueInput = {
    strategyId: string
    itemId: string
  }

  export type StrategyItemCostCountOrderByAggregateInput = {
    id?: SortOrder
    strategyId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    customNotes?: SortOrder
    countryOverrides?: SortOrder
    isRequired?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StrategyItemCostAvgOrderByAggregateInput = {
    quantity?: SortOrder
    displayOrder?: SortOrder
  }

  export type StrategyItemCostMaxOrderByAggregateInput = {
    id?: SortOrder
    strategyId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    customNotes?: SortOrder
    countryOverrides?: SortOrder
    isRequired?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StrategyItemCostMinOrderByAggregateInput = {
    id?: SortOrder
    strategyId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    customNotes?: SortOrder
    countryOverrides?: SortOrder
    isRequired?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StrategyItemCostSumOrderByAggregateInput = {
    quantity?: SortOrder
    displayOrder?: SortOrder
  }

  export type ActionStepRelationFilter = {
    is?: ActionStepWhereInput
    isNot?: ActionStepWhereInput
  }

  export type ActionStepItemCostActionStepIdItemIdCompoundUniqueInput = {
    actionStepId: string
    itemId: string
  }

  export type ActionStepItemCostCountOrderByAggregateInput = {
    id?: SortOrder
    actionStepId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    customNotes?: SortOrder
    countryOverrides?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ActionStepItemCostAvgOrderByAggregateInput = {
    quantity?: SortOrder
    displayOrder?: SortOrder
  }

  export type ActionStepItemCostMaxOrderByAggregateInput = {
    id?: SortOrder
    actionStepId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    customNotes?: SortOrder
    countryOverrides?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ActionStepItemCostMinOrderByAggregateInput = {
    id?: SortOrder
    actionStepId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    customNotes?: SortOrder
    countryOverrides?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ActionStepItemCostSumOrderByAggregateInput = {
    quantity?: SortOrder
    displayOrder?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type BusinessTypeTranslationBusinessTypeIdLocaleCompoundUniqueInput = {
    businessTypeId: string
    locale: string
  }

  export type BusinessTypeTranslationCountOrderByAggregateInput = {
    id?: SortOrder
    businessTypeId?: SortOrder
    locale?: SortOrder
    name?: SortOrder
    description?: SortOrder
    exampleBusinessPurposes?: SortOrder
    exampleProducts?: SortOrder
    exampleKeyPersonnel?: SortOrder
    exampleCustomerBase?: SortOrder
    minimumEquipment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BusinessTypeTranslationMaxOrderByAggregateInput = {
    id?: SortOrder
    businessTypeId?: SortOrder
    locale?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BusinessTypeTranslationMinOrderByAggregateInput = {
    id?: SortOrder
    businessTypeId?: SortOrder
    locale?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type StrategyTranslationStrategyIdLocaleCompoundUniqueInput = {
    strategyId: string
    locale: string
  }

  export type StrategyTranslationCountOrderByAggregateInput = {
    id?: SortOrder
    strategyId?: SortOrder
    locale?: SortOrder
    name?: SortOrder
    description?: SortOrder
    smeTitle?: SortOrder
    smeSummary?: SortOrder
    realWorldExample?: SortOrder
    whyImportant?: SortOrder
    whenToImplement?: SortOrder
    expectedOutcome?: SortOrder
    benefitsBullets?: SortOrder
    helpfulTips?: SortOrder
    commonMistakes?: SortOrder
    successMetrics?: SortOrder
    requiredResources?: SortOrder
    lowBudgetAlternative?: SortOrder
    diyApproach?: SortOrder
    bcpTemplateText?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StrategyTranslationMaxOrderByAggregateInput = {
    id?: SortOrder
    strategyId?: SortOrder
    locale?: SortOrder
    name?: SortOrder
    description?: SortOrder
    smeTitle?: SortOrder
    smeSummary?: SortOrder
    realWorldExample?: SortOrder
    whyImportant?: SortOrder
    whenToImplement?: SortOrder
    expectedOutcome?: SortOrder
    lowBudgetAlternative?: SortOrder
    diyApproach?: SortOrder
    bcpTemplateText?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StrategyTranslationMinOrderByAggregateInput = {
    id?: SortOrder
    strategyId?: SortOrder
    locale?: SortOrder
    name?: SortOrder
    description?: SortOrder
    smeTitle?: SortOrder
    smeSummary?: SortOrder
    realWorldExample?: SortOrder
    whyImportant?: SortOrder
    whenToImplement?: SortOrder
    expectedOutcome?: SortOrder
    lowBudgetAlternative?: SortOrder
    diyApproach?: SortOrder
    bcpTemplateText?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ActionStepTranslationActionStepIdLocaleCompoundUniqueInput = {
    actionStepId: string
    locale: string
  }

  export type ActionStepTranslationCountOrderByAggregateInput = {
    id?: SortOrder
    actionStepId?: SortOrder
    locale?: SortOrder
    title?: SortOrder
    description?: SortOrder
    smeAction?: SortOrder
    timeframe?: SortOrder
    whyThisStepMatters?: SortOrder
    howToKnowItsDone?: SortOrder
    whatHappensIfSkipped?: SortOrder
    exampleOutput?: SortOrder
    freeAlternative?: SortOrder
    lowTechOption?: SortOrder
    commonMistakesForStep?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ActionStepTranslationMaxOrderByAggregateInput = {
    id?: SortOrder
    actionStepId?: SortOrder
    locale?: SortOrder
    title?: SortOrder
    description?: SortOrder
    smeAction?: SortOrder
    timeframe?: SortOrder
    whyThisStepMatters?: SortOrder
    howToKnowItsDone?: SortOrder
    whatHappensIfSkipped?: SortOrder
    exampleOutput?: SortOrder
    freeAlternative?: SortOrder
    lowTechOption?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ActionStepTranslationMinOrderByAggregateInput = {
    id?: SortOrder
    actionStepId?: SortOrder
    locale?: SortOrder
    title?: SortOrder
    description?: SortOrder
    smeAction?: SortOrder
    timeframe?: SortOrder
    whyThisStepMatters?: SortOrder
    howToKnowItsDone?: SortOrder
    whatHappensIfSkipped?: SortOrder
    exampleOutput?: SortOrder
    freeAlternative?: SortOrder
    lowTechOption?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HazardTranslationHazardIdLocaleCompoundUniqueInput = {
    hazardId: string
    locale: string
  }

  export type HazardTranslationCountOrderByAggregateInput = {
    id?: SortOrder
    hazardId?: SortOrder
    locale?: SortOrder
    name?: SortOrder
    description?: SortOrder
    impact?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HazardTranslationMaxOrderByAggregateInput = {
    id?: SortOrder
    hazardId?: SortOrder
    locale?: SortOrder
    name?: SortOrder
    description?: SortOrder
    impact?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HazardTranslationMinOrderByAggregateInput = {
    id?: SortOrder
    hazardId?: SortOrder
    locale?: SortOrder
    name?: SortOrder
    description?: SortOrder
    impact?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RiskMultiplierRelationFilter = {
    is?: RiskMultiplierWhereInput
    isNot?: RiskMultiplierWhereInput
  }

  export type RiskMultiplierTranslationRiskMultiplierIdLocaleCompoundUniqueInput = {
    riskMultiplierId: string
    locale: string
  }

  export type RiskMultiplierTranslationCountOrderByAggregateInput = {
    id?: SortOrder
    riskMultiplierId?: SortOrder
    locale?: SortOrder
    name?: SortOrder
    description?: SortOrder
    reasoning?: SortOrder
    wizardQuestion?: SortOrder
    wizardHelpText?: SortOrder
    wizardAnswerOptions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RiskMultiplierTranslationMaxOrderByAggregateInput = {
    id?: SortOrder
    riskMultiplierId?: SortOrder
    locale?: SortOrder
    name?: SortOrder
    description?: SortOrder
    reasoning?: SortOrder
    wizardQuestion?: SortOrder
    wizardHelpText?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RiskMultiplierTranslationMinOrderByAggregateInput = {
    id?: SortOrder
    riskMultiplierId?: SortOrder
    locale?: SortOrder
    name?: SortOrder
    description?: SortOrder
    reasoning?: SortOrder
    wizardQuestion?: SortOrder
    wizardHelpText?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanInformationCreateNestedOneWithoutPlanInput = {
    create?: XOR<PlanInformationCreateWithoutPlanInput, PlanInformationUncheckedCreateWithoutPlanInput>
    connectOrCreate?: PlanInformationCreateOrConnectWithoutPlanInput
    connect?: PlanInformationWhereUniqueInput
  }

  export type BusinessOverviewCreateNestedOneWithoutPlanInput = {
    create?: XOR<BusinessOverviewCreateWithoutPlanInput, BusinessOverviewUncheckedCreateWithoutPlanInput>
    connectOrCreate?: BusinessOverviewCreateOrConnectWithoutPlanInput
    connect?: BusinessOverviewWhereUniqueInput
  }

  export type EssentialFunctionCreateNestedOneWithoutPlanInput = {
    create?: XOR<EssentialFunctionCreateWithoutPlanInput, EssentialFunctionUncheckedCreateWithoutPlanInput>
    connectOrCreate?: EssentialFunctionCreateOrConnectWithoutPlanInput
    connect?: EssentialFunctionWhereUniqueInput
  }

  export type RiskAssessmentCreateNestedOneWithoutPlanInput = {
    create?: XOR<RiskAssessmentCreateWithoutPlanInput, RiskAssessmentUncheckedCreateWithoutPlanInput>
    connectOrCreate?: RiskAssessmentCreateOrConnectWithoutPlanInput
    connect?: RiskAssessmentWhereUniqueInput
  }

  export type StrategyCreateNestedOneWithoutPlanInput = {
    create?: XOR<StrategyCreateWithoutPlanInput, StrategyUncheckedCreateWithoutPlanInput>
    connectOrCreate?: StrategyCreateOrConnectWithoutPlanInput
    connect?: StrategyWhereUniqueInput
  }

  export type ActionPlanCreateNestedOneWithoutPlanInput = {
    create?: XOR<ActionPlanCreateWithoutPlanInput, ActionPlanUncheckedCreateWithoutPlanInput>
    connectOrCreate?: ActionPlanCreateOrConnectWithoutPlanInput
    connect?: ActionPlanWhereUniqueInput
  }

  export type ContactsInformationCreateNestedOneWithoutPlanInput = {
    create?: XOR<ContactsInformationCreateWithoutPlanInput, ContactsInformationUncheckedCreateWithoutPlanInput>
    connectOrCreate?: ContactsInformationCreateOrConnectWithoutPlanInput
    connect?: ContactsInformationWhereUniqueInput
  }

  export type TestingMaintenanceCreateNestedOneWithoutPlanInput = {
    create?: XOR<TestingMaintenanceCreateWithoutPlanInput, TestingMaintenanceUncheckedCreateWithoutPlanInput>
    connectOrCreate?: TestingMaintenanceCreateOrConnectWithoutPlanInput
    connect?: TestingMaintenanceWhereUniqueInput
  }

  export type PlanInformationUncheckedCreateNestedOneWithoutPlanInput = {
    create?: XOR<PlanInformationCreateWithoutPlanInput, PlanInformationUncheckedCreateWithoutPlanInput>
    connectOrCreate?: PlanInformationCreateOrConnectWithoutPlanInput
    connect?: PlanInformationWhereUniqueInput
  }

  export type BusinessOverviewUncheckedCreateNestedOneWithoutPlanInput = {
    create?: XOR<BusinessOverviewCreateWithoutPlanInput, BusinessOverviewUncheckedCreateWithoutPlanInput>
    connectOrCreate?: BusinessOverviewCreateOrConnectWithoutPlanInput
    connect?: BusinessOverviewWhereUniqueInput
  }

  export type EssentialFunctionUncheckedCreateNestedOneWithoutPlanInput = {
    create?: XOR<EssentialFunctionCreateWithoutPlanInput, EssentialFunctionUncheckedCreateWithoutPlanInput>
    connectOrCreate?: EssentialFunctionCreateOrConnectWithoutPlanInput
    connect?: EssentialFunctionWhereUniqueInput
  }

  export type RiskAssessmentUncheckedCreateNestedOneWithoutPlanInput = {
    create?: XOR<RiskAssessmentCreateWithoutPlanInput, RiskAssessmentUncheckedCreateWithoutPlanInput>
    connectOrCreate?: RiskAssessmentCreateOrConnectWithoutPlanInput
    connect?: RiskAssessmentWhereUniqueInput
  }

  export type StrategyUncheckedCreateNestedOneWithoutPlanInput = {
    create?: XOR<StrategyCreateWithoutPlanInput, StrategyUncheckedCreateWithoutPlanInput>
    connectOrCreate?: StrategyCreateOrConnectWithoutPlanInput
    connect?: StrategyWhereUniqueInput
  }

  export type ActionPlanUncheckedCreateNestedOneWithoutPlanInput = {
    create?: XOR<ActionPlanCreateWithoutPlanInput, ActionPlanUncheckedCreateWithoutPlanInput>
    connectOrCreate?: ActionPlanCreateOrConnectWithoutPlanInput
    connect?: ActionPlanWhereUniqueInput
  }

  export type ContactsInformationUncheckedCreateNestedOneWithoutPlanInput = {
    create?: XOR<ContactsInformationCreateWithoutPlanInput, ContactsInformationUncheckedCreateWithoutPlanInput>
    connectOrCreate?: ContactsInformationCreateOrConnectWithoutPlanInput
    connect?: ContactsInformationWhereUniqueInput
  }

  export type TestingMaintenanceUncheckedCreateNestedOneWithoutPlanInput = {
    create?: XOR<TestingMaintenanceCreateWithoutPlanInput, TestingMaintenanceUncheckedCreateWithoutPlanInput>
    connectOrCreate?: TestingMaintenanceCreateOrConnectWithoutPlanInput
    connect?: TestingMaintenanceWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type PlanInformationUpdateOneWithoutPlanNestedInput = {
    create?: XOR<PlanInformationCreateWithoutPlanInput, PlanInformationUncheckedCreateWithoutPlanInput>
    connectOrCreate?: PlanInformationCreateOrConnectWithoutPlanInput
    upsert?: PlanInformationUpsertWithoutPlanInput
    disconnect?: PlanInformationWhereInput | boolean
    delete?: PlanInformationWhereInput | boolean
    connect?: PlanInformationWhereUniqueInput
    update?: XOR<XOR<PlanInformationUpdateToOneWithWhereWithoutPlanInput, PlanInformationUpdateWithoutPlanInput>, PlanInformationUncheckedUpdateWithoutPlanInput>
  }

  export type BusinessOverviewUpdateOneWithoutPlanNestedInput = {
    create?: XOR<BusinessOverviewCreateWithoutPlanInput, BusinessOverviewUncheckedCreateWithoutPlanInput>
    connectOrCreate?: BusinessOverviewCreateOrConnectWithoutPlanInput
    upsert?: BusinessOverviewUpsertWithoutPlanInput
    disconnect?: BusinessOverviewWhereInput | boolean
    delete?: BusinessOverviewWhereInput | boolean
    connect?: BusinessOverviewWhereUniqueInput
    update?: XOR<XOR<BusinessOverviewUpdateToOneWithWhereWithoutPlanInput, BusinessOverviewUpdateWithoutPlanInput>, BusinessOverviewUncheckedUpdateWithoutPlanInput>
  }

  export type EssentialFunctionUpdateOneWithoutPlanNestedInput = {
    create?: XOR<EssentialFunctionCreateWithoutPlanInput, EssentialFunctionUncheckedCreateWithoutPlanInput>
    connectOrCreate?: EssentialFunctionCreateOrConnectWithoutPlanInput
    upsert?: EssentialFunctionUpsertWithoutPlanInput
    disconnect?: EssentialFunctionWhereInput | boolean
    delete?: EssentialFunctionWhereInput | boolean
    connect?: EssentialFunctionWhereUniqueInput
    update?: XOR<XOR<EssentialFunctionUpdateToOneWithWhereWithoutPlanInput, EssentialFunctionUpdateWithoutPlanInput>, EssentialFunctionUncheckedUpdateWithoutPlanInput>
  }

  export type RiskAssessmentUpdateOneWithoutPlanNestedInput = {
    create?: XOR<RiskAssessmentCreateWithoutPlanInput, RiskAssessmentUncheckedCreateWithoutPlanInput>
    connectOrCreate?: RiskAssessmentCreateOrConnectWithoutPlanInput
    upsert?: RiskAssessmentUpsertWithoutPlanInput
    disconnect?: RiskAssessmentWhereInput | boolean
    delete?: RiskAssessmentWhereInput | boolean
    connect?: RiskAssessmentWhereUniqueInput
    update?: XOR<XOR<RiskAssessmentUpdateToOneWithWhereWithoutPlanInput, RiskAssessmentUpdateWithoutPlanInput>, RiskAssessmentUncheckedUpdateWithoutPlanInput>
  }

  export type StrategyUpdateOneWithoutPlanNestedInput = {
    create?: XOR<StrategyCreateWithoutPlanInput, StrategyUncheckedCreateWithoutPlanInput>
    connectOrCreate?: StrategyCreateOrConnectWithoutPlanInput
    upsert?: StrategyUpsertWithoutPlanInput
    disconnect?: StrategyWhereInput | boolean
    delete?: StrategyWhereInput | boolean
    connect?: StrategyWhereUniqueInput
    update?: XOR<XOR<StrategyUpdateToOneWithWhereWithoutPlanInput, StrategyUpdateWithoutPlanInput>, StrategyUncheckedUpdateWithoutPlanInput>
  }

  export type ActionPlanUpdateOneWithoutPlanNestedInput = {
    create?: XOR<ActionPlanCreateWithoutPlanInput, ActionPlanUncheckedCreateWithoutPlanInput>
    connectOrCreate?: ActionPlanCreateOrConnectWithoutPlanInput
    upsert?: ActionPlanUpsertWithoutPlanInput
    disconnect?: ActionPlanWhereInput | boolean
    delete?: ActionPlanWhereInput | boolean
    connect?: ActionPlanWhereUniqueInput
    update?: XOR<XOR<ActionPlanUpdateToOneWithWhereWithoutPlanInput, ActionPlanUpdateWithoutPlanInput>, ActionPlanUncheckedUpdateWithoutPlanInput>
  }

  export type ContactsInformationUpdateOneWithoutPlanNestedInput = {
    create?: XOR<ContactsInformationCreateWithoutPlanInput, ContactsInformationUncheckedCreateWithoutPlanInput>
    connectOrCreate?: ContactsInformationCreateOrConnectWithoutPlanInput
    upsert?: ContactsInformationUpsertWithoutPlanInput
    disconnect?: ContactsInformationWhereInput | boolean
    delete?: ContactsInformationWhereInput | boolean
    connect?: ContactsInformationWhereUniqueInput
    update?: XOR<XOR<ContactsInformationUpdateToOneWithWhereWithoutPlanInput, ContactsInformationUpdateWithoutPlanInput>, ContactsInformationUncheckedUpdateWithoutPlanInput>
  }

  export type TestingMaintenanceUpdateOneWithoutPlanNestedInput = {
    create?: XOR<TestingMaintenanceCreateWithoutPlanInput, TestingMaintenanceUncheckedCreateWithoutPlanInput>
    connectOrCreate?: TestingMaintenanceCreateOrConnectWithoutPlanInput
    upsert?: TestingMaintenanceUpsertWithoutPlanInput
    disconnect?: TestingMaintenanceWhereInput | boolean
    delete?: TestingMaintenanceWhereInput | boolean
    connect?: TestingMaintenanceWhereUniqueInput
    update?: XOR<XOR<TestingMaintenanceUpdateToOneWithWhereWithoutPlanInput, TestingMaintenanceUpdateWithoutPlanInput>, TestingMaintenanceUncheckedUpdateWithoutPlanInput>
  }

  export type PlanInformationUncheckedUpdateOneWithoutPlanNestedInput = {
    create?: XOR<PlanInformationCreateWithoutPlanInput, PlanInformationUncheckedCreateWithoutPlanInput>
    connectOrCreate?: PlanInformationCreateOrConnectWithoutPlanInput
    upsert?: PlanInformationUpsertWithoutPlanInput
    disconnect?: PlanInformationWhereInput | boolean
    delete?: PlanInformationWhereInput | boolean
    connect?: PlanInformationWhereUniqueInput
    update?: XOR<XOR<PlanInformationUpdateToOneWithWhereWithoutPlanInput, PlanInformationUpdateWithoutPlanInput>, PlanInformationUncheckedUpdateWithoutPlanInput>
  }

  export type BusinessOverviewUncheckedUpdateOneWithoutPlanNestedInput = {
    create?: XOR<BusinessOverviewCreateWithoutPlanInput, BusinessOverviewUncheckedCreateWithoutPlanInput>
    connectOrCreate?: BusinessOverviewCreateOrConnectWithoutPlanInput
    upsert?: BusinessOverviewUpsertWithoutPlanInput
    disconnect?: BusinessOverviewWhereInput | boolean
    delete?: BusinessOverviewWhereInput | boolean
    connect?: BusinessOverviewWhereUniqueInput
    update?: XOR<XOR<BusinessOverviewUpdateToOneWithWhereWithoutPlanInput, BusinessOverviewUpdateWithoutPlanInput>, BusinessOverviewUncheckedUpdateWithoutPlanInput>
  }

  export type EssentialFunctionUncheckedUpdateOneWithoutPlanNestedInput = {
    create?: XOR<EssentialFunctionCreateWithoutPlanInput, EssentialFunctionUncheckedCreateWithoutPlanInput>
    connectOrCreate?: EssentialFunctionCreateOrConnectWithoutPlanInput
    upsert?: EssentialFunctionUpsertWithoutPlanInput
    disconnect?: EssentialFunctionWhereInput | boolean
    delete?: EssentialFunctionWhereInput | boolean
    connect?: EssentialFunctionWhereUniqueInput
    update?: XOR<XOR<EssentialFunctionUpdateToOneWithWhereWithoutPlanInput, EssentialFunctionUpdateWithoutPlanInput>, EssentialFunctionUncheckedUpdateWithoutPlanInput>
  }

  export type RiskAssessmentUncheckedUpdateOneWithoutPlanNestedInput = {
    create?: XOR<RiskAssessmentCreateWithoutPlanInput, RiskAssessmentUncheckedCreateWithoutPlanInput>
    connectOrCreate?: RiskAssessmentCreateOrConnectWithoutPlanInput
    upsert?: RiskAssessmentUpsertWithoutPlanInput
    disconnect?: RiskAssessmentWhereInput | boolean
    delete?: RiskAssessmentWhereInput | boolean
    connect?: RiskAssessmentWhereUniqueInput
    update?: XOR<XOR<RiskAssessmentUpdateToOneWithWhereWithoutPlanInput, RiskAssessmentUpdateWithoutPlanInput>, RiskAssessmentUncheckedUpdateWithoutPlanInput>
  }

  export type StrategyUncheckedUpdateOneWithoutPlanNestedInput = {
    create?: XOR<StrategyCreateWithoutPlanInput, StrategyUncheckedCreateWithoutPlanInput>
    connectOrCreate?: StrategyCreateOrConnectWithoutPlanInput
    upsert?: StrategyUpsertWithoutPlanInput
    disconnect?: StrategyWhereInput | boolean
    delete?: StrategyWhereInput | boolean
    connect?: StrategyWhereUniqueInput
    update?: XOR<XOR<StrategyUpdateToOneWithWhereWithoutPlanInput, StrategyUpdateWithoutPlanInput>, StrategyUncheckedUpdateWithoutPlanInput>
  }

  export type ActionPlanUncheckedUpdateOneWithoutPlanNestedInput = {
    create?: XOR<ActionPlanCreateWithoutPlanInput, ActionPlanUncheckedCreateWithoutPlanInput>
    connectOrCreate?: ActionPlanCreateOrConnectWithoutPlanInput
    upsert?: ActionPlanUpsertWithoutPlanInput
    disconnect?: ActionPlanWhereInput | boolean
    delete?: ActionPlanWhereInput | boolean
    connect?: ActionPlanWhereUniqueInput
    update?: XOR<XOR<ActionPlanUpdateToOneWithWhereWithoutPlanInput, ActionPlanUpdateWithoutPlanInput>, ActionPlanUncheckedUpdateWithoutPlanInput>
  }

  export type ContactsInformationUncheckedUpdateOneWithoutPlanNestedInput = {
    create?: XOR<ContactsInformationCreateWithoutPlanInput, ContactsInformationUncheckedCreateWithoutPlanInput>
    connectOrCreate?: ContactsInformationCreateOrConnectWithoutPlanInput
    upsert?: ContactsInformationUpsertWithoutPlanInput
    disconnect?: ContactsInformationWhereInput | boolean
    delete?: ContactsInformationWhereInput | boolean
    connect?: ContactsInformationWhereUniqueInput
    update?: XOR<XOR<ContactsInformationUpdateToOneWithWhereWithoutPlanInput, ContactsInformationUpdateWithoutPlanInput>, ContactsInformationUncheckedUpdateWithoutPlanInput>
  }

  export type TestingMaintenanceUncheckedUpdateOneWithoutPlanNestedInput = {
    create?: XOR<TestingMaintenanceCreateWithoutPlanInput, TestingMaintenanceUncheckedCreateWithoutPlanInput>
    connectOrCreate?: TestingMaintenanceCreateOrConnectWithoutPlanInput
    upsert?: TestingMaintenanceUpsertWithoutPlanInput
    disconnect?: TestingMaintenanceWhereInput | boolean
    delete?: TestingMaintenanceWhereInput | boolean
    connect?: TestingMaintenanceWhereUniqueInput
    update?: XOR<XOR<TestingMaintenanceUpdateToOneWithWhereWithoutPlanInput, TestingMaintenanceUpdateWithoutPlanInput>, TestingMaintenanceUncheckedUpdateWithoutPlanInput>
  }

  export type BusinessContinuityPlanCreateNestedOneWithoutPlanInformationInput = {
    create?: XOR<BusinessContinuityPlanCreateWithoutPlanInformationInput, BusinessContinuityPlanUncheckedCreateWithoutPlanInformationInput>
    connectOrCreate?: BusinessContinuityPlanCreateOrConnectWithoutPlanInformationInput
    connect?: BusinessContinuityPlanWhereUniqueInput
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BusinessContinuityPlanUpdateOneRequiredWithoutPlanInformationNestedInput = {
    create?: XOR<BusinessContinuityPlanCreateWithoutPlanInformationInput, BusinessContinuityPlanUncheckedCreateWithoutPlanInformationInput>
    connectOrCreate?: BusinessContinuityPlanCreateOrConnectWithoutPlanInformationInput
    upsert?: BusinessContinuityPlanUpsertWithoutPlanInformationInput
    connect?: BusinessContinuityPlanWhereUniqueInput
    update?: XOR<XOR<BusinessContinuityPlanUpdateToOneWithWhereWithoutPlanInformationInput, BusinessContinuityPlanUpdateWithoutPlanInformationInput>, BusinessContinuityPlanUncheckedUpdateWithoutPlanInformationInput>
  }

  export type BusinessContinuityPlanCreateNestedOneWithoutBusinessOverviewInput = {
    create?: XOR<BusinessContinuityPlanCreateWithoutBusinessOverviewInput, BusinessContinuityPlanUncheckedCreateWithoutBusinessOverviewInput>
    connectOrCreate?: BusinessContinuityPlanCreateOrConnectWithoutBusinessOverviewInput
    connect?: BusinessContinuityPlanWhereUniqueInput
  }

  export type BusinessContinuityPlanUpdateOneRequiredWithoutBusinessOverviewNestedInput = {
    create?: XOR<BusinessContinuityPlanCreateWithoutBusinessOverviewInput, BusinessContinuityPlanUncheckedCreateWithoutBusinessOverviewInput>
    connectOrCreate?: BusinessContinuityPlanCreateOrConnectWithoutBusinessOverviewInput
    upsert?: BusinessContinuityPlanUpsertWithoutBusinessOverviewInput
    connect?: BusinessContinuityPlanWhereUniqueInput
    update?: XOR<XOR<BusinessContinuityPlanUpdateToOneWithWhereWithoutBusinessOverviewInput, BusinessContinuityPlanUpdateWithoutBusinessOverviewInput>, BusinessContinuityPlanUncheckedUpdateWithoutBusinessOverviewInput>
  }

  export type BusinessContinuityPlanCreateNestedOneWithoutEssentialFunctionInput = {
    create?: XOR<BusinessContinuityPlanCreateWithoutEssentialFunctionInput, BusinessContinuityPlanUncheckedCreateWithoutEssentialFunctionInput>
    connectOrCreate?: BusinessContinuityPlanCreateOrConnectWithoutEssentialFunctionInput
    connect?: BusinessContinuityPlanWhereUniqueInput
  }

  export type BusinessContinuityPlanUpdateOneRequiredWithoutEssentialFunctionNestedInput = {
    create?: XOR<BusinessContinuityPlanCreateWithoutEssentialFunctionInput, BusinessContinuityPlanUncheckedCreateWithoutEssentialFunctionInput>
    connectOrCreate?: BusinessContinuityPlanCreateOrConnectWithoutEssentialFunctionInput
    upsert?: BusinessContinuityPlanUpsertWithoutEssentialFunctionInput
    connect?: BusinessContinuityPlanWhereUniqueInput
    update?: XOR<XOR<BusinessContinuityPlanUpdateToOneWithWhereWithoutEssentialFunctionInput, BusinessContinuityPlanUpdateWithoutEssentialFunctionInput>, BusinessContinuityPlanUncheckedUpdateWithoutEssentialFunctionInput>
  }

  export type BusinessContinuityPlanCreateNestedOneWithoutRiskAssessmentInput = {
    create?: XOR<BusinessContinuityPlanCreateWithoutRiskAssessmentInput, BusinessContinuityPlanUncheckedCreateWithoutRiskAssessmentInput>
    connectOrCreate?: BusinessContinuityPlanCreateOrConnectWithoutRiskAssessmentInput
    connect?: BusinessContinuityPlanWhereUniqueInput
  }

  export type BusinessContinuityPlanUpdateOneRequiredWithoutRiskAssessmentNestedInput = {
    create?: XOR<BusinessContinuityPlanCreateWithoutRiskAssessmentInput, BusinessContinuityPlanUncheckedCreateWithoutRiskAssessmentInput>
    connectOrCreate?: BusinessContinuityPlanCreateOrConnectWithoutRiskAssessmentInput
    upsert?: BusinessContinuityPlanUpsertWithoutRiskAssessmentInput
    connect?: BusinessContinuityPlanWhereUniqueInput
    update?: XOR<XOR<BusinessContinuityPlanUpdateToOneWithWhereWithoutRiskAssessmentInput, BusinessContinuityPlanUpdateWithoutRiskAssessmentInput>, BusinessContinuityPlanUncheckedUpdateWithoutRiskAssessmentInput>
  }

  export type BusinessContinuityPlanCreateNestedOneWithoutStrategyInput = {
    create?: XOR<BusinessContinuityPlanCreateWithoutStrategyInput, BusinessContinuityPlanUncheckedCreateWithoutStrategyInput>
    connectOrCreate?: BusinessContinuityPlanCreateOrConnectWithoutStrategyInput
    connect?: BusinessContinuityPlanWhereUniqueInput
  }

  export type BusinessContinuityPlanUpdateOneRequiredWithoutStrategyNestedInput = {
    create?: XOR<BusinessContinuityPlanCreateWithoutStrategyInput, BusinessContinuityPlanUncheckedCreateWithoutStrategyInput>
    connectOrCreate?: BusinessContinuityPlanCreateOrConnectWithoutStrategyInput
    upsert?: BusinessContinuityPlanUpsertWithoutStrategyInput
    connect?: BusinessContinuityPlanWhereUniqueInput
    update?: XOR<XOR<BusinessContinuityPlanUpdateToOneWithWhereWithoutStrategyInput, BusinessContinuityPlanUpdateWithoutStrategyInput>, BusinessContinuityPlanUncheckedUpdateWithoutStrategyInput>
  }

  export type BusinessContinuityPlanCreateNestedOneWithoutActionPlanInput = {
    create?: XOR<BusinessContinuityPlanCreateWithoutActionPlanInput, BusinessContinuityPlanUncheckedCreateWithoutActionPlanInput>
    connectOrCreate?: BusinessContinuityPlanCreateOrConnectWithoutActionPlanInput
    connect?: BusinessContinuityPlanWhereUniqueInput
  }

  export type BusinessContinuityPlanUpdateOneRequiredWithoutActionPlanNestedInput = {
    create?: XOR<BusinessContinuityPlanCreateWithoutActionPlanInput, BusinessContinuityPlanUncheckedCreateWithoutActionPlanInput>
    connectOrCreate?: BusinessContinuityPlanCreateOrConnectWithoutActionPlanInput
    upsert?: BusinessContinuityPlanUpsertWithoutActionPlanInput
    connect?: BusinessContinuityPlanWhereUniqueInput
    update?: XOR<XOR<BusinessContinuityPlanUpdateToOneWithWhereWithoutActionPlanInput, BusinessContinuityPlanUpdateWithoutActionPlanInput>, BusinessContinuityPlanUncheckedUpdateWithoutActionPlanInput>
  }

  export type BusinessProfileCreateNestedOneWithoutSessionInput = {
    create?: XOR<BusinessProfileCreateWithoutSessionInput, BusinessProfileUncheckedCreateWithoutSessionInput>
    connectOrCreate?: BusinessProfileCreateOrConnectWithoutSessionInput
    connect?: BusinessProfileWhereUniqueInput
  }

  export type BusinessProfileUncheckedCreateNestedOneWithoutSessionInput = {
    create?: XOR<BusinessProfileCreateWithoutSessionInput, BusinessProfileUncheckedCreateWithoutSessionInput>
    connectOrCreate?: BusinessProfileCreateOrConnectWithoutSessionInput
    connect?: BusinessProfileWhereUniqueInput
  }

  export type BusinessProfileUpdateOneWithoutSessionNestedInput = {
    create?: XOR<BusinessProfileCreateWithoutSessionInput, BusinessProfileUncheckedCreateWithoutSessionInput>
    connectOrCreate?: BusinessProfileCreateOrConnectWithoutSessionInput
    upsert?: BusinessProfileUpsertWithoutSessionInput
    disconnect?: BusinessProfileWhereInput | boolean
    delete?: BusinessProfileWhereInput | boolean
    connect?: BusinessProfileWhereUniqueInput
    update?: XOR<XOR<BusinessProfileUpdateToOneWithWhereWithoutSessionInput, BusinessProfileUpdateWithoutSessionInput>, BusinessProfileUncheckedUpdateWithoutSessionInput>
  }

  export type BusinessProfileUncheckedUpdateOneWithoutSessionNestedInput = {
    create?: XOR<BusinessProfileCreateWithoutSessionInput, BusinessProfileUncheckedCreateWithoutSessionInput>
    connectOrCreate?: BusinessProfileCreateOrConnectWithoutSessionInput
    upsert?: BusinessProfileUpsertWithoutSessionInput
    disconnect?: BusinessProfileWhereInput | boolean
    delete?: BusinessProfileWhereInput | boolean
    connect?: BusinessProfileWhereUniqueInput
    update?: XOR<XOR<BusinessProfileUpdateToOneWithWhereWithoutSessionInput, BusinessProfileUpdateWithoutSessionInput>, BusinessProfileUncheckedUpdateWithoutSessionInput>
  }

  export type SessionCreateNestedOneWithoutBusinessProfileInput = {
    create?: XOR<SessionCreateWithoutBusinessProfileInput, SessionUncheckedCreateWithoutBusinessProfileInput>
    connectOrCreate?: SessionCreateOrConnectWithoutBusinessProfileInput
    connect?: SessionWhereUniqueInput
  }

  export type SessionUpdateOneRequiredWithoutBusinessProfileNestedInput = {
    create?: XOR<SessionCreateWithoutBusinessProfileInput, SessionUncheckedCreateWithoutBusinessProfileInput>
    connectOrCreate?: SessionCreateOrConnectWithoutBusinessProfileInput
    upsert?: SessionUpsertWithoutBusinessProfileInput
    connect?: SessionWhereUniqueInput
    update?: XOR<XOR<SessionUpdateToOneWithWhereWithoutBusinessProfileInput, SessionUpdateWithoutBusinessProfileInput>, SessionUncheckedUpdateWithoutBusinessProfileInput>
  }

  export type BusinessContinuityPlanCreateNestedOneWithoutContactsInformationInput = {
    create?: XOR<BusinessContinuityPlanCreateWithoutContactsInformationInput, BusinessContinuityPlanUncheckedCreateWithoutContactsInformationInput>
    connectOrCreate?: BusinessContinuityPlanCreateOrConnectWithoutContactsInformationInput
    connect?: BusinessContinuityPlanWhereUniqueInput
  }

  export type BusinessContinuityPlanUpdateOneRequiredWithoutContactsInformationNestedInput = {
    create?: XOR<BusinessContinuityPlanCreateWithoutContactsInformationInput, BusinessContinuityPlanUncheckedCreateWithoutContactsInformationInput>
    connectOrCreate?: BusinessContinuityPlanCreateOrConnectWithoutContactsInformationInput
    upsert?: BusinessContinuityPlanUpsertWithoutContactsInformationInput
    connect?: BusinessContinuityPlanWhereUniqueInput
    update?: XOR<XOR<BusinessContinuityPlanUpdateToOneWithWhereWithoutContactsInformationInput, BusinessContinuityPlanUpdateWithoutContactsInformationInput>, BusinessContinuityPlanUncheckedUpdateWithoutContactsInformationInput>
  }

  export type BusinessContinuityPlanCreateNestedOneWithoutTestingMaintenanceInput = {
    create?: XOR<BusinessContinuityPlanCreateWithoutTestingMaintenanceInput, BusinessContinuityPlanUncheckedCreateWithoutTestingMaintenanceInput>
    connectOrCreate?: BusinessContinuityPlanCreateOrConnectWithoutTestingMaintenanceInput
    connect?: BusinessContinuityPlanWhereUniqueInput
  }

  export type BusinessContinuityPlanUpdateOneRequiredWithoutTestingMaintenanceNestedInput = {
    create?: XOR<BusinessContinuityPlanCreateWithoutTestingMaintenanceInput, BusinessContinuityPlanUncheckedCreateWithoutTestingMaintenanceInput>
    connectOrCreate?: BusinessContinuityPlanCreateOrConnectWithoutTestingMaintenanceInput
    upsert?: BusinessContinuityPlanUpsertWithoutTestingMaintenanceInput
    connect?: BusinessContinuityPlanWhereUniqueInput
    update?: XOR<XOR<BusinessContinuityPlanUpdateToOneWithWhereWithoutTestingMaintenanceInput, BusinessContinuityPlanUpdateWithoutTestingMaintenanceInput>, BusinessContinuityPlanUncheckedUpdateWithoutTestingMaintenanceInput>
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type AdminBusinessTypeHazardCreateNestedManyWithoutBusinessTypeInput = {
    create?: XOR<AdminBusinessTypeHazardCreateWithoutBusinessTypeInput, AdminBusinessTypeHazardUncheckedCreateWithoutBusinessTypeInput> | AdminBusinessTypeHazardCreateWithoutBusinessTypeInput[] | AdminBusinessTypeHazardUncheckedCreateWithoutBusinessTypeInput[]
    connectOrCreate?: AdminBusinessTypeHazardCreateOrConnectWithoutBusinessTypeInput | AdminBusinessTypeHazardCreateOrConnectWithoutBusinessTypeInput[]
    createMany?: AdminBusinessTypeHazardCreateManyBusinessTypeInputEnvelope
    connect?: AdminBusinessTypeHazardWhereUniqueInput | AdminBusinessTypeHazardWhereUniqueInput[]
  }

  export type AdminRiskProfileCreateNestedManyWithoutBusinessTypeInput = {
    create?: XOR<AdminRiskProfileCreateWithoutBusinessTypeInput, AdminRiskProfileUncheckedCreateWithoutBusinessTypeInput> | AdminRiskProfileCreateWithoutBusinessTypeInput[] | AdminRiskProfileUncheckedCreateWithoutBusinessTypeInput[]
    connectOrCreate?: AdminRiskProfileCreateOrConnectWithoutBusinessTypeInput | AdminRiskProfileCreateOrConnectWithoutBusinessTypeInput[]
    createMany?: AdminRiskProfileCreateManyBusinessTypeInputEnvelope
    connect?: AdminRiskProfileWhereUniqueInput | AdminRiskProfileWhereUniqueInput[]
  }

  export type AdminBusinessTypeHazardUncheckedCreateNestedManyWithoutBusinessTypeInput = {
    create?: XOR<AdminBusinessTypeHazardCreateWithoutBusinessTypeInput, AdminBusinessTypeHazardUncheckedCreateWithoutBusinessTypeInput> | AdminBusinessTypeHazardCreateWithoutBusinessTypeInput[] | AdminBusinessTypeHazardUncheckedCreateWithoutBusinessTypeInput[]
    connectOrCreate?: AdminBusinessTypeHazardCreateOrConnectWithoutBusinessTypeInput | AdminBusinessTypeHazardCreateOrConnectWithoutBusinessTypeInput[]
    createMany?: AdminBusinessTypeHazardCreateManyBusinessTypeInputEnvelope
    connect?: AdminBusinessTypeHazardWhereUniqueInput | AdminBusinessTypeHazardWhereUniqueInput[]
  }

  export type AdminRiskProfileUncheckedCreateNestedManyWithoutBusinessTypeInput = {
    create?: XOR<AdminRiskProfileCreateWithoutBusinessTypeInput, AdminRiskProfileUncheckedCreateWithoutBusinessTypeInput> | AdminRiskProfileCreateWithoutBusinessTypeInput[] | AdminRiskProfileUncheckedCreateWithoutBusinessTypeInput[]
    connectOrCreate?: AdminRiskProfileCreateOrConnectWithoutBusinessTypeInput | AdminRiskProfileCreateOrConnectWithoutBusinessTypeInput[]
    createMany?: AdminRiskProfileCreateManyBusinessTypeInputEnvelope
    connect?: AdminRiskProfileWhereUniqueInput | AdminRiskProfileWhereUniqueInput[]
  }

  export type AdminBusinessTypeHazardUpdateManyWithoutBusinessTypeNestedInput = {
    create?: XOR<AdminBusinessTypeHazardCreateWithoutBusinessTypeInput, AdminBusinessTypeHazardUncheckedCreateWithoutBusinessTypeInput> | AdminBusinessTypeHazardCreateWithoutBusinessTypeInput[] | AdminBusinessTypeHazardUncheckedCreateWithoutBusinessTypeInput[]
    connectOrCreate?: AdminBusinessTypeHazardCreateOrConnectWithoutBusinessTypeInput | AdminBusinessTypeHazardCreateOrConnectWithoutBusinessTypeInput[]
    upsert?: AdminBusinessTypeHazardUpsertWithWhereUniqueWithoutBusinessTypeInput | AdminBusinessTypeHazardUpsertWithWhereUniqueWithoutBusinessTypeInput[]
    createMany?: AdminBusinessTypeHazardCreateManyBusinessTypeInputEnvelope
    set?: AdminBusinessTypeHazardWhereUniqueInput | AdminBusinessTypeHazardWhereUniqueInput[]
    disconnect?: AdminBusinessTypeHazardWhereUniqueInput | AdminBusinessTypeHazardWhereUniqueInput[]
    delete?: AdminBusinessTypeHazardWhereUniqueInput | AdminBusinessTypeHazardWhereUniqueInput[]
    connect?: AdminBusinessTypeHazardWhereUniqueInput | AdminBusinessTypeHazardWhereUniqueInput[]
    update?: AdminBusinessTypeHazardUpdateWithWhereUniqueWithoutBusinessTypeInput | AdminBusinessTypeHazardUpdateWithWhereUniqueWithoutBusinessTypeInput[]
    updateMany?: AdminBusinessTypeHazardUpdateManyWithWhereWithoutBusinessTypeInput | AdminBusinessTypeHazardUpdateManyWithWhereWithoutBusinessTypeInput[]
    deleteMany?: AdminBusinessTypeHazardScalarWhereInput | AdminBusinessTypeHazardScalarWhereInput[]
  }

  export type AdminRiskProfileUpdateManyWithoutBusinessTypeNestedInput = {
    create?: XOR<AdminRiskProfileCreateWithoutBusinessTypeInput, AdminRiskProfileUncheckedCreateWithoutBusinessTypeInput> | AdminRiskProfileCreateWithoutBusinessTypeInput[] | AdminRiskProfileUncheckedCreateWithoutBusinessTypeInput[]
    connectOrCreate?: AdminRiskProfileCreateOrConnectWithoutBusinessTypeInput | AdminRiskProfileCreateOrConnectWithoutBusinessTypeInput[]
    upsert?: AdminRiskProfileUpsertWithWhereUniqueWithoutBusinessTypeInput | AdminRiskProfileUpsertWithWhereUniqueWithoutBusinessTypeInput[]
    createMany?: AdminRiskProfileCreateManyBusinessTypeInputEnvelope
    set?: AdminRiskProfileWhereUniqueInput | AdminRiskProfileWhereUniqueInput[]
    disconnect?: AdminRiskProfileWhereUniqueInput | AdminRiskProfileWhereUniqueInput[]
    delete?: AdminRiskProfileWhereUniqueInput | AdminRiskProfileWhereUniqueInput[]
    connect?: AdminRiskProfileWhereUniqueInput | AdminRiskProfileWhereUniqueInput[]
    update?: AdminRiskProfileUpdateWithWhereUniqueWithoutBusinessTypeInput | AdminRiskProfileUpdateWithWhereUniqueWithoutBusinessTypeInput[]
    updateMany?: AdminRiskProfileUpdateManyWithWhereWithoutBusinessTypeInput | AdminRiskProfileUpdateManyWithWhereWithoutBusinessTypeInput[]
    deleteMany?: AdminRiskProfileScalarWhereInput | AdminRiskProfileScalarWhereInput[]
  }

  export type AdminBusinessTypeHazardUncheckedUpdateManyWithoutBusinessTypeNestedInput = {
    create?: XOR<AdminBusinessTypeHazardCreateWithoutBusinessTypeInput, AdminBusinessTypeHazardUncheckedCreateWithoutBusinessTypeInput> | AdminBusinessTypeHazardCreateWithoutBusinessTypeInput[] | AdminBusinessTypeHazardUncheckedCreateWithoutBusinessTypeInput[]
    connectOrCreate?: AdminBusinessTypeHazardCreateOrConnectWithoutBusinessTypeInput | AdminBusinessTypeHazardCreateOrConnectWithoutBusinessTypeInput[]
    upsert?: AdminBusinessTypeHazardUpsertWithWhereUniqueWithoutBusinessTypeInput | AdminBusinessTypeHazardUpsertWithWhereUniqueWithoutBusinessTypeInput[]
    createMany?: AdminBusinessTypeHazardCreateManyBusinessTypeInputEnvelope
    set?: AdminBusinessTypeHazardWhereUniqueInput | AdminBusinessTypeHazardWhereUniqueInput[]
    disconnect?: AdminBusinessTypeHazardWhereUniqueInput | AdminBusinessTypeHazardWhereUniqueInput[]
    delete?: AdminBusinessTypeHazardWhereUniqueInput | AdminBusinessTypeHazardWhereUniqueInput[]
    connect?: AdminBusinessTypeHazardWhereUniqueInput | AdminBusinessTypeHazardWhereUniqueInput[]
    update?: AdminBusinessTypeHazardUpdateWithWhereUniqueWithoutBusinessTypeInput | AdminBusinessTypeHazardUpdateWithWhereUniqueWithoutBusinessTypeInput[]
    updateMany?: AdminBusinessTypeHazardUpdateManyWithWhereWithoutBusinessTypeInput | AdminBusinessTypeHazardUpdateManyWithWhereWithoutBusinessTypeInput[]
    deleteMany?: AdminBusinessTypeHazardScalarWhereInput | AdminBusinessTypeHazardScalarWhereInput[]
  }

  export type AdminRiskProfileUncheckedUpdateManyWithoutBusinessTypeNestedInput = {
    create?: XOR<AdminRiskProfileCreateWithoutBusinessTypeInput, AdminRiskProfileUncheckedCreateWithoutBusinessTypeInput> | AdminRiskProfileCreateWithoutBusinessTypeInput[] | AdminRiskProfileUncheckedCreateWithoutBusinessTypeInput[]
    connectOrCreate?: AdminRiskProfileCreateOrConnectWithoutBusinessTypeInput | AdminRiskProfileCreateOrConnectWithoutBusinessTypeInput[]
    upsert?: AdminRiskProfileUpsertWithWhereUniqueWithoutBusinessTypeInput | AdminRiskProfileUpsertWithWhereUniqueWithoutBusinessTypeInput[]
    createMany?: AdminRiskProfileCreateManyBusinessTypeInputEnvelope
    set?: AdminRiskProfileWhereUniqueInput | AdminRiskProfileWhereUniqueInput[]
    disconnect?: AdminRiskProfileWhereUniqueInput | AdminRiskProfileWhereUniqueInput[]
    delete?: AdminRiskProfileWhereUniqueInput | AdminRiskProfileWhereUniqueInput[]
    connect?: AdminRiskProfileWhereUniqueInput | AdminRiskProfileWhereUniqueInput[]
    update?: AdminRiskProfileUpdateWithWhereUniqueWithoutBusinessTypeInput | AdminRiskProfileUpdateWithWhereUniqueWithoutBusinessTypeInput[]
    updateMany?: AdminRiskProfileUpdateManyWithWhereWithoutBusinessTypeInput | AdminRiskProfileUpdateManyWithWhereWithoutBusinessTypeInput[]
    deleteMany?: AdminRiskProfileScalarWhereInput | AdminRiskProfileScalarWhereInput[]
  }

  export type AdminBusinessTypeHazardCreateNestedManyWithoutHazardInput = {
    create?: XOR<AdminBusinessTypeHazardCreateWithoutHazardInput, AdminBusinessTypeHazardUncheckedCreateWithoutHazardInput> | AdminBusinessTypeHazardCreateWithoutHazardInput[] | AdminBusinessTypeHazardUncheckedCreateWithoutHazardInput[]
    connectOrCreate?: AdminBusinessTypeHazardCreateOrConnectWithoutHazardInput | AdminBusinessTypeHazardCreateOrConnectWithoutHazardInput[]
    createMany?: AdminBusinessTypeHazardCreateManyHazardInputEnvelope
    connect?: AdminBusinessTypeHazardWhereUniqueInput | AdminBusinessTypeHazardWhereUniqueInput[]
  }

  export type AdminLocationHazardCreateNestedManyWithoutHazardInput = {
    create?: XOR<AdminLocationHazardCreateWithoutHazardInput, AdminLocationHazardUncheckedCreateWithoutHazardInput> | AdminLocationHazardCreateWithoutHazardInput[] | AdminLocationHazardUncheckedCreateWithoutHazardInput[]
    connectOrCreate?: AdminLocationHazardCreateOrConnectWithoutHazardInput | AdminLocationHazardCreateOrConnectWithoutHazardInput[]
    createMany?: AdminLocationHazardCreateManyHazardInputEnvelope
    connect?: AdminLocationHazardWhereUniqueInput | AdminLocationHazardWhereUniqueInput[]
  }

  export type AdminHazardStrategyCreateNestedManyWithoutHazardInput = {
    create?: XOR<AdminHazardStrategyCreateWithoutHazardInput, AdminHazardStrategyUncheckedCreateWithoutHazardInput> | AdminHazardStrategyCreateWithoutHazardInput[] | AdminHazardStrategyUncheckedCreateWithoutHazardInput[]
    connectOrCreate?: AdminHazardStrategyCreateOrConnectWithoutHazardInput | AdminHazardStrategyCreateOrConnectWithoutHazardInput[]
    createMany?: AdminHazardStrategyCreateManyHazardInputEnvelope
    connect?: AdminHazardStrategyWhereUniqueInput | AdminHazardStrategyWhereUniqueInput[]
  }

  export type AdminHazardActionPlanCreateNestedManyWithoutHazardInput = {
    create?: XOR<AdminHazardActionPlanCreateWithoutHazardInput, AdminHazardActionPlanUncheckedCreateWithoutHazardInput> | AdminHazardActionPlanCreateWithoutHazardInput[] | AdminHazardActionPlanUncheckedCreateWithoutHazardInput[]
    connectOrCreate?: AdminHazardActionPlanCreateOrConnectWithoutHazardInput | AdminHazardActionPlanCreateOrConnectWithoutHazardInput[]
    createMany?: AdminHazardActionPlanCreateManyHazardInputEnvelope
    connect?: AdminHazardActionPlanWhereUniqueInput | AdminHazardActionPlanWhereUniqueInput[]
  }

  export type AdminActionPlanCreateNestedOneWithoutHazardInput = {
    create?: XOR<AdminActionPlanCreateWithoutHazardInput, AdminActionPlanUncheckedCreateWithoutHazardInput>
    connectOrCreate?: AdminActionPlanCreateOrConnectWithoutHazardInput
    connect?: AdminActionPlanWhereUniqueInput
  }

  export type HazardTranslationCreateNestedManyWithoutHazardInput = {
    create?: XOR<HazardTranslationCreateWithoutHazardInput, HazardTranslationUncheckedCreateWithoutHazardInput> | HazardTranslationCreateWithoutHazardInput[] | HazardTranslationUncheckedCreateWithoutHazardInput[]
    connectOrCreate?: HazardTranslationCreateOrConnectWithoutHazardInput | HazardTranslationCreateOrConnectWithoutHazardInput[]
    createMany?: HazardTranslationCreateManyHazardInputEnvelope
    connect?: HazardTranslationWhereUniqueInput | HazardTranslationWhereUniqueInput[]
  }

  export type AdminBusinessTypeHazardUncheckedCreateNestedManyWithoutHazardInput = {
    create?: XOR<AdminBusinessTypeHazardCreateWithoutHazardInput, AdminBusinessTypeHazardUncheckedCreateWithoutHazardInput> | AdminBusinessTypeHazardCreateWithoutHazardInput[] | AdminBusinessTypeHazardUncheckedCreateWithoutHazardInput[]
    connectOrCreate?: AdminBusinessTypeHazardCreateOrConnectWithoutHazardInput | AdminBusinessTypeHazardCreateOrConnectWithoutHazardInput[]
    createMany?: AdminBusinessTypeHazardCreateManyHazardInputEnvelope
    connect?: AdminBusinessTypeHazardWhereUniqueInput | AdminBusinessTypeHazardWhereUniqueInput[]
  }

  export type AdminLocationHazardUncheckedCreateNestedManyWithoutHazardInput = {
    create?: XOR<AdminLocationHazardCreateWithoutHazardInput, AdminLocationHazardUncheckedCreateWithoutHazardInput> | AdminLocationHazardCreateWithoutHazardInput[] | AdminLocationHazardUncheckedCreateWithoutHazardInput[]
    connectOrCreate?: AdminLocationHazardCreateOrConnectWithoutHazardInput | AdminLocationHazardCreateOrConnectWithoutHazardInput[]
    createMany?: AdminLocationHazardCreateManyHazardInputEnvelope
    connect?: AdminLocationHazardWhereUniqueInput | AdminLocationHazardWhereUniqueInput[]
  }

  export type AdminHazardStrategyUncheckedCreateNestedManyWithoutHazardInput = {
    create?: XOR<AdminHazardStrategyCreateWithoutHazardInput, AdminHazardStrategyUncheckedCreateWithoutHazardInput> | AdminHazardStrategyCreateWithoutHazardInput[] | AdminHazardStrategyUncheckedCreateWithoutHazardInput[]
    connectOrCreate?: AdminHazardStrategyCreateOrConnectWithoutHazardInput | AdminHazardStrategyCreateOrConnectWithoutHazardInput[]
    createMany?: AdminHazardStrategyCreateManyHazardInputEnvelope
    connect?: AdminHazardStrategyWhereUniqueInput | AdminHazardStrategyWhereUniqueInput[]
  }

  export type AdminHazardActionPlanUncheckedCreateNestedManyWithoutHazardInput = {
    create?: XOR<AdminHazardActionPlanCreateWithoutHazardInput, AdminHazardActionPlanUncheckedCreateWithoutHazardInput> | AdminHazardActionPlanCreateWithoutHazardInput[] | AdminHazardActionPlanUncheckedCreateWithoutHazardInput[]
    connectOrCreate?: AdminHazardActionPlanCreateOrConnectWithoutHazardInput | AdminHazardActionPlanCreateOrConnectWithoutHazardInput[]
    createMany?: AdminHazardActionPlanCreateManyHazardInputEnvelope
    connect?: AdminHazardActionPlanWhereUniqueInput | AdminHazardActionPlanWhereUniqueInput[]
  }

  export type AdminActionPlanUncheckedCreateNestedOneWithoutHazardInput = {
    create?: XOR<AdminActionPlanCreateWithoutHazardInput, AdminActionPlanUncheckedCreateWithoutHazardInput>
    connectOrCreate?: AdminActionPlanCreateOrConnectWithoutHazardInput
    connect?: AdminActionPlanWhereUniqueInput
  }

  export type HazardTranslationUncheckedCreateNestedManyWithoutHazardInput = {
    create?: XOR<HazardTranslationCreateWithoutHazardInput, HazardTranslationUncheckedCreateWithoutHazardInput> | HazardTranslationCreateWithoutHazardInput[] | HazardTranslationUncheckedCreateWithoutHazardInput[]
    connectOrCreate?: HazardTranslationCreateOrConnectWithoutHazardInput | HazardTranslationCreateOrConnectWithoutHazardInput[]
    createMany?: HazardTranslationCreateManyHazardInputEnvelope
    connect?: HazardTranslationWhereUniqueInput | HazardTranslationWhereUniqueInput[]
  }

  export type AdminBusinessTypeHazardUpdateManyWithoutHazardNestedInput = {
    create?: XOR<AdminBusinessTypeHazardCreateWithoutHazardInput, AdminBusinessTypeHazardUncheckedCreateWithoutHazardInput> | AdminBusinessTypeHazardCreateWithoutHazardInput[] | AdminBusinessTypeHazardUncheckedCreateWithoutHazardInput[]
    connectOrCreate?: AdminBusinessTypeHazardCreateOrConnectWithoutHazardInput | AdminBusinessTypeHazardCreateOrConnectWithoutHazardInput[]
    upsert?: AdminBusinessTypeHazardUpsertWithWhereUniqueWithoutHazardInput | AdminBusinessTypeHazardUpsertWithWhereUniqueWithoutHazardInput[]
    createMany?: AdminBusinessTypeHazardCreateManyHazardInputEnvelope
    set?: AdminBusinessTypeHazardWhereUniqueInput | AdminBusinessTypeHazardWhereUniqueInput[]
    disconnect?: AdminBusinessTypeHazardWhereUniqueInput | AdminBusinessTypeHazardWhereUniqueInput[]
    delete?: AdminBusinessTypeHazardWhereUniqueInput | AdminBusinessTypeHazardWhereUniqueInput[]
    connect?: AdminBusinessTypeHazardWhereUniqueInput | AdminBusinessTypeHazardWhereUniqueInput[]
    update?: AdminBusinessTypeHazardUpdateWithWhereUniqueWithoutHazardInput | AdminBusinessTypeHazardUpdateWithWhereUniqueWithoutHazardInput[]
    updateMany?: AdminBusinessTypeHazardUpdateManyWithWhereWithoutHazardInput | AdminBusinessTypeHazardUpdateManyWithWhereWithoutHazardInput[]
    deleteMany?: AdminBusinessTypeHazardScalarWhereInput | AdminBusinessTypeHazardScalarWhereInput[]
  }

  export type AdminLocationHazardUpdateManyWithoutHazardNestedInput = {
    create?: XOR<AdminLocationHazardCreateWithoutHazardInput, AdminLocationHazardUncheckedCreateWithoutHazardInput> | AdminLocationHazardCreateWithoutHazardInput[] | AdminLocationHazardUncheckedCreateWithoutHazardInput[]
    connectOrCreate?: AdminLocationHazardCreateOrConnectWithoutHazardInput | AdminLocationHazardCreateOrConnectWithoutHazardInput[]
    upsert?: AdminLocationHazardUpsertWithWhereUniqueWithoutHazardInput | AdminLocationHazardUpsertWithWhereUniqueWithoutHazardInput[]
    createMany?: AdminLocationHazardCreateManyHazardInputEnvelope
    set?: AdminLocationHazardWhereUniqueInput | AdminLocationHazardWhereUniqueInput[]
    disconnect?: AdminLocationHazardWhereUniqueInput | AdminLocationHazardWhereUniqueInput[]
    delete?: AdminLocationHazardWhereUniqueInput | AdminLocationHazardWhereUniqueInput[]
    connect?: AdminLocationHazardWhereUniqueInput | AdminLocationHazardWhereUniqueInput[]
    update?: AdminLocationHazardUpdateWithWhereUniqueWithoutHazardInput | AdminLocationHazardUpdateWithWhereUniqueWithoutHazardInput[]
    updateMany?: AdminLocationHazardUpdateManyWithWhereWithoutHazardInput | AdminLocationHazardUpdateManyWithWhereWithoutHazardInput[]
    deleteMany?: AdminLocationHazardScalarWhereInput | AdminLocationHazardScalarWhereInput[]
  }

  export type AdminHazardStrategyUpdateManyWithoutHazardNestedInput = {
    create?: XOR<AdminHazardStrategyCreateWithoutHazardInput, AdminHazardStrategyUncheckedCreateWithoutHazardInput> | AdminHazardStrategyCreateWithoutHazardInput[] | AdminHazardStrategyUncheckedCreateWithoutHazardInput[]
    connectOrCreate?: AdminHazardStrategyCreateOrConnectWithoutHazardInput | AdminHazardStrategyCreateOrConnectWithoutHazardInput[]
    upsert?: AdminHazardStrategyUpsertWithWhereUniqueWithoutHazardInput | AdminHazardStrategyUpsertWithWhereUniqueWithoutHazardInput[]
    createMany?: AdminHazardStrategyCreateManyHazardInputEnvelope
    set?: AdminHazardStrategyWhereUniqueInput | AdminHazardStrategyWhereUniqueInput[]
    disconnect?: AdminHazardStrategyWhereUniqueInput | AdminHazardStrategyWhereUniqueInput[]
    delete?: AdminHazardStrategyWhereUniqueInput | AdminHazardStrategyWhereUniqueInput[]
    connect?: AdminHazardStrategyWhereUniqueInput | AdminHazardStrategyWhereUniqueInput[]
    update?: AdminHazardStrategyUpdateWithWhereUniqueWithoutHazardInput | AdminHazardStrategyUpdateWithWhereUniqueWithoutHazardInput[]
    updateMany?: AdminHazardStrategyUpdateManyWithWhereWithoutHazardInput | AdminHazardStrategyUpdateManyWithWhereWithoutHazardInput[]
    deleteMany?: AdminHazardStrategyScalarWhereInput | AdminHazardStrategyScalarWhereInput[]
  }

  export type AdminHazardActionPlanUpdateManyWithoutHazardNestedInput = {
    create?: XOR<AdminHazardActionPlanCreateWithoutHazardInput, AdminHazardActionPlanUncheckedCreateWithoutHazardInput> | AdminHazardActionPlanCreateWithoutHazardInput[] | AdminHazardActionPlanUncheckedCreateWithoutHazardInput[]
    connectOrCreate?: AdminHazardActionPlanCreateOrConnectWithoutHazardInput | AdminHazardActionPlanCreateOrConnectWithoutHazardInput[]
    upsert?: AdminHazardActionPlanUpsertWithWhereUniqueWithoutHazardInput | AdminHazardActionPlanUpsertWithWhereUniqueWithoutHazardInput[]
    createMany?: AdminHazardActionPlanCreateManyHazardInputEnvelope
    set?: AdminHazardActionPlanWhereUniqueInput | AdminHazardActionPlanWhereUniqueInput[]
    disconnect?: AdminHazardActionPlanWhereUniqueInput | AdminHazardActionPlanWhereUniqueInput[]
    delete?: AdminHazardActionPlanWhereUniqueInput | AdminHazardActionPlanWhereUniqueInput[]
    connect?: AdminHazardActionPlanWhereUniqueInput | AdminHazardActionPlanWhereUniqueInput[]
    update?: AdminHazardActionPlanUpdateWithWhereUniqueWithoutHazardInput | AdminHazardActionPlanUpdateWithWhereUniqueWithoutHazardInput[]
    updateMany?: AdminHazardActionPlanUpdateManyWithWhereWithoutHazardInput | AdminHazardActionPlanUpdateManyWithWhereWithoutHazardInput[]
    deleteMany?: AdminHazardActionPlanScalarWhereInput | AdminHazardActionPlanScalarWhereInput[]
  }

  export type AdminActionPlanUpdateOneWithoutHazardNestedInput = {
    create?: XOR<AdminActionPlanCreateWithoutHazardInput, AdminActionPlanUncheckedCreateWithoutHazardInput>
    connectOrCreate?: AdminActionPlanCreateOrConnectWithoutHazardInput
    upsert?: AdminActionPlanUpsertWithoutHazardInput
    disconnect?: AdminActionPlanWhereInput | boolean
    delete?: AdminActionPlanWhereInput | boolean
    connect?: AdminActionPlanWhereUniqueInput
    update?: XOR<XOR<AdminActionPlanUpdateToOneWithWhereWithoutHazardInput, AdminActionPlanUpdateWithoutHazardInput>, AdminActionPlanUncheckedUpdateWithoutHazardInput>
  }

  export type HazardTranslationUpdateManyWithoutHazardNestedInput = {
    create?: XOR<HazardTranslationCreateWithoutHazardInput, HazardTranslationUncheckedCreateWithoutHazardInput> | HazardTranslationCreateWithoutHazardInput[] | HazardTranslationUncheckedCreateWithoutHazardInput[]
    connectOrCreate?: HazardTranslationCreateOrConnectWithoutHazardInput | HazardTranslationCreateOrConnectWithoutHazardInput[]
    upsert?: HazardTranslationUpsertWithWhereUniqueWithoutHazardInput | HazardTranslationUpsertWithWhereUniqueWithoutHazardInput[]
    createMany?: HazardTranslationCreateManyHazardInputEnvelope
    set?: HazardTranslationWhereUniqueInput | HazardTranslationWhereUniqueInput[]
    disconnect?: HazardTranslationWhereUniqueInput | HazardTranslationWhereUniqueInput[]
    delete?: HazardTranslationWhereUniqueInput | HazardTranslationWhereUniqueInput[]
    connect?: HazardTranslationWhereUniqueInput | HazardTranslationWhereUniqueInput[]
    update?: HazardTranslationUpdateWithWhereUniqueWithoutHazardInput | HazardTranslationUpdateWithWhereUniqueWithoutHazardInput[]
    updateMany?: HazardTranslationUpdateManyWithWhereWithoutHazardInput | HazardTranslationUpdateManyWithWhereWithoutHazardInput[]
    deleteMany?: HazardTranslationScalarWhereInput | HazardTranslationScalarWhereInput[]
  }

  export type AdminBusinessTypeHazardUncheckedUpdateManyWithoutHazardNestedInput = {
    create?: XOR<AdminBusinessTypeHazardCreateWithoutHazardInput, AdminBusinessTypeHazardUncheckedCreateWithoutHazardInput> | AdminBusinessTypeHazardCreateWithoutHazardInput[] | AdminBusinessTypeHazardUncheckedCreateWithoutHazardInput[]
    connectOrCreate?: AdminBusinessTypeHazardCreateOrConnectWithoutHazardInput | AdminBusinessTypeHazardCreateOrConnectWithoutHazardInput[]
    upsert?: AdminBusinessTypeHazardUpsertWithWhereUniqueWithoutHazardInput | AdminBusinessTypeHazardUpsertWithWhereUniqueWithoutHazardInput[]
    createMany?: AdminBusinessTypeHazardCreateManyHazardInputEnvelope
    set?: AdminBusinessTypeHazardWhereUniqueInput | AdminBusinessTypeHazardWhereUniqueInput[]
    disconnect?: AdminBusinessTypeHazardWhereUniqueInput | AdminBusinessTypeHazardWhereUniqueInput[]
    delete?: AdminBusinessTypeHazardWhereUniqueInput | AdminBusinessTypeHazardWhereUniqueInput[]
    connect?: AdminBusinessTypeHazardWhereUniqueInput | AdminBusinessTypeHazardWhereUniqueInput[]
    update?: AdminBusinessTypeHazardUpdateWithWhereUniqueWithoutHazardInput | AdminBusinessTypeHazardUpdateWithWhereUniqueWithoutHazardInput[]
    updateMany?: AdminBusinessTypeHazardUpdateManyWithWhereWithoutHazardInput | AdminBusinessTypeHazardUpdateManyWithWhereWithoutHazardInput[]
    deleteMany?: AdminBusinessTypeHazardScalarWhereInput | AdminBusinessTypeHazardScalarWhereInput[]
  }

  export type AdminLocationHazardUncheckedUpdateManyWithoutHazardNestedInput = {
    create?: XOR<AdminLocationHazardCreateWithoutHazardInput, AdminLocationHazardUncheckedCreateWithoutHazardInput> | AdminLocationHazardCreateWithoutHazardInput[] | AdminLocationHazardUncheckedCreateWithoutHazardInput[]
    connectOrCreate?: AdminLocationHazardCreateOrConnectWithoutHazardInput | AdminLocationHazardCreateOrConnectWithoutHazardInput[]
    upsert?: AdminLocationHazardUpsertWithWhereUniqueWithoutHazardInput | AdminLocationHazardUpsertWithWhereUniqueWithoutHazardInput[]
    createMany?: AdminLocationHazardCreateManyHazardInputEnvelope
    set?: AdminLocationHazardWhereUniqueInput | AdminLocationHazardWhereUniqueInput[]
    disconnect?: AdminLocationHazardWhereUniqueInput | AdminLocationHazardWhereUniqueInput[]
    delete?: AdminLocationHazardWhereUniqueInput | AdminLocationHazardWhereUniqueInput[]
    connect?: AdminLocationHazardWhereUniqueInput | AdminLocationHazardWhereUniqueInput[]
    update?: AdminLocationHazardUpdateWithWhereUniqueWithoutHazardInput | AdminLocationHazardUpdateWithWhereUniqueWithoutHazardInput[]
    updateMany?: AdminLocationHazardUpdateManyWithWhereWithoutHazardInput | AdminLocationHazardUpdateManyWithWhereWithoutHazardInput[]
    deleteMany?: AdminLocationHazardScalarWhereInput | AdminLocationHazardScalarWhereInput[]
  }

  export type AdminHazardStrategyUncheckedUpdateManyWithoutHazardNestedInput = {
    create?: XOR<AdminHazardStrategyCreateWithoutHazardInput, AdminHazardStrategyUncheckedCreateWithoutHazardInput> | AdminHazardStrategyCreateWithoutHazardInput[] | AdminHazardStrategyUncheckedCreateWithoutHazardInput[]
    connectOrCreate?: AdminHazardStrategyCreateOrConnectWithoutHazardInput | AdminHazardStrategyCreateOrConnectWithoutHazardInput[]
    upsert?: AdminHazardStrategyUpsertWithWhereUniqueWithoutHazardInput | AdminHazardStrategyUpsertWithWhereUniqueWithoutHazardInput[]
    createMany?: AdminHazardStrategyCreateManyHazardInputEnvelope
    set?: AdminHazardStrategyWhereUniqueInput | AdminHazardStrategyWhereUniqueInput[]
    disconnect?: AdminHazardStrategyWhereUniqueInput | AdminHazardStrategyWhereUniqueInput[]
    delete?: AdminHazardStrategyWhereUniqueInput | AdminHazardStrategyWhereUniqueInput[]
    connect?: AdminHazardStrategyWhereUniqueInput | AdminHazardStrategyWhereUniqueInput[]
    update?: AdminHazardStrategyUpdateWithWhereUniqueWithoutHazardInput | AdminHazardStrategyUpdateWithWhereUniqueWithoutHazardInput[]
    updateMany?: AdminHazardStrategyUpdateManyWithWhereWithoutHazardInput | AdminHazardStrategyUpdateManyWithWhereWithoutHazardInput[]
    deleteMany?: AdminHazardStrategyScalarWhereInput | AdminHazardStrategyScalarWhereInput[]
  }

  export type AdminHazardActionPlanUncheckedUpdateManyWithoutHazardNestedInput = {
    create?: XOR<AdminHazardActionPlanCreateWithoutHazardInput, AdminHazardActionPlanUncheckedCreateWithoutHazardInput> | AdminHazardActionPlanCreateWithoutHazardInput[] | AdminHazardActionPlanUncheckedCreateWithoutHazardInput[]
    connectOrCreate?: AdminHazardActionPlanCreateOrConnectWithoutHazardInput | AdminHazardActionPlanCreateOrConnectWithoutHazardInput[]
    upsert?: AdminHazardActionPlanUpsertWithWhereUniqueWithoutHazardInput | AdminHazardActionPlanUpsertWithWhereUniqueWithoutHazardInput[]
    createMany?: AdminHazardActionPlanCreateManyHazardInputEnvelope
    set?: AdminHazardActionPlanWhereUniqueInput | AdminHazardActionPlanWhereUniqueInput[]
    disconnect?: AdminHazardActionPlanWhereUniqueInput | AdminHazardActionPlanWhereUniqueInput[]
    delete?: AdminHazardActionPlanWhereUniqueInput | AdminHazardActionPlanWhereUniqueInput[]
    connect?: AdminHazardActionPlanWhereUniqueInput | AdminHazardActionPlanWhereUniqueInput[]
    update?: AdminHazardActionPlanUpdateWithWhereUniqueWithoutHazardInput | AdminHazardActionPlanUpdateWithWhereUniqueWithoutHazardInput[]
    updateMany?: AdminHazardActionPlanUpdateManyWithWhereWithoutHazardInput | AdminHazardActionPlanUpdateManyWithWhereWithoutHazardInput[]
    deleteMany?: AdminHazardActionPlanScalarWhereInput | AdminHazardActionPlanScalarWhereInput[]
  }

  export type AdminActionPlanUncheckedUpdateOneWithoutHazardNestedInput = {
    create?: XOR<AdminActionPlanCreateWithoutHazardInput, AdminActionPlanUncheckedCreateWithoutHazardInput>
    connectOrCreate?: AdminActionPlanCreateOrConnectWithoutHazardInput
    upsert?: AdminActionPlanUpsertWithoutHazardInput
    disconnect?: AdminActionPlanWhereInput | boolean
    delete?: AdminActionPlanWhereInput | boolean
    connect?: AdminActionPlanWhereUniqueInput
    update?: XOR<XOR<AdminActionPlanUpdateToOneWithWhereWithoutHazardInput, AdminActionPlanUpdateWithoutHazardInput>, AdminActionPlanUncheckedUpdateWithoutHazardInput>
  }

  export type HazardTranslationUncheckedUpdateManyWithoutHazardNestedInput = {
    create?: XOR<HazardTranslationCreateWithoutHazardInput, HazardTranslationUncheckedCreateWithoutHazardInput> | HazardTranslationCreateWithoutHazardInput[] | HazardTranslationUncheckedCreateWithoutHazardInput[]
    connectOrCreate?: HazardTranslationCreateOrConnectWithoutHazardInput | HazardTranslationCreateOrConnectWithoutHazardInput[]
    upsert?: HazardTranslationUpsertWithWhereUniqueWithoutHazardInput | HazardTranslationUpsertWithWhereUniqueWithoutHazardInput[]
    createMany?: HazardTranslationCreateManyHazardInputEnvelope
    set?: HazardTranslationWhereUniqueInput | HazardTranslationWhereUniqueInput[]
    disconnect?: HazardTranslationWhereUniqueInput | HazardTranslationWhereUniqueInput[]
    delete?: HazardTranslationWhereUniqueInput | HazardTranslationWhereUniqueInput[]
    connect?: HazardTranslationWhereUniqueInput | HazardTranslationWhereUniqueInput[]
    update?: HazardTranslationUpdateWithWhereUniqueWithoutHazardInput | HazardTranslationUpdateWithWhereUniqueWithoutHazardInput[]
    updateMany?: HazardTranslationUpdateManyWithWhereWithoutHazardInput | HazardTranslationUpdateManyWithWhereWithoutHazardInput[]
    deleteMany?: HazardTranslationScalarWhereInput | HazardTranslationScalarWhereInput[]
  }

  export type AdminLocationHazardCreateNestedManyWithoutLocationInput = {
    create?: XOR<AdminLocationHazardCreateWithoutLocationInput, AdminLocationHazardUncheckedCreateWithoutLocationInput> | AdminLocationHazardCreateWithoutLocationInput[] | AdminLocationHazardUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: AdminLocationHazardCreateOrConnectWithoutLocationInput | AdminLocationHazardCreateOrConnectWithoutLocationInput[]
    createMany?: AdminLocationHazardCreateManyLocationInputEnvelope
    connect?: AdminLocationHazardWhereUniqueInput | AdminLocationHazardWhereUniqueInput[]
  }

  export type AdminRiskProfileCreateNestedManyWithoutLocationInput = {
    create?: XOR<AdminRiskProfileCreateWithoutLocationInput, AdminRiskProfileUncheckedCreateWithoutLocationInput> | AdminRiskProfileCreateWithoutLocationInput[] | AdminRiskProfileUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: AdminRiskProfileCreateOrConnectWithoutLocationInput | AdminRiskProfileCreateOrConnectWithoutLocationInput[]
    createMany?: AdminRiskProfileCreateManyLocationInputEnvelope
    connect?: AdminRiskProfileWhereUniqueInput | AdminRiskProfileWhereUniqueInput[]
  }

  export type AdminLocationHazardUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<AdminLocationHazardCreateWithoutLocationInput, AdminLocationHazardUncheckedCreateWithoutLocationInput> | AdminLocationHazardCreateWithoutLocationInput[] | AdminLocationHazardUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: AdminLocationHazardCreateOrConnectWithoutLocationInput | AdminLocationHazardCreateOrConnectWithoutLocationInput[]
    createMany?: AdminLocationHazardCreateManyLocationInputEnvelope
    connect?: AdminLocationHazardWhereUniqueInput | AdminLocationHazardWhereUniqueInput[]
  }

  export type AdminRiskProfileUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<AdminRiskProfileCreateWithoutLocationInput, AdminRiskProfileUncheckedCreateWithoutLocationInput> | AdminRiskProfileCreateWithoutLocationInput[] | AdminRiskProfileUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: AdminRiskProfileCreateOrConnectWithoutLocationInput | AdminRiskProfileCreateOrConnectWithoutLocationInput[]
    createMany?: AdminRiskProfileCreateManyLocationInputEnvelope
    connect?: AdminRiskProfileWhereUniqueInput | AdminRiskProfileWhereUniqueInput[]
  }

  export type AdminLocationHazardUpdateManyWithoutLocationNestedInput = {
    create?: XOR<AdminLocationHazardCreateWithoutLocationInput, AdminLocationHazardUncheckedCreateWithoutLocationInput> | AdminLocationHazardCreateWithoutLocationInput[] | AdminLocationHazardUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: AdminLocationHazardCreateOrConnectWithoutLocationInput | AdminLocationHazardCreateOrConnectWithoutLocationInput[]
    upsert?: AdminLocationHazardUpsertWithWhereUniqueWithoutLocationInput | AdminLocationHazardUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: AdminLocationHazardCreateManyLocationInputEnvelope
    set?: AdminLocationHazardWhereUniqueInput | AdminLocationHazardWhereUniqueInput[]
    disconnect?: AdminLocationHazardWhereUniqueInput | AdminLocationHazardWhereUniqueInput[]
    delete?: AdminLocationHazardWhereUniqueInput | AdminLocationHazardWhereUniqueInput[]
    connect?: AdminLocationHazardWhereUniqueInput | AdminLocationHazardWhereUniqueInput[]
    update?: AdminLocationHazardUpdateWithWhereUniqueWithoutLocationInput | AdminLocationHazardUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: AdminLocationHazardUpdateManyWithWhereWithoutLocationInput | AdminLocationHazardUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: AdminLocationHazardScalarWhereInput | AdminLocationHazardScalarWhereInput[]
  }

  export type AdminRiskProfileUpdateManyWithoutLocationNestedInput = {
    create?: XOR<AdminRiskProfileCreateWithoutLocationInput, AdminRiskProfileUncheckedCreateWithoutLocationInput> | AdminRiskProfileCreateWithoutLocationInput[] | AdminRiskProfileUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: AdminRiskProfileCreateOrConnectWithoutLocationInput | AdminRiskProfileCreateOrConnectWithoutLocationInput[]
    upsert?: AdminRiskProfileUpsertWithWhereUniqueWithoutLocationInput | AdminRiskProfileUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: AdminRiskProfileCreateManyLocationInputEnvelope
    set?: AdminRiskProfileWhereUniqueInput | AdminRiskProfileWhereUniqueInput[]
    disconnect?: AdminRiskProfileWhereUniqueInput | AdminRiskProfileWhereUniqueInput[]
    delete?: AdminRiskProfileWhereUniqueInput | AdminRiskProfileWhereUniqueInput[]
    connect?: AdminRiskProfileWhereUniqueInput | AdminRiskProfileWhereUniqueInput[]
    update?: AdminRiskProfileUpdateWithWhereUniqueWithoutLocationInput | AdminRiskProfileUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: AdminRiskProfileUpdateManyWithWhereWithoutLocationInput | AdminRiskProfileUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: AdminRiskProfileScalarWhereInput | AdminRiskProfileScalarWhereInput[]
  }

  export type AdminLocationHazardUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<AdminLocationHazardCreateWithoutLocationInput, AdminLocationHazardUncheckedCreateWithoutLocationInput> | AdminLocationHazardCreateWithoutLocationInput[] | AdminLocationHazardUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: AdminLocationHazardCreateOrConnectWithoutLocationInput | AdminLocationHazardCreateOrConnectWithoutLocationInput[]
    upsert?: AdminLocationHazardUpsertWithWhereUniqueWithoutLocationInput | AdminLocationHazardUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: AdminLocationHazardCreateManyLocationInputEnvelope
    set?: AdminLocationHazardWhereUniqueInput | AdminLocationHazardWhereUniqueInput[]
    disconnect?: AdminLocationHazardWhereUniqueInput | AdminLocationHazardWhereUniqueInput[]
    delete?: AdminLocationHazardWhereUniqueInput | AdminLocationHazardWhereUniqueInput[]
    connect?: AdminLocationHazardWhereUniqueInput | AdminLocationHazardWhereUniqueInput[]
    update?: AdminLocationHazardUpdateWithWhereUniqueWithoutLocationInput | AdminLocationHazardUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: AdminLocationHazardUpdateManyWithWhereWithoutLocationInput | AdminLocationHazardUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: AdminLocationHazardScalarWhereInput | AdminLocationHazardScalarWhereInput[]
  }

  export type AdminRiskProfileUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<AdminRiskProfileCreateWithoutLocationInput, AdminRiskProfileUncheckedCreateWithoutLocationInput> | AdminRiskProfileCreateWithoutLocationInput[] | AdminRiskProfileUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: AdminRiskProfileCreateOrConnectWithoutLocationInput | AdminRiskProfileCreateOrConnectWithoutLocationInput[]
    upsert?: AdminRiskProfileUpsertWithWhereUniqueWithoutLocationInput | AdminRiskProfileUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: AdminRiskProfileCreateManyLocationInputEnvelope
    set?: AdminRiskProfileWhereUniqueInput | AdminRiskProfileWhereUniqueInput[]
    disconnect?: AdminRiskProfileWhereUniqueInput | AdminRiskProfileWhereUniqueInput[]
    delete?: AdminRiskProfileWhereUniqueInput | AdminRiskProfileWhereUniqueInput[]
    connect?: AdminRiskProfileWhereUniqueInput | AdminRiskProfileWhereUniqueInput[]
    update?: AdminRiskProfileUpdateWithWhereUniqueWithoutLocationInput | AdminRiskProfileUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: AdminRiskProfileUpdateManyWithWhereWithoutLocationInput | AdminRiskProfileUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: AdminRiskProfileScalarWhereInput | AdminRiskProfileScalarWhereInput[]
  }

  export type AdminBusinessTypeCreateNestedOneWithoutBusinessTypeHazardsInput = {
    create?: XOR<AdminBusinessTypeCreateWithoutBusinessTypeHazardsInput, AdminBusinessTypeUncheckedCreateWithoutBusinessTypeHazardsInput>
    connectOrCreate?: AdminBusinessTypeCreateOrConnectWithoutBusinessTypeHazardsInput
    connect?: AdminBusinessTypeWhereUniqueInput
  }

  export type AdminHazardTypeCreateNestedOneWithoutBusinessTypeHazardsInput = {
    create?: XOR<AdminHazardTypeCreateWithoutBusinessTypeHazardsInput, AdminHazardTypeUncheckedCreateWithoutBusinessTypeHazardsInput>
    connectOrCreate?: AdminHazardTypeCreateOrConnectWithoutBusinessTypeHazardsInput
    connect?: AdminHazardTypeWhereUniqueInput
  }

  export type AdminBusinessTypeUpdateOneRequiredWithoutBusinessTypeHazardsNestedInput = {
    create?: XOR<AdminBusinessTypeCreateWithoutBusinessTypeHazardsInput, AdminBusinessTypeUncheckedCreateWithoutBusinessTypeHazardsInput>
    connectOrCreate?: AdminBusinessTypeCreateOrConnectWithoutBusinessTypeHazardsInput
    upsert?: AdminBusinessTypeUpsertWithoutBusinessTypeHazardsInput
    connect?: AdminBusinessTypeWhereUniqueInput
    update?: XOR<XOR<AdminBusinessTypeUpdateToOneWithWhereWithoutBusinessTypeHazardsInput, AdminBusinessTypeUpdateWithoutBusinessTypeHazardsInput>, AdminBusinessTypeUncheckedUpdateWithoutBusinessTypeHazardsInput>
  }

  export type AdminHazardTypeUpdateOneRequiredWithoutBusinessTypeHazardsNestedInput = {
    create?: XOR<AdminHazardTypeCreateWithoutBusinessTypeHazardsInput, AdminHazardTypeUncheckedCreateWithoutBusinessTypeHazardsInput>
    connectOrCreate?: AdminHazardTypeCreateOrConnectWithoutBusinessTypeHazardsInput
    upsert?: AdminHazardTypeUpsertWithoutBusinessTypeHazardsInput
    connect?: AdminHazardTypeWhereUniqueInput
    update?: XOR<XOR<AdminHazardTypeUpdateToOneWithWhereWithoutBusinessTypeHazardsInput, AdminHazardTypeUpdateWithoutBusinessTypeHazardsInput>, AdminHazardTypeUncheckedUpdateWithoutBusinessTypeHazardsInput>
  }

  export type AdminLocationCreateNestedOneWithoutLocationHazardsInput = {
    create?: XOR<AdminLocationCreateWithoutLocationHazardsInput, AdminLocationUncheckedCreateWithoutLocationHazardsInput>
    connectOrCreate?: AdminLocationCreateOrConnectWithoutLocationHazardsInput
    connect?: AdminLocationWhereUniqueInput
  }

  export type AdminHazardTypeCreateNestedOneWithoutLocationHazardsInput = {
    create?: XOR<AdminHazardTypeCreateWithoutLocationHazardsInput, AdminHazardTypeUncheckedCreateWithoutLocationHazardsInput>
    connectOrCreate?: AdminHazardTypeCreateOrConnectWithoutLocationHazardsInput
    connect?: AdminHazardTypeWhereUniqueInput
  }

  export type AdminLocationUpdateOneRequiredWithoutLocationHazardsNestedInput = {
    create?: XOR<AdminLocationCreateWithoutLocationHazardsInput, AdminLocationUncheckedCreateWithoutLocationHazardsInput>
    connectOrCreate?: AdminLocationCreateOrConnectWithoutLocationHazardsInput
    upsert?: AdminLocationUpsertWithoutLocationHazardsInput
    connect?: AdminLocationWhereUniqueInput
    update?: XOR<XOR<AdminLocationUpdateToOneWithWhereWithoutLocationHazardsInput, AdminLocationUpdateWithoutLocationHazardsInput>, AdminLocationUncheckedUpdateWithoutLocationHazardsInput>
  }

  export type AdminHazardTypeUpdateOneRequiredWithoutLocationHazardsNestedInput = {
    create?: XOR<AdminHazardTypeCreateWithoutLocationHazardsInput, AdminHazardTypeUncheckedCreateWithoutLocationHazardsInput>
    connectOrCreate?: AdminHazardTypeCreateOrConnectWithoutLocationHazardsInput
    upsert?: AdminHazardTypeUpsertWithoutLocationHazardsInput
    connect?: AdminHazardTypeWhereUniqueInput
    update?: XOR<XOR<AdminHazardTypeUpdateToOneWithWhereWithoutLocationHazardsInput, AdminHazardTypeUpdateWithoutLocationHazardsInput>, AdminHazardTypeUncheckedUpdateWithoutLocationHazardsInput>
  }

  export type AdminHazardStrategyCreateNestedManyWithoutStrategyInput = {
    create?: XOR<AdminHazardStrategyCreateWithoutStrategyInput, AdminHazardStrategyUncheckedCreateWithoutStrategyInput> | AdminHazardStrategyCreateWithoutStrategyInput[] | AdminHazardStrategyUncheckedCreateWithoutStrategyInput[]
    connectOrCreate?: AdminHazardStrategyCreateOrConnectWithoutStrategyInput | AdminHazardStrategyCreateOrConnectWithoutStrategyInput[]
    createMany?: AdminHazardStrategyCreateManyStrategyInputEnvelope
    connect?: AdminHazardStrategyWhereUniqueInput | AdminHazardStrategyWhereUniqueInput[]
  }

  export type AdminHazardStrategyUncheckedCreateNestedManyWithoutStrategyInput = {
    create?: XOR<AdminHazardStrategyCreateWithoutStrategyInput, AdminHazardStrategyUncheckedCreateWithoutStrategyInput> | AdminHazardStrategyCreateWithoutStrategyInput[] | AdminHazardStrategyUncheckedCreateWithoutStrategyInput[]
    connectOrCreate?: AdminHazardStrategyCreateOrConnectWithoutStrategyInput | AdminHazardStrategyCreateOrConnectWithoutStrategyInput[]
    createMany?: AdminHazardStrategyCreateManyStrategyInputEnvelope
    connect?: AdminHazardStrategyWhereUniqueInput | AdminHazardStrategyWhereUniqueInput[]
  }

  export type AdminHazardStrategyUpdateManyWithoutStrategyNestedInput = {
    create?: XOR<AdminHazardStrategyCreateWithoutStrategyInput, AdminHazardStrategyUncheckedCreateWithoutStrategyInput> | AdminHazardStrategyCreateWithoutStrategyInput[] | AdminHazardStrategyUncheckedCreateWithoutStrategyInput[]
    connectOrCreate?: AdminHazardStrategyCreateOrConnectWithoutStrategyInput | AdminHazardStrategyCreateOrConnectWithoutStrategyInput[]
    upsert?: AdminHazardStrategyUpsertWithWhereUniqueWithoutStrategyInput | AdminHazardStrategyUpsertWithWhereUniqueWithoutStrategyInput[]
    createMany?: AdminHazardStrategyCreateManyStrategyInputEnvelope
    set?: AdminHazardStrategyWhereUniqueInput | AdminHazardStrategyWhereUniqueInput[]
    disconnect?: AdminHazardStrategyWhereUniqueInput | AdminHazardStrategyWhereUniqueInput[]
    delete?: AdminHazardStrategyWhereUniqueInput | AdminHazardStrategyWhereUniqueInput[]
    connect?: AdminHazardStrategyWhereUniqueInput | AdminHazardStrategyWhereUniqueInput[]
    update?: AdminHazardStrategyUpdateWithWhereUniqueWithoutStrategyInput | AdminHazardStrategyUpdateWithWhereUniqueWithoutStrategyInput[]
    updateMany?: AdminHazardStrategyUpdateManyWithWhereWithoutStrategyInput | AdminHazardStrategyUpdateManyWithWhereWithoutStrategyInput[]
    deleteMany?: AdminHazardStrategyScalarWhereInput | AdminHazardStrategyScalarWhereInput[]
  }

  export type AdminHazardStrategyUncheckedUpdateManyWithoutStrategyNestedInput = {
    create?: XOR<AdminHazardStrategyCreateWithoutStrategyInput, AdminHazardStrategyUncheckedCreateWithoutStrategyInput> | AdminHazardStrategyCreateWithoutStrategyInput[] | AdminHazardStrategyUncheckedCreateWithoutStrategyInput[]
    connectOrCreate?: AdminHazardStrategyCreateOrConnectWithoutStrategyInput | AdminHazardStrategyCreateOrConnectWithoutStrategyInput[]
    upsert?: AdminHazardStrategyUpsertWithWhereUniqueWithoutStrategyInput | AdminHazardStrategyUpsertWithWhereUniqueWithoutStrategyInput[]
    createMany?: AdminHazardStrategyCreateManyStrategyInputEnvelope
    set?: AdminHazardStrategyWhereUniqueInput | AdminHazardStrategyWhereUniqueInput[]
    disconnect?: AdminHazardStrategyWhereUniqueInput | AdminHazardStrategyWhereUniqueInput[]
    delete?: AdminHazardStrategyWhereUniqueInput | AdminHazardStrategyWhereUniqueInput[]
    connect?: AdminHazardStrategyWhereUniqueInput | AdminHazardStrategyWhereUniqueInput[]
    update?: AdminHazardStrategyUpdateWithWhereUniqueWithoutStrategyInput | AdminHazardStrategyUpdateWithWhereUniqueWithoutStrategyInput[]
    updateMany?: AdminHazardStrategyUpdateManyWithWhereWithoutStrategyInput | AdminHazardStrategyUpdateManyWithWhereWithoutStrategyInput[]
    deleteMany?: AdminHazardStrategyScalarWhereInput | AdminHazardStrategyScalarWhereInput[]
  }

  export type AdminHazardTypeCreateNestedOneWithoutHazardStrategiesInput = {
    create?: XOR<AdminHazardTypeCreateWithoutHazardStrategiesInput, AdminHazardTypeUncheckedCreateWithoutHazardStrategiesInput>
    connectOrCreate?: AdminHazardTypeCreateOrConnectWithoutHazardStrategiesInput
    connect?: AdminHazardTypeWhereUniqueInput
  }

  export type AdminStrategyCreateNestedOneWithoutHazardStrategiesInput = {
    create?: XOR<AdminStrategyCreateWithoutHazardStrategiesInput, AdminStrategyUncheckedCreateWithoutHazardStrategiesInput>
    connectOrCreate?: AdminStrategyCreateOrConnectWithoutHazardStrategiesInput
    connect?: AdminStrategyWhereUniqueInput
  }

  export type AdminHazardTypeUpdateOneRequiredWithoutHazardStrategiesNestedInput = {
    create?: XOR<AdminHazardTypeCreateWithoutHazardStrategiesInput, AdminHazardTypeUncheckedCreateWithoutHazardStrategiesInput>
    connectOrCreate?: AdminHazardTypeCreateOrConnectWithoutHazardStrategiesInput
    upsert?: AdminHazardTypeUpsertWithoutHazardStrategiesInput
    connect?: AdminHazardTypeWhereUniqueInput
    update?: XOR<XOR<AdminHazardTypeUpdateToOneWithWhereWithoutHazardStrategiesInput, AdminHazardTypeUpdateWithoutHazardStrategiesInput>, AdminHazardTypeUncheckedUpdateWithoutHazardStrategiesInput>
  }

  export type AdminStrategyUpdateOneRequiredWithoutHazardStrategiesNestedInput = {
    create?: XOR<AdminStrategyCreateWithoutHazardStrategiesInput, AdminStrategyUncheckedCreateWithoutHazardStrategiesInput>
    connectOrCreate?: AdminStrategyCreateOrConnectWithoutHazardStrategiesInput
    upsert?: AdminStrategyUpsertWithoutHazardStrategiesInput
    connect?: AdminStrategyWhereUniqueInput
    update?: XOR<XOR<AdminStrategyUpdateToOneWithWhereWithoutHazardStrategiesInput, AdminStrategyUpdateWithoutHazardStrategiesInput>, AdminStrategyUncheckedUpdateWithoutHazardStrategiesInput>
  }

  export type AdminHazardTypeCreateNestedOneWithoutAdminActionPlanInput = {
    create?: XOR<AdminHazardTypeCreateWithoutAdminActionPlanInput, AdminHazardTypeUncheckedCreateWithoutAdminActionPlanInput>
    connectOrCreate?: AdminHazardTypeCreateOrConnectWithoutAdminActionPlanInput
    connect?: AdminHazardTypeWhereUniqueInput
  }

  export type AdminHazardActionPlanCreateNestedManyWithoutActionPlanInput = {
    create?: XOR<AdminHazardActionPlanCreateWithoutActionPlanInput, AdminHazardActionPlanUncheckedCreateWithoutActionPlanInput> | AdminHazardActionPlanCreateWithoutActionPlanInput[] | AdminHazardActionPlanUncheckedCreateWithoutActionPlanInput[]
    connectOrCreate?: AdminHazardActionPlanCreateOrConnectWithoutActionPlanInput | AdminHazardActionPlanCreateOrConnectWithoutActionPlanInput[]
    createMany?: AdminHazardActionPlanCreateManyActionPlanInputEnvelope
    connect?: AdminHazardActionPlanWhereUniqueInput | AdminHazardActionPlanWhereUniqueInput[]
  }

  export type AdminHazardActionPlanUncheckedCreateNestedManyWithoutActionPlanInput = {
    create?: XOR<AdminHazardActionPlanCreateWithoutActionPlanInput, AdminHazardActionPlanUncheckedCreateWithoutActionPlanInput> | AdminHazardActionPlanCreateWithoutActionPlanInput[] | AdminHazardActionPlanUncheckedCreateWithoutActionPlanInput[]
    connectOrCreate?: AdminHazardActionPlanCreateOrConnectWithoutActionPlanInput | AdminHazardActionPlanCreateOrConnectWithoutActionPlanInput[]
    createMany?: AdminHazardActionPlanCreateManyActionPlanInputEnvelope
    connect?: AdminHazardActionPlanWhereUniqueInput | AdminHazardActionPlanWhereUniqueInput[]
  }

  export type AdminHazardTypeUpdateOneRequiredWithoutAdminActionPlanNestedInput = {
    create?: XOR<AdminHazardTypeCreateWithoutAdminActionPlanInput, AdminHazardTypeUncheckedCreateWithoutAdminActionPlanInput>
    connectOrCreate?: AdminHazardTypeCreateOrConnectWithoutAdminActionPlanInput
    upsert?: AdminHazardTypeUpsertWithoutAdminActionPlanInput
    connect?: AdminHazardTypeWhereUniqueInput
    update?: XOR<XOR<AdminHazardTypeUpdateToOneWithWhereWithoutAdminActionPlanInput, AdminHazardTypeUpdateWithoutAdminActionPlanInput>, AdminHazardTypeUncheckedUpdateWithoutAdminActionPlanInput>
  }

  export type AdminHazardActionPlanUpdateManyWithoutActionPlanNestedInput = {
    create?: XOR<AdminHazardActionPlanCreateWithoutActionPlanInput, AdminHazardActionPlanUncheckedCreateWithoutActionPlanInput> | AdminHazardActionPlanCreateWithoutActionPlanInput[] | AdminHazardActionPlanUncheckedCreateWithoutActionPlanInput[]
    connectOrCreate?: AdminHazardActionPlanCreateOrConnectWithoutActionPlanInput | AdminHazardActionPlanCreateOrConnectWithoutActionPlanInput[]
    upsert?: AdminHazardActionPlanUpsertWithWhereUniqueWithoutActionPlanInput | AdminHazardActionPlanUpsertWithWhereUniqueWithoutActionPlanInput[]
    createMany?: AdminHazardActionPlanCreateManyActionPlanInputEnvelope
    set?: AdminHazardActionPlanWhereUniqueInput | AdminHazardActionPlanWhereUniqueInput[]
    disconnect?: AdminHazardActionPlanWhereUniqueInput | AdminHazardActionPlanWhereUniqueInput[]
    delete?: AdminHazardActionPlanWhereUniqueInput | AdminHazardActionPlanWhereUniqueInput[]
    connect?: AdminHazardActionPlanWhereUniqueInput | AdminHazardActionPlanWhereUniqueInput[]
    update?: AdminHazardActionPlanUpdateWithWhereUniqueWithoutActionPlanInput | AdminHazardActionPlanUpdateWithWhereUniqueWithoutActionPlanInput[]
    updateMany?: AdminHazardActionPlanUpdateManyWithWhereWithoutActionPlanInput | AdminHazardActionPlanUpdateManyWithWhereWithoutActionPlanInput[]
    deleteMany?: AdminHazardActionPlanScalarWhereInput | AdminHazardActionPlanScalarWhereInput[]
  }

  export type AdminHazardActionPlanUncheckedUpdateManyWithoutActionPlanNestedInput = {
    create?: XOR<AdminHazardActionPlanCreateWithoutActionPlanInput, AdminHazardActionPlanUncheckedCreateWithoutActionPlanInput> | AdminHazardActionPlanCreateWithoutActionPlanInput[] | AdminHazardActionPlanUncheckedCreateWithoutActionPlanInput[]
    connectOrCreate?: AdminHazardActionPlanCreateOrConnectWithoutActionPlanInput | AdminHazardActionPlanCreateOrConnectWithoutActionPlanInput[]
    upsert?: AdminHazardActionPlanUpsertWithWhereUniqueWithoutActionPlanInput | AdminHazardActionPlanUpsertWithWhereUniqueWithoutActionPlanInput[]
    createMany?: AdminHazardActionPlanCreateManyActionPlanInputEnvelope
    set?: AdminHazardActionPlanWhereUniqueInput | AdminHazardActionPlanWhereUniqueInput[]
    disconnect?: AdminHazardActionPlanWhereUniqueInput | AdminHazardActionPlanWhereUniqueInput[]
    delete?: AdminHazardActionPlanWhereUniqueInput | AdminHazardActionPlanWhereUniqueInput[]
    connect?: AdminHazardActionPlanWhereUniqueInput | AdminHazardActionPlanWhereUniqueInput[]
    update?: AdminHazardActionPlanUpdateWithWhereUniqueWithoutActionPlanInput | AdminHazardActionPlanUpdateWithWhereUniqueWithoutActionPlanInput[]
    updateMany?: AdminHazardActionPlanUpdateManyWithWhereWithoutActionPlanInput | AdminHazardActionPlanUpdateManyWithWhereWithoutActionPlanInput[]
    deleteMany?: AdminHazardActionPlanScalarWhereInput | AdminHazardActionPlanScalarWhereInput[]
  }

  export type AdminHazardTypeCreateNestedOneWithoutHazardActionPlansInput = {
    create?: XOR<AdminHazardTypeCreateWithoutHazardActionPlansInput, AdminHazardTypeUncheckedCreateWithoutHazardActionPlansInput>
    connectOrCreate?: AdminHazardTypeCreateOrConnectWithoutHazardActionPlansInput
    connect?: AdminHazardTypeWhereUniqueInput
  }

  export type AdminActionPlanCreateNestedOneWithoutAdminHazardActionPlanInput = {
    create?: XOR<AdminActionPlanCreateWithoutAdminHazardActionPlanInput, AdminActionPlanUncheckedCreateWithoutAdminHazardActionPlanInput>
    connectOrCreate?: AdminActionPlanCreateOrConnectWithoutAdminHazardActionPlanInput
    connect?: AdminActionPlanWhereUniqueInput
  }

  export type AdminHazardTypeUpdateOneRequiredWithoutHazardActionPlansNestedInput = {
    create?: XOR<AdminHazardTypeCreateWithoutHazardActionPlansInput, AdminHazardTypeUncheckedCreateWithoutHazardActionPlansInput>
    connectOrCreate?: AdminHazardTypeCreateOrConnectWithoutHazardActionPlansInput
    upsert?: AdminHazardTypeUpsertWithoutHazardActionPlansInput
    connect?: AdminHazardTypeWhereUniqueInput
    update?: XOR<XOR<AdminHazardTypeUpdateToOneWithWhereWithoutHazardActionPlansInput, AdminHazardTypeUpdateWithoutHazardActionPlansInput>, AdminHazardTypeUncheckedUpdateWithoutHazardActionPlansInput>
  }

  export type AdminActionPlanUpdateOneRequiredWithoutAdminHazardActionPlanNestedInput = {
    create?: XOR<AdminActionPlanCreateWithoutAdminHazardActionPlanInput, AdminActionPlanUncheckedCreateWithoutAdminHazardActionPlanInput>
    connectOrCreate?: AdminActionPlanCreateOrConnectWithoutAdminHazardActionPlanInput
    upsert?: AdminActionPlanUpsertWithoutAdminHazardActionPlanInput
    connect?: AdminActionPlanWhereUniqueInput
    update?: XOR<XOR<AdminActionPlanUpdateToOneWithWhereWithoutAdminHazardActionPlanInput, AdminActionPlanUpdateWithoutAdminHazardActionPlanInput>, AdminActionPlanUncheckedUpdateWithoutAdminHazardActionPlanInput>
  }

  export type AdminBusinessTypeCreateNestedOneWithoutRiskProfilesInput = {
    create?: XOR<AdminBusinessTypeCreateWithoutRiskProfilesInput, AdminBusinessTypeUncheckedCreateWithoutRiskProfilesInput>
    connectOrCreate?: AdminBusinessTypeCreateOrConnectWithoutRiskProfilesInput
    connect?: AdminBusinessTypeWhereUniqueInput
  }

  export type AdminLocationCreateNestedOneWithoutRiskProfilesInput = {
    create?: XOR<AdminLocationCreateWithoutRiskProfilesInput, AdminLocationUncheckedCreateWithoutRiskProfilesInput>
    connectOrCreate?: AdminLocationCreateOrConnectWithoutRiskProfilesInput
    connect?: AdminLocationWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AdminBusinessTypeUpdateOneRequiredWithoutRiskProfilesNestedInput = {
    create?: XOR<AdminBusinessTypeCreateWithoutRiskProfilesInput, AdminBusinessTypeUncheckedCreateWithoutRiskProfilesInput>
    connectOrCreate?: AdminBusinessTypeCreateOrConnectWithoutRiskProfilesInput
    upsert?: AdminBusinessTypeUpsertWithoutRiskProfilesInput
    connect?: AdminBusinessTypeWhereUniqueInput
    update?: XOR<XOR<AdminBusinessTypeUpdateToOneWithWhereWithoutRiskProfilesInput, AdminBusinessTypeUpdateWithoutRiskProfilesInput>, AdminBusinessTypeUncheckedUpdateWithoutRiskProfilesInput>
  }

  export type AdminLocationUpdateOneRequiredWithoutRiskProfilesNestedInput = {
    create?: XOR<AdminLocationCreateWithoutRiskProfilesInput, AdminLocationUncheckedCreateWithoutRiskProfilesInput>
    connectOrCreate?: AdminLocationCreateOrConnectWithoutRiskProfilesInput
    upsert?: AdminLocationUpsertWithoutRiskProfilesInput
    connect?: AdminLocationWhereUniqueInput
    update?: XOR<XOR<AdminLocationUpdateToOneWithWhereWithoutRiskProfilesInput, AdminLocationUpdateWithoutRiskProfilesInput>, AdminLocationUncheckedUpdateWithoutRiskProfilesInput>
  }

  export type AdminUnitCreateNestedManyWithoutCountryInput = {
    create?: XOR<AdminUnitCreateWithoutCountryInput, AdminUnitUncheckedCreateWithoutCountryInput> | AdminUnitCreateWithoutCountryInput[] | AdminUnitUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: AdminUnitCreateOrConnectWithoutCountryInput | AdminUnitCreateOrConnectWithoutCountryInput[]
    createMany?: AdminUnitCreateManyCountryInputEnvelope
    connect?: AdminUnitWhereUniqueInput | AdminUnitWhereUniqueInput[]
  }

  export type AdminUnitUncheckedCreateNestedManyWithoutCountryInput = {
    create?: XOR<AdminUnitCreateWithoutCountryInput, AdminUnitUncheckedCreateWithoutCountryInput> | AdminUnitCreateWithoutCountryInput[] | AdminUnitUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: AdminUnitCreateOrConnectWithoutCountryInput | AdminUnitCreateOrConnectWithoutCountryInput[]
    createMany?: AdminUnitCreateManyCountryInputEnvelope
    connect?: AdminUnitWhereUniqueInput | AdminUnitWhereUniqueInput[]
  }

  export type AdminUnitUpdateManyWithoutCountryNestedInput = {
    create?: XOR<AdminUnitCreateWithoutCountryInput, AdminUnitUncheckedCreateWithoutCountryInput> | AdminUnitCreateWithoutCountryInput[] | AdminUnitUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: AdminUnitCreateOrConnectWithoutCountryInput | AdminUnitCreateOrConnectWithoutCountryInput[]
    upsert?: AdminUnitUpsertWithWhereUniqueWithoutCountryInput | AdminUnitUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: AdminUnitCreateManyCountryInputEnvelope
    set?: AdminUnitWhereUniqueInput | AdminUnitWhereUniqueInput[]
    disconnect?: AdminUnitWhereUniqueInput | AdminUnitWhereUniqueInput[]
    delete?: AdminUnitWhereUniqueInput | AdminUnitWhereUniqueInput[]
    connect?: AdminUnitWhereUniqueInput | AdminUnitWhereUniqueInput[]
    update?: AdminUnitUpdateWithWhereUniqueWithoutCountryInput | AdminUnitUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: AdminUnitUpdateManyWithWhereWithoutCountryInput | AdminUnitUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: AdminUnitScalarWhereInput | AdminUnitScalarWhereInput[]
  }

  export type AdminUnitUncheckedUpdateManyWithoutCountryNestedInput = {
    create?: XOR<AdminUnitCreateWithoutCountryInput, AdminUnitUncheckedCreateWithoutCountryInput> | AdminUnitCreateWithoutCountryInput[] | AdminUnitUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: AdminUnitCreateOrConnectWithoutCountryInput | AdminUnitCreateOrConnectWithoutCountryInput[]
    upsert?: AdminUnitUpsertWithWhereUniqueWithoutCountryInput | AdminUnitUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: AdminUnitCreateManyCountryInputEnvelope
    set?: AdminUnitWhereUniqueInput | AdminUnitWhereUniqueInput[]
    disconnect?: AdminUnitWhereUniqueInput | AdminUnitWhereUniqueInput[]
    delete?: AdminUnitWhereUniqueInput | AdminUnitWhereUniqueInput[]
    connect?: AdminUnitWhereUniqueInput | AdminUnitWhereUniqueInput[]
    update?: AdminUnitUpdateWithWhereUniqueWithoutCountryInput | AdminUnitUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: AdminUnitUpdateManyWithWhereWithoutCountryInput | AdminUnitUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: AdminUnitScalarWhereInput | AdminUnitScalarWhereInput[]
  }

  export type CountryCreateNestedOneWithoutAdminUnitsInput = {
    create?: XOR<CountryCreateWithoutAdminUnitsInput, CountryUncheckedCreateWithoutAdminUnitsInput>
    connectOrCreate?: CountryCreateOrConnectWithoutAdminUnitsInput
    connect?: CountryWhereUniqueInput
  }

  export type AdminUnitRiskCreateNestedOneWithoutAdminUnitInput = {
    create?: XOR<AdminUnitRiskCreateWithoutAdminUnitInput, AdminUnitRiskUncheckedCreateWithoutAdminUnitInput>
    connectOrCreate?: AdminUnitRiskCreateOrConnectWithoutAdminUnitInput
    connect?: AdminUnitRiskWhereUniqueInput
  }

  export type AdminUnitRiskUncheckedCreateNestedOneWithoutAdminUnitInput = {
    create?: XOR<AdminUnitRiskCreateWithoutAdminUnitInput, AdminUnitRiskUncheckedCreateWithoutAdminUnitInput>
    connectOrCreate?: AdminUnitRiskCreateOrConnectWithoutAdminUnitInput
    connect?: AdminUnitRiskWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CountryUpdateOneRequiredWithoutAdminUnitsNestedInput = {
    create?: XOR<CountryCreateWithoutAdminUnitsInput, CountryUncheckedCreateWithoutAdminUnitsInput>
    connectOrCreate?: CountryCreateOrConnectWithoutAdminUnitsInput
    upsert?: CountryUpsertWithoutAdminUnitsInput
    connect?: CountryWhereUniqueInput
    update?: XOR<XOR<CountryUpdateToOneWithWhereWithoutAdminUnitsInput, CountryUpdateWithoutAdminUnitsInput>, CountryUncheckedUpdateWithoutAdminUnitsInput>
  }

  export type AdminUnitRiskUpdateOneWithoutAdminUnitNestedInput = {
    create?: XOR<AdminUnitRiskCreateWithoutAdminUnitInput, AdminUnitRiskUncheckedCreateWithoutAdminUnitInput>
    connectOrCreate?: AdminUnitRiskCreateOrConnectWithoutAdminUnitInput
    upsert?: AdminUnitRiskUpsertWithoutAdminUnitInput
    disconnect?: AdminUnitRiskWhereInput | boolean
    delete?: AdminUnitRiskWhereInput | boolean
    connect?: AdminUnitRiskWhereUniqueInput
    update?: XOR<XOR<AdminUnitRiskUpdateToOneWithWhereWithoutAdminUnitInput, AdminUnitRiskUpdateWithoutAdminUnitInput>, AdminUnitRiskUncheckedUpdateWithoutAdminUnitInput>
  }

  export type AdminUnitRiskUncheckedUpdateOneWithoutAdminUnitNestedInput = {
    create?: XOR<AdminUnitRiskCreateWithoutAdminUnitInput, AdminUnitRiskUncheckedCreateWithoutAdminUnitInput>
    connectOrCreate?: AdminUnitRiskCreateOrConnectWithoutAdminUnitInput
    upsert?: AdminUnitRiskUpsertWithoutAdminUnitInput
    disconnect?: AdminUnitRiskWhereInput | boolean
    delete?: AdminUnitRiskWhereInput | boolean
    connect?: AdminUnitRiskWhereUniqueInput
    update?: XOR<XOR<AdminUnitRiskUpdateToOneWithWhereWithoutAdminUnitInput, AdminUnitRiskUpdateWithoutAdminUnitInput>, AdminUnitRiskUncheckedUpdateWithoutAdminUnitInput>
  }

  export type ParishRiskCreateNestedOneWithoutParishInput = {
    create?: XOR<ParishRiskCreateWithoutParishInput, ParishRiskUncheckedCreateWithoutParishInput>
    connectOrCreate?: ParishRiskCreateOrConnectWithoutParishInput
    connect?: ParishRiskWhereUniqueInput
  }

  export type BusinessRiskProfileCreateNestedManyWithoutParishInput = {
    create?: XOR<BusinessRiskProfileCreateWithoutParishInput, BusinessRiskProfileUncheckedCreateWithoutParishInput> | BusinessRiskProfileCreateWithoutParishInput[] | BusinessRiskProfileUncheckedCreateWithoutParishInput[]
    connectOrCreate?: BusinessRiskProfileCreateOrConnectWithoutParishInput | BusinessRiskProfileCreateOrConnectWithoutParishInput[]
    createMany?: BusinessRiskProfileCreateManyParishInputEnvelope
    connect?: BusinessRiskProfileWhereUniqueInput | BusinessRiskProfileWhereUniqueInput[]
  }

  export type ParishRiskUncheckedCreateNestedOneWithoutParishInput = {
    create?: XOR<ParishRiskCreateWithoutParishInput, ParishRiskUncheckedCreateWithoutParishInput>
    connectOrCreate?: ParishRiskCreateOrConnectWithoutParishInput
    connect?: ParishRiskWhereUniqueInput
  }

  export type BusinessRiskProfileUncheckedCreateNestedManyWithoutParishInput = {
    create?: XOR<BusinessRiskProfileCreateWithoutParishInput, BusinessRiskProfileUncheckedCreateWithoutParishInput> | BusinessRiskProfileCreateWithoutParishInput[] | BusinessRiskProfileUncheckedCreateWithoutParishInput[]
    connectOrCreate?: BusinessRiskProfileCreateOrConnectWithoutParishInput | BusinessRiskProfileCreateOrConnectWithoutParishInput[]
    createMany?: BusinessRiskProfileCreateManyParishInputEnvelope
    connect?: BusinessRiskProfileWhereUniqueInput | BusinessRiskProfileWhereUniqueInput[]
  }

  export type ParishRiskUpdateOneWithoutParishNestedInput = {
    create?: XOR<ParishRiskCreateWithoutParishInput, ParishRiskUncheckedCreateWithoutParishInput>
    connectOrCreate?: ParishRiskCreateOrConnectWithoutParishInput
    upsert?: ParishRiskUpsertWithoutParishInput
    disconnect?: ParishRiskWhereInput | boolean
    delete?: ParishRiskWhereInput | boolean
    connect?: ParishRiskWhereUniqueInput
    update?: XOR<XOR<ParishRiskUpdateToOneWithWhereWithoutParishInput, ParishRiskUpdateWithoutParishInput>, ParishRiskUncheckedUpdateWithoutParishInput>
  }

  export type BusinessRiskProfileUpdateManyWithoutParishNestedInput = {
    create?: XOR<BusinessRiskProfileCreateWithoutParishInput, BusinessRiskProfileUncheckedCreateWithoutParishInput> | BusinessRiskProfileCreateWithoutParishInput[] | BusinessRiskProfileUncheckedCreateWithoutParishInput[]
    connectOrCreate?: BusinessRiskProfileCreateOrConnectWithoutParishInput | BusinessRiskProfileCreateOrConnectWithoutParishInput[]
    upsert?: BusinessRiskProfileUpsertWithWhereUniqueWithoutParishInput | BusinessRiskProfileUpsertWithWhereUniqueWithoutParishInput[]
    createMany?: BusinessRiskProfileCreateManyParishInputEnvelope
    set?: BusinessRiskProfileWhereUniqueInput | BusinessRiskProfileWhereUniqueInput[]
    disconnect?: BusinessRiskProfileWhereUniqueInput | BusinessRiskProfileWhereUniqueInput[]
    delete?: BusinessRiskProfileWhereUniqueInput | BusinessRiskProfileWhereUniqueInput[]
    connect?: BusinessRiskProfileWhereUniqueInput | BusinessRiskProfileWhereUniqueInput[]
    update?: BusinessRiskProfileUpdateWithWhereUniqueWithoutParishInput | BusinessRiskProfileUpdateWithWhereUniqueWithoutParishInput[]
    updateMany?: BusinessRiskProfileUpdateManyWithWhereWithoutParishInput | BusinessRiskProfileUpdateManyWithWhereWithoutParishInput[]
    deleteMany?: BusinessRiskProfileScalarWhereInput | BusinessRiskProfileScalarWhereInput[]
  }

  export type ParishRiskUncheckedUpdateOneWithoutParishNestedInput = {
    create?: XOR<ParishRiskCreateWithoutParishInput, ParishRiskUncheckedCreateWithoutParishInput>
    connectOrCreate?: ParishRiskCreateOrConnectWithoutParishInput
    upsert?: ParishRiskUpsertWithoutParishInput
    disconnect?: ParishRiskWhereInput | boolean
    delete?: ParishRiskWhereInput | boolean
    connect?: ParishRiskWhereUniqueInput
    update?: XOR<XOR<ParishRiskUpdateToOneWithWhereWithoutParishInput, ParishRiskUpdateWithoutParishInput>, ParishRiskUncheckedUpdateWithoutParishInput>
  }

  export type BusinessRiskProfileUncheckedUpdateManyWithoutParishNestedInput = {
    create?: XOR<BusinessRiskProfileCreateWithoutParishInput, BusinessRiskProfileUncheckedCreateWithoutParishInput> | BusinessRiskProfileCreateWithoutParishInput[] | BusinessRiskProfileUncheckedCreateWithoutParishInput[]
    connectOrCreate?: BusinessRiskProfileCreateOrConnectWithoutParishInput | BusinessRiskProfileCreateOrConnectWithoutParishInput[]
    upsert?: BusinessRiskProfileUpsertWithWhereUniqueWithoutParishInput | BusinessRiskProfileUpsertWithWhereUniqueWithoutParishInput[]
    createMany?: BusinessRiskProfileCreateManyParishInputEnvelope
    set?: BusinessRiskProfileWhereUniqueInput | BusinessRiskProfileWhereUniqueInput[]
    disconnect?: BusinessRiskProfileWhereUniqueInput | BusinessRiskProfileWhereUniqueInput[]
    delete?: BusinessRiskProfileWhereUniqueInput | BusinessRiskProfileWhereUniqueInput[]
    connect?: BusinessRiskProfileWhereUniqueInput | BusinessRiskProfileWhereUniqueInput[]
    update?: BusinessRiskProfileUpdateWithWhereUniqueWithoutParishInput | BusinessRiskProfileUpdateWithWhereUniqueWithoutParishInput[]
    updateMany?: BusinessRiskProfileUpdateManyWithWhereWithoutParishInput | BusinessRiskProfileUpdateManyWithWhereWithoutParishInput[]
    deleteMany?: BusinessRiskProfileScalarWhereInput | BusinessRiskProfileScalarWhereInput[]
  }

  export type AdminUnitCreateNestedOneWithoutAdminUnitRiskInput = {
    create?: XOR<AdminUnitCreateWithoutAdminUnitRiskInput, AdminUnitUncheckedCreateWithoutAdminUnitRiskInput>
    connectOrCreate?: AdminUnitCreateOrConnectWithoutAdminUnitRiskInput
    connect?: AdminUnitWhereUniqueInput
  }

  export type AdminUnitRiskChangeLogCreateNestedManyWithoutAdminUnitRiskInput = {
    create?: XOR<AdminUnitRiskChangeLogCreateWithoutAdminUnitRiskInput, AdminUnitRiskChangeLogUncheckedCreateWithoutAdminUnitRiskInput> | AdminUnitRiskChangeLogCreateWithoutAdminUnitRiskInput[] | AdminUnitRiskChangeLogUncheckedCreateWithoutAdminUnitRiskInput[]
    connectOrCreate?: AdminUnitRiskChangeLogCreateOrConnectWithoutAdminUnitRiskInput | AdminUnitRiskChangeLogCreateOrConnectWithoutAdminUnitRiskInput[]
    createMany?: AdminUnitRiskChangeLogCreateManyAdminUnitRiskInputEnvelope
    connect?: AdminUnitRiskChangeLogWhereUniqueInput | AdminUnitRiskChangeLogWhereUniqueInput[]
  }

  export type AdminUnitRiskChangeLogUncheckedCreateNestedManyWithoutAdminUnitRiskInput = {
    create?: XOR<AdminUnitRiskChangeLogCreateWithoutAdminUnitRiskInput, AdminUnitRiskChangeLogUncheckedCreateWithoutAdminUnitRiskInput> | AdminUnitRiskChangeLogCreateWithoutAdminUnitRiskInput[] | AdminUnitRiskChangeLogUncheckedCreateWithoutAdminUnitRiskInput[]
    connectOrCreate?: AdminUnitRiskChangeLogCreateOrConnectWithoutAdminUnitRiskInput | AdminUnitRiskChangeLogCreateOrConnectWithoutAdminUnitRiskInput[]
    createMany?: AdminUnitRiskChangeLogCreateManyAdminUnitRiskInputEnvelope
    connect?: AdminUnitRiskChangeLogWhereUniqueInput | AdminUnitRiskChangeLogWhereUniqueInput[]
  }

  export type AdminUnitUpdateOneRequiredWithoutAdminUnitRiskNestedInput = {
    create?: XOR<AdminUnitCreateWithoutAdminUnitRiskInput, AdminUnitUncheckedCreateWithoutAdminUnitRiskInput>
    connectOrCreate?: AdminUnitCreateOrConnectWithoutAdminUnitRiskInput
    upsert?: AdminUnitUpsertWithoutAdminUnitRiskInput
    connect?: AdminUnitWhereUniqueInput
    update?: XOR<XOR<AdminUnitUpdateToOneWithWhereWithoutAdminUnitRiskInput, AdminUnitUpdateWithoutAdminUnitRiskInput>, AdminUnitUncheckedUpdateWithoutAdminUnitRiskInput>
  }

  export type AdminUnitRiskChangeLogUpdateManyWithoutAdminUnitRiskNestedInput = {
    create?: XOR<AdminUnitRiskChangeLogCreateWithoutAdminUnitRiskInput, AdminUnitRiskChangeLogUncheckedCreateWithoutAdminUnitRiskInput> | AdminUnitRiskChangeLogCreateWithoutAdminUnitRiskInput[] | AdminUnitRiskChangeLogUncheckedCreateWithoutAdminUnitRiskInput[]
    connectOrCreate?: AdminUnitRiskChangeLogCreateOrConnectWithoutAdminUnitRiskInput | AdminUnitRiskChangeLogCreateOrConnectWithoutAdminUnitRiskInput[]
    upsert?: AdminUnitRiskChangeLogUpsertWithWhereUniqueWithoutAdminUnitRiskInput | AdminUnitRiskChangeLogUpsertWithWhereUniqueWithoutAdminUnitRiskInput[]
    createMany?: AdminUnitRiskChangeLogCreateManyAdminUnitRiskInputEnvelope
    set?: AdminUnitRiskChangeLogWhereUniqueInput | AdminUnitRiskChangeLogWhereUniqueInput[]
    disconnect?: AdminUnitRiskChangeLogWhereUniqueInput | AdminUnitRiskChangeLogWhereUniqueInput[]
    delete?: AdminUnitRiskChangeLogWhereUniqueInput | AdminUnitRiskChangeLogWhereUniqueInput[]
    connect?: AdminUnitRiskChangeLogWhereUniqueInput | AdminUnitRiskChangeLogWhereUniqueInput[]
    update?: AdminUnitRiskChangeLogUpdateWithWhereUniqueWithoutAdminUnitRiskInput | AdminUnitRiskChangeLogUpdateWithWhereUniqueWithoutAdminUnitRiskInput[]
    updateMany?: AdminUnitRiskChangeLogUpdateManyWithWhereWithoutAdminUnitRiskInput | AdminUnitRiskChangeLogUpdateManyWithWhereWithoutAdminUnitRiskInput[]
    deleteMany?: AdminUnitRiskChangeLogScalarWhereInput | AdminUnitRiskChangeLogScalarWhereInput[]
  }

  export type AdminUnitRiskChangeLogUncheckedUpdateManyWithoutAdminUnitRiskNestedInput = {
    create?: XOR<AdminUnitRiskChangeLogCreateWithoutAdminUnitRiskInput, AdminUnitRiskChangeLogUncheckedCreateWithoutAdminUnitRiskInput> | AdminUnitRiskChangeLogCreateWithoutAdminUnitRiskInput[] | AdminUnitRiskChangeLogUncheckedCreateWithoutAdminUnitRiskInput[]
    connectOrCreate?: AdminUnitRiskChangeLogCreateOrConnectWithoutAdminUnitRiskInput | AdminUnitRiskChangeLogCreateOrConnectWithoutAdminUnitRiskInput[]
    upsert?: AdminUnitRiskChangeLogUpsertWithWhereUniqueWithoutAdminUnitRiskInput | AdminUnitRiskChangeLogUpsertWithWhereUniqueWithoutAdminUnitRiskInput[]
    createMany?: AdminUnitRiskChangeLogCreateManyAdminUnitRiskInputEnvelope
    set?: AdminUnitRiskChangeLogWhereUniqueInput | AdminUnitRiskChangeLogWhereUniqueInput[]
    disconnect?: AdminUnitRiskChangeLogWhereUniqueInput | AdminUnitRiskChangeLogWhereUniqueInput[]
    delete?: AdminUnitRiskChangeLogWhereUniqueInput | AdminUnitRiskChangeLogWhereUniqueInput[]
    connect?: AdminUnitRiskChangeLogWhereUniqueInput | AdminUnitRiskChangeLogWhereUniqueInput[]
    update?: AdminUnitRiskChangeLogUpdateWithWhereUniqueWithoutAdminUnitRiskInput | AdminUnitRiskChangeLogUpdateWithWhereUniqueWithoutAdminUnitRiskInput[]
    updateMany?: AdminUnitRiskChangeLogUpdateManyWithWhereWithoutAdminUnitRiskInput | AdminUnitRiskChangeLogUpdateManyWithWhereWithoutAdminUnitRiskInput[]
    deleteMany?: AdminUnitRiskChangeLogScalarWhereInput | AdminUnitRiskChangeLogScalarWhereInput[]
  }

  export type AdminUnitRiskCreateNestedOneWithoutChangeLogsInput = {
    create?: XOR<AdminUnitRiskCreateWithoutChangeLogsInput, AdminUnitRiskUncheckedCreateWithoutChangeLogsInput>
    connectOrCreate?: AdminUnitRiskCreateOrConnectWithoutChangeLogsInput
    connect?: AdminUnitRiskWhereUniqueInput
  }

  export type AdminUnitRiskUpdateOneRequiredWithoutChangeLogsNestedInput = {
    create?: XOR<AdminUnitRiskCreateWithoutChangeLogsInput, AdminUnitRiskUncheckedCreateWithoutChangeLogsInput>
    connectOrCreate?: AdminUnitRiskCreateOrConnectWithoutChangeLogsInput
    upsert?: AdminUnitRiskUpsertWithoutChangeLogsInput
    connect?: AdminUnitRiskWhereUniqueInput
    update?: XOR<XOR<AdminUnitRiskUpdateToOneWithWhereWithoutChangeLogsInput, AdminUnitRiskUpdateWithoutChangeLogsInput>, AdminUnitRiskUncheckedUpdateWithoutChangeLogsInput>
  }

  export type ParishCreateNestedOneWithoutParishRiskInput = {
    create?: XOR<ParishCreateWithoutParishRiskInput, ParishUncheckedCreateWithoutParishRiskInput>
    connectOrCreate?: ParishCreateOrConnectWithoutParishRiskInput
    connect?: ParishWhereUniqueInput
  }

  export type RiskChangeLogCreateNestedManyWithoutParishRiskInput = {
    create?: XOR<RiskChangeLogCreateWithoutParishRiskInput, RiskChangeLogUncheckedCreateWithoutParishRiskInput> | RiskChangeLogCreateWithoutParishRiskInput[] | RiskChangeLogUncheckedCreateWithoutParishRiskInput[]
    connectOrCreate?: RiskChangeLogCreateOrConnectWithoutParishRiskInput | RiskChangeLogCreateOrConnectWithoutParishRiskInput[]
    createMany?: RiskChangeLogCreateManyParishRiskInputEnvelope
    connect?: RiskChangeLogWhereUniqueInput | RiskChangeLogWhereUniqueInput[]
  }

  export type RiskChangeLogUncheckedCreateNestedManyWithoutParishRiskInput = {
    create?: XOR<RiskChangeLogCreateWithoutParishRiskInput, RiskChangeLogUncheckedCreateWithoutParishRiskInput> | RiskChangeLogCreateWithoutParishRiskInput[] | RiskChangeLogUncheckedCreateWithoutParishRiskInput[]
    connectOrCreate?: RiskChangeLogCreateOrConnectWithoutParishRiskInput | RiskChangeLogCreateOrConnectWithoutParishRiskInput[]
    createMany?: RiskChangeLogCreateManyParishRiskInputEnvelope
    connect?: RiskChangeLogWhereUniqueInput | RiskChangeLogWhereUniqueInput[]
  }

  export type ParishUpdateOneRequiredWithoutParishRiskNestedInput = {
    create?: XOR<ParishCreateWithoutParishRiskInput, ParishUncheckedCreateWithoutParishRiskInput>
    connectOrCreate?: ParishCreateOrConnectWithoutParishRiskInput
    upsert?: ParishUpsertWithoutParishRiskInput
    connect?: ParishWhereUniqueInput
    update?: XOR<XOR<ParishUpdateToOneWithWhereWithoutParishRiskInput, ParishUpdateWithoutParishRiskInput>, ParishUncheckedUpdateWithoutParishRiskInput>
  }

  export type RiskChangeLogUpdateManyWithoutParishRiskNestedInput = {
    create?: XOR<RiskChangeLogCreateWithoutParishRiskInput, RiskChangeLogUncheckedCreateWithoutParishRiskInput> | RiskChangeLogCreateWithoutParishRiskInput[] | RiskChangeLogUncheckedCreateWithoutParishRiskInput[]
    connectOrCreate?: RiskChangeLogCreateOrConnectWithoutParishRiskInput | RiskChangeLogCreateOrConnectWithoutParishRiskInput[]
    upsert?: RiskChangeLogUpsertWithWhereUniqueWithoutParishRiskInput | RiskChangeLogUpsertWithWhereUniqueWithoutParishRiskInput[]
    createMany?: RiskChangeLogCreateManyParishRiskInputEnvelope
    set?: RiskChangeLogWhereUniqueInput | RiskChangeLogWhereUniqueInput[]
    disconnect?: RiskChangeLogWhereUniqueInput | RiskChangeLogWhereUniqueInput[]
    delete?: RiskChangeLogWhereUniqueInput | RiskChangeLogWhereUniqueInput[]
    connect?: RiskChangeLogWhereUniqueInput | RiskChangeLogWhereUniqueInput[]
    update?: RiskChangeLogUpdateWithWhereUniqueWithoutParishRiskInput | RiskChangeLogUpdateWithWhereUniqueWithoutParishRiskInput[]
    updateMany?: RiskChangeLogUpdateManyWithWhereWithoutParishRiskInput | RiskChangeLogUpdateManyWithWhereWithoutParishRiskInput[]
    deleteMany?: RiskChangeLogScalarWhereInput | RiskChangeLogScalarWhereInput[]
  }

  export type RiskChangeLogUncheckedUpdateManyWithoutParishRiskNestedInput = {
    create?: XOR<RiskChangeLogCreateWithoutParishRiskInput, RiskChangeLogUncheckedCreateWithoutParishRiskInput> | RiskChangeLogCreateWithoutParishRiskInput[] | RiskChangeLogUncheckedCreateWithoutParishRiskInput[]
    connectOrCreate?: RiskChangeLogCreateOrConnectWithoutParishRiskInput | RiskChangeLogCreateOrConnectWithoutParishRiskInput[]
    upsert?: RiskChangeLogUpsertWithWhereUniqueWithoutParishRiskInput | RiskChangeLogUpsertWithWhereUniqueWithoutParishRiskInput[]
    createMany?: RiskChangeLogCreateManyParishRiskInputEnvelope
    set?: RiskChangeLogWhereUniqueInput | RiskChangeLogWhereUniqueInput[]
    disconnect?: RiskChangeLogWhereUniqueInput | RiskChangeLogWhereUniqueInput[]
    delete?: RiskChangeLogWhereUniqueInput | RiskChangeLogWhereUniqueInput[]
    connect?: RiskChangeLogWhereUniqueInput | RiskChangeLogWhereUniqueInput[]
    update?: RiskChangeLogUpdateWithWhereUniqueWithoutParishRiskInput | RiskChangeLogUpdateWithWhereUniqueWithoutParishRiskInput[]
    updateMany?: RiskChangeLogUpdateManyWithWhereWithoutParishRiskInput | RiskChangeLogUpdateManyWithWhereWithoutParishRiskInput[]
    deleteMany?: RiskChangeLogScalarWhereInput | RiskChangeLogScalarWhereInput[]
  }

  export type ParishRiskCreateNestedOneWithoutChangeLogsInput = {
    create?: XOR<ParishRiskCreateWithoutChangeLogsInput, ParishRiskUncheckedCreateWithoutChangeLogsInput>
    connectOrCreate?: ParishRiskCreateOrConnectWithoutChangeLogsInput
    connect?: ParishRiskWhereUniqueInput
  }

  export type ParishRiskUpdateOneRequiredWithoutChangeLogsNestedInput = {
    create?: XOR<ParishRiskCreateWithoutChangeLogsInput, ParishRiskUncheckedCreateWithoutChangeLogsInput>
    connectOrCreate?: ParishRiskCreateOrConnectWithoutChangeLogsInput
    upsert?: ParishRiskUpsertWithoutChangeLogsInput
    connect?: ParishRiskWhereUniqueInput
    update?: XOR<XOR<ParishRiskUpdateToOneWithWhereWithoutChangeLogsInput, ParishRiskUpdateWithoutChangeLogsInput>, ParishRiskUncheckedUpdateWithoutChangeLogsInput>
  }

  export type BusinessRiskVulnerabilityCreateNestedManyWithoutBusinessTypeInput = {
    create?: XOR<BusinessRiskVulnerabilityCreateWithoutBusinessTypeInput, BusinessRiskVulnerabilityUncheckedCreateWithoutBusinessTypeInput> | BusinessRiskVulnerabilityCreateWithoutBusinessTypeInput[] | BusinessRiskVulnerabilityUncheckedCreateWithoutBusinessTypeInput[]
    connectOrCreate?: BusinessRiskVulnerabilityCreateOrConnectWithoutBusinessTypeInput | BusinessRiskVulnerabilityCreateOrConnectWithoutBusinessTypeInput[]
    createMany?: BusinessRiskVulnerabilityCreateManyBusinessTypeInputEnvelope
    connect?: BusinessRiskVulnerabilityWhereUniqueInput | BusinessRiskVulnerabilityWhereUniqueInput[]
  }

  export type BusinessTypeStrategyCreateNestedManyWithoutBusinessTypeInput = {
    create?: XOR<BusinessTypeStrategyCreateWithoutBusinessTypeInput, BusinessTypeStrategyUncheckedCreateWithoutBusinessTypeInput> | BusinessTypeStrategyCreateWithoutBusinessTypeInput[] | BusinessTypeStrategyUncheckedCreateWithoutBusinessTypeInput[]
    connectOrCreate?: BusinessTypeStrategyCreateOrConnectWithoutBusinessTypeInput | BusinessTypeStrategyCreateOrConnectWithoutBusinessTypeInput[]
    createMany?: BusinessTypeStrategyCreateManyBusinessTypeInputEnvelope
    connect?: BusinessTypeStrategyWhereUniqueInput | BusinessTypeStrategyWhereUniqueInput[]
  }

  export type BusinessRiskProfileCreateNestedManyWithoutBusinessTypeInput = {
    create?: XOR<BusinessRiskProfileCreateWithoutBusinessTypeInput, BusinessRiskProfileUncheckedCreateWithoutBusinessTypeInput> | BusinessRiskProfileCreateWithoutBusinessTypeInput[] | BusinessRiskProfileUncheckedCreateWithoutBusinessTypeInput[]
    connectOrCreate?: BusinessRiskProfileCreateOrConnectWithoutBusinessTypeInput | BusinessRiskProfileCreateOrConnectWithoutBusinessTypeInput[]
    createMany?: BusinessRiskProfileCreateManyBusinessTypeInputEnvelope
    connect?: BusinessRiskProfileWhereUniqueInput | BusinessRiskProfileWhereUniqueInput[]
  }

  export type BusinessTypeTranslationCreateNestedManyWithoutBusinessTypeInput = {
    create?: XOR<BusinessTypeTranslationCreateWithoutBusinessTypeInput, BusinessTypeTranslationUncheckedCreateWithoutBusinessTypeInput> | BusinessTypeTranslationCreateWithoutBusinessTypeInput[] | BusinessTypeTranslationUncheckedCreateWithoutBusinessTypeInput[]
    connectOrCreate?: BusinessTypeTranslationCreateOrConnectWithoutBusinessTypeInput | BusinessTypeTranslationCreateOrConnectWithoutBusinessTypeInput[]
    createMany?: BusinessTypeTranslationCreateManyBusinessTypeInputEnvelope
    connect?: BusinessTypeTranslationWhereUniqueInput | BusinessTypeTranslationWhereUniqueInput[]
  }

  export type BusinessRiskVulnerabilityUncheckedCreateNestedManyWithoutBusinessTypeInput = {
    create?: XOR<BusinessRiskVulnerabilityCreateWithoutBusinessTypeInput, BusinessRiskVulnerabilityUncheckedCreateWithoutBusinessTypeInput> | BusinessRiskVulnerabilityCreateWithoutBusinessTypeInput[] | BusinessRiskVulnerabilityUncheckedCreateWithoutBusinessTypeInput[]
    connectOrCreate?: BusinessRiskVulnerabilityCreateOrConnectWithoutBusinessTypeInput | BusinessRiskVulnerabilityCreateOrConnectWithoutBusinessTypeInput[]
    createMany?: BusinessRiskVulnerabilityCreateManyBusinessTypeInputEnvelope
    connect?: BusinessRiskVulnerabilityWhereUniqueInput | BusinessRiskVulnerabilityWhereUniqueInput[]
  }

  export type BusinessTypeStrategyUncheckedCreateNestedManyWithoutBusinessTypeInput = {
    create?: XOR<BusinessTypeStrategyCreateWithoutBusinessTypeInput, BusinessTypeStrategyUncheckedCreateWithoutBusinessTypeInput> | BusinessTypeStrategyCreateWithoutBusinessTypeInput[] | BusinessTypeStrategyUncheckedCreateWithoutBusinessTypeInput[]
    connectOrCreate?: BusinessTypeStrategyCreateOrConnectWithoutBusinessTypeInput | BusinessTypeStrategyCreateOrConnectWithoutBusinessTypeInput[]
    createMany?: BusinessTypeStrategyCreateManyBusinessTypeInputEnvelope
    connect?: BusinessTypeStrategyWhereUniqueInput | BusinessTypeStrategyWhereUniqueInput[]
  }

  export type BusinessRiskProfileUncheckedCreateNestedManyWithoutBusinessTypeInput = {
    create?: XOR<BusinessRiskProfileCreateWithoutBusinessTypeInput, BusinessRiskProfileUncheckedCreateWithoutBusinessTypeInput> | BusinessRiskProfileCreateWithoutBusinessTypeInput[] | BusinessRiskProfileUncheckedCreateWithoutBusinessTypeInput[]
    connectOrCreate?: BusinessRiskProfileCreateOrConnectWithoutBusinessTypeInput | BusinessRiskProfileCreateOrConnectWithoutBusinessTypeInput[]
    createMany?: BusinessRiskProfileCreateManyBusinessTypeInputEnvelope
    connect?: BusinessRiskProfileWhereUniqueInput | BusinessRiskProfileWhereUniqueInput[]
  }

  export type BusinessTypeTranslationUncheckedCreateNestedManyWithoutBusinessTypeInput = {
    create?: XOR<BusinessTypeTranslationCreateWithoutBusinessTypeInput, BusinessTypeTranslationUncheckedCreateWithoutBusinessTypeInput> | BusinessTypeTranslationCreateWithoutBusinessTypeInput[] | BusinessTypeTranslationUncheckedCreateWithoutBusinessTypeInput[]
    connectOrCreate?: BusinessTypeTranslationCreateOrConnectWithoutBusinessTypeInput | BusinessTypeTranslationCreateOrConnectWithoutBusinessTypeInput[]
    createMany?: BusinessTypeTranslationCreateManyBusinessTypeInputEnvelope
    connect?: BusinessTypeTranslationWhereUniqueInput | BusinessTypeTranslationWhereUniqueInput[]
  }

  export type BusinessRiskVulnerabilityUpdateManyWithoutBusinessTypeNestedInput = {
    create?: XOR<BusinessRiskVulnerabilityCreateWithoutBusinessTypeInput, BusinessRiskVulnerabilityUncheckedCreateWithoutBusinessTypeInput> | BusinessRiskVulnerabilityCreateWithoutBusinessTypeInput[] | BusinessRiskVulnerabilityUncheckedCreateWithoutBusinessTypeInput[]
    connectOrCreate?: BusinessRiskVulnerabilityCreateOrConnectWithoutBusinessTypeInput | BusinessRiskVulnerabilityCreateOrConnectWithoutBusinessTypeInput[]
    upsert?: BusinessRiskVulnerabilityUpsertWithWhereUniqueWithoutBusinessTypeInput | BusinessRiskVulnerabilityUpsertWithWhereUniqueWithoutBusinessTypeInput[]
    createMany?: BusinessRiskVulnerabilityCreateManyBusinessTypeInputEnvelope
    set?: BusinessRiskVulnerabilityWhereUniqueInput | BusinessRiskVulnerabilityWhereUniqueInput[]
    disconnect?: BusinessRiskVulnerabilityWhereUniqueInput | BusinessRiskVulnerabilityWhereUniqueInput[]
    delete?: BusinessRiskVulnerabilityWhereUniqueInput | BusinessRiskVulnerabilityWhereUniqueInput[]
    connect?: BusinessRiskVulnerabilityWhereUniqueInput | BusinessRiskVulnerabilityWhereUniqueInput[]
    update?: BusinessRiskVulnerabilityUpdateWithWhereUniqueWithoutBusinessTypeInput | BusinessRiskVulnerabilityUpdateWithWhereUniqueWithoutBusinessTypeInput[]
    updateMany?: BusinessRiskVulnerabilityUpdateManyWithWhereWithoutBusinessTypeInput | BusinessRiskVulnerabilityUpdateManyWithWhereWithoutBusinessTypeInput[]
    deleteMany?: BusinessRiskVulnerabilityScalarWhereInput | BusinessRiskVulnerabilityScalarWhereInput[]
  }

  export type BusinessTypeStrategyUpdateManyWithoutBusinessTypeNestedInput = {
    create?: XOR<BusinessTypeStrategyCreateWithoutBusinessTypeInput, BusinessTypeStrategyUncheckedCreateWithoutBusinessTypeInput> | BusinessTypeStrategyCreateWithoutBusinessTypeInput[] | BusinessTypeStrategyUncheckedCreateWithoutBusinessTypeInput[]
    connectOrCreate?: BusinessTypeStrategyCreateOrConnectWithoutBusinessTypeInput | BusinessTypeStrategyCreateOrConnectWithoutBusinessTypeInput[]
    upsert?: BusinessTypeStrategyUpsertWithWhereUniqueWithoutBusinessTypeInput | BusinessTypeStrategyUpsertWithWhereUniqueWithoutBusinessTypeInput[]
    createMany?: BusinessTypeStrategyCreateManyBusinessTypeInputEnvelope
    set?: BusinessTypeStrategyWhereUniqueInput | BusinessTypeStrategyWhereUniqueInput[]
    disconnect?: BusinessTypeStrategyWhereUniqueInput | BusinessTypeStrategyWhereUniqueInput[]
    delete?: BusinessTypeStrategyWhereUniqueInput | BusinessTypeStrategyWhereUniqueInput[]
    connect?: BusinessTypeStrategyWhereUniqueInput | BusinessTypeStrategyWhereUniqueInput[]
    update?: BusinessTypeStrategyUpdateWithWhereUniqueWithoutBusinessTypeInput | BusinessTypeStrategyUpdateWithWhereUniqueWithoutBusinessTypeInput[]
    updateMany?: BusinessTypeStrategyUpdateManyWithWhereWithoutBusinessTypeInput | BusinessTypeStrategyUpdateManyWithWhereWithoutBusinessTypeInput[]
    deleteMany?: BusinessTypeStrategyScalarWhereInput | BusinessTypeStrategyScalarWhereInput[]
  }

  export type BusinessRiskProfileUpdateManyWithoutBusinessTypeNestedInput = {
    create?: XOR<BusinessRiskProfileCreateWithoutBusinessTypeInput, BusinessRiskProfileUncheckedCreateWithoutBusinessTypeInput> | BusinessRiskProfileCreateWithoutBusinessTypeInput[] | BusinessRiskProfileUncheckedCreateWithoutBusinessTypeInput[]
    connectOrCreate?: BusinessRiskProfileCreateOrConnectWithoutBusinessTypeInput | BusinessRiskProfileCreateOrConnectWithoutBusinessTypeInput[]
    upsert?: BusinessRiskProfileUpsertWithWhereUniqueWithoutBusinessTypeInput | BusinessRiskProfileUpsertWithWhereUniqueWithoutBusinessTypeInput[]
    createMany?: BusinessRiskProfileCreateManyBusinessTypeInputEnvelope
    set?: BusinessRiskProfileWhereUniqueInput | BusinessRiskProfileWhereUniqueInput[]
    disconnect?: BusinessRiskProfileWhereUniqueInput | BusinessRiskProfileWhereUniqueInput[]
    delete?: BusinessRiskProfileWhereUniqueInput | BusinessRiskProfileWhereUniqueInput[]
    connect?: BusinessRiskProfileWhereUniqueInput | BusinessRiskProfileWhereUniqueInput[]
    update?: BusinessRiskProfileUpdateWithWhereUniqueWithoutBusinessTypeInput | BusinessRiskProfileUpdateWithWhereUniqueWithoutBusinessTypeInput[]
    updateMany?: BusinessRiskProfileUpdateManyWithWhereWithoutBusinessTypeInput | BusinessRiskProfileUpdateManyWithWhereWithoutBusinessTypeInput[]
    deleteMany?: BusinessRiskProfileScalarWhereInput | BusinessRiskProfileScalarWhereInput[]
  }

  export type BusinessTypeTranslationUpdateManyWithoutBusinessTypeNestedInput = {
    create?: XOR<BusinessTypeTranslationCreateWithoutBusinessTypeInput, BusinessTypeTranslationUncheckedCreateWithoutBusinessTypeInput> | BusinessTypeTranslationCreateWithoutBusinessTypeInput[] | BusinessTypeTranslationUncheckedCreateWithoutBusinessTypeInput[]
    connectOrCreate?: BusinessTypeTranslationCreateOrConnectWithoutBusinessTypeInput | BusinessTypeTranslationCreateOrConnectWithoutBusinessTypeInput[]
    upsert?: BusinessTypeTranslationUpsertWithWhereUniqueWithoutBusinessTypeInput | BusinessTypeTranslationUpsertWithWhereUniqueWithoutBusinessTypeInput[]
    createMany?: BusinessTypeTranslationCreateManyBusinessTypeInputEnvelope
    set?: BusinessTypeTranslationWhereUniqueInput | BusinessTypeTranslationWhereUniqueInput[]
    disconnect?: BusinessTypeTranslationWhereUniqueInput | BusinessTypeTranslationWhereUniqueInput[]
    delete?: BusinessTypeTranslationWhereUniqueInput | BusinessTypeTranslationWhereUniqueInput[]
    connect?: BusinessTypeTranslationWhereUniqueInput | BusinessTypeTranslationWhereUniqueInput[]
    update?: BusinessTypeTranslationUpdateWithWhereUniqueWithoutBusinessTypeInput | BusinessTypeTranslationUpdateWithWhereUniqueWithoutBusinessTypeInput[]
    updateMany?: BusinessTypeTranslationUpdateManyWithWhereWithoutBusinessTypeInput | BusinessTypeTranslationUpdateManyWithWhereWithoutBusinessTypeInput[]
    deleteMany?: BusinessTypeTranslationScalarWhereInput | BusinessTypeTranslationScalarWhereInput[]
  }

  export type BusinessRiskVulnerabilityUncheckedUpdateManyWithoutBusinessTypeNestedInput = {
    create?: XOR<BusinessRiskVulnerabilityCreateWithoutBusinessTypeInput, BusinessRiskVulnerabilityUncheckedCreateWithoutBusinessTypeInput> | BusinessRiskVulnerabilityCreateWithoutBusinessTypeInput[] | BusinessRiskVulnerabilityUncheckedCreateWithoutBusinessTypeInput[]
    connectOrCreate?: BusinessRiskVulnerabilityCreateOrConnectWithoutBusinessTypeInput | BusinessRiskVulnerabilityCreateOrConnectWithoutBusinessTypeInput[]
    upsert?: BusinessRiskVulnerabilityUpsertWithWhereUniqueWithoutBusinessTypeInput | BusinessRiskVulnerabilityUpsertWithWhereUniqueWithoutBusinessTypeInput[]
    createMany?: BusinessRiskVulnerabilityCreateManyBusinessTypeInputEnvelope
    set?: BusinessRiskVulnerabilityWhereUniqueInput | BusinessRiskVulnerabilityWhereUniqueInput[]
    disconnect?: BusinessRiskVulnerabilityWhereUniqueInput | BusinessRiskVulnerabilityWhereUniqueInput[]
    delete?: BusinessRiskVulnerabilityWhereUniqueInput | BusinessRiskVulnerabilityWhereUniqueInput[]
    connect?: BusinessRiskVulnerabilityWhereUniqueInput | BusinessRiskVulnerabilityWhereUniqueInput[]
    update?: BusinessRiskVulnerabilityUpdateWithWhereUniqueWithoutBusinessTypeInput | BusinessRiskVulnerabilityUpdateWithWhereUniqueWithoutBusinessTypeInput[]
    updateMany?: BusinessRiskVulnerabilityUpdateManyWithWhereWithoutBusinessTypeInput | BusinessRiskVulnerabilityUpdateManyWithWhereWithoutBusinessTypeInput[]
    deleteMany?: BusinessRiskVulnerabilityScalarWhereInput | BusinessRiskVulnerabilityScalarWhereInput[]
  }

  export type BusinessTypeStrategyUncheckedUpdateManyWithoutBusinessTypeNestedInput = {
    create?: XOR<BusinessTypeStrategyCreateWithoutBusinessTypeInput, BusinessTypeStrategyUncheckedCreateWithoutBusinessTypeInput> | BusinessTypeStrategyCreateWithoutBusinessTypeInput[] | BusinessTypeStrategyUncheckedCreateWithoutBusinessTypeInput[]
    connectOrCreate?: BusinessTypeStrategyCreateOrConnectWithoutBusinessTypeInput | BusinessTypeStrategyCreateOrConnectWithoutBusinessTypeInput[]
    upsert?: BusinessTypeStrategyUpsertWithWhereUniqueWithoutBusinessTypeInput | BusinessTypeStrategyUpsertWithWhereUniqueWithoutBusinessTypeInput[]
    createMany?: BusinessTypeStrategyCreateManyBusinessTypeInputEnvelope
    set?: BusinessTypeStrategyWhereUniqueInput | BusinessTypeStrategyWhereUniqueInput[]
    disconnect?: BusinessTypeStrategyWhereUniqueInput | BusinessTypeStrategyWhereUniqueInput[]
    delete?: BusinessTypeStrategyWhereUniqueInput | BusinessTypeStrategyWhereUniqueInput[]
    connect?: BusinessTypeStrategyWhereUniqueInput | BusinessTypeStrategyWhereUniqueInput[]
    update?: BusinessTypeStrategyUpdateWithWhereUniqueWithoutBusinessTypeInput | BusinessTypeStrategyUpdateWithWhereUniqueWithoutBusinessTypeInput[]
    updateMany?: BusinessTypeStrategyUpdateManyWithWhereWithoutBusinessTypeInput | BusinessTypeStrategyUpdateManyWithWhereWithoutBusinessTypeInput[]
    deleteMany?: BusinessTypeStrategyScalarWhereInput | BusinessTypeStrategyScalarWhereInput[]
  }

  export type BusinessRiskProfileUncheckedUpdateManyWithoutBusinessTypeNestedInput = {
    create?: XOR<BusinessRiskProfileCreateWithoutBusinessTypeInput, BusinessRiskProfileUncheckedCreateWithoutBusinessTypeInput> | BusinessRiskProfileCreateWithoutBusinessTypeInput[] | BusinessRiskProfileUncheckedCreateWithoutBusinessTypeInput[]
    connectOrCreate?: BusinessRiskProfileCreateOrConnectWithoutBusinessTypeInput | BusinessRiskProfileCreateOrConnectWithoutBusinessTypeInput[]
    upsert?: BusinessRiskProfileUpsertWithWhereUniqueWithoutBusinessTypeInput | BusinessRiskProfileUpsertWithWhereUniqueWithoutBusinessTypeInput[]
    createMany?: BusinessRiskProfileCreateManyBusinessTypeInputEnvelope
    set?: BusinessRiskProfileWhereUniqueInput | BusinessRiskProfileWhereUniqueInput[]
    disconnect?: BusinessRiskProfileWhereUniqueInput | BusinessRiskProfileWhereUniqueInput[]
    delete?: BusinessRiskProfileWhereUniqueInput | BusinessRiskProfileWhereUniqueInput[]
    connect?: BusinessRiskProfileWhereUniqueInput | BusinessRiskProfileWhereUniqueInput[]
    update?: BusinessRiskProfileUpdateWithWhereUniqueWithoutBusinessTypeInput | BusinessRiskProfileUpdateWithWhereUniqueWithoutBusinessTypeInput[]
    updateMany?: BusinessRiskProfileUpdateManyWithWhereWithoutBusinessTypeInput | BusinessRiskProfileUpdateManyWithWhereWithoutBusinessTypeInput[]
    deleteMany?: BusinessRiskProfileScalarWhereInput | BusinessRiskProfileScalarWhereInput[]
  }

  export type BusinessTypeTranslationUncheckedUpdateManyWithoutBusinessTypeNestedInput = {
    create?: XOR<BusinessTypeTranslationCreateWithoutBusinessTypeInput, BusinessTypeTranslationUncheckedCreateWithoutBusinessTypeInput> | BusinessTypeTranslationCreateWithoutBusinessTypeInput[] | BusinessTypeTranslationUncheckedCreateWithoutBusinessTypeInput[]
    connectOrCreate?: BusinessTypeTranslationCreateOrConnectWithoutBusinessTypeInput | BusinessTypeTranslationCreateOrConnectWithoutBusinessTypeInput[]
    upsert?: BusinessTypeTranslationUpsertWithWhereUniqueWithoutBusinessTypeInput | BusinessTypeTranslationUpsertWithWhereUniqueWithoutBusinessTypeInput[]
    createMany?: BusinessTypeTranslationCreateManyBusinessTypeInputEnvelope
    set?: BusinessTypeTranslationWhereUniqueInput | BusinessTypeTranslationWhereUniqueInput[]
    disconnect?: BusinessTypeTranslationWhereUniqueInput | BusinessTypeTranslationWhereUniqueInput[]
    delete?: BusinessTypeTranslationWhereUniqueInput | BusinessTypeTranslationWhereUniqueInput[]
    connect?: BusinessTypeTranslationWhereUniqueInput | BusinessTypeTranslationWhereUniqueInput[]
    update?: BusinessTypeTranslationUpdateWithWhereUniqueWithoutBusinessTypeInput | BusinessTypeTranslationUpdateWithWhereUniqueWithoutBusinessTypeInput[]
    updateMany?: BusinessTypeTranslationUpdateManyWithWhereWithoutBusinessTypeInput | BusinessTypeTranslationUpdateManyWithWhereWithoutBusinessTypeInput[]
    deleteMany?: BusinessTypeTranslationScalarWhereInput | BusinessTypeTranslationScalarWhereInput[]
  }

  export type BusinessTypeCreateNestedOneWithoutRiskVulnerabilitiesInput = {
    create?: XOR<BusinessTypeCreateWithoutRiskVulnerabilitiesInput, BusinessTypeUncheckedCreateWithoutRiskVulnerabilitiesInput>
    connectOrCreate?: BusinessTypeCreateOrConnectWithoutRiskVulnerabilitiesInput
    connect?: BusinessTypeWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BusinessTypeUpdateOneRequiredWithoutRiskVulnerabilitiesNestedInput = {
    create?: XOR<BusinessTypeCreateWithoutRiskVulnerabilitiesInput, BusinessTypeUncheckedCreateWithoutRiskVulnerabilitiesInput>
    connectOrCreate?: BusinessTypeCreateOrConnectWithoutRiskVulnerabilitiesInput
    upsert?: BusinessTypeUpsertWithoutRiskVulnerabilitiesInput
    connect?: BusinessTypeWhereUniqueInput
    update?: XOR<XOR<BusinessTypeUpdateToOneWithWhereWithoutRiskVulnerabilitiesInput, BusinessTypeUpdateWithoutRiskVulnerabilitiesInput>, BusinessTypeUncheckedUpdateWithoutRiskVulnerabilitiesInput>
  }

  export type BusinessTypeStrategyCreateNestedManyWithoutStrategyInput = {
    create?: XOR<BusinessTypeStrategyCreateWithoutStrategyInput, BusinessTypeStrategyUncheckedCreateWithoutStrategyInput> | BusinessTypeStrategyCreateWithoutStrategyInput[] | BusinessTypeStrategyUncheckedCreateWithoutStrategyInput[]
    connectOrCreate?: BusinessTypeStrategyCreateOrConnectWithoutStrategyInput | BusinessTypeStrategyCreateOrConnectWithoutStrategyInput[]
    createMany?: BusinessTypeStrategyCreateManyStrategyInputEnvelope
    connect?: BusinessTypeStrategyWhereUniqueInput | BusinessTypeStrategyWhereUniqueInput[]
  }

  export type ActionStepCreateNestedManyWithoutStrategyInput = {
    create?: XOR<ActionStepCreateWithoutStrategyInput, ActionStepUncheckedCreateWithoutStrategyInput> | ActionStepCreateWithoutStrategyInput[] | ActionStepUncheckedCreateWithoutStrategyInput[]
    connectOrCreate?: ActionStepCreateOrConnectWithoutStrategyInput | ActionStepCreateOrConnectWithoutStrategyInput[]
    createMany?: ActionStepCreateManyStrategyInputEnvelope
    connect?: ActionStepWhereUniqueInput | ActionStepWhereUniqueInput[]
  }

  export type StrategyItemCostCreateNestedManyWithoutStrategyInput = {
    create?: XOR<StrategyItemCostCreateWithoutStrategyInput, StrategyItemCostUncheckedCreateWithoutStrategyInput> | StrategyItemCostCreateWithoutStrategyInput[] | StrategyItemCostUncheckedCreateWithoutStrategyInput[]
    connectOrCreate?: StrategyItemCostCreateOrConnectWithoutStrategyInput | StrategyItemCostCreateOrConnectWithoutStrategyInput[]
    createMany?: StrategyItemCostCreateManyStrategyInputEnvelope
    connect?: StrategyItemCostWhereUniqueInput | StrategyItemCostWhereUniqueInput[]
  }

  export type StrategyTranslationCreateNestedManyWithoutStrategyInput = {
    create?: XOR<StrategyTranslationCreateWithoutStrategyInput, StrategyTranslationUncheckedCreateWithoutStrategyInput> | StrategyTranslationCreateWithoutStrategyInput[] | StrategyTranslationUncheckedCreateWithoutStrategyInput[]
    connectOrCreate?: StrategyTranslationCreateOrConnectWithoutStrategyInput | StrategyTranslationCreateOrConnectWithoutStrategyInput[]
    createMany?: StrategyTranslationCreateManyStrategyInputEnvelope
    connect?: StrategyTranslationWhereUniqueInput | StrategyTranslationWhereUniqueInput[]
  }

  export type BusinessTypeStrategyUncheckedCreateNestedManyWithoutStrategyInput = {
    create?: XOR<BusinessTypeStrategyCreateWithoutStrategyInput, BusinessTypeStrategyUncheckedCreateWithoutStrategyInput> | BusinessTypeStrategyCreateWithoutStrategyInput[] | BusinessTypeStrategyUncheckedCreateWithoutStrategyInput[]
    connectOrCreate?: BusinessTypeStrategyCreateOrConnectWithoutStrategyInput | BusinessTypeStrategyCreateOrConnectWithoutStrategyInput[]
    createMany?: BusinessTypeStrategyCreateManyStrategyInputEnvelope
    connect?: BusinessTypeStrategyWhereUniqueInput | BusinessTypeStrategyWhereUniqueInput[]
  }

  export type ActionStepUncheckedCreateNestedManyWithoutStrategyInput = {
    create?: XOR<ActionStepCreateWithoutStrategyInput, ActionStepUncheckedCreateWithoutStrategyInput> | ActionStepCreateWithoutStrategyInput[] | ActionStepUncheckedCreateWithoutStrategyInput[]
    connectOrCreate?: ActionStepCreateOrConnectWithoutStrategyInput | ActionStepCreateOrConnectWithoutStrategyInput[]
    createMany?: ActionStepCreateManyStrategyInputEnvelope
    connect?: ActionStepWhereUniqueInput | ActionStepWhereUniqueInput[]
  }

  export type StrategyItemCostUncheckedCreateNestedManyWithoutStrategyInput = {
    create?: XOR<StrategyItemCostCreateWithoutStrategyInput, StrategyItemCostUncheckedCreateWithoutStrategyInput> | StrategyItemCostCreateWithoutStrategyInput[] | StrategyItemCostUncheckedCreateWithoutStrategyInput[]
    connectOrCreate?: StrategyItemCostCreateOrConnectWithoutStrategyInput | StrategyItemCostCreateOrConnectWithoutStrategyInput[]
    createMany?: StrategyItemCostCreateManyStrategyInputEnvelope
    connect?: StrategyItemCostWhereUniqueInput | StrategyItemCostWhereUniqueInput[]
  }

  export type StrategyTranslationUncheckedCreateNestedManyWithoutStrategyInput = {
    create?: XOR<StrategyTranslationCreateWithoutStrategyInput, StrategyTranslationUncheckedCreateWithoutStrategyInput> | StrategyTranslationCreateWithoutStrategyInput[] | StrategyTranslationUncheckedCreateWithoutStrategyInput[]
    connectOrCreate?: StrategyTranslationCreateOrConnectWithoutStrategyInput | StrategyTranslationCreateOrConnectWithoutStrategyInput[]
    createMany?: StrategyTranslationCreateManyStrategyInputEnvelope
    connect?: StrategyTranslationWhereUniqueInput | StrategyTranslationWhereUniqueInput[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type BusinessTypeStrategyUpdateManyWithoutStrategyNestedInput = {
    create?: XOR<BusinessTypeStrategyCreateWithoutStrategyInput, BusinessTypeStrategyUncheckedCreateWithoutStrategyInput> | BusinessTypeStrategyCreateWithoutStrategyInput[] | BusinessTypeStrategyUncheckedCreateWithoutStrategyInput[]
    connectOrCreate?: BusinessTypeStrategyCreateOrConnectWithoutStrategyInput | BusinessTypeStrategyCreateOrConnectWithoutStrategyInput[]
    upsert?: BusinessTypeStrategyUpsertWithWhereUniqueWithoutStrategyInput | BusinessTypeStrategyUpsertWithWhereUniqueWithoutStrategyInput[]
    createMany?: BusinessTypeStrategyCreateManyStrategyInputEnvelope
    set?: BusinessTypeStrategyWhereUniqueInput | BusinessTypeStrategyWhereUniqueInput[]
    disconnect?: BusinessTypeStrategyWhereUniqueInput | BusinessTypeStrategyWhereUniqueInput[]
    delete?: BusinessTypeStrategyWhereUniqueInput | BusinessTypeStrategyWhereUniqueInput[]
    connect?: BusinessTypeStrategyWhereUniqueInput | BusinessTypeStrategyWhereUniqueInput[]
    update?: BusinessTypeStrategyUpdateWithWhereUniqueWithoutStrategyInput | BusinessTypeStrategyUpdateWithWhereUniqueWithoutStrategyInput[]
    updateMany?: BusinessTypeStrategyUpdateManyWithWhereWithoutStrategyInput | BusinessTypeStrategyUpdateManyWithWhereWithoutStrategyInput[]
    deleteMany?: BusinessTypeStrategyScalarWhereInput | BusinessTypeStrategyScalarWhereInput[]
  }

  export type ActionStepUpdateManyWithoutStrategyNestedInput = {
    create?: XOR<ActionStepCreateWithoutStrategyInput, ActionStepUncheckedCreateWithoutStrategyInput> | ActionStepCreateWithoutStrategyInput[] | ActionStepUncheckedCreateWithoutStrategyInput[]
    connectOrCreate?: ActionStepCreateOrConnectWithoutStrategyInput | ActionStepCreateOrConnectWithoutStrategyInput[]
    upsert?: ActionStepUpsertWithWhereUniqueWithoutStrategyInput | ActionStepUpsertWithWhereUniqueWithoutStrategyInput[]
    createMany?: ActionStepCreateManyStrategyInputEnvelope
    set?: ActionStepWhereUniqueInput | ActionStepWhereUniqueInput[]
    disconnect?: ActionStepWhereUniqueInput | ActionStepWhereUniqueInput[]
    delete?: ActionStepWhereUniqueInput | ActionStepWhereUniqueInput[]
    connect?: ActionStepWhereUniqueInput | ActionStepWhereUniqueInput[]
    update?: ActionStepUpdateWithWhereUniqueWithoutStrategyInput | ActionStepUpdateWithWhereUniqueWithoutStrategyInput[]
    updateMany?: ActionStepUpdateManyWithWhereWithoutStrategyInput | ActionStepUpdateManyWithWhereWithoutStrategyInput[]
    deleteMany?: ActionStepScalarWhereInput | ActionStepScalarWhereInput[]
  }

  export type StrategyItemCostUpdateManyWithoutStrategyNestedInput = {
    create?: XOR<StrategyItemCostCreateWithoutStrategyInput, StrategyItemCostUncheckedCreateWithoutStrategyInput> | StrategyItemCostCreateWithoutStrategyInput[] | StrategyItemCostUncheckedCreateWithoutStrategyInput[]
    connectOrCreate?: StrategyItemCostCreateOrConnectWithoutStrategyInput | StrategyItemCostCreateOrConnectWithoutStrategyInput[]
    upsert?: StrategyItemCostUpsertWithWhereUniqueWithoutStrategyInput | StrategyItemCostUpsertWithWhereUniqueWithoutStrategyInput[]
    createMany?: StrategyItemCostCreateManyStrategyInputEnvelope
    set?: StrategyItemCostWhereUniqueInput | StrategyItemCostWhereUniqueInput[]
    disconnect?: StrategyItemCostWhereUniqueInput | StrategyItemCostWhereUniqueInput[]
    delete?: StrategyItemCostWhereUniqueInput | StrategyItemCostWhereUniqueInput[]
    connect?: StrategyItemCostWhereUniqueInput | StrategyItemCostWhereUniqueInput[]
    update?: StrategyItemCostUpdateWithWhereUniqueWithoutStrategyInput | StrategyItemCostUpdateWithWhereUniqueWithoutStrategyInput[]
    updateMany?: StrategyItemCostUpdateManyWithWhereWithoutStrategyInput | StrategyItemCostUpdateManyWithWhereWithoutStrategyInput[]
    deleteMany?: StrategyItemCostScalarWhereInput | StrategyItemCostScalarWhereInput[]
  }

  export type StrategyTranslationUpdateManyWithoutStrategyNestedInput = {
    create?: XOR<StrategyTranslationCreateWithoutStrategyInput, StrategyTranslationUncheckedCreateWithoutStrategyInput> | StrategyTranslationCreateWithoutStrategyInput[] | StrategyTranslationUncheckedCreateWithoutStrategyInput[]
    connectOrCreate?: StrategyTranslationCreateOrConnectWithoutStrategyInput | StrategyTranslationCreateOrConnectWithoutStrategyInput[]
    upsert?: StrategyTranslationUpsertWithWhereUniqueWithoutStrategyInput | StrategyTranslationUpsertWithWhereUniqueWithoutStrategyInput[]
    createMany?: StrategyTranslationCreateManyStrategyInputEnvelope
    set?: StrategyTranslationWhereUniqueInput | StrategyTranslationWhereUniqueInput[]
    disconnect?: StrategyTranslationWhereUniqueInput | StrategyTranslationWhereUniqueInput[]
    delete?: StrategyTranslationWhereUniqueInput | StrategyTranslationWhereUniqueInput[]
    connect?: StrategyTranslationWhereUniqueInput | StrategyTranslationWhereUniqueInput[]
    update?: StrategyTranslationUpdateWithWhereUniqueWithoutStrategyInput | StrategyTranslationUpdateWithWhereUniqueWithoutStrategyInput[]
    updateMany?: StrategyTranslationUpdateManyWithWhereWithoutStrategyInput | StrategyTranslationUpdateManyWithWhereWithoutStrategyInput[]
    deleteMany?: StrategyTranslationScalarWhereInput | StrategyTranslationScalarWhereInput[]
  }

  export type BusinessTypeStrategyUncheckedUpdateManyWithoutStrategyNestedInput = {
    create?: XOR<BusinessTypeStrategyCreateWithoutStrategyInput, BusinessTypeStrategyUncheckedCreateWithoutStrategyInput> | BusinessTypeStrategyCreateWithoutStrategyInput[] | BusinessTypeStrategyUncheckedCreateWithoutStrategyInput[]
    connectOrCreate?: BusinessTypeStrategyCreateOrConnectWithoutStrategyInput | BusinessTypeStrategyCreateOrConnectWithoutStrategyInput[]
    upsert?: BusinessTypeStrategyUpsertWithWhereUniqueWithoutStrategyInput | BusinessTypeStrategyUpsertWithWhereUniqueWithoutStrategyInput[]
    createMany?: BusinessTypeStrategyCreateManyStrategyInputEnvelope
    set?: BusinessTypeStrategyWhereUniqueInput | BusinessTypeStrategyWhereUniqueInput[]
    disconnect?: BusinessTypeStrategyWhereUniqueInput | BusinessTypeStrategyWhereUniqueInput[]
    delete?: BusinessTypeStrategyWhereUniqueInput | BusinessTypeStrategyWhereUniqueInput[]
    connect?: BusinessTypeStrategyWhereUniqueInput | BusinessTypeStrategyWhereUniqueInput[]
    update?: BusinessTypeStrategyUpdateWithWhereUniqueWithoutStrategyInput | BusinessTypeStrategyUpdateWithWhereUniqueWithoutStrategyInput[]
    updateMany?: BusinessTypeStrategyUpdateManyWithWhereWithoutStrategyInput | BusinessTypeStrategyUpdateManyWithWhereWithoutStrategyInput[]
    deleteMany?: BusinessTypeStrategyScalarWhereInput | BusinessTypeStrategyScalarWhereInput[]
  }

  export type ActionStepUncheckedUpdateManyWithoutStrategyNestedInput = {
    create?: XOR<ActionStepCreateWithoutStrategyInput, ActionStepUncheckedCreateWithoutStrategyInput> | ActionStepCreateWithoutStrategyInput[] | ActionStepUncheckedCreateWithoutStrategyInput[]
    connectOrCreate?: ActionStepCreateOrConnectWithoutStrategyInput | ActionStepCreateOrConnectWithoutStrategyInput[]
    upsert?: ActionStepUpsertWithWhereUniqueWithoutStrategyInput | ActionStepUpsertWithWhereUniqueWithoutStrategyInput[]
    createMany?: ActionStepCreateManyStrategyInputEnvelope
    set?: ActionStepWhereUniqueInput | ActionStepWhereUniqueInput[]
    disconnect?: ActionStepWhereUniqueInput | ActionStepWhereUniqueInput[]
    delete?: ActionStepWhereUniqueInput | ActionStepWhereUniqueInput[]
    connect?: ActionStepWhereUniqueInput | ActionStepWhereUniqueInput[]
    update?: ActionStepUpdateWithWhereUniqueWithoutStrategyInput | ActionStepUpdateWithWhereUniqueWithoutStrategyInput[]
    updateMany?: ActionStepUpdateManyWithWhereWithoutStrategyInput | ActionStepUpdateManyWithWhereWithoutStrategyInput[]
    deleteMany?: ActionStepScalarWhereInput | ActionStepScalarWhereInput[]
  }

  export type StrategyItemCostUncheckedUpdateManyWithoutStrategyNestedInput = {
    create?: XOR<StrategyItemCostCreateWithoutStrategyInput, StrategyItemCostUncheckedCreateWithoutStrategyInput> | StrategyItemCostCreateWithoutStrategyInput[] | StrategyItemCostUncheckedCreateWithoutStrategyInput[]
    connectOrCreate?: StrategyItemCostCreateOrConnectWithoutStrategyInput | StrategyItemCostCreateOrConnectWithoutStrategyInput[]
    upsert?: StrategyItemCostUpsertWithWhereUniqueWithoutStrategyInput | StrategyItemCostUpsertWithWhereUniqueWithoutStrategyInput[]
    createMany?: StrategyItemCostCreateManyStrategyInputEnvelope
    set?: StrategyItemCostWhereUniqueInput | StrategyItemCostWhereUniqueInput[]
    disconnect?: StrategyItemCostWhereUniqueInput | StrategyItemCostWhereUniqueInput[]
    delete?: StrategyItemCostWhereUniqueInput | StrategyItemCostWhereUniqueInput[]
    connect?: StrategyItemCostWhereUniqueInput | StrategyItemCostWhereUniqueInput[]
    update?: StrategyItemCostUpdateWithWhereUniqueWithoutStrategyInput | StrategyItemCostUpdateWithWhereUniqueWithoutStrategyInput[]
    updateMany?: StrategyItemCostUpdateManyWithWhereWithoutStrategyInput | StrategyItemCostUpdateManyWithWhereWithoutStrategyInput[]
    deleteMany?: StrategyItemCostScalarWhereInput | StrategyItemCostScalarWhereInput[]
  }

  export type StrategyTranslationUncheckedUpdateManyWithoutStrategyNestedInput = {
    create?: XOR<StrategyTranslationCreateWithoutStrategyInput, StrategyTranslationUncheckedCreateWithoutStrategyInput> | StrategyTranslationCreateWithoutStrategyInput[] | StrategyTranslationUncheckedCreateWithoutStrategyInput[]
    connectOrCreate?: StrategyTranslationCreateOrConnectWithoutStrategyInput | StrategyTranslationCreateOrConnectWithoutStrategyInput[]
    upsert?: StrategyTranslationUpsertWithWhereUniqueWithoutStrategyInput | StrategyTranslationUpsertWithWhereUniqueWithoutStrategyInput[]
    createMany?: StrategyTranslationCreateManyStrategyInputEnvelope
    set?: StrategyTranslationWhereUniqueInput | StrategyTranslationWhereUniqueInput[]
    disconnect?: StrategyTranslationWhereUniqueInput | StrategyTranslationWhereUniqueInput[]
    delete?: StrategyTranslationWhereUniqueInput | StrategyTranslationWhereUniqueInput[]
    connect?: StrategyTranslationWhereUniqueInput | StrategyTranslationWhereUniqueInput[]
    update?: StrategyTranslationUpdateWithWhereUniqueWithoutStrategyInput | StrategyTranslationUpdateWithWhereUniqueWithoutStrategyInput[]
    updateMany?: StrategyTranslationUpdateManyWithWhereWithoutStrategyInput | StrategyTranslationUpdateManyWithWhereWithoutStrategyInput[]
    deleteMany?: StrategyTranslationScalarWhereInput | StrategyTranslationScalarWhereInput[]
  }

  export type RiskMitigationStrategyCreateNestedOneWithoutActionStepsInput = {
    create?: XOR<RiskMitigationStrategyCreateWithoutActionStepsInput, RiskMitigationStrategyUncheckedCreateWithoutActionStepsInput>
    connectOrCreate?: RiskMitigationStrategyCreateOrConnectWithoutActionStepsInput
    connect?: RiskMitigationStrategyWhereUniqueInput
  }

  export type ActionStepItemCostCreateNestedManyWithoutActionStepInput = {
    create?: XOR<ActionStepItemCostCreateWithoutActionStepInput, ActionStepItemCostUncheckedCreateWithoutActionStepInput> | ActionStepItemCostCreateWithoutActionStepInput[] | ActionStepItemCostUncheckedCreateWithoutActionStepInput[]
    connectOrCreate?: ActionStepItemCostCreateOrConnectWithoutActionStepInput | ActionStepItemCostCreateOrConnectWithoutActionStepInput[]
    createMany?: ActionStepItemCostCreateManyActionStepInputEnvelope
    connect?: ActionStepItemCostWhereUniqueInput | ActionStepItemCostWhereUniqueInput[]
  }

  export type ActionStepTranslationCreateNestedManyWithoutActionStepInput = {
    create?: XOR<ActionStepTranslationCreateWithoutActionStepInput, ActionStepTranslationUncheckedCreateWithoutActionStepInput> | ActionStepTranslationCreateWithoutActionStepInput[] | ActionStepTranslationUncheckedCreateWithoutActionStepInput[]
    connectOrCreate?: ActionStepTranslationCreateOrConnectWithoutActionStepInput | ActionStepTranslationCreateOrConnectWithoutActionStepInput[]
    createMany?: ActionStepTranslationCreateManyActionStepInputEnvelope
    connect?: ActionStepTranslationWhereUniqueInput | ActionStepTranslationWhereUniqueInput[]
  }

  export type ActionStepItemCostUncheckedCreateNestedManyWithoutActionStepInput = {
    create?: XOR<ActionStepItemCostCreateWithoutActionStepInput, ActionStepItemCostUncheckedCreateWithoutActionStepInput> | ActionStepItemCostCreateWithoutActionStepInput[] | ActionStepItemCostUncheckedCreateWithoutActionStepInput[]
    connectOrCreate?: ActionStepItemCostCreateOrConnectWithoutActionStepInput | ActionStepItemCostCreateOrConnectWithoutActionStepInput[]
    createMany?: ActionStepItemCostCreateManyActionStepInputEnvelope
    connect?: ActionStepItemCostWhereUniqueInput | ActionStepItemCostWhereUniqueInput[]
  }

  export type ActionStepTranslationUncheckedCreateNestedManyWithoutActionStepInput = {
    create?: XOR<ActionStepTranslationCreateWithoutActionStepInput, ActionStepTranslationUncheckedCreateWithoutActionStepInput> | ActionStepTranslationCreateWithoutActionStepInput[] | ActionStepTranslationUncheckedCreateWithoutActionStepInput[]
    connectOrCreate?: ActionStepTranslationCreateOrConnectWithoutActionStepInput | ActionStepTranslationCreateOrConnectWithoutActionStepInput[]
    createMany?: ActionStepTranslationCreateManyActionStepInputEnvelope
    connect?: ActionStepTranslationWhereUniqueInput | ActionStepTranslationWhereUniqueInput[]
  }

  export type RiskMitigationStrategyUpdateOneRequiredWithoutActionStepsNestedInput = {
    create?: XOR<RiskMitigationStrategyCreateWithoutActionStepsInput, RiskMitigationStrategyUncheckedCreateWithoutActionStepsInput>
    connectOrCreate?: RiskMitigationStrategyCreateOrConnectWithoutActionStepsInput
    upsert?: RiskMitigationStrategyUpsertWithoutActionStepsInput
    connect?: RiskMitigationStrategyWhereUniqueInput
    update?: XOR<XOR<RiskMitigationStrategyUpdateToOneWithWhereWithoutActionStepsInput, RiskMitigationStrategyUpdateWithoutActionStepsInput>, RiskMitigationStrategyUncheckedUpdateWithoutActionStepsInput>
  }

  export type ActionStepItemCostUpdateManyWithoutActionStepNestedInput = {
    create?: XOR<ActionStepItemCostCreateWithoutActionStepInput, ActionStepItemCostUncheckedCreateWithoutActionStepInput> | ActionStepItemCostCreateWithoutActionStepInput[] | ActionStepItemCostUncheckedCreateWithoutActionStepInput[]
    connectOrCreate?: ActionStepItemCostCreateOrConnectWithoutActionStepInput | ActionStepItemCostCreateOrConnectWithoutActionStepInput[]
    upsert?: ActionStepItemCostUpsertWithWhereUniqueWithoutActionStepInput | ActionStepItemCostUpsertWithWhereUniqueWithoutActionStepInput[]
    createMany?: ActionStepItemCostCreateManyActionStepInputEnvelope
    set?: ActionStepItemCostWhereUniqueInput | ActionStepItemCostWhereUniqueInput[]
    disconnect?: ActionStepItemCostWhereUniqueInput | ActionStepItemCostWhereUniqueInput[]
    delete?: ActionStepItemCostWhereUniqueInput | ActionStepItemCostWhereUniqueInput[]
    connect?: ActionStepItemCostWhereUniqueInput | ActionStepItemCostWhereUniqueInput[]
    update?: ActionStepItemCostUpdateWithWhereUniqueWithoutActionStepInput | ActionStepItemCostUpdateWithWhereUniqueWithoutActionStepInput[]
    updateMany?: ActionStepItemCostUpdateManyWithWhereWithoutActionStepInput | ActionStepItemCostUpdateManyWithWhereWithoutActionStepInput[]
    deleteMany?: ActionStepItemCostScalarWhereInput | ActionStepItemCostScalarWhereInput[]
  }

  export type ActionStepTranslationUpdateManyWithoutActionStepNestedInput = {
    create?: XOR<ActionStepTranslationCreateWithoutActionStepInput, ActionStepTranslationUncheckedCreateWithoutActionStepInput> | ActionStepTranslationCreateWithoutActionStepInput[] | ActionStepTranslationUncheckedCreateWithoutActionStepInput[]
    connectOrCreate?: ActionStepTranslationCreateOrConnectWithoutActionStepInput | ActionStepTranslationCreateOrConnectWithoutActionStepInput[]
    upsert?: ActionStepTranslationUpsertWithWhereUniqueWithoutActionStepInput | ActionStepTranslationUpsertWithWhereUniqueWithoutActionStepInput[]
    createMany?: ActionStepTranslationCreateManyActionStepInputEnvelope
    set?: ActionStepTranslationWhereUniqueInput | ActionStepTranslationWhereUniqueInput[]
    disconnect?: ActionStepTranslationWhereUniqueInput | ActionStepTranslationWhereUniqueInput[]
    delete?: ActionStepTranslationWhereUniqueInput | ActionStepTranslationWhereUniqueInput[]
    connect?: ActionStepTranslationWhereUniqueInput | ActionStepTranslationWhereUniqueInput[]
    update?: ActionStepTranslationUpdateWithWhereUniqueWithoutActionStepInput | ActionStepTranslationUpdateWithWhereUniqueWithoutActionStepInput[]
    updateMany?: ActionStepTranslationUpdateManyWithWhereWithoutActionStepInput | ActionStepTranslationUpdateManyWithWhereWithoutActionStepInput[]
    deleteMany?: ActionStepTranslationScalarWhereInput | ActionStepTranslationScalarWhereInput[]
  }

  export type ActionStepItemCostUncheckedUpdateManyWithoutActionStepNestedInput = {
    create?: XOR<ActionStepItemCostCreateWithoutActionStepInput, ActionStepItemCostUncheckedCreateWithoutActionStepInput> | ActionStepItemCostCreateWithoutActionStepInput[] | ActionStepItemCostUncheckedCreateWithoutActionStepInput[]
    connectOrCreate?: ActionStepItemCostCreateOrConnectWithoutActionStepInput | ActionStepItemCostCreateOrConnectWithoutActionStepInput[]
    upsert?: ActionStepItemCostUpsertWithWhereUniqueWithoutActionStepInput | ActionStepItemCostUpsertWithWhereUniqueWithoutActionStepInput[]
    createMany?: ActionStepItemCostCreateManyActionStepInputEnvelope
    set?: ActionStepItemCostWhereUniqueInput | ActionStepItemCostWhereUniqueInput[]
    disconnect?: ActionStepItemCostWhereUniqueInput | ActionStepItemCostWhereUniqueInput[]
    delete?: ActionStepItemCostWhereUniqueInput | ActionStepItemCostWhereUniqueInput[]
    connect?: ActionStepItemCostWhereUniqueInput | ActionStepItemCostWhereUniqueInput[]
    update?: ActionStepItemCostUpdateWithWhereUniqueWithoutActionStepInput | ActionStepItemCostUpdateWithWhereUniqueWithoutActionStepInput[]
    updateMany?: ActionStepItemCostUpdateManyWithWhereWithoutActionStepInput | ActionStepItemCostUpdateManyWithWhereWithoutActionStepInput[]
    deleteMany?: ActionStepItemCostScalarWhereInput | ActionStepItemCostScalarWhereInput[]
  }

  export type ActionStepTranslationUncheckedUpdateManyWithoutActionStepNestedInput = {
    create?: XOR<ActionStepTranslationCreateWithoutActionStepInput, ActionStepTranslationUncheckedCreateWithoutActionStepInput> | ActionStepTranslationCreateWithoutActionStepInput[] | ActionStepTranslationUncheckedCreateWithoutActionStepInput[]
    connectOrCreate?: ActionStepTranslationCreateOrConnectWithoutActionStepInput | ActionStepTranslationCreateOrConnectWithoutActionStepInput[]
    upsert?: ActionStepTranslationUpsertWithWhereUniqueWithoutActionStepInput | ActionStepTranslationUpsertWithWhereUniqueWithoutActionStepInput[]
    createMany?: ActionStepTranslationCreateManyActionStepInputEnvelope
    set?: ActionStepTranslationWhereUniqueInput | ActionStepTranslationWhereUniqueInput[]
    disconnect?: ActionStepTranslationWhereUniqueInput | ActionStepTranslationWhereUniqueInput[]
    delete?: ActionStepTranslationWhereUniqueInput | ActionStepTranslationWhereUniqueInput[]
    connect?: ActionStepTranslationWhereUniqueInput | ActionStepTranslationWhereUniqueInput[]
    update?: ActionStepTranslationUpdateWithWhereUniqueWithoutActionStepInput | ActionStepTranslationUpdateWithWhereUniqueWithoutActionStepInput[]
    updateMany?: ActionStepTranslationUpdateManyWithWhereWithoutActionStepInput | ActionStepTranslationUpdateManyWithWhereWithoutActionStepInput[]
    deleteMany?: ActionStepTranslationScalarWhereInput | ActionStepTranslationScalarWhereInput[]
  }

  export type BusinessTypeCreateNestedOneWithoutBusinessTypeStrategiesInput = {
    create?: XOR<BusinessTypeCreateWithoutBusinessTypeStrategiesInput, BusinessTypeUncheckedCreateWithoutBusinessTypeStrategiesInput>
    connectOrCreate?: BusinessTypeCreateOrConnectWithoutBusinessTypeStrategiesInput
    connect?: BusinessTypeWhereUniqueInput
  }

  export type RiskMitigationStrategyCreateNestedOneWithoutBusinessTypeStrategiesInput = {
    create?: XOR<RiskMitigationStrategyCreateWithoutBusinessTypeStrategiesInput, RiskMitigationStrategyUncheckedCreateWithoutBusinessTypeStrategiesInput>
    connectOrCreate?: RiskMitigationStrategyCreateOrConnectWithoutBusinessTypeStrategiesInput
    connect?: RiskMitigationStrategyWhereUniqueInput
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type BusinessTypeUpdateOneRequiredWithoutBusinessTypeStrategiesNestedInput = {
    create?: XOR<BusinessTypeCreateWithoutBusinessTypeStrategiesInput, BusinessTypeUncheckedCreateWithoutBusinessTypeStrategiesInput>
    connectOrCreate?: BusinessTypeCreateOrConnectWithoutBusinessTypeStrategiesInput
    upsert?: BusinessTypeUpsertWithoutBusinessTypeStrategiesInput
    connect?: BusinessTypeWhereUniqueInput
    update?: XOR<XOR<BusinessTypeUpdateToOneWithWhereWithoutBusinessTypeStrategiesInput, BusinessTypeUpdateWithoutBusinessTypeStrategiesInput>, BusinessTypeUncheckedUpdateWithoutBusinessTypeStrategiesInput>
  }

  export type RiskMitigationStrategyUpdateOneRequiredWithoutBusinessTypeStrategiesNestedInput = {
    create?: XOR<RiskMitigationStrategyCreateWithoutBusinessTypeStrategiesInput, RiskMitigationStrategyUncheckedCreateWithoutBusinessTypeStrategiesInput>
    connectOrCreate?: RiskMitigationStrategyCreateOrConnectWithoutBusinessTypeStrategiesInput
    upsert?: RiskMitigationStrategyUpsertWithoutBusinessTypeStrategiesInput
    connect?: RiskMitigationStrategyWhereUniqueInput
    update?: XOR<XOR<RiskMitigationStrategyUpdateToOneWithWhereWithoutBusinessTypeStrategiesInput, RiskMitigationStrategyUpdateWithoutBusinessTypeStrategiesInput>, RiskMitigationStrategyUncheckedUpdateWithoutBusinessTypeStrategiesInput>
  }

  export type BusinessTypeCreateNestedOneWithoutBusinessRiskProfilesInput = {
    create?: XOR<BusinessTypeCreateWithoutBusinessRiskProfilesInput, BusinessTypeUncheckedCreateWithoutBusinessRiskProfilesInput>
    connectOrCreate?: BusinessTypeCreateOrConnectWithoutBusinessRiskProfilesInput
    connect?: BusinessTypeWhereUniqueInput
  }

  export type ParishCreateNestedOneWithoutBusinessRiskProfilesInput = {
    create?: XOR<ParishCreateWithoutBusinessRiskProfilesInput, ParishUncheckedCreateWithoutBusinessRiskProfilesInput>
    connectOrCreate?: ParishCreateOrConnectWithoutBusinessRiskProfilesInput
    connect?: ParishWhereUniqueInput
  }

  export type BusinessTypeUpdateOneRequiredWithoutBusinessRiskProfilesNestedInput = {
    create?: XOR<BusinessTypeCreateWithoutBusinessRiskProfilesInput, BusinessTypeUncheckedCreateWithoutBusinessRiskProfilesInput>
    connectOrCreate?: BusinessTypeCreateOrConnectWithoutBusinessRiskProfilesInput
    upsert?: BusinessTypeUpsertWithoutBusinessRiskProfilesInput
    connect?: BusinessTypeWhereUniqueInput
    update?: XOR<XOR<BusinessTypeUpdateToOneWithWhereWithoutBusinessRiskProfilesInput, BusinessTypeUpdateWithoutBusinessRiskProfilesInput>, BusinessTypeUncheckedUpdateWithoutBusinessRiskProfilesInput>
  }

  export type ParishUpdateOneRequiredWithoutBusinessRiskProfilesNestedInput = {
    create?: XOR<ParishCreateWithoutBusinessRiskProfilesInput, ParishUncheckedCreateWithoutBusinessRiskProfilesInput>
    connectOrCreate?: ParishCreateOrConnectWithoutBusinessRiskProfilesInput
    upsert?: ParishUpsertWithoutBusinessRiskProfilesInput
    connect?: ParishWhereUniqueInput
    update?: XOR<XOR<ParishUpdateToOneWithWhereWithoutBusinessRiskProfilesInput, ParishUpdateWithoutBusinessRiskProfilesInput>, ParishUncheckedUpdateWithoutBusinessRiskProfilesInput>
  }

  export type RiskMultiplierTranslationCreateNestedManyWithoutRiskMultiplierInput = {
    create?: XOR<RiskMultiplierTranslationCreateWithoutRiskMultiplierInput, RiskMultiplierTranslationUncheckedCreateWithoutRiskMultiplierInput> | RiskMultiplierTranslationCreateWithoutRiskMultiplierInput[] | RiskMultiplierTranslationUncheckedCreateWithoutRiskMultiplierInput[]
    connectOrCreate?: RiskMultiplierTranslationCreateOrConnectWithoutRiskMultiplierInput | RiskMultiplierTranslationCreateOrConnectWithoutRiskMultiplierInput[]
    createMany?: RiskMultiplierTranslationCreateManyRiskMultiplierInputEnvelope
    connect?: RiskMultiplierTranslationWhereUniqueInput | RiskMultiplierTranslationWhereUniqueInput[]
  }

  export type RiskMultiplierTranslationUncheckedCreateNestedManyWithoutRiskMultiplierInput = {
    create?: XOR<RiskMultiplierTranslationCreateWithoutRiskMultiplierInput, RiskMultiplierTranslationUncheckedCreateWithoutRiskMultiplierInput> | RiskMultiplierTranslationCreateWithoutRiskMultiplierInput[] | RiskMultiplierTranslationUncheckedCreateWithoutRiskMultiplierInput[]
    connectOrCreate?: RiskMultiplierTranslationCreateOrConnectWithoutRiskMultiplierInput | RiskMultiplierTranslationCreateOrConnectWithoutRiskMultiplierInput[]
    createMany?: RiskMultiplierTranslationCreateManyRiskMultiplierInputEnvelope
    connect?: RiskMultiplierTranslationWhereUniqueInput | RiskMultiplierTranslationWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type RiskMultiplierTranslationUpdateManyWithoutRiskMultiplierNestedInput = {
    create?: XOR<RiskMultiplierTranslationCreateWithoutRiskMultiplierInput, RiskMultiplierTranslationUncheckedCreateWithoutRiskMultiplierInput> | RiskMultiplierTranslationCreateWithoutRiskMultiplierInput[] | RiskMultiplierTranslationUncheckedCreateWithoutRiskMultiplierInput[]
    connectOrCreate?: RiskMultiplierTranslationCreateOrConnectWithoutRiskMultiplierInput | RiskMultiplierTranslationCreateOrConnectWithoutRiskMultiplierInput[]
    upsert?: RiskMultiplierTranslationUpsertWithWhereUniqueWithoutRiskMultiplierInput | RiskMultiplierTranslationUpsertWithWhereUniqueWithoutRiskMultiplierInput[]
    createMany?: RiskMultiplierTranslationCreateManyRiskMultiplierInputEnvelope
    set?: RiskMultiplierTranslationWhereUniqueInput | RiskMultiplierTranslationWhereUniqueInput[]
    disconnect?: RiskMultiplierTranslationWhereUniqueInput | RiskMultiplierTranslationWhereUniqueInput[]
    delete?: RiskMultiplierTranslationWhereUniqueInput | RiskMultiplierTranslationWhereUniqueInput[]
    connect?: RiskMultiplierTranslationWhereUniqueInput | RiskMultiplierTranslationWhereUniqueInput[]
    update?: RiskMultiplierTranslationUpdateWithWhereUniqueWithoutRiskMultiplierInput | RiskMultiplierTranslationUpdateWithWhereUniqueWithoutRiskMultiplierInput[]
    updateMany?: RiskMultiplierTranslationUpdateManyWithWhereWithoutRiskMultiplierInput | RiskMultiplierTranslationUpdateManyWithWhereWithoutRiskMultiplierInput[]
    deleteMany?: RiskMultiplierTranslationScalarWhereInput | RiskMultiplierTranslationScalarWhereInput[]
  }

  export type RiskMultiplierTranslationUncheckedUpdateManyWithoutRiskMultiplierNestedInput = {
    create?: XOR<RiskMultiplierTranslationCreateWithoutRiskMultiplierInput, RiskMultiplierTranslationUncheckedCreateWithoutRiskMultiplierInput> | RiskMultiplierTranslationCreateWithoutRiskMultiplierInput[] | RiskMultiplierTranslationUncheckedCreateWithoutRiskMultiplierInput[]
    connectOrCreate?: RiskMultiplierTranslationCreateOrConnectWithoutRiskMultiplierInput | RiskMultiplierTranslationCreateOrConnectWithoutRiskMultiplierInput[]
    upsert?: RiskMultiplierTranslationUpsertWithWhereUniqueWithoutRiskMultiplierInput | RiskMultiplierTranslationUpsertWithWhereUniqueWithoutRiskMultiplierInput[]
    createMany?: RiskMultiplierTranslationCreateManyRiskMultiplierInputEnvelope
    set?: RiskMultiplierTranslationWhereUniqueInput | RiskMultiplierTranslationWhereUniqueInput[]
    disconnect?: RiskMultiplierTranslationWhereUniqueInput | RiskMultiplierTranslationWhereUniqueInput[]
    delete?: RiskMultiplierTranslationWhereUniqueInput | RiskMultiplierTranslationWhereUniqueInput[]
    connect?: RiskMultiplierTranslationWhereUniqueInput | RiskMultiplierTranslationWhereUniqueInput[]
    update?: RiskMultiplierTranslationUpdateWithWhereUniqueWithoutRiskMultiplierInput | RiskMultiplierTranslationUpdateWithWhereUniqueWithoutRiskMultiplierInput[]
    updateMany?: RiskMultiplierTranslationUpdateManyWithWhereWithoutRiskMultiplierInput | RiskMultiplierTranslationUpdateManyWithWhereWithoutRiskMultiplierInput[]
    deleteMany?: RiskMultiplierTranslationScalarWhereInput | RiskMultiplierTranslationScalarWhereInput[]
  }

  export type StrategyItemCostCreateNestedManyWithoutItemInput = {
    create?: XOR<StrategyItemCostCreateWithoutItemInput, StrategyItemCostUncheckedCreateWithoutItemInput> | StrategyItemCostCreateWithoutItemInput[] | StrategyItemCostUncheckedCreateWithoutItemInput[]
    connectOrCreate?: StrategyItemCostCreateOrConnectWithoutItemInput | StrategyItemCostCreateOrConnectWithoutItemInput[]
    createMany?: StrategyItemCostCreateManyItemInputEnvelope
    connect?: StrategyItemCostWhereUniqueInput | StrategyItemCostWhereUniqueInput[]
  }

  export type ActionStepItemCostCreateNestedManyWithoutItemInput = {
    create?: XOR<ActionStepItemCostCreateWithoutItemInput, ActionStepItemCostUncheckedCreateWithoutItemInput> | ActionStepItemCostCreateWithoutItemInput[] | ActionStepItemCostUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ActionStepItemCostCreateOrConnectWithoutItemInput | ActionStepItemCostCreateOrConnectWithoutItemInput[]
    createMany?: ActionStepItemCostCreateManyItemInputEnvelope
    connect?: ActionStepItemCostWhereUniqueInput | ActionStepItemCostWhereUniqueInput[]
  }

  export type StrategyItemCostUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<StrategyItemCostCreateWithoutItemInput, StrategyItemCostUncheckedCreateWithoutItemInput> | StrategyItemCostCreateWithoutItemInput[] | StrategyItemCostUncheckedCreateWithoutItemInput[]
    connectOrCreate?: StrategyItemCostCreateOrConnectWithoutItemInput | StrategyItemCostCreateOrConnectWithoutItemInput[]
    createMany?: StrategyItemCostCreateManyItemInputEnvelope
    connect?: StrategyItemCostWhereUniqueInput | StrategyItemCostWhereUniqueInput[]
  }

  export type ActionStepItemCostUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<ActionStepItemCostCreateWithoutItemInput, ActionStepItemCostUncheckedCreateWithoutItemInput> | ActionStepItemCostCreateWithoutItemInput[] | ActionStepItemCostUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ActionStepItemCostCreateOrConnectWithoutItemInput | ActionStepItemCostCreateOrConnectWithoutItemInput[]
    createMany?: ActionStepItemCostCreateManyItemInputEnvelope
    connect?: ActionStepItemCostWhereUniqueInput | ActionStepItemCostWhereUniqueInput[]
  }

  export type StrategyItemCostUpdateManyWithoutItemNestedInput = {
    create?: XOR<StrategyItemCostCreateWithoutItemInput, StrategyItemCostUncheckedCreateWithoutItemInput> | StrategyItemCostCreateWithoutItemInput[] | StrategyItemCostUncheckedCreateWithoutItemInput[]
    connectOrCreate?: StrategyItemCostCreateOrConnectWithoutItemInput | StrategyItemCostCreateOrConnectWithoutItemInput[]
    upsert?: StrategyItemCostUpsertWithWhereUniqueWithoutItemInput | StrategyItemCostUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: StrategyItemCostCreateManyItemInputEnvelope
    set?: StrategyItemCostWhereUniqueInput | StrategyItemCostWhereUniqueInput[]
    disconnect?: StrategyItemCostWhereUniqueInput | StrategyItemCostWhereUniqueInput[]
    delete?: StrategyItemCostWhereUniqueInput | StrategyItemCostWhereUniqueInput[]
    connect?: StrategyItemCostWhereUniqueInput | StrategyItemCostWhereUniqueInput[]
    update?: StrategyItemCostUpdateWithWhereUniqueWithoutItemInput | StrategyItemCostUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: StrategyItemCostUpdateManyWithWhereWithoutItemInput | StrategyItemCostUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: StrategyItemCostScalarWhereInput | StrategyItemCostScalarWhereInput[]
  }

  export type ActionStepItemCostUpdateManyWithoutItemNestedInput = {
    create?: XOR<ActionStepItemCostCreateWithoutItemInput, ActionStepItemCostUncheckedCreateWithoutItemInput> | ActionStepItemCostCreateWithoutItemInput[] | ActionStepItemCostUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ActionStepItemCostCreateOrConnectWithoutItemInput | ActionStepItemCostCreateOrConnectWithoutItemInput[]
    upsert?: ActionStepItemCostUpsertWithWhereUniqueWithoutItemInput | ActionStepItemCostUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: ActionStepItemCostCreateManyItemInputEnvelope
    set?: ActionStepItemCostWhereUniqueInput | ActionStepItemCostWhereUniqueInput[]
    disconnect?: ActionStepItemCostWhereUniqueInput | ActionStepItemCostWhereUniqueInput[]
    delete?: ActionStepItemCostWhereUniqueInput | ActionStepItemCostWhereUniqueInput[]
    connect?: ActionStepItemCostWhereUniqueInput | ActionStepItemCostWhereUniqueInput[]
    update?: ActionStepItemCostUpdateWithWhereUniqueWithoutItemInput | ActionStepItemCostUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: ActionStepItemCostUpdateManyWithWhereWithoutItemInput | ActionStepItemCostUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: ActionStepItemCostScalarWhereInput | ActionStepItemCostScalarWhereInput[]
  }

  export type StrategyItemCostUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<StrategyItemCostCreateWithoutItemInput, StrategyItemCostUncheckedCreateWithoutItemInput> | StrategyItemCostCreateWithoutItemInput[] | StrategyItemCostUncheckedCreateWithoutItemInput[]
    connectOrCreate?: StrategyItemCostCreateOrConnectWithoutItemInput | StrategyItemCostCreateOrConnectWithoutItemInput[]
    upsert?: StrategyItemCostUpsertWithWhereUniqueWithoutItemInput | StrategyItemCostUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: StrategyItemCostCreateManyItemInputEnvelope
    set?: StrategyItemCostWhereUniqueInput | StrategyItemCostWhereUniqueInput[]
    disconnect?: StrategyItemCostWhereUniqueInput | StrategyItemCostWhereUniqueInput[]
    delete?: StrategyItemCostWhereUniqueInput | StrategyItemCostWhereUniqueInput[]
    connect?: StrategyItemCostWhereUniqueInput | StrategyItemCostWhereUniqueInput[]
    update?: StrategyItemCostUpdateWithWhereUniqueWithoutItemInput | StrategyItemCostUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: StrategyItemCostUpdateManyWithWhereWithoutItemInput | StrategyItemCostUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: StrategyItemCostScalarWhereInput | StrategyItemCostScalarWhereInput[]
  }

  export type ActionStepItemCostUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<ActionStepItemCostCreateWithoutItemInput, ActionStepItemCostUncheckedCreateWithoutItemInput> | ActionStepItemCostCreateWithoutItemInput[] | ActionStepItemCostUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ActionStepItemCostCreateOrConnectWithoutItemInput | ActionStepItemCostCreateOrConnectWithoutItemInput[]
    upsert?: ActionStepItemCostUpsertWithWhereUniqueWithoutItemInput | ActionStepItemCostUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: ActionStepItemCostCreateManyItemInputEnvelope
    set?: ActionStepItemCostWhereUniqueInput | ActionStepItemCostWhereUniqueInput[]
    disconnect?: ActionStepItemCostWhereUniqueInput | ActionStepItemCostWhereUniqueInput[]
    delete?: ActionStepItemCostWhereUniqueInput | ActionStepItemCostWhereUniqueInput[]
    connect?: ActionStepItemCostWhereUniqueInput | ActionStepItemCostWhereUniqueInput[]
    update?: ActionStepItemCostUpdateWithWhereUniqueWithoutItemInput | ActionStepItemCostUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: ActionStepItemCostUpdateManyWithWhereWithoutItemInput | ActionStepItemCostUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: ActionStepItemCostScalarWhereInput | ActionStepItemCostScalarWhereInput[]
  }

  export type RiskMitigationStrategyCreateNestedOneWithoutItemCostsInput = {
    create?: XOR<RiskMitigationStrategyCreateWithoutItemCostsInput, RiskMitigationStrategyUncheckedCreateWithoutItemCostsInput>
    connectOrCreate?: RiskMitigationStrategyCreateOrConnectWithoutItemCostsInput
    connect?: RiskMitigationStrategyWhereUniqueInput
  }

  export type CostItemCreateNestedOneWithoutStrategyItemsInput = {
    create?: XOR<CostItemCreateWithoutStrategyItemsInput, CostItemUncheckedCreateWithoutStrategyItemsInput>
    connectOrCreate?: CostItemCreateOrConnectWithoutStrategyItemsInput
    connect?: CostItemWhereUniqueInput
  }

  export type RiskMitigationStrategyUpdateOneRequiredWithoutItemCostsNestedInput = {
    create?: XOR<RiskMitigationStrategyCreateWithoutItemCostsInput, RiskMitigationStrategyUncheckedCreateWithoutItemCostsInput>
    connectOrCreate?: RiskMitigationStrategyCreateOrConnectWithoutItemCostsInput
    upsert?: RiskMitigationStrategyUpsertWithoutItemCostsInput
    connect?: RiskMitigationStrategyWhereUniqueInput
    update?: XOR<XOR<RiskMitigationStrategyUpdateToOneWithWhereWithoutItemCostsInput, RiskMitigationStrategyUpdateWithoutItemCostsInput>, RiskMitigationStrategyUncheckedUpdateWithoutItemCostsInput>
  }

  export type CostItemUpdateOneRequiredWithoutStrategyItemsNestedInput = {
    create?: XOR<CostItemCreateWithoutStrategyItemsInput, CostItemUncheckedCreateWithoutStrategyItemsInput>
    connectOrCreate?: CostItemCreateOrConnectWithoutStrategyItemsInput
    upsert?: CostItemUpsertWithoutStrategyItemsInput
    connect?: CostItemWhereUniqueInput
    update?: XOR<XOR<CostItemUpdateToOneWithWhereWithoutStrategyItemsInput, CostItemUpdateWithoutStrategyItemsInput>, CostItemUncheckedUpdateWithoutStrategyItemsInput>
  }

  export type ActionStepCreateNestedOneWithoutItemCostsInput = {
    create?: XOR<ActionStepCreateWithoutItemCostsInput, ActionStepUncheckedCreateWithoutItemCostsInput>
    connectOrCreate?: ActionStepCreateOrConnectWithoutItemCostsInput
    connect?: ActionStepWhereUniqueInput
  }

  export type CostItemCreateNestedOneWithoutActionStepItemsInput = {
    create?: XOR<CostItemCreateWithoutActionStepItemsInput, CostItemUncheckedCreateWithoutActionStepItemsInput>
    connectOrCreate?: CostItemCreateOrConnectWithoutActionStepItemsInput
    connect?: CostItemWhereUniqueInput
  }

  export type ActionStepUpdateOneRequiredWithoutItemCostsNestedInput = {
    create?: XOR<ActionStepCreateWithoutItemCostsInput, ActionStepUncheckedCreateWithoutItemCostsInput>
    connectOrCreate?: ActionStepCreateOrConnectWithoutItemCostsInput
    upsert?: ActionStepUpsertWithoutItemCostsInput
    connect?: ActionStepWhereUniqueInput
    update?: XOR<XOR<ActionStepUpdateToOneWithWhereWithoutItemCostsInput, ActionStepUpdateWithoutItemCostsInput>, ActionStepUncheckedUpdateWithoutItemCostsInput>
  }

  export type CostItemUpdateOneRequiredWithoutActionStepItemsNestedInput = {
    create?: XOR<CostItemCreateWithoutActionStepItemsInput, CostItemUncheckedCreateWithoutActionStepItemsInput>
    connectOrCreate?: CostItemCreateOrConnectWithoutActionStepItemsInput
    upsert?: CostItemUpsertWithoutActionStepItemsInput
    connect?: CostItemWhereUniqueInput
    update?: XOR<XOR<CostItemUpdateToOneWithWhereWithoutActionStepItemsInput, CostItemUpdateWithoutActionStepItemsInput>, CostItemUncheckedUpdateWithoutActionStepItemsInput>
  }

  export type BusinessTypeCreateNestedOneWithoutTranslationsInput = {
    create?: XOR<BusinessTypeCreateWithoutTranslationsInput, BusinessTypeUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: BusinessTypeCreateOrConnectWithoutTranslationsInput
    connect?: BusinessTypeWhereUniqueInput
  }

  export type BusinessTypeUpdateOneRequiredWithoutTranslationsNestedInput = {
    create?: XOR<BusinessTypeCreateWithoutTranslationsInput, BusinessTypeUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: BusinessTypeCreateOrConnectWithoutTranslationsInput
    upsert?: BusinessTypeUpsertWithoutTranslationsInput
    connect?: BusinessTypeWhereUniqueInput
    update?: XOR<XOR<BusinessTypeUpdateToOneWithWhereWithoutTranslationsInput, BusinessTypeUpdateWithoutTranslationsInput>, BusinessTypeUncheckedUpdateWithoutTranslationsInput>
  }

  export type RiskMitigationStrategyCreateNestedOneWithoutTranslationsInput = {
    create?: XOR<RiskMitigationStrategyCreateWithoutTranslationsInput, RiskMitigationStrategyUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: RiskMitigationStrategyCreateOrConnectWithoutTranslationsInput
    connect?: RiskMitigationStrategyWhereUniqueInput
  }

  export type RiskMitigationStrategyUpdateOneRequiredWithoutTranslationsNestedInput = {
    create?: XOR<RiskMitigationStrategyCreateWithoutTranslationsInput, RiskMitigationStrategyUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: RiskMitigationStrategyCreateOrConnectWithoutTranslationsInput
    upsert?: RiskMitigationStrategyUpsertWithoutTranslationsInput
    connect?: RiskMitigationStrategyWhereUniqueInput
    update?: XOR<XOR<RiskMitigationStrategyUpdateToOneWithWhereWithoutTranslationsInput, RiskMitigationStrategyUpdateWithoutTranslationsInput>, RiskMitigationStrategyUncheckedUpdateWithoutTranslationsInput>
  }

  export type ActionStepCreateNestedOneWithoutTranslationsInput = {
    create?: XOR<ActionStepCreateWithoutTranslationsInput, ActionStepUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: ActionStepCreateOrConnectWithoutTranslationsInput
    connect?: ActionStepWhereUniqueInput
  }

  export type ActionStepUpdateOneRequiredWithoutTranslationsNestedInput = {
    create?: XOR<ActionStepCreateWithoutTranslationsInput, ActionStepUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: ActionStepCreateOrConnectWithoutTranslationsInput
    upsert?: ActionStepUpsertWithoutTranslationsInput
    connect?: ActionStepWhereUniqueInput
    update?: XOR<XOR<ActionStepUpdateToOneWithWhereWithoutTranslationsInput, ActionStepUpdateWithoutTranslationsInput>, ActionStepUncheckedUpdateWithoutTranslationsInput>
  }

  export type AdminHazardTypeCreateNestedOneWithoutTranslationsInput = {
    create?: XOR<AdminHazardTypeCreateWithoutTranslationsInput, AdminHazardTypeUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: AdminHazardTypeCreateOrConnectWithoutTranslationsInput
    connect?: AdminHazardTypeWhereUniqueInput
  }

  export type AdminHazardTypeUpdateOneRequiredWithoutTranslationsNestedInput = {
    create?: XOR<AdminHazardTypeCreateWithoutTranslationsInput, AdminHazardTypeUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: AdminHazardTypeCreateOrConnectWithoutTranslationsInput
    upsert?: AdminHazardTypeUpsertWithoutTranslationsInput
    connect?: AdminHazardTypeWhereUniqueInput
    update?: XOR<XOR<AdminHazardTypeUpdateToOneWithWhereWithoutTranslationsInput, AdminHazardTypeUpdateWithoutTranslationsInput>, AdminHazardTypeUncheckedUpdateWithoutTranslationsInput>
  }

  export type RiskMultiplierCreateNestedOneWithoutTranslationsInput = {
    create?: XOR<RiskMultiplierCreateWithoutTranslationsInput, RiskMultiplierUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: RiskMultiplierCreateOrConnectWithoutTranslationsInput
    connect?: RiskMultiplierWhereUniqueInput
  }

  export type RiskMultiplierUpdateOneRequiredWithoutTranslationsNestedInput = {
    create?: XOR<RiskMultiplierCreateWithoutTranslationsInput, RiskMultiplierUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: RiskMultiplierCreateOrConnectWithoutTranslationsInput
    upsert?: RiskMultiplierUpsertWithoutTranslationsInput
    connect?: RiskMultiplierWhereUniqueInput
    update?: XOR<XOR<RiskMultiplierUpdateToOneWithWhereWithoutTranslationsInput, RiskMultiplierUpdateWithoutTranslationsInput>, RiskMultiplierUncheckedUpdateWithoutTranslationsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type PlanInformationCreateWithoutPlanInput = {
    id?: string
    companyName: string
    planManager: string
    alternateManager?: string | null
    physicalPlanLocation: string
    digitalPlanLocation?: string | null
  }

  export type PlanInformationUncheckedCreateWithoutPlanInput = {
    id?: string
    companyName: string
    planManager: string
    alternateManager?: string | null
    physicalPlanLocation: string
    digitalPlanLocation?: string | null
  }

  export type PlanInformationCreateOrConnectWithoutPlanInput = {
    where: PlanInformationWhereUniqueInput
    create: XOR<PlanInformationCreateWithoutPlanInput, PlanInformationUncheckedCreateWithoutPlanInput>
  }

  export type BusinessOverviewCreateWithoutPlanInput = {
    id?: string
    businessLicenseNumber: string
    businessPurpose: string
    productsAndServices: string
    serviceDeliveryMethods: string
    operatingHours: string
    keyPersonnel: string
    minimumResources: string
    customerBase: string
    serviceProviderBCP: string
  }

  export type BusinessOverviewUncheckedCreateWithoutPlanInput = {
    id?: string
    businessLicenseNumber: string
    businessPurpose: string
    productsAndServices: string
    serviceDeliveryMethods: string
    operatingHours: string
    keyPersonnel: string
    minimumResources: string
    customerBase: string
    serviceProviderBCP: string
  }

  export type BusinessOverviewCreateOrConnectWithoutPlanInput = {
    where: BusinessOverviewWhereUniqueInput
    create: XOR<BusinessOverviewCreateWithoutPlanInput, BusinessOverviewUncheckedCreateWithoutPlanInput>
  }

  export type EssentialFunctionCreateWithoutPlanInput = {
    id?: string
    supplyChainManagement: string
    staffManagement: string
    technology: string
    productsServices: string
    infrastructureFacilities: string
    sales: string
    administration: string
  }

  export type EssentialFunctionUncheckedCreateWithoutPlanInput = {
    id?: string
    supplyChainManagement: string
    staffManagement: string
    technology: string
    productsServices: string
    infrastructureFacilities: string
    sales: string
    administration: string
  }

  export type EssentialFunctionCreateOrConnectWithoutPlanInput = {
    where: EssentialFunctionWhereUniqueInput
    create: XOR<EssentialFunctionCreateWithoutPlanInput, EssentialFunctionUncheckedCreateWithoutPlanInput>
  }

  export type RiskAssessmentCreateWithoutPlanInput = {
    id?: string
    potentialHazards: string
    hazards: string
  }

  export type RiskAssessmentUncheckedCreateWithoutPlanInput = {
    id?: string
    potentialHazards: string
    hazards: string
  }

  export type RiskAssessmentCreateOrConnectWithoutPlanInput = {
    where: RiskAssessmentWhereUniqueInput
    create: XOR<RiskAssessmentCreateWithoutPlanInput, RiskAssessmentUncheckedCreateWithoutPlanInput>
  }

  export type StrategyCreateWithoutPlanInput = {
    id?: string
    preventionStrategies: string
    responseStrategies: string
    recoveryStrategies: string
    longTermRiskReduction: string
  }

  export type StrategyUncheckedCreateWithoutPlanInput = {
    id?: string
    preventionStrategies: string
    responseStrategies: string
    recoveryStrategies: string
    longTermRiskReduction: string
  }

  export type StrategyCreateOrConnectWithoutPlanInput = {
    where: StrategyWhereUniqueInput
    create: XOR<StrategyCreateWithoutPlanInput, StrategyUncheckedCreateWithoutPlanInput>
  }

  export type ActionPlanCreateWithoutPlanInput = {
    id?: string
    actionPlanByRisk: string
    implementationTimeline: string
    resourceRequirements: string
    responsibleParties: string
    reviewUpdateSchedule: string
    testingAssessmentPlan: string
  }

  export type ActionPlanUncheckedCreateWithoutPlanInput = {
    id?: string
    actionPlanByRisk: string
    implementationTimeline: string
    resourceRequirements: string
    responsibleParties: string
    reviewUpdateSchedule: string
    testingAssessmentPlan: string
  }

  export type ActionPlanCreateOrConnectWithoutPlanInput = {
    where: ActionPlanWhereUniqueInput
    create: XOR<ActionPlanCreateWithoutPlanInput, ActionPlanUncheckedCreateWithoutPlanInput>
  }

  export type ContactsInformationCreateWithoutPlanInput = {
    id?: string
    staffContactInfo: string
    keyCustomerContacts: string
    supplierInformation: string
    emergencyServicesUtilities: string
    criticalBusinessInfo: string
    planDistributionList: string
  }

  export type ContactsInformationUncheckedCreateWithoutPlanInput = {
    id?: string
    staffContactInfo: string
    keyCustomerContacts: string
    supplierInformation: string
    emergencyServicesUtilities: string
    criticalBusinessInfo: string
    planDistributionList: string
  }

  export type ContactsInformationCreateOrConnectWithoutPlanInput = {
    where: ContactsInformationWhereUniqueInput
    create: XOR<ContactsInformationCreateWithoutPlanInput, ContactsInformationUncheckedCreateWithoutPlanInput>
  }

  export type TestingMaintenanceCreateWithoutPlanInput = {
    id?: string
    planTestingSchedule: string
    planRevisionHistory: string
    improvementTracking: string
    annualReviewProcess: string
    triggerEventsForUpdates: string
  }

  export type TestingMaintenanceUncheckedCreateWithoutPlanInput = {
    id?: string
    planTestingSchedule: string
    planRevisionHistory: string
    improvementTracking: string
    annualReviewProcess: string
    triggerEventsForUpdates: string
  }

  export type TestingMaintenanceCreateOrConnectWithoutPlanInput = {
    where: TestingMaintenanceWhereUniqueInput
    create: XOR<TestingMaintenanceCreateWithoutPlanInput, TestingMaintenanceUncheckedCreateWithoutPlanInput>
  }

  export type PlanInformationUpsertWithoutPlanInput = {
    update: XOR<PlanInformationUpdateWithoutPlanInput, PlanInformationUncheckedUpdateWithoutPlanInput>
    create: XOR<PlanInformationCreateWithoutPlanInput, PlanInformationUncheckedCreateWithoutPlanInput>
    where?: PlanInformationWhereInput
  }

  export type PlanInformationUpdateToOneWithWhereWithoutPlanInput = {
    where?: PlanInformationWhereInput
    data: XOR<PlanInformationUpdateWithoutPlanInput, PlanInformationUncheckedUpdateWithoutPlanInput>
  }

  export type PlanInformationUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    planManager?: StringFieldUpdateOperationsInput | string
    alternateManager?: NullableStringFieldUpdateOperationsInput | string | null
    physicalPlanLocation?: StringFieldUpdateOperationsInput | string
    digitalPlanLocation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlanInformationUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    planManager?: StringFieldUpdateOperationsInput | string
    alternateManager?: NullableStringFieldUpdateOperationsInput | string | null
    physicalPlanLocation?: StringFieldUpdateOperationsInput | string
    digitalPlanLocation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BusinessOverviewUpsertWithoutPlanInput = {
    update: XOR<BusinessOverviewUpdateWithoutPlanInput, BusinessOverviewUncheckedUpdateWithoutPlanInput>
    create: XOR<BusinessOverviewCreateWithoutPlanInput, BusinessOverviewUncheckedCreateWithoutPlanInput>
    where?: BusinessOverviewWhereInput
  }

  export type BusinessOverviewUpdateToOneWithWhereWithoutPlanInput = {
    where?: BusinessOverviewWhereInput
    data: XOR<BusinessOverviewUpdateWithoutPlanInput, BusinessOverviewUncheckedUpdateWithoutPlanInput>
  }

  export type BusinessOverviewUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessLicenseNumber?: StringFieldUpdateOperationsInput | string
    businessPurpose?: StringFieldUpdateOperationsInput | string
    productsAndServices?: StringFieldUpdateOperationsInput | string
    serviceDeliveryMethods?: StringFieldUpdateOperationsInput | string
    operatingHours?: StringFieldUpdateOperationsInput | string
    keyPersonnel?: StringFieldUpdateOperationsInput | string
    minimumResources?: StringFieldUpdateOperationsInput | string
    customerBase?: StringFieldUpdateOperationsInput | string
    serviceProviderBCP?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessOverviewUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessLicenseNumber?: StringFieldUpdateOperationsInput | string
    businessPurpose?: StringFieldUpdateOperationsInput | string
    productsAndServices?: StringFieldUpdateOperationsInput | string
    serviceDeliveryMethods?: StringFieldUpdateOperationsInput | string
    operatingHours?: StringFieldUpdateOperationsInput | string
    keyPersonnel?: StringFieldUpdateOperationsInput | string
    minimumResources?: StringFieldUpdateOperationsInput | string
    customerBase?: StringFieldUpdateOperationsInput | string
    serviceProviderBCP?: StringFieldUpdateOperationsInput | string
  }

  export type EssentialFunctionUpsertWithoutPlanInput = {
    update: XOR<EssentialFunctionUpdateWithoutPlanInput, EssentialFunctionUncheckedUpdateWithoutPlanInput>
    create: XOR<EssentialFunctionCreateWithoutPlanInput, EssentialFunctionUncheckedCreateWithoutPlanInput>
    where?: EssentialFunctionWhereInput
  }

  export type EssentialFunctionUpdateToOneWithWhereWithoutPlanInput = {
    where?: EssentialFunctionWhereInput
    data: XOR<EssentialFunctionUpdateWithoutPlanInput, EssentialFunctionUncheckedUpdateWithoutPlanInput>
  }

  export type EssentialFunctionUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplyChainManagement?: StringFieldUpdateOperationsInput | string
    staffManagement?: StringFieldUpdateOperationsInput | string
    technology?: StringFieldUpdateOperationsInput | string
    productsServices?: StringFieldUpdateOperationsInput | string
    infrastructureFacilities?: StringFieldUpdateOperationsInput | string
    sales?: StringFieldUpdateOperationsInput | string
    administration?: StringFieldUpdateOperationsInput | string
  }

  export type EssentialFunctionUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplyChainManagement?: StringFieldUpdateOperationsInput | string
    staffManagement?: StringFieldUpdateOperationsInput | string
    technology?: StringFieldUpdateOperationsInput | string
    productsServices?: StringFieldUpdateOperationsInput | string
    infrastructureFacilities?: StringFieldUpdateOperationsInput | string
    sales?: StringFieldUpdateOperationsInput | string
    administration?: StringFieldUpdateOperationsInput | string
  }

  export type RiskAssessmentUpsertWithoutPlanInput = {
    update: XOR<RiskAssessmentUpdateWithoutPlanInput, RiskAssessmentUncheckedUpdateWithoutPlanInput>
    create: XOR<RiskAssessmentCreateWithoutPlanInput, RiskAssessmentUncheckedCreateWithoutPlanInput>
    where?: RiskAssessmentWhereInput
  }

  export type RiskAssessmentUpdateToOneWithWhereWithoutPlanInput = {
    where?: RiskAssessmentWhereInput
    data: XOR<RiskAssessmentUpdateWithoutPlanInput, RiskAssessmentUncheckedUpdateWithoutPlanInput>
  }

  export type RiskAssessmentUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    potentialHazards?: StringFieldUpdateOperationsInput | string
    hazards?: StringFieldUpdateOperationsInput | string
  }

  export type RiskAssessmentUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    potentialHazards?: StringFieldUpdateOperationsInput | string
    hazards?: StringFieldUpdateOperationsInput | string
  }

  export type StrategyUpsertWithoutPlanInput = {
    update: XOR<StrategyUpdateWithoutPlanInput, StrategyUncheckedUpdateWithoutPlanInput>
    create: XOR<StrategyCreateWithoutPlanInput, StrategyUncheckedCreateWithoutPlanInput>
    where?: StrategyWhereInput
  }

  export type StrategyUpdateToOneWithWhereWithoutPlanInput = {
    where?: StrategyWhereInput
    data: XOR<StrategyUpdateWithoutPlanInput, StrategyUncheckedUpdateWithoutPlanInput>
  }

  export type StrategyUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    preventionStrategies?: StringFieldUpdateOperationsInput | string
    responseStrategies?: StringFieldUpdateOperationsInput | string
    recoveryStrategies?: StringFieldUpdateOperationsInput | string
    longTermRiskReduction?: StringFieldUpdateOperationsInput | string
  }

  export type StrategyUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    preventionStrategies?: StringFieldUpdateOperationsInput | string
    responseStrategies?: StringFieldUpdateOperationsInput | string
    recoveryStrategies?: StringFieldUpdateOperationsInput | string
    longTermRiskReduction?: StringFieldUpdateOperationsInput | string
  }

  export type ActionPlanUpsertWithoutPlanInput = {
    update: XOR<ActionPlanUpdateWithoutPlanInput, ActionPlanUncheckedUpdateWithoutPlanInput>
    create: XOR<ActionPlanCreateWithoutPlanInput, ActionPlanUncheckedCreateWithoutPlanInput>
    where?: ActionPlanWhereInput
  }

  export type ActionPlanUpdateToOneWithWhereWithoutPlanInput = {
    where?: ActionPlanWhereInput
    data: XOR<ActionPlanUpdateWithoutPlanInput, ActionPlanUncheckedUpdateWithoutPlanInput>
  }

  export type ActionPlanUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionPlanByRisk?: StringFieldUpdateOperationsInput | string
    implementationTimeline?: StringFieldUpdateOperationsInput | string
    resourceRequirements?: StringFieldUpdateOperationsInput | string
    responsibleParties?: StringFieldUpdateOperationsInput | string
    reviewUpdateSchedule?: StringFieldUpdateOperationsInput | string
    testingAssessmentPlan?: StringFieldUpdateOperationsInput | string
  }

  export type ActionPlanUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionPlanByRisk?: StringFieldUpdateOperationsInput | string
    implementationTimeline?: StringFieldUpdateOperationsInput | string
    resourceRequirements?: StringFieldUpdateOperationsInput | string
    responsibleParties?: StringFieldUpdateOperationsInput | string
    reviewUpdateSchedule?: StringFieldUpdateOperationsInput | string
    testingAssessmentPlan?: StringFieldUpdateOperationsInput | string
  }

  export type ContactsInformationUpsertWithoutPlanInput = {
    update: XOR<ContactsInformationUpdateWithoutPlanInput, ContactsInformationUncheckedUpdateWithoutPlanInput>
    create: XOR<ContactsInformationCreateWithoutPlanInput, ContactsInformationUncheckedCreateWithoutPlanInput>
    where?: ContactsInformationWhereInput
  }

  export type ContactsInformationUpdateToOneWithWhereWithoutPlanInput = {
    where?: ContactsInformationWhereInput
    data: XOR<ContactsInformationUpdateWithoutPlanInput, ContactsInformationUncheckedUpdateWithoutPlanInput>
  }

  export type ContactsInformationUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffContactInfo?: StringFieldUpdateOperationsInput | string
    keyCustomerContacts?: StringFieldUpdateOperationsInput | string
    supplierInformation?: StringFieldUpdateOperationsInput | string
    emergencyServicesUtilities?: StringFieldUpdateOperationsInput | string
    criticalBusinessInfo?: StringFieldUpdateOperationsInput | string
    planDistributionList?: StringFieldUpdateOperationsInput | string
  }

  export type ContactsInformationUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffContactInfo?: StringFieldUpdateOperationsInput | string
    keyCustomerContacts?: StringFieldUpdateOperationsInput | string
    supplierInformation?: StringFieldUpdateOperationsInput | string
    emergencyServicesUtilities?: StringFieldUpdateOperationsInput | string
    criticalBusinessInfo?: StringFieldUpdateOperationsInput | string
    planDistributionList?: StringFieldUpdateOperationsInput | string
  }

  export type TestingMaintenanceUpsertWithoutPlanInput = {
    update: XOR<TestingMaintenanceUpdateWithoutPlanInput, TestingMaintenanceUncheckedUpdateWithoutPlanInput>
    create: XOR<TestingMaintenanceCreateWithoutPlanInput, TestingMaintenanceUncheckedCreateWithoutPlanInput>
    where?: TestingMaintenanceWhereInput
  }

  export type TestingMaintenanceUpdateToOneWithWhereWithoutPlanInput = {
    where?: TestingMaintenanceWhereInput
    data: XOR<TestingMaintenanceUpdateWithoutPlanInput, TestingMaintenanceUncheckedUpdateWithoutPlanInput>
  }

  export type TestingMaintenanceUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    planTestingSchedule?: StringFieldUpdateOperationsInput | string
    planRevisionHistory?: StringFieldUpdateOperationsInput | string
    improvementTracking?: StringFieldUpdateOperationsInput | string
    annualReviewProcess?: StringFieldUpdateOperationsInput | string
    triggerEventsForUpdates?: StringFieldUpdateOperationsInput | string
  }

  export type TestingMaintenanceUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    planTestingSchedule?: StringFieldUpdateOperationsInput | string
    planRevisionHistory?: StringFieldUpdateOperationsInput | string
    improvementTracking?: StringFieldUpdateOperationsInput | string
    annualReviewProcess?: StringFieldUpdateOperationsInput | string
    triggerEventsForUpdates?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessContinuityPlanCreateWithoutPlanInformationInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    businessOverview?: BusinessOverviewCreateNestedOneWithoutPlanInput
    essentialFunction?: EssentialFunctionCreateNestedOneWithoutPlanInput
    riskAssessment?: RiskAssessmentCreateNestedOneWithoutPlanInput
    strategy?: StrategyCreateNestedOneWithoutPlanInput
    actionPlan?: ActionPlanCreateNestedOneWithoutPlanInput
    contactsInformation?: ContactsInformationCreateNestedOneWithoutPlanInput
    testingMaintenance?: TestingMaintenanceCreateNestedOneWithoutPlanInput
  }

  export type BusinessContinuityPlanUncheckedCreateWithoutPlanInformationInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    businessOverview?: BusinessOverviewUncheckedCreateNestedOneWithoutPlanInput
    essentialFunction?: EssentialFunctionUncheckedCreateNestedOneWithoutPlanInput
    riskAssessment?: RiskAssessmentUncheckedCreateNestedOneWithoutPlanInput
    strategy?: StrategyUncheckedCreateNestedOneWithoutPlanInput
    actionPlan?: ActionPlanUncheckedCreateNestedOneWithoutPlanInput
    contactsInformation?: ContactsInformationUncheckedCreateNestedOneWithoutPlanInput
    testingMaintenance?: TestingMaintenanceUncheckedCreateNestedOneWithoutPlanInput
  }

  export type BusinessContinuityPlanCreateOrConnectWithoutPlanInformationInput = {
    where: BusinessContinuityPlanWhereUniqueInput
    create: XOR<BusinessContinuityPlanCreateWithoutPlanInformationInput, BusinessContinuityPlanUncheckedCreateWithoutPlanInformationInput>
  }

  export type BusinessContinuityPlanUpsertWithoutPlanInformationInput = {
    update: XOR<BusinessContinuityPlanUpdateWithoutPlanInformationInput, BusinessContinuityPlanUncheckedUpdateWithoutPlanInformationInput>
    create: XOR<BusinessContinuityPlanCreateWithoutPlanInformationInput, BusinessContinuityPlanUncheckedCreateWithoutPlanInformationInput>
    where?: BusinessContinuityPlanWhereInput
  }

  export type BusinessContinuityPlanUpdateToOneWithWhereWithoutPlanInformationInput = {
    where?: BusinessContinuityPlanWhereInput
    data: XOR<BusinessContinuityPlanUpdateWithoutPlanInformationInput, BusinessContinuityPlanUncheckedUpdateWithoutPlanInformationInput>
  }

  export type BusinessContinuityPlanUpdateWithoutPlanInformationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessOverview?: BusinessOverviewUpdateOneWithoutPlanNestedInput
    essentialFunction?: EssentialFunctionUpdateOneWithoutPlanNestedInput
    riskAssessment?: RiskAssessmentUpdateOneWithoutPlanNestedInput
    strategy?: StrategyUpdateOneWithoutPlanNestedInput
    actionPlan?: ActionPlanUpdateOneWithoutPlanNestedInput
    contactsInformation?: ContactsInformationUpdateOneWithoutPlanNestedInput
    testingMaintenance?: TestingMaintenanceUpdateOneWithoutPlanNestedInput
  }

  export type BusinessContinuityPlanUncheckedUpdateWithoutPlanInformationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessOverview?: BusinessOverviewUncheckedUpdateOneWithoutPlanNestedInput
    essentialFunction?: EssentialFunctionUncheckedUpdateOneWithoutPlanNestedInput
    riskAssessment?: RiskAssessmentUncheckedUpdateOneWithoutPlanNestedInput
    strategy?: StrategyUncheckedUpdateOneWithoutPlanNestedInput
    actionPlan?: ActionPlanUncheckedUpdateOneWithoutPlanNestedInput
    contactsInformation?: ContactsInformationUncheckedUpdateOneWithoutPlanNestedInput
    testingMaintenance?: TestingMaintenanceUncheckedUpdateOneWithoutPlanNestedInput
  }

  export type BusinessContinuityPlanCreateWithoutBusinessOverviewInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    planInformation?: PlanInformationCreateNestedOneWithoutPlanInput
    essentialFunction?: EssentialFunctionCreateNestedOneWithoutPlanInput
    riskAssessment?: RiskAssessmentCreateNestedOneWithoutPlanInput
    strategy?: StrategyCreateNestedOneWithoutPlanInput
    actionPlan?: ActionPlanCreateNestedOneWithoutPlanInput
    contactsInformation?: ContactsInformationCreateNestedOneWithoutPlanInput
    testingMaintenance?: TestingMaintenanceCreateNestedOneWithoutPlanInput
  }

  export type BusinessContinuityPlanUncheckedCreateWithoutBusinessOverviewInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    planInformation?: PlanInformationUncheckedCreateNestedOneWithoutPlanInput
    essentialFunction?: EssentialFunctionUncheckedCreateNestedOneWithoutPlanInput
    riskAssessment?: RiskAssessmentUncheckedCreateNestedOneWithoutPlanInput
    strategy?: StrategyUncheckedCreateNestedOneWithoutPlanInput
    actionPlan?: ActionPlanUncheckedCreateNestedOneWithoutPlanInput
    contactsInformation?: ContactsInformationUncheckedCreateNestedOneWithoutPlanInput
    testingMaintenance?: TestingMaintenanceUncheckedCreateNestedOneWithoutPlanInput
  }

  export type BusinessContinuityPlanCreateOrConnectWithoutBusinessOverviewInput = {
    where: BusinessContinuityPlanWhereUniqueInput
    create: XOR<BusinessContinuityPlanCreateWithoutBusinessOverviewInput, BusinessContinuityPlanUncheckedCreateWithoutBusinessOverviewInput>
  }

  export type BusinessContinuityPlanUpsertWithoutBusinessOverviewInput = {
    update: XOR<BusinessContinuityPlanUpdateWithoutBusinessOverviewInput, BusinessContinuityPlanUncheckedUpdateWithoutBusinessOverviewInput>
    create: XOR<BusinessContinuityPlanCreateWithoutBusinessOverviewInput, BusinessContinuityPlanUncheckedCreateWithoutBusinessOverviewInput>
    where?: BusinessContinuityPlanWhereInput
  }

  export type BusinessContinuityPlanUpdateToOneWithWhereWithoutBusinessOverviewInput = {
    where?: BusinessContinuityPlanWhereInput
    data: XOR<BusinessContinuityPlanUpdateWithoutBusinessOverviewInput, BusinessContinuityPlanUncheckedUpdateWithoutBusinessOverviewInput>
  }

  export type BusinessContinuityPlanUpdateWithoutBusinessOverviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planInformation?: PlanInformationUpdateOneWithoutPlanNestedInput
    essentialFunction?: EssentialFunctionUpdateOneWithoutPlanNestedInput
    riskAssessment?: RiskAssessmentUpdateOneWithoutPlanNestedInput
    strategy?: StrategyUpdateOneWithoutPlanNestedInput
    actionPlan?: ActionPlanUpdateOneWithoutPlanNestedInput
    contactsInformation?: ContactsInformationUpdateOneWithoutPlanNestedInput
    testingMaintenance?: TestingMaintenanceUpdateOneWithoutPlanNestedInput
  }

  export type BusinessContinuityPlanUncheckedUpdateWithoutBusinessOverviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planInformation?: PlanInformationUncheckedUpdateOneWithoutPlanNestedInput
    essentialFunction?: EssentialFunctionUncheckedUpdateOneWithoutPlanNestedInput
    riskAssessment?: RiskAssessmentUncheckedUpdateOneWithoutPlanNestedInput
    strategy?: StrategyUncheckedUpdateOneWithoutPlanNestedInput
    actionPlan?: ActionPlanUncheckedUpdateOneWithoutPlanNestedInput
    contactsInformation?: ContactsInformationUncheckedUpdateOneWithoutPlanNestedInput
    testingMaintenance?: TestingMaintenanceUncheckedUpdateOneWithoutPlanNestedInput
  }

  export type BusinessContinuityPlanCreateWithoutEssentialFunctionInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    planInformation?: PlanInformationCreateNestedOneWithoutPlanInput
    businessOverview?: BusinessOverviewCreateNestedOneWithoutPlanInput
    riskAssessment?: RiskAssessmentCreateNestedOneWithoutPlanInput
    strategy?: StrategyCreateNestedOneWithoutPlanInput
    actionPlan?: ActionPlanCreateNestedOneWithoutPlanInput
    contactsInformation?: ContactsInformationCreateNestedOneWithoutPlanInput
    testingMaintenance?: TestingMaintenanceCreateNestedOneWithoutPlanInput
  }

  export type BusinessContinuityPlanUncheckedCreateWithoutEssentialFunctionInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    planInformation?: PlanInformationUncheckedCreateNestedOneWithoutPlanInput
    businessOverview?: BusinessOverviewUncheckedCreateNestedOneWithoutPlanInput
    riskAssessment?: RiskAssessmentUncheckedCreateNestedOneWithoutPlanInput
    strategy?: StrategyUncheckedCreateNestedOneWithoutPlanInput
    actionPlan?: ActionPlanUncheckedCreateNestedOneWithoutPlanInput
    contactsInformation?: ContactsInformationUncheckedCreateNestedOneWithoutPlanInput
    testingMaintenance?: TestingMaintenanceUncheckedCreateNestedOneWithoutPlanInput
  }

  export type BusinessContinuityPlanCreateOrConnectWithoutEssentialFunctionInput = {
    where: BusinessContinuityPlanWhereUniqueInput
    create: XOR<BusinessContinuityPlanCreateWithoutEssentialFunctionInput, BusinessContinuityPlanUncheckedCreateWithoutEssentialFunctionInput>
  }

  export type BusinessContinuityPlanUpsertWithoutEssentialFunctionInput = {
    update: XOR<BusinessContinuityPlanUpdateWithoutEssentialFunctionInput, BusinessContinuityPlanUncheckedUpdateWithoutEssentialFunctionInput>
    create: XOR<BusinessContinuityPlanCreateWithoutEssentialFunctionInput, BusinessContinuityPlanUncheckedCreateWithoutEssentialFunctionInput>
    where?: BusinessContinuityPlanWhereInput
  }

  export type BusinessContinuityPlanUpdateToOneWithWhereWithoutEssentialFunctionInput = {
    where?: BusinessContinuityPlanWhereInput
    data: XOR<BusinessContinuityPlanUpdateWithoutEssentialFunctionInput, BusinessContinuityPlanUncheckedUpdateWithoutEssentialFunctionInput>
  }

  export type BusinessContinuityPlanUpdateWithoutEssentialFunctionInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planInformation?: PlanInformationUpdateOneWithoutPlanNestedInput
    businessOverview?: BusinessOverviewUpdateOneWithoutPlanNestedInput
    riskAssessment?: RiskAssessmentUpdateOneWithoutPlanNestedInput
    strategy?: StrategyUpdateOneWithoutPlanNestedInput
    actionPlan?: ActionPlanUpdateOneWithoutPlanNestedInput
    contactsInformation?: ContactsInformationUpdateOneWithoutPlanNestedInput
    testingMaintenance?: TestingMaintenanceUpdateOneWithoutPlanNestedInput
  }

  export type BusinessContinuityPlanUncheckedUpdateWithoutEssentialFunctionInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planInformation?: PlanInformationUncheckedUpdateOneWithoutPlanNestedInput
    businessOverview?: BusinessOverviewUncheckedUpdateOneWithoutPlanNestedInput
    riskAssessment?: RiskAssessmentUncheckedUpdateOneWithoutPlanNestedInput
    strategy?: StrategyUncheckedUpdateOneWithoutPlanNestedInput
    actionPlan?: ActionPlanUncheckedUpdateOneWithoutPlanNestedInput
    contactsInformation?: ContactsInformationUncheckedUpdateOneWithoutPlanNestedInput
    testingMaintenance?: TestingMaintenanceUncheckedUpdateOneWithoutPlanNestedInput
  }

  export type BusinessContinuityPlanCreateWithoutRiskAssessmentInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    planInformation?: PlanInformationCreateNestedOneWithoutPlanInput
    businessOverview?: BusinessOverviewCreateNestedOneWithoutPlanInput
    essentialFunction?: EssentialFunctionCreateNestedOneWithoutPlanInput
    strategy?: StrategyCreateNestedOneWithoutPlanInput
    actionPlan?: ActionPlanCreateNestedOneWithoutPlanInput
    contactsInformation?: ContactsInformationCreateNestedOneWithoutPlanInput
    testingMaintenance?: TestingMaintenanceCreateNestedOneWithoutPlanInput
  }

  export type BusinessContinuityPlanUncheckedCreateWithoutRiskAssessmentInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    planInformation?: PlanInformationUncheckedCreateNestedOneWithoutPlanInput
    businessOverview?: BusinessOverviewUncheckedCreateNestedOneWithoutPlanInput
    essentialFunction?: EssentialFunctionUncheckedCreateNestedOneWithoutPlanInput
    strategy?: StrategyUncheckedCreateNestedOneWithoutPlanInput
    actionPlan?: ActionPlanUncheckedCreateNestedOneWithoutPlanInput
    contactsInformation?: ContactsInformationUncheckedCreateNestedOneWithoutPlanInput
    testingMaintenance?: TestingMaintenanceUncheckedCreateNestedOneWithoutPlanInput
  }

  export type BusinessContinuityPlanCreateOrConnectWithoutRiskAssessmentInput = {
    where: BusinessContinuityPlanWhereUniqueInput
    create: XOR<BusinessContinuityPlanCreateWithoutRiskAssessmentInput, BusinessContinuityPlanUncheckedCreateWithoutRiskAssessmentInput>
  }

  export type BusinessContinuityPlanUpsertWithoutRiskAssessmentInput = {
    update: XOR<BusinessContinuityPlanUpdateWithoutRiskAssessmentInput, BusinessContinuityPlanUncheckedUpdateWithoutRiskAssessmentInput>
    create: XOR<BusinessContinuityPlanCreateWithoutRiskAssessmentInput, BusinessContinuityPlanUncheckedCreateWithoutRiskAssessmentInput>
    where?: BusinessContinuityPlanWhereInput
  }

  export type BusinessContinuityPlanUpdateToOneWithWhereWithoutRiskAssessmentInput = {
    where?: BusinessContinuityPlanWhereInput
    data: XOR<BusinessContinuityPlanUpdateWithoutRiskAssessmentInput, BusinessContinuityPlanUncheckedUpdateWithoutRiskAssessmentInput>
  }

  export type BusinessContinuityPlanUpdateWithoutRiskAssessmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planInformation?: PlanInformationUpdateOneWithoutPlanNestedInput
    businessOverview?: BusinessOverviewUpdateOneWithoutPlanNestedInput
    essentialFunction?: EssentialFunctionUpdateOneWithoutPlanNestedInput
    strategy?: StrategyUpdateOneWithoutPlanNestedInput
    actionPlan?: ActionPlanUpdateOneWithoutPlanNestedInput
    contactsInformation?: ContactsInformationUpdateOneWithoutPlanNestedInput
    testingMaintenance?: TestingMaintenanceUpdateOneWithoutPlanNestedInput
  }

  export type BusinessContinuityPlanUncheckedUpdateWithoutRiskAssessmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planInformation?: PlanInformationUncheckedUpdateOneWithoutPlanNestedInput
    businessOverview?: BusinessOverviewUncheckedUpdateOneWithoutPlanNestedInput
    essentialFunction?: EssentialFunctionUncheckedUpdateOneWithoutPlanNestedInput
    strategy?: StrategyUncheckedUpdateOneWithoutPlanNestedInput
    actionPlan?: ActionPlanUncheckedUpdateOneWithoutPlanNestedInput
    contactsInformation?: ContactsInformationUncheckedUpdateOneWithoutPlanNestedInput
    testingMaintenance?: TestingMaintenanceUncheckedUpdateOneWithoutPlanNestedInput
  }

  export type BusinessContinuityPlanCreateWithoutStrategyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    planInformation?: PlanInformationCreateNestedOneWithoutPlanInput
    businessOverview?: BusinessOverviewCreateNestedOneWithoutPlanInput
    essentialFunction?: EssentialFunctionCreateNestedOneWithoutPlanInput
    riskAssessment?: RiskAssessmentCreateNestedOneWithoutPlanInput
    actionPlan?: ActionPlanCreateNestedOneWithoutPlanInput
    contactsInformation?: ContactsInformationCreateNestedOneWithoutPlanInput
    testingMaintenance?: TestingMaintenanceCreateNestedOneWithoutPlanInput
  }

  export type BusinessContinuityPlanUncheckedCreateWithoutStrategyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    planInformation?: PlanInformationUncheckedCreateNestedOneWithoutPlanInput
    businessOverview?: BusinessOverviewUncheckedCreateNestedOneWithoutPlanInput
    essentialFunction?: EssentialFunctionUncheckedCreateNestedOneWithoutPlanInput
    riskAssessment?: RiskAssessmentUncheckedCreateNestedOneWithoutPlanInput
    actionPlan?: ActionPlanUncheckedCreateNestedOneWithoutPlanInput
    contactsInformation?: ContactsInformationUncheckedCreateNestedOneWithoutPlanInput
    testingMaintenance?: TestingMaintenanceUncheckedCreateNestedOneWithoutPlanInput
  }

  export type BusinessContinuityPlanCreateOrConnectWithoutStrategyInput = {
    where: BusinessContinuityPlanWhereUniqueInput
    create: XOR<BusinessContinuityPlanCreateWithoutStrategyInput, BusinessContinuityPlanUncheckedCreateWithoutStrategyInput>
  }

  export type BusinessContinuityPlanUpsertWithoutStrategyInput = {
    update: XOR<BusinessContinuityPlanUpdateWithoutStrategyInput, BusinessContinuityPlanUncheckedUpdateWithoutStrategyInput>
    create: XOR<BusinessContinuityPlanCreateWithoutStrategyInput, BusinessContinuityPlanUncheckedCreateWithoutStrategyInput>
    where?: BusinessContinuityPlanWhereInput
  }

  export type BusinessContinuityPlanUpdateToOneWithWhereWithoutStrategyInput = {
    where?: BusinessContinuityPlanWhereInput
    data: XOR<BusinessContinuityPlanUpdateWithoutStrategyInput, BusinessContinuityPlanUncheckedUpdateWithoutStrategyInput>
  }

  export type BusinessContinuityPlanUpdateWithoutStrategyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planInformation?: PlanInformationUpdateOneWithoutPlanNestedInput
    businessOverview?: BusinessOverviewUpdateOneWithoutPlanNestedInput
    essentialFunction?: EssentialFunctionUpdateOneWithoutPlanNestedInput
    riskAssessment?: RiskAssessmentUpdateOneWithoutPlanNestedInput
    actionPlan?: ActionPlanUpdateOneWithoutPlanNestedInput
    contactsInformation?: ContactsInformationUpdateOneWithoutPlanNestedInput
    testingMaintenance?: TestingMaintenanceUpdateOneWithoutPlanNestedInput
  }

  export type BusinessContinuityPlanUncheckedUpdateWithoutStrategyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planInformation?: PlanInformationUncheckedUpdateOneWithoutPlanNestedInput
    businessOverview?: BusinessOverviewUncheckedUpdateOneWithoutPlanNestedInput
    essentialFunction?: EssentialFunctionUncheckedUpdateOneWithoutPlanNestedInput
    riskAssessment?: RiskAssessmentUncheckedUpdateOneWithoutPlanNestedInput
    actionPlan?: ActionPlanUncheckedUpdateOneWithoutPlanNestedInput
    contactsInformation?: ContactsInformationUncheckedUpdateOneWithoutPlanNestedInput
    testingMaintenance?: TestingMaintenanceUncheckedUpdateOneWithoutPlanNestedInput
  }

  export type BusinessContinuityPlanCreateWithoutActionPlanInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    planInformation?: PlanInformationCreateNestedOneWithoutPlanInput
    businessOverview?: BusinessOverviewCreateNestedOneWithoutPlanInput
    essentialFunction?: EssentialFunctionCreateNestedOneWithoutPlanInput
    riskAssessment?: RiskAssessmentCreateNestedOneWithoutPlanInput
    strategy?: StrategyCreateNestedOneWithoutPlanInput
    contactsInformation?: ContactsInformationCreateNestedOneWithoutPlanInput
    testingMaintenance?: TestingMaintenanceCreateNestedOneWithoutPlanInput
  }

  export type BusinessContinuityPlanUncheckedCreateWithoutActionPlanInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    planInformation?: PlanInformationUncheckedCreateNestedOneWithoutPlanInput
    businessOverview?: BusinessOverviewUncheckedCreateNestedOneWithoutPlanInput
    essentialFunction?: EssentialFunctionUncheckedCreateNestedOneWithoutPlanInput
    riskAssessment?: RiskAssessmentUncheckedCreateNestedOneWithoutPlanInput
    strategy?: StrategyUncheckedCreateNestedOneWithoutPlanInput
    contactsInformation?: ContactsInformationUncheckedCreateNestedOneWithoutPlanInput
    testingMaintenance?: TestingMaintenanceUncheckedCreateNestedOneWithoutPlanInput
  }

  export type BusinessContinuityPlanCreateOrConnectWithoutActionPlanInput = {
    where: BusinessContinuityPlanWhereUniqueInput
    create: XOR<BusinessContinuityPlanCreateWithoutActionPlanInput, BusinessContinuityPlanUncheckedCreateWithoutActionPlanInput>
  }

  export type BusinessContinuityPlanUpsertWithoutActionPlanInput = {
    update: XOR<BusinessContinuityPlanUpdateWithoutActionPlanInput, BusinessContinuityPlanUncheckedUpdateWithoutActionPlanInput>
    create: XOR<BusinessContinuityPlanCreateWithoutActionPlanInput, BusinessContinuityPlanUncheckedCreateWithoutActionPlanInput>
    where?: BusinessContinuityPlanWhereInput
  }

  export type BusinessContinuityPlanUpdateToOneWithWhereWithoutActionPlanInput = {
    where?: BusinessContinuityPlanWhereInput
    data: XOR<BusinessContinuityPlanUpdateWithoutActionPlanInput, BusinessContinuityPlanUncheckedUpdateWithoutActionPlanInput>
  }

  export type BusinessContinuityPlanUpdateWithoutActionPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planInformation?: PlanInformationUpdateOneWithoutPlanNestedInput
    businessOverview?: BusinessOverviewUpdateOneWithoutPlanNestedInput
    essentialFunction?: EssentialFunctionUpdateOneWithoutPlanNestedInput
    riskAssessment?: RiskAssessmentUpdateOneWithoutPlanNestedInput
    strategy?: StrategyUpdateOneWithoutPlanNestedInput
    contactsInformation?: ContactsInformationUpdateOneWithoutPlanNestedInput
    testingMaintenance?: TestingMaintenanceUpdateOneWithoutPlanNestedInput
  }

  export type BusinessContinuityPlanUncheckedUpdateWithoutActionPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planInformation?: PlanInformationUncheckedUpdateOneWithoutPlanNestedInput
    businessOverview?: BusinessOverviewUncheckedUpdateOneWithoutPlanNestedInput
    essentialFunction?: EssentialFunctionUncheckedUpdateOneWithoutPlanNestedInput
    riskAssessment?: RiskAssessmentUncheckedUpdateOneWithoutPlanNestedInput
    strategy?: StrategyUncheckedUpdateOneWithoutPlanNestedInput
    contactsInformation?: ContactsInformationUncheckedUpdateOneWithoutPlanNestedInput
    testingMaintenance?: TestingMaintenanceUncheckedUpdateOneWithoutPlanNestedInput
  }

  export type BusinessProfileCreateWithoutSessionInput = {
    id?: string
    name: string
    industry: string
    size: string
    location: string
  }

  export type BusinessProfileUncheckedCreateWithoutSessionInput = {
    id?: string
    name: string
    industry: string
    size: string
    location: string
  }

  export type BusinessProfileCreateOrConnectWithoutSessionInput = {
    where: BusinessProfileWhereUniqueInput
    create: XOR<BusinessProfileCreateWithoutSessionInput, BusinessProfileUncheckedCreateWithoutSessionInput>
  }

  export type BusinessProfileUpsertWithoutSessionInput = {
    update: XOR<BusinessProfileUpdateWithoutSessionInput, BusinessProfileUncheckedUpdateWithoutSessionInput>
    create: XOR<BusinessProfileCreateWithoutSessionInput, BusinessProfileUncheckedCreateWithoutSessionInput>
    where?: BusinessProfileWhereInput
  }

  export type BusinessProfileUpdateToOneWithWhereWithoutSessionInput = {
    where?: BusinessProfileWhereInput
    data: XOR<BusinessProfileUpdateWithoutSessionInput, BusinessProfileUncheckedUpdateWithoutSessionInput>
  }

  export type BusinessProfileUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessProfileUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
  }

  export type SessionCreateWithoutBusinessProfileInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    currentStep: string
    stepData: string
  }

  export type SessionUncheckedCreateWithoutBusinessProfileInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    currentStep: string
    stepData: string
  }

  export type SessionCreateOrConnectWithoutBusinessProfileInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutBusinessProfileInput, SessionUncheckedCreateWithoutBusinessProfileInput>
  }

  export type SessionUpsertWithoutBusinessProfileInput = {
    update: XOR<SessionUpdateWithoutBusinessProfileInput, SessionUncheckedUpdateWithoutBusinessProfileInput>
    create: XOR<SessionCreateWithoutBusinessProfileInput, SessionUncheckedCreateWithoutBusinessProfileInput>
    where?: SessionWhereInput
  }

  export type SessionUpdateToOneWithWhereWithoutBusinessProfileInput = {
    where?: SessionWhereInput
    data: XOR<SessionUpdateWithoutBusinessProfileInput, SessionUncheckedUpdateWithoutBusinessProfileInput>
  }

  export type SessionUpdateWithoutBusinessProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentStep?: StringFieldUpdateOperationsInput | string
    stepData?: StringFieldUpdateOperationsInput | string
  }

  export type SessionUncheckedUpdateWithoutBusinessProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentStep?: StringFieldUpdateOperationsInput | string
    stepData?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessContinuityPlanCreateWithoutContactsInformationInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    planInformation?: PlanInformationCreateNestedOneWithoutPlanInput
    businessOverview?: BusinessOverviewCreateNestedOneWithoutPlanInput
    essentialFunction?: EssentialFunctionCreateNestedOneWithoutPlanInput
    riskAssessment?: RiskAssessmentCreateNestedOneWithoutPlanInput
    strategy?: StrategyCreateNestedOneWithoutPlanInput
    actionPlan?: ActionPlanCreateNestedOneWithoutPlanInput
    testingMaintenance?: TestingMaintenanceCreateNestedOneWithoutPlanInput
  }

  export type BusinessContinuityPlanUncheckedCreateWithoutContactsInformationInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    planInformation?: PlanInformationUncheckedCreateNestedOneWithoutPlanInput
    businessOverview?: BusinessOverviewUncheckedCreateNestedOneWithoutPlanInput
    essentialFunction?: EssentialFunctionUncheckedCreateNestedOneWithoutPlanInput
    riskAssessment?: RiskAssessmentUncheckedCreateNestedOneWithoutPlanInput
    strategy?: StrategyUncheckedCreateNestedOneWithoutPlanInput
    actionPlan?: ActionPlanUncheckedCreateNestedOneWithoutPlanInput
    testingMaintenance?: TestingMaintenanceUncheckedCreateNestedOneWithoutPlanInput
  }

  export type BusinessContinuityPlanCreateOrConnectWithoutContactsInformationInput = {
    where: BusinessContinuityPlanWhereUniqueInput
    create: XOR<BusinessContinuityPlanCreateWithoutContactsInformationInput, BusinessContinuityPlanUncheckedCreateWithoutContactsInformationInput>
  }

  export type BusinessContinuityPlanUpsertWithoutContactsInformationInput = {
    update: XOR<BusinessContinuityPlanUpdateWithoutContactsInformationInput, BusinessContinuityPlanUncheckedUpdateWithoutContactsInformationInput>
    create: XOR<BusinessContinuityPlanCreateWithoutContactsInformationInput, BusinessContinuityPlanUncheckedCreateWithoutContactsInformationInput>
    where?: BusinessContinuityPlanWhereInput
  }

  export type BusinessContinuityPlanUpdateToOneWithWhereWithoutContactsInformationInput = {
    where?: BusinessContinuityPlanWhereInput
    data: XOR<BusinessContinuityPlanUpdateWithoutContactsInformationInput, BusinessContinuityPlanUncheckedUpdateWithoutContactsInformationInput>
  }

  export type BusinessContinuityPlanUpdateWithoutContactsInformationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planInformation?: PlanInformationUpdateOneWithoutPlanNestedInput
    businessOverview?: BusinessOverviewUpdateOneWithoutPlanNestedInput
    essentialFunction?: EssentialFunctionUpdateOneWithoutPlanNestedInput
    riskAssessment?: RiskAssessmentUpdateOneWithoutPlanNestedInput
    strategy?: StrategyUpdateOneWithoutPlanNestedInput
    actionPlan?: ActionPlanUpdateOneWithoutPlanNestedInput
    testingMaintenance?: TestingMaintenanceUpdateOneWithoutPlanNestedInput
  }

  export type BusinessContinuityPlanUncheckedUpdateWithoutContactsInformationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planInformation?: PlanInformationUncheckedUpdateOneWithoutPlanNestedInput
    businessOverview?: BusinessOverviewUncheckedUpdateOneWithoutPlanNestedInput
    essentialFunction?: EssentialFunctionUncheckedUpdateOneWithoutPlanNestedInput
    riskAssessment?: RiskAssessmentUncheckedUpdateOneWithoutPlanNestedInput
    strategy?: StrategyUncheckedUpdateOneWithoutPlanNestedInput
    actionPlan?: ActionPlanUncheckedUpdateOneWithoutPlanNestedInput
    testingMaintenance?: TestingMaintenanceUncheckedUpdateOneWithoutPlanNestedInput
  }

  export type BusinessContinuityPlanCreateWithoutTestingMaintenanceInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    planInformation?: PlanInformationCreateNestedOneWithoutPlanInput
    businessOverview?: BusinessOverviewCreateNestedOneWithoutPlanInput
    essentialFunction?: EssentialFunctionCreateNestedOneWithoutPlanInput
    riskAssessment?: RiskAssessmentCreateNestedOneWithoutPlanInput
    strategy?: StrategyCreateNestedOneWithoutPlanInput
    actionPlan?: ActionPlanCreateNestedOneWithoutPlanInput
    contactsInformation?: ContactsInformationCreateNestedOneWithoutPlanInput
  }

  export type BusinessContinuityPlanUncheckedCreateWithoutTestingMaintenanceInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    planInformation?: PlanInformationUncheckedCreateNestedOneWithoutPlanInput
    businessOverview?: BusinessOverviewUncheckedCreateNestedOneWithoutPlanInput
    essentialFunction?: EssentialFunctionUncheckedCreateNestedOneWithoutPlanInput
    riskAssessment?: RiskAssessmentUncheckedCreateNestedOneWithoutPlanInput
    strategy?: StrategyUncheckedCreateNestedOneWithoutPlanInput
    actionPlan?: ActionPlanUncheckedCreateNestedOneWithoutPlanInput
    contactsInformation?: ContactsInformationUncheckedCreateNestedOneWithoutPlanInput
  }

  export type BusinessContinuityPlanCreateOrConnectWithoutTestingMaintenanceInput = {
    where: BusinessContinuityPlanWhereUniqueInput
    create: XOR<BusinessContinuityPlanCreateWithoutTestingMaintenanceInput, BusinessContinuityPlanUncheckedCreateWithoutTestingMaintenanceInput>
  }

  export type BusinessContinuityPlanUpsertWithoutTestingMaintenanceInput = {
    update: XOR<BusinessContinuityPlanUpdateWithoutTestingMaintenanceInput, BusinessContinuityPlanUncheckedUpdateWithoutTestingMaintenanceInput>
    create: XOR<BusinessContinuityPlanCreateWithoutTestingMaintenanceInput, BusinessContinuityPlanUncheckedCreateWithoutTestingMaintenanceInput>
    where?: BusinessContinuityPlanWhereInput
  }

  export type BusinessContinuityPlanUpdateToOneWithWhereWithoutTestingMaintenanceInput = {
    where?: BusinessContinuityPlanWhereInput
    data: XOR<BusinessContinuityPlanUpdateWithoutTestingMaintenanceInput, BusinessContinuityPlanUncheckedUpdateWithoutTestingMaintenanceInput>
  }

  export type BusinessContinuityPlanUpdateWithoutTestingMaintenanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planInformation?: PlanInformationUpdateOneWithoutPlanNestedInput
    businessOverview?: BusinessOverviewUpdateOneWithoutPlanNestedInput
    essentialFunction?: EssentialFunctionUpdateOneWithoutPlanNestedInput
    riskAssessment?: RiskAssessmentUpdateOneWithoutPlanNestedInput
    strategy?: StrategyUpdateOneWithoutPlanNestedInput
    actionPlan?: ActionPlanUpdateOneWithoutPlanNestedInput
    contactsInformation?: ContactsInformationUpdateOneWithoutPlanNestedInput
  }

  export type BusinessContinuityPlanUncheckedUpdateWithoutTestingMaintenanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planInformation?: PlanInformationUncheckedUpdateOneWithoutPlanNestedInput
    businessOverview?: BusinessOverviewUncheckedUpdateOneWithoutPlanNestedInput
    essentialFunction?: EssentialFunctionUncheckedUpdateOneWithoutPlanNestedInput
    riskAssessment?: RiskAssessmentUncheckedUpdateOneWithoutPlanNestedInput
    strategy?: StrategyUncheckedUpdateOneWithoutPlanNestedInput
    actionPlan?: ActionPlanUncheckedUpdateOneWithoutPlanNestedInput
    contactsInformation?: ContactsInformationUncheckedUpdateOneWithoutPlanNestedInput
  }

  export type AdminBusinessTypeHazardCreateWithoutBusinessTypeInput = {
    id?: string
    riskLevel: string
    frequency?: string | null
    impact?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    hazard: AdminHazardTypeCreateNestedOneWithoutBusinessTypeHazardsInput
  }

  export type AdminBusinessTypeHazardUncheckedCreateWithoutBusinessTypeInput = {
    id?: string
    hazardId: string
    riskLevel: string
    frequency?: string | null
    impact?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminBusinessTypeHazardCreateOrConnectWithoutBusinessTypeInput = {
    where: AdminBusinessTypeHazardWhereUniqueInput
    create: XOR<AdminBusinessTypeHazardCreateWithoutBusinessTypeInput, AdminBusinessTypeHazardUncheckedCreateWithoutBusinessTypeInput>
  }

  export type AdminBusinessTypeHazardCreateManyBusinessTypeInputEnvelope = {
    data: AdminBusinessTypeHazardCreateManyBusinessTypeInput | AdminBusinessTypeHazardCreateManyBusinessTypeInput[]
    skipDuplicates?: boolean
  }

  export type AdminRiskProfileCreateWithoutBusinessTypeInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    calculatedRisks: string
    recommendedStrategies: string
    lastCalculated?: Date | string
    riskScore: number
    location: AdminLocationCreateNestedOneWithoutRiskProfilesInput
  }

  export type AdminRiskProfileUncheckedCreateWithoutBusinessTypeInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    locationId: string
    calculatedRisks: string
    recommendedStrategies: string
    lastCalculated?: Date | string
    riskScore: number
  }

  export type AdminRiskProfileCreateOrConnectWithoutBusinessTypeInput = {
    where: AdminRiskProfileWhereUniqueInput
    create: XOR<AdminRiskProfileCreateWithoutBusinessTypeInput, AdminRiskProfileUncheckedCreateWithoutBusinessTypeInput>
  }

  export type AdminRiskProfileCreateManyBusinessTypeInputEnvelope = {
    data: AdminRiskProfileCreateManyBusinessTypeInput | AdminRiskProfileCreateManyBusinessTypeInput[]
    skipDuplicates?: boolean
  }

  export type AdminBusinessTypeHazardUpsertWithWhereUniqueWithoutBusinessTypeInput = {
    where: AdminBusinessTypeHazardWhereUniqueInput
    update: XOR<AdminBusinessTypeHazardUpdateWithoutBusinessTypeInput, AdminBusinessTypeHazardUncheckedUpdateWithoutBusinessTypeInput>
    create: XOR<AdminBusinessTypeHazardCreateWithoutBusinessTypeInput, AdminBusinessTypeHazardUncheckedCreateWithoutBusinessTypeInput>
  }

  export type AdminBusinessTypeHazardUpdateWithWhereUniqueWithoutBusinessTypeInput = {
    where: AdminBusinessTypeHazardWhereUniqueInput
    data: XOR<AdminBusinessTypeHazardUpdateWithoutBusinessTypeInput, AdminBusinessTypeHazardUncheckedUpdateWithoutBusinessTypeInput>
  }

  export type AdminBusinessTypeHazardUpdateManyWithWhereWithoutBusinessTypeInput = {
    where: AdminBusinessTypeHazardScalarWhereInput
    data: XOR<AdminBusinessTypeHazardUpdateManyMutationInput, AdminBusinessTypeHazardUncheckedUpdateManyWithoutBusinessTypeInput>
  }

  export type AdminBusinessTypeHazardScalarWhereInput = {
    AND?: AdminBusinessTypeHazardScalarWhereInput | AdminBusinessTypeHazardScalarWhereInput[]
    OR?: AdminBusinessTypeHazardScalarWhereInput[]
    NOT?: AdminBusinessTypeHazardScalarWhereInput | AdminBusinessTypeHazardScalarWhereInput[]
    id?: StringFilter<"AdminBusinessTypeHazard"> | string
    businessTypeId?: StringFilter<"AdminBusinessTypeHazard"> | string
    hazardId?: StringFilter<"AdminBusinessTypeHazard"> | string
    riskLevel?: StringFilter<"AdminBusinessTypeHazard"> | string
    frequency?: StringNullableFilter<"AdminBusinessTypeHazard"> | string | null
    impact?: StringNullableFilter<"AdminBusinessTypeHazard"> | string | null
    notes?: StringNullableFilter<"AdminBusinessTypeHazard"> | string | null
    isActive?: BoolFilter<"AdminBusinessTypeHazard"> | boolean
    createdAt?: DateTimeFilter<"AdminBusinessTypeHazard"> | Date | string
    updatedAt?: DateTimeFilter<"AdminBusinessTypeHazard"> | Date | string
  }

  export type AdminRiskProfileUpsertWithWhereUniqueWithoutBusinessTypeInput = {
    where: AdminRiskProfileWhereUniqueInput
    update: XOR<AdminRiskProfileUpdateWithoutBusinessTypeInput, AdminRiskProfileUncheckedUpdateWithoutBusinessTypeInput>
    create: XOR<AdminRiskProfileCreateWithoutBusinessTypeInput, AdminRiskProfileUncheckedCreateWithoutBusinessTypeInput>
  }

  export type AdminRiskProfileUpdateWithWhereUniqueWithoutBusinessTypeInput = {
    where: AdminRiskProfileWhereUniqueInput
    data: XOR<AdminRiskProfileUpdateWithoutBusinessTypeInput, AdminRiskProfileUncheckedUpdateWithoutBusinessTypeInput>
  }

  export type AdminRiskProfileUpdateManyWithWhereWithoutBusinessTypeInput = {
    where: AdminRiskProfileScalarWhereInput
    data: XOR<AdminRiskProfileUpdateManyMutationInput, AdminRiskProfileUncheckedUpdateManyWithoutBusinessTypeInput>
  }

  export type AdminRiskProfileScalarWhereInput = {
    AND?: AdminRiskProfileScalarWhereInput | AdminRiskProfileScalarWhereInput[]
    OR?: AdminRiskProfileScalarWhereInput[]
    NOT?: AdminRiskProfileScalarWhereInput | AdminRiskProfileScalarWhereInput[]
    id?: StringFilter<"AdminRiskProfile"> | string
    createdAt?: DateTimeFilter<"AdminRiskProfile"> | Date | string
    updatedAt?: DateTimeFilter<"AdminRiskProfile"> | Date | string
    businessTypeId?: StringFilter<"AdminRiskProfile"> | string
    locationId?: StringFilter<"AdminRiskProfile"> | string
    calculatedRisks?: StringFilter<"AdminRiskProfile"> | string
    recommendedStrategies?: StringFilter<"AdminRiskProfile"> | string
    lastCalculated?: DateTimeFilter<"AdminRiskProfile"> | Date | string
    riskScore?: IntFilter<"AdminRiskProfile"> | number
  }

  export type AdminBusinessTypeHazardCreateWithoutHazardInput = {
    id?: string
    riskLevel: string
    frequency?: string | null
    impact?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    businessType: AdminBusinessTypeCreateNestedOneWithoutBusinessTypeHazardsInput
  }

  export type AdminBusinessTypeHazardUncheckedCreateWithoutHazardInput = {
    id?: string
    businessTypeId: string
    riskLevel: string
    frequency?: string | null
    impact?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminBusinessTypeHazardCreateOrConnectWithoutHazardInput = {
    where: AdminBusinessTypeHazardWhereUniqueInput
    create: XOR<AdminBusinessTypeHazardCreateWithoutHazardInput, AdminBusinessTypeHazardUncheckedCreateWithoutHazardInput>
  }

  export type AdminBusinessTypeHazardCreateManyHazardInputEnvelope = {
    data: AdminBusinessTypeHazardCreateManyHazardInput | AdminBusinessTypeHazardCreateManyHazardInput[]
    skipDuplicates?: boolean
  }

  export type AdminLocationHazardCreateWithoutHazardInput = {
    id?: string
    riskLevel: string
    frequency?: string | null
    impact?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    location: AdminLocationCreateNestedOneWithoutLocationHazardsInput
  }

  export type AdminLocationHazardUncheckedCreateWithoutHazardInput = {
    id?: string
    locationId: string
    riskLevel: string
    frequency?: string | null
    impact?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminLocationHazardCreateOrConnectWithoutHazardInput = {
    where: AdminLocationHazardWhereUniqueInput
    create: XOR<AdminLocationHazardCreateWithoutHazardInput, AdminLocationHazardUncheckedCreateWithoutHazardInput>
  }

  export type AdminLocationHazardCreateManyHazardInputEnvelope = {
    data: AdminLocationHazardCreateManyHazardInput | AdminLocationHazardCreateManyHazardInput[]
    skipDuplicates?: boolean
  }

  export type AdminHazardStrategyCreateWithoutHazardInput = {
    id?: string
    businessTypes?: string | null
    priority?: string
    isRecommended?: boolean
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    strategy: AdminStrategyCreateNestedOneWithoutHazardStrategiesInput
  }

  export type AdminHazardStrategyUncheckedCreateWithoutHazardInput = {
    id?: string
    strategyId: string
    businessTypes?: string | null
    priority?: string
    isRecommended?: boolean
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminHazardStrategyCreateOrConnectWithoutHazardInput = {
    where: AdminHazardStrategyWhereUniqueInput
    create: XOR<AdminHazardStrategyCreateWithoutHazardInput, AdminHazardStrategyUncheckedCreateWithoutHazardInput>
  }

  export type AdminHazardStrategyCreateManyHazardInputEnvelope = {
    data: AdminHazardStrategyCreateManyHazardInput | AdminHazardStrategyCreateManyHazardInput[]
    skipDuplicates?: boolean
  }

  export type AdminHazardActionPlanCreateWithoutHazardInput = {
    id?: string
    businessTypes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    actionPlan: AdminActionPlanCreateNestedOneWithoutAdminHazardActionPlanInput
  }

  export type AdminHazardActionPlanUncheckedCreateWithoutHazardInput = {
    id?: string
    actionPlanId: string
    businessTypes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminHazardActionPlanCreateOrConnectWithoutHazardInput = {
    where: AdminHazardActionPlanWhereUniqueInput
    create: XOR<AdminHazardActionPlanCreateWithoutHazardInput, AdminHazardActionPlanUncheckedCreateWithoutHazardInput>
  }

  export type AdminHazardActionPlanCreateManyHazardInputEnvelope = {
    data: AdminHazardActionPlanCreateManyHazardInput | AdminHazardActionPlanCreateManyHazardInput[]
    skipDuplicates?: boolean
  }

  export type AdminActionPlanCreateWithoutHazardInput = {
    id?: string
    resourcesNeeded: string
    immediateActions: string
    shortTermActions: string
    mediumTermActions: string
    longTermReduction: string
    businessTypeModifiers?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    AdminHazardActionPlan?: AdminHazardActionPlanCreateNestedManyWithoutActionPlanInput
  }

  export type AdminActionPlanUncheckedCreateWithoutHazardInput = {
    id?: string
    resourcesNeeded: string
    immediateActions: string
    shortTermActions: string
    mediumTermActions: string
    longTermReduction: string
    businessTypeModifiers?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    AdminHazardActionPlan?: AdminHazardActionPlanUncheckedCreateNestedManyWithoutActionPlanInput
  }

  export type AdminActionPlanCreateOrConnectWithoutHazardInput = {
    where: AdminActionPlanWhereUniqueInput
    create: XOR<AdminActionPlanCreateWithoutHazardInput, AdminActionPlanUncheckedCreateWithoutHazardInput>
  }

  export type HazardTranslationCreateWithoutHazardInput = {
    id?: string
    locale: string
    name: string
    description?: string | null
    impact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HazardTranslationUncheckedCreateWithoutHazardInput = {
    id?: string
    locale: string
    name: string
    description?: string | null
    impact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HazardTranslationCreateOrConnectWithoutHazardInput = {
    where: HazardTranslationWhereUniqueInput
    create: XOR<HazardTranslationCreateWithoutHazardInput, HazardTranslationUncheckedCreateWithoutHazardInput>
  }

  export type HazardTranslationCreateManyHazardInputEnvelope = {
    data: HazardTranslationCreateManyHazardInput | HazardTranslationCreateManyHazardInput[]
    skipDuplicates?: boolean
  }

  export type AdminBusinessTypeHazardUpsertWithWhereUniqueWithoutHazardInput = {
    where: AdminBusinessTypeHazardWhereUniqueInput
    update: XOR<AdminBusinessTypeHazardUpdateWithoutHazardInput, AdminBusinessTypeHazardUncheckedUpdateWithoutHazardInput>
    create: XOR<AdminBusinessTypeHazardCreateWithoutHazardInput, AdminBusinessTypeHazardUncheckedCreateWithoutHazardInput>
  }

  export type AdminBusinessTypeHazardUpdateWithWhereUniqueWithoutHazardInput = {
    where: AdminBusinessTypeHazardWhereUniqueInput
    data: XOR<AdminBusinessTypeHazardUpdateWithoutHazardInput, AdminBusinessTypeHazardUncheckedUpdateWithoutHazardInput>
  }

  export type AdminBusinessTypeHazardUpdateManyWithWhereWithoutHazardInput = {
    where: AdminBusinessTypeHazardScalarWhereInput
    data: XOR<AdminBusinessTypeHazardUpdateManyMutationInput, AdminBusinessTypeHazardUncheckedUpdateManyWithoutHazardInput>
  }

  export type AdminLocationHazardUpsertWithWhereUniqueWithoutHazardInput = {
    where: AdminLocationHazardWhereUniqueInput
    update: XOR<AdminLocationHazardUpdateWithoutHazardInput, AdminLocationHazardUncheckedUpdateWithoutHazardInput>
    create: XOR<AdminLocationHazardCreateWithoutHazardInput, AdminLocationHazardUncheckedCreateWithoutHazardInput>
  }

  export type AdminLocationHazardUpdateWithWhereUniqueWithoutHazardInput = {
    where: AdminLocationHazardWhereUniqueInput
    data: XOR<AdminLocationHazardUpdateWithoutHazardInput, AdminLocationHazardUncheckedUpdateWithoutHazardInput>
  }

  export type AdminLocationHazardUpdateManyWithWhereWithoutHazardInput = {
    where: AdminLocationHazardScalarWhereInput
    data: XOR<AdminLocationHazardUpdateManyMutationInput, AdminLocationHazardUncheckedUpdateManyWithoutHazardInput>
  }

  export type AdminLocationHazardScalarWhereInput = {
    AND?: AdminLocationHazardScalarWhereInput | AdminLocationHazardScalarWhereInput[]
    OR?: AdminLocationHazardScalarWhereInput[]
    NOT?: AdminLocationHazardScalarWhereInput | AdminLocationHazardScalarWhereInput[]
    id?: StringFilter<"AdminLocationHazard"> | string
    locationId?: StringFilter<"AdminLocationHazard"> | string
    hazardId?: StringFilter<"AdminLocationHazard"> | string
    riskLevel?: StringFilter<"AdminLocationHazard"> | string
    frequency?: StringNullableFilter<"AdminLocationHazard"> | string | null
    impact?: StringNullableFilter<"AdminLocationHazard"> | string | null
    notes?: StringNullableFilter<"AdminLocationHazard"> | string | null
    isActive?: BoolFilter<"AdminLocationHazard"> | boolean
    createdAt?: DateTimeFilter<"AdminLocationHazard"> | Date | string
    updatedAt?: DateTimeFilter<"AdminLocationHazard"> | Date | string
  }

  export type AdminHazardStrategyUpsertWithWhereUniqueWithoutHazardInput = {
    where: AdminHazardStrategyWhereUniqueInput
    update: XOR<AdminHazardStrategyUpdateWithoutHazardInput, AdminHazardStrategyUncheckedUpdateWithoutHazardInput>
    create: XOR<AdminHazardStrategyCreateWithoutHazardInput, AdminHazardStrategyUncheckedCreateWithoutHazardInput>
  }

  export type AdminHazardStrategyUpdateWithWhereUniqueWithoutHazardInput = {
    where: AdminHazardStrategyWhereUniqueInput
    data: XOR<AdminHazardStrategyUpdateWithoutHazardInput, AdminHazardStrategyUncheckedUpdateWithoutHazardInput>
  }

  export type AdminHazardStrategyUpdateManyWithWhereWithoutHazardInput = {
    where: AdminHazardStrategyScalarWhereInput
    data: XOR<AdminHazardStrategyUpdateManyMutationInput, AdminHazardStrategyUncheckedUpdateManyWithoutHazardInput>
  }

  export type AdminHazardStrategyScalarWhereInput = {
    AND?: AdminHazardStrategyScalarWhereInput | AdminHazardStrategyScalarWhereInput[]
    OR?: AdminHazardStrategyScalarWhereInput[]
    NOT?: AdminHazardStrategyScalarWhereInput | AdminHazardStrategyScalarWhereInput[]
    id?: StringFilter<"AdminHazardStrategy"> | string
    hazardId?: StringFilter<"AdminHazardStrategy"> | string
    strategyId?: StringFilter<"AdminHazardStrategy"> | string
    businessTypes?: StringNullableFilter<"AdminHazardStrategy"> | string | null
    priority?: StringFilter<"AdminHazardStrategy"> | string
    isRecommended?: BoolFilter<"AdminHazardStrategy"> | boolean
    notes?: StringNullableFilter<"AdminHazardStrategy"> | string | null
    isActive?: BoolFilter<"AdminHazardStrategy"> | boolean
    createdAt?: DateTimeFilter<"AdminHazardStrategy"> | Date | string
    updatedAt?: DateTimeFilter<"AdminHazardStrategy"> | Date | string
  }

  export type AdminHazardActionPlanUpsertWithWhereUniqueWithoutHazardInput = {
    where: AdminHazardActionPlanWhereUniqueInput
    update: XOR<AdminHazardActionPlanUpdateWithoutHazardInput, AdminHazardActionPlanUncheckedUpdateWithoutHazardInput>
    create: XOR<AdminHazardActionPlanCreateWithoutHazardInput, AdminHazardActionPlanUncheckedCreateWithoutHazardInput>
  }

  export type AdminHazardActionPlanUpdateWithWhereUniqueWithoutHazardInput = {
    where: AdminHazardActionPlanWhereUniqueInput
    data: XOR<AdminHazardActionPlanUpdateWithoutHazardInput, AdminHazardActionPlanUncheckedUpdateWithoutHazardInput>
  }

  export type AdminHazardActionPlanUpdateManyWithWhereWithoutHazardInput = {
    where: AdminHazardActionPlanScalarWhereInput
    data: XOR<AdminHazardActionPlanUpdateManyMutationInput, AdminHazardActionPlanUncheckedUpdateManyWithoutHazardInput>
  }

  export type AdminHazardActionPlanScalarWhereInput = {
    AND?: AdminHazardActionPlanScalarWhereInput | AdminHazardActionPlanScalarWhereInput[]
    OR?: AdminHazardActionPlanScalarWhereInput[]
    NOT?: AdminHazardActionPlanScalarWhereInput | AdminHazardActionPlanScalarWhereInput[]
    id?: StringFilter<"AdminHazardActionPlan"> | string
    hazardId?: StringFilter<"AdminHazardActionPlan"> | string
    actionPlanId?: StringFilter<"AdminHazardActionPlan"> | string
    businessTypes?: StringNullableFilter<"AdminHazardActionPlan"> | string | null
    isActive?: BoolFilter<"AdminHazardActionPlan"> | boolean
    createdAt?: DateTimeFilter<"AdminHazardActionPlan"> | Date | string
    updatedAt?: DateTimeFilter<"AdminHazardActionPlan"> | Date | string
  }

  export type AdminActionPlanUpsertWithoutHazardInput = {
    update: XOR<AdminActionPlanUpdateWithoutHazardInput, AdminActionPlanUncheckedUpdateWithoutHazardInput>
    create: XOR<AdminActionPlanCreateWithoutHazardInput, AdminActionPlanUncheckedCreateWithoutHazardInput>
    where?: AdminActionPlanWhereInput
  }

  export type AdminActionPlanUpdateToOneWithWhereWithoutHazardInput = {
    where?: AdminActionPlanWhereInput
    data: XOR<AdminActionPlanUpdateWithoutHazardInput, AdminActionPlanUncheckedUpdateWithoutHazardInput>
  }

  export type AdminActionPlanUpdateWithoutHazardInput = {
    id?: StringFieldUpdateOperationsInput | string
    resourcesNeeded?: StringFieldUpdateOperationsInput | string
    immediateActions?: StringFieldUpdateOperationsInput | string
    shortTermActions?: StringFieldUpdateOperationsInput | string
    mediumTermActions?: StringFieldUpdateOperationsInput | string
    longTermReduction?: StringFieldUpdateOperationsInput | string
    businessTypeModifiers?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AdminHazardActionPlan?: AdminHazardActionPlanUpdateManyWithoutActionPlanNestedInput
  }

  export type AdminActionPlanUncheckedUpdateWithoutHazardInput = {
    id?: StringFieldUpdateOperationsInput | string
    resourcesNeeded?: StringFieldUpdateOperationsInput | string
    immediateActions?: StringFieldUpdateOperationsInput | string
    shortTermActions?: StringFieldUpdateOperationsInput | string
    mediumTermActions?: StringFieldUpdateOperationsInput | string
    longTermReduction?: StringFieldUpdateOperationsInput | string
    businessTypeModifiers?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AdminHazardActionPlan?: AdminHazardActionPlanUncheckedUpdateManyWithoutActionPlanNestedInput
  }

  export type HazardTranslationUpsertWithWhereUniqueWithoutHazardInput = {
    where: HazardTranslationWhereUniqueInput
    update: XOR<HazardTranslationUpdateWithoutHazardInput, HazardTranslationUncheckedUpdateWithoutHazardInput>
    create: XOR<HazardTranslationCreateWithoutHazardInput, HazardTranslationUncheckedCreateWithoutHazardInput>
  }

  export type HazardTranslationUpdateWithWhereUniqueWithoutHazardInput = {
    where: HazardTranslationWhereUniqueInput
    data: XOR<HazardTranslationUpdateWithoutHazardInput, HazardTranslationUncheckedUpdateWithoutHazardInput>
  }

  export type HazardTranslationUpdateManyWithWhereWithoutHazardInput = {
    where: HazardTranslationScalarWhereInput
    data: XOR<HazardTranslationUpdateManyMutationInput, HazardTranslationUncheckedUpdateManyWithoutHazardInput>
  }

  export type HazardTranslationScalarWhereInput = {
    AND?: HazardTranslationScalarWhereInput | HazardTranslationScalarWhereInput[]
    OR?: HazardTranslationScalarWhereInput[]
    NOT?: HazardTranslationScalarWhereInput | HazardTranslationScalarWhereInput[]
    id?: StringFilter<"HazardTranslation"> | string
    hazardId?: StringFilter<"HazardTranslation"> | string
    locale?: StringFilter<"HazardTranslation"> | string
    name?: StringFilter<"HazardTranslation"> | string
    description?: StringNullableFilter<"HazardTranslation"> | string | null
    impact?: StringNullableFilter<"HazardTranslation"> | string | null
    createdAt?: DateTimeFilter<"HazardTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"HazardTranslation"> | Date | string
  }

  export type AdminLocationHazardCreateWithoutLocationInput = {
    id?: string
    riskLevel: string
    frequency?: string | null
    impact?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    hazard: AdminHazardTypeCreateNestedOneWithoutLocationHazardsInput
  }

  export type AdminLocationHazardUncheckedCreateWithoutLocationInput = {
    id?: string
    hazardId: string
    riskLevel: string
    frequency?: string | null
    impact?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminLocationHazardCreateOrConnectWithoutLocationInput = {
    where: AdminLocationHazardWhereUniqueInput
    create: XOR<AdminLocationHazardCreateWithoutLocationInput, AdminLocationHazardUncheckedCreateWithoutLocationInput>
  }

  export type AdminLocationHazardCreateManyLocationInputEnvelope = {
    data: AdminLocationHazardCreateManyLocationInput | AdminLocationHazardCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type AdminRiskProfileCreateWithoutLocationInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    calculatedRisks: string
    recommendedStrategies: string
    lastCalculated?: Date | string
    riskScore: number
    businessType: AdminBusinessTypeCreateNestedOneWithoutRiskProfilesInput
  }

  export type AdminRiskProfileUncheckedCreateWithoutLocationInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    businessTypeId: string
    calculatedRisks: string
    recommendedStrategies: string
    lastCalculated?: Date | string
    riskScore: number
  }

  export type AdminRiskProfileCreateOrConnectWithoutLocationInput = {
    where: AdminRiskProfileWhereUniqueInput
    create: XOR<AdminRiskProfileCreateWithoutLocationInput, AdminRiskProfileUncheckedCreateWithoutLocationInput>
  }

  export type AdminRiskProfileCreateManyLocationInputEnvelope = {
    data: AdminRiskProfileCreateManyLocationInput | AdminRiskProfileCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type AdminLocationHazardUpsertWithWhereUniqueWithoutLocationInput = {
    where: AdminLocationHazardWhereUniqueInput
    update: XOR<AdminLocationHazardUpdateWithoutLocationInput, AdminLocationHazardUncheckedUpdateWithoutLocationInput>
    create: XOR<AdminLocationHazardCreateWithoutLocationInput, AdminLocationHazardUncheckedCreateWithoutLocationInput>
  }

  export type AdminLocationHazardUpdateWithWhereUniqueWithoutLocationInput = {
    where: AdminLocationHazardWhereUniqueInput
    data: XOR<AdminLocationHazardUpdateWithoutLocationInput, AdminLocationHazardUncheckedUpdateWithoutLocationInput>
  }

  export type AdminLocationHazardUpdateManyWithWhereWithoutLocationInput = {
    where: AdminLocationHazardScalarWhereInput
    data: XOR<AdminLocationHazardUpdateManyMutationInput, AdminLocationHazardUncheckedUpdateManyWithoutLocationInput>
  }

  export type AdminRiskProfileUpsertWithWhereUniqueWithoutLocationInput = {
    where: AdminRiskProfileWhereUniqueInput
    update: XOR<AdminRiskProfileUpdateWithoutLocationInput, AdminRiskProfileUncheckedUpdateWithoutLocationInput>
    create: XOR<AdminRiskProfileCreateWithoutLocationInput, AdminRiskProfileUncheckedCreateWithoutLocationInput>
  }

  export type AdminRiskProfileUpdateWithWhereUniqueWithoutLocationInput = {
    where: AdminRiskProfileWhereUniqueInput
    data: XOR<AdminRiskProfileUpdateWithoutLocationInput, AdminRiskProfileUncheckedUpdateWithoutLocationInput>
  }

  export type AdminRiskProfileUpdateManyWithWhereWithoutLocationInput = {
    where: AdminRiskProfileScalarWhereInput
    data: XOR<AdminRiskProfileUpdateManyMutationInput, AdminRiskProfileUncheckedUpdateManyWithoutLocationInput>
  }

  export type AdminBusinessTypeCreateWithoutBusinessTypeHazardsInput = {
    id?: string
    businessTypeId: string
    name: string
    localName: string
    category: string
    description?: string | null
    typicalOperatingHours?: string | null
    minimumStaff?: string | null
    minimumEquipment?: string | null
    minimumUtilities?: string | null
    minimumSpace?: string | null
    essentialFunctions?: string | null
    criticalSuppliers?: string | null
    exampleBusinessPurposes?: string | null
    exampleProducts?: string | null
    exampleKeyPersonnel?: string | null
    exampleCustomerBase?: string | null
    dependencies?: string | null
    vulnerabilityMatrix?: string | null
    operationalThresholds?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    riskProfiles?: AdminRiskProfileCreateNestedManyWithoutBusinessTypeInput
  }

  export type AdminBusinessTypeUncheckedCreateWithoutBusinessTypeHazardsInput = {
    id?: string
    businessTypeId: string
    name: string
    localName: string
    category: string
    description?: string | null
    typicalOperatingHours?: string | null
    minimumStaff?: string | null
    minimumEquipment?: string | null
    minimumUtilities?: string | null
    minimumSpace?: string | null
    essentialFunctions?: string | null
    criticalSuppliers?: string | null
    exampleBusinessPurposes?: string | null
    exampleProducts?: string | null
    exampleKeyPersonnel?: string | null
    exampleCustomerBase?: string | null
    dependencies?: string | null
    vulnerabilityMatrix?: string | null
    operationalThresholds?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    riskProfiles?: AdminRiskProfileUncheckedCreateNestedManyWithoutBusinessTypeInput
  }

  export type AdminBusinessTypeCreateOrConnectWithoutBusinessTypeHazardsInput = {
    where: AdminBusinessTypeWhereUniqueInput
    create: XOR<AdminBusinessTypeCreateWithoutBusinessTypeHazardsInput, AdminBusinessTypeUncheckedCreateWithoutBusinessTypeHazardsInput>
  }

  export type AdminHazardTypeCreateWithoutBusinessTypeHazardsInput = {
    id?: string
    hazardId: string
    name: string
    category: string
    description?: string | null
    defaultFrequency: string
    defaultImpact: string
    seasonalPattern?: string | null
    peakMonths?: string | null
    warningTime?: string | null
    geographicScope?: string | null
    cascadingRisks?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    locationHazards?: AdminLocationHazardCreateNestedManyWithoutHazardInput
    hazardStrategies?: AdminHazardStrategyCreateNestedManyWithoutHazardInput
    hazardActionPlans?: AdminHazardActionPlanCreateNestedManyWithoutHazardInput
    AdminActionPlan?: AdminActionPlanCreateNestedOneWithoutHazardInput
    translations?: HazardTranslationCreateNestedManyWithoutHazardInput
  }

  export type AdminHazardTypeUncheckedCreateWithoutBusinessTypeHazardsInput = {
    id?: string
    hazardId: string
    name: string
    category: string
    description?: string | null
    defaultFrequency: string
    defaultImpact: string
    seasonalPattern?: string | null
    peakMonths?: string | null
    warningTime?: string | null
    geographicScope?: string | null
    cascadingRisks?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    locationHazards?: AdminLocationHazardUncheckedCreateNestedManyWithoutHazardInput
    hazardStrategies?: AdminHazardStrategyUncheckedCreateNestedManyWithoutHazardInput
    hazardActionPlans?: AdminHazardActionPlanUncheckedCreateNestedManyWithoutHazardInput
    AdminActionPlan?: AdminActionPlanUncheckedCreateNestedOneWithoutHazardInput
    translations?: HazardTranslationUncheckedCreateNestedManyWithoutHazardInput
  }

  export type AdminHazardTypeCreateOrConnectWithoutBusinessTypeHazardsInput = {
    where: AdminHazardTypeWhereUniqueInput
    create: XOR<AdminHazardTypeCreateWithoutBusinessTypeHazardsInput, AdminHazardTypeUncheckedCreateWithoutBusinessTypeHazardsInput>
  }

  export type AdminBusinessTypeUpsertWithoutBusinessTypeHazardsInput = {
    update: XOR<AdminBusinessTypeUpdateWithoutBusinessTypeHazardsInput, AdminBusinessTypeUncheckedUpdateWithoutBusinessTypeHazardsInput>
    create: XOR<AdminBusinessTypeCreateWithoutBusinessTypeHazardsInput, AdminBusinessTypeUncheckedCreateWithoutBusinessTypeHazardsInput>
    where?: AdminBusinessTypeWhereInput
  }

  export type AdminBusinessTypeUpdateToOneWithWhereWithoutBusinessTypeHazardsInput = {
    where?: AdminBusinessTypeWhereInput
    data: XOR<AdminBusinessTypeUpdateWithoutBusinessTypeHazardsInput, AdminBusinessTypeUncheckedUpdateWithoutBusinessTypeHazardsInput>
  }

  export type AdminBusinessTypeUpdateWithoutBusinessTypeHazardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessTypeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    localName?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    typicalOperatingHours?: NullableStringFieldUpdateOperationsInput | string | null
    minimumStaff?: NullableStringFieldUpdateOperationsInput | string | null
    minimumEquipment?: NullableStringFieldUpdateOperationsInput | string | null
    minimumUtilities?: NullableStringFieldUpdateOperationsInput | string | null
    minimumSpace?: NullableStringFieldUpdateOperationsInput | string | null
    essentialFunctions?: NullableStringFieldUpdateOperationsInput | string | null
    criticalSuppliers?: NullableStringFieldUpdateOperationsInput | string | null
    exampleBusinessPurposes?: NullableStringFieldUpdateOperationsInput | string | null
    exampleProducts?: NullableStringFieldUpdateOperationsInput | string | null
    exampleKeyPersonnel?: NullableStringFieldUpdateOperationsInput | string | null
    exampleCustomerBase?: NullableStringFieldUpdateOperationsInput | string | null
    dependencies?: NullableStringFieldUpdateOperationsInput | string | null
    vulnerabilityMatrix?: NullableStringFieldUpdateOperationsInput | string | null
    operationalThresholds?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    riskProfiles?: AdminRiskProfileUpdateManyWithoutBusinessTypeNestedInput
  }

  export type AdminBusinessTypeUncheckedUpdateWithoutBusinessTypeHazardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessTypeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    localName?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    typicalOperatingHours?: NullableStringFieldUpdateOperationsInput | string | null
    minimumStaff?: NullableStringFieldUpdateOperationsInput | string | null
    minimumEquipment?: NullableStringFieldUpdateOperationsInput | string | null
    minimumUtilities?: NullableStringFieldUpdateOperationsInput | string | null
    minimumSpace?: NullableStringFieldUpdateOperationsInput | string | null
    essentialFunctions?: NullableStringFieldUpdateOperationsInput | string | null
    criticalSuppliers?: NullableStringFieldUpdateOperationsInput | string | null
    exampleBusinessPurposes?: NullableStringFieldUpdateOperationsInput | string | null
    exampleProducts?: NullableStringFieldUpdateOperationsInput | string | null
    exampleKeyPersonnel?: NullableStringFieldUpdateOperationsInput | string | null
    exampleCustomerBase?: NullableStringFieldUpdateOperationsInput | string | null
    dependencies?: NullableStringFieldUpdateOperationsInput | string | null
    vulnerabilityMatrix?: NullableStringFieldUpdateOperationsInput | string | null
    operationalThresholds?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    riskProfiles?: AdminRiskProfileUncheckedUpdateManyWithoutBusinessTypeNestedInput
  }

  export type AdminHazardTypeUpsertWithoutBusinessTypeHazardsInput = {
    update: XOR<AdminHazardTypeUpdateWithoutBusinessTypeHazardsInput, AdminHazardTypeUncheckedUpdateWithoutBusinessTypeHazardsInput>
    create: XOR<AdminHazardTypeCreateWithoutBusinessTypeHazardsInput, AdminHazardTypeUncheckedCreateWithoutBusinessTypeHazardsInput>
    where?: AdminHazardTypeWhereInput
  }

  export type AdminHazardTypeUpdateToOneWithWhereWithoutBusinessTypeHazardsInput = {
    where?: AdminHazardTypeWhereInput
    data: XOR<AdminHazardTypeUpdateWithoutBusinessTypeHazardsInput, AdminHazardTypeUncheckedUpdateWithoutBusinessTypeHazardsInput>
  }

  export type AdminHazardTypeUpdateWithoutBusinessTypeHazardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    hazardId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultFrequency?: StringFieldUpdateOperationsInput | string
    defaultImpact?: StringFieldUpdateOperationsInput | string
    seasonalPattern?: NullableStringFieldUpdateOperationsInput | string | null
    peakMonths?: NullableStringFieldUpdateOperationsInput | string | null
    warningTime?: NullableStringFieldUpdateOperationsInput | string | null
    geographicScope?: NullableStringFieldUpdateOperationsInput | string | null
    cascadingRisks?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationHazards?: AdminLocationHazardUpdateManyWithoutHazardNestedInput
    hazardStrategies?: AdminHazardStrategyUpdateManyWithoutHazardNestedInput
    hazardActionPlans?: AdminHazardActionPlanUpdateManyWithoutHazardNestedInput
    AdminActionPlan?: AdminActionPlanUpdateOneWithoutHazardNestedInput
    translations?: HazardTranslationUpdateManyWithoutHazardNestedInput
  }

  export type AdminHazardTypeUncheckedUpdateWithoutBusinessTypeHazardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    hazardId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultFrequency?: StringFieldUpdateOperationsInput | string
    defaultImpact?: StringFieldUpdateOperationsInput | string
    seasonalPattern?: NullableStringFieldUpdateOperationsInput | string | null
    peakMonths?: NullableStringFieldUpdateOperationsInput | string | null
    warningTime?: NullableStringFieldUpdateOperationsInput | string | null
    geographicScope?: NullableStringFieldUpdateOperationsInput | string | null
    cascadingRisks?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationHazards?: AdminLocationHazardUncheckedUpdateManyWithoutHazardNestedInput
    hazardStrategies?: AdminHazardStrategyUncheckedUpdateManyWithoutHazardNestedInput
    hazardActionPlans?: AdminHazardActionPlanUncheckedUpdateManyWithoutHazardNestedInput
    AdminActionPlan?: AdminActionPlanUncheckedUpdateOneWithoutHazardNestedInput
    translations?: HazardTranslationUncheckedUpdateManyWithoutHazardNestedInput
  }

  export type AdminLocationCreateWithoutLocationHazardsInput = {
    id?: string
    country: string
    countryCode: string
    parish?: string | null
    isCoastal?: boolean
    isUrban?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    riskProfiles?: AdminRiskProfileCreateNestedManyWithoutLocationInput
  }

  export type AdminLocationUncheckedCreateWithoutLocationHazardsInput = {
    id?: string
    country: string
    countryCode: string
    parish?: string | null
    isCoastal?: boolean
    isUrban?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    riskProfiles?: AdminRiskProfileUncheckedCreateNestedManyWithoutLocationInput
  }

  export type AdminLocationCreateOrConnectWithoutLocationHazardsInput = {
    where: AdminLocationWhereUniqueInput
    create: XOR<AdminLocationCreateWithoutLocationHazardsInput, AdminLocationUncheckedCreateWithoutLocationHazardsInput>
  }

  export type AdminHazardTypeCreateWithoutLocationHazardsInput = {
    id?: string
    hazardId: string
    name: string
    category: string
    description?: string | null
    defaultFrequency: string
    defaultImpact: string
    seasonalPattern?: string | null
    peakMonths?: string | null
    warningTime?: string | null
    geographicScope?: string | null
    cascadingRisks?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    businessTypeHazards?: AdminBusinessTypeHazardCreateNestedManyWithoutHazardInput
    hazardStrategies?: AdminHazardStrategyCreateNestedManyWithoutHazardInput
    hazardActionPlans?: AdminHazardActionPlanCreateNestedManyWithoutHazardInput
    AdminActionPlan?: AdminActionPlanCreateNestedOneWithoutHazardInput
    translations?: HazardTranslationCreateNestedManyWithoutHazardInput
  }

  export type AdminHazardTypeUncheckedCreateWithoutLocationHazardsInput = {
    id?: string
    hazardId: string
    name: string
    category: string
    description?: string | null
    defaultFrequency: string
    defaultImpact: string
    seasonalPattern?: string | null
    peakMonths?: string | null
    warningTime?: string | null
    geographicScope?: string | null
    cascadingRisks?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    businessTypeHazards?: AdminBusinessTypeHazardUncheckedCreateNestedManyWithoutHazardInput
    hazardStrategies?: AdminHazardStrategyUncheckedCreateNestedManyWithoutHazardInput
    hazardActionPlans?: AdminHazardActionPlanUncheckedCreateNestedManyWithoutHazardInput
    AdminActionPlan?: AdminActionPlanUncheckedCreateNestedOneWithoutHazardInput
    translations?: HazardTranslationUncheckedCreateNestedManyWithoutHazardInput
  }

  export type AdminHazardTypeCreateOrConnectWithoutLocationHazardsInput = {
    where: AdminHazardTypeWhereUniqueInput
    create: XOR<AdminHazardTypeCreateWithoutLocationHazardsInput, AdminHazardTypeUncheckedCreateWithoutLocationHazardsInput>
  }

  export type AdminLocationUpsertWithoutLocationHazardsInput = {
    update: XOR<AdminLocationUpdateWithoutLocationHazardsInput, AdminLocationUncheckedUpdateWithoutLocationHazardsInput>
    create: XOR<AdminLocationCreateWithoutLocationHazardsInput, AdminLocationUncheckedCreateWithoutLocationHazardsInput>
    where?: AdminLocationWhereInput
  }

  export type AdminLocationUpdateToOneWithWhereWithoutLocationHazardsInput = {
    where?: AdminLocationWhereInput
    data: XOR<AdminLocationUpdateWithoutLocationHazardsInput, AdminLocationUncheckedUpdateWithoutLocationHazardsInput>
  }

  export type AdminLocationUpdateWithoutLocationHazardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    parish?: NullableStringFieldUpdateOperationsInput | string | null
    isCoastal?: BoolFieldUpdateOperationsInput | boolean
    isUrban?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    riskProfiles?: AdminRiskProfileUpdateManyWithoutLocationNestedInput
  }

  export type AdminLocationUncheckedUpdateWithoutLocationHazardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    parish?: NullableStringFieldUpdateOperationsInput | string | null
    isCoastal?: BoolFieldUpdateOperationsInput | boolean
    isUrban?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    riskProfiles?: AdminRiskProfileUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type AdminHazardTypeUpsertWithoutLocationHazardsInput = {
    update: XOR<AdminHazardTypeUpdateWithoutLocationHazardsInput, AdminHazardTypeUncheckedUpdateWithoutLocationHazardsInput>
    create: XOR<AdminHazardTypeCreateWithoutLocationHazardsInput, AdminHazardTypeUncheckedCreateWithoutLocationHazardsInput>
    where?: AdminHazardTypeWhereInput
  }

  export type AdminHazardTypeUpdateToOneWithWhereWithoutLocationHazardsInput = {
    where?: AdminHazardTypeWhereInput
    data: XOR<AdminHazardTypeUpdateWithoutLocationHazardsInput, AdminHazardTypeUncheckedUpdateWithoutLocationHazardsInput>
  }

  export type AdminHazardTypeUpdateWithoutLocationHazardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    hazardId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultFrequency?: StringFieldUpdateOperationsInput | string
    defaultImpact?: StringFieldUpdateOperationsInput | string
    seasonalPattern?: NullableStringFieldUpdateOperationsInput | string | null
    peakMonths?: NullableStringFieldUpdateOperationsInput | string | null
    warningTime?: NullableStringFieldUpdateOperationsInput | string | null
    geographicScope?: NullableStringFieldUpdateOperationsInput | string | null
    cascadingRisks?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessTypeHazards?: AdminBusinessTypeHazardUpdateManyWithoutHazardNestedInput
    hazardStrategies?: AdminHazardStrategyUpdateManyWithoutHazardNestedInput
    hazardActionPlans?: AdminHazardActionPlanUpdateManyWithoutHazardNestedInput
    AdminActionPlan?: AdminActionPlanUpdateOneWithoutHazardNestedInput
    translations?: HazardTranslationUpdateManyWithoutHazardNestedInput
  }

  export type AdminHazardTypeUncheckedUpdateWithoutLocationHazardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    hazardId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultFrequency?: StringFieldUpdateOperationsInput | string
    defaultImpact?: StringFieldUpdateOperationsInput | string
    seasonalPattern?: NullableStringFieldUpdateOperationsInput | string | null
    peakMonths?: NullableStringFieldUpdateOperationsInput | string | null
    warningTime?: NullableStringFieldUpdateOperationsInput | string | null
    geographicScope?: NullableStringFieldUpdateOperationsInput | string | null
    cascadingRisks?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessTypeHazards?: AdminBusinessTypeHazardUncheckedUpdateManyWithoutHazardNestedInput
    hazardStrategies?: AdminHazardStrategyUncheckedUpdateManyWithoutHazardNestedInput
    hazardActionPlans?: AdminHazardActionPlanUncheckedUpdateManyWithoutHazardNestedInput
    AdminActionPlan?: AdminActionPlanUncheckedUpdateOneWithoutHazardNestedInput
    translations?: HazardTranslationUncheckedUpdateManyWithoutHazardNestedInput
  }

  export type AdminHazardStrategyCreateWithoutStrategyInput = {
    id?: string
    businessTypes?: string | null
    priority?: string
    isRecommended?: boolean
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    hazard: AdminHazardTypeCreateNestedOneWithoutHazardStrategiesInput
  }

  export type AdminHazardStrategyUncheckedCreateWithoutStrategyInput = {
    id?: string
    hazardId: string
    businessTypes?: string | null
    priority?: string
    isRecommended?: boolean
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminHazardStrategyCreateOrConnectWithoutStrategyInput = {
    where: AdminHazardStrategyWhereUniqueInput
    create: XOR<AdminHazardStrategyCreateWithoutStrategyInput, AdminHazardStrategyUncheckedCreateWithoutStrategyInput>
  }

  export type AdminHazardStrategyCreateManyStrategyInputEnvelope = {
    data: AdminHazardStrategyCreateManyStrategyInput | AdminHazardStrategyCreateManyStrategyInput[]
    skipDuplicates?: boolean
  }

  export type AdminHazardStrategyUpsertWithWhereUniqueWithoutStrategyInput = {
    where: AdminHazardStrategyWhereUniqueInput
    update: XOR<AdminHazardStrategyUpdateWithoutStrategyInput, AdminHazardStrategyUncheckedUpdateWithoutStrategyInput>
    create: XOR<AdminHazardStrategyCreateWithoutStrategyInput, AdminHazardStrategyUncheckedCreateWithoutStrategyInput>
  }

  export type AdminHazardStrategyUpdateWithWhereUniqueWithoutStrategyInput = {
    where: AdminHazardStrategyWhereUniqueInput
    data: XOR<AdminHazardStrategyUpdateWithoutStrategyInput, AdminHazardStrategyUncheckedUpdateWithoutStrategyInput>
  }

  export type AdminHazardStrategyUpdateManyWithWhereWithoutStrategyInput = {
    where: AdminHazardStrategyScalarWhereInput
    data: XOR<AdminHazardStrategyUpdateManyMutationInput, AdminHazardStrategyUncheckedUpdateManyWithoutStrategyInput>
  }

  export type AdminHazardTypeCreateWithoutHazardStrategiesInput = {
    id?: string
    hazardId: string
    name: string
    category: string
    description?: string | null
    defaultFrequency: string
    defaultImpact: string
    seasonalPattern?: string | null
    peakMonths?: string | null
    warningTime?: string | null
    geographicScope?: string | null
    cascadingRisks?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    businessTypeHazards?: AdminBusinessTypeHazardCreateNestedManyWithoutHazardInput
    locationHazards?: AdminLocationHazardCreateNestedManyWithoutHazardInput
    hazardActionPlans?: AdminHazardActionPlanCreateNestedManyWithoutHazardInput
    AdminActionPlan?: AdminActionPlanCreateNestedOneWithoutHazardInput
    translations?: HazardTranslationCreateNestedManyWithoutHazardInput
  }

  export type AdminHazardTypeUncheckedCreateWithoutHazardStrategiesInput = {
    id?: string
    hazardId: string
    name: string
    category: string
    description?: string | null
    defaultFrequency: string
    defaultImpact: string
    seasonalPattern?: string | null
    peakMonths?: string | null
    warningTime?: string | null
    geographicScope?: string | null
    cascadingRisks?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    businessTypeHazards?: AdminBusinessTypeHazardUncheckedCreateNestedManyWithoutHazardInput
    locationHazards?: AdminLocationHazardUncheckedCreateNestedManyWithoutHazardInput
    hazardActionPlans?: AdminHazardActionPlanUncheckedCreateNestedManyWithoutHazardInput
    AdminActionPlan?: AdminActionPlanUncheckedCreateNestedOneWithoutHazardInput
    translations?: HazardTranslationUncheckedCreateNestedManyWithoutHazardInput
  }

  export type AdminHazardTypeCreateOrConnectWithoutHazardStrategiesInput = {
    where: AdminHazardTypeWhereUniqueInput
    create: XOR<AdminHazardTypeCreateWithoutHazardStrategiesInput, AdminHazardTypeUncheckedCreateWithoutHazardStrategiesInput>
  }

  export type AdminStrategyCreateWithoutHazardStrategiesInput = {
    id?: string
    strategyId: string
    title: string
    description: string
    category: string
    reasoning?: string | null
    icon?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminStrategyUncheckedCreateWithoutHazardStrategiesInput = {
    id?: string
    strategyId: string
    title: string
    description: string
    category: string
    reasoning?: string | null
    icon?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminStrategyCreateOrConnectWithoutHazardStrategiesInput = {
    where: AdminStrategyWhereUniqueInput
    create: XOR<AdminStrategyCreateWithoutHazardStrategiesInput, AdminStrategyUncheckedCreateWithoutHazardStrategiesInput>
  }

  export type AdminHazardTypeUpsertWithoutHazardStrategiesInput = {
    update: XOR<AdminHazardTypeUpdateWithoutHazardStrategiesInput, AdminHazardTypeUncheckedUpdateWithoutHazardStrategiesInput>
    create: XOR<AdminHazardTypeCreateWithoutHazardStrategiesInput, AdminHazardTypeUncheckedCreateWithoutHazardStrategiesInput>
    where?: AdminHazardTypeWhereInput
  }

  export type AdminHazardTypeUpdateToOneWithWhereWithoutHazardStrategiesInput = {
    where?: AdminHazardTypeWhereInput
    data: XOR<AdminHazardTypeUpdateWithoutHazardStrategiesInput, AdminHazardTypeUncheckedUpdateWithoutHazardStrategiesInput>
  }

  export type AdminHazardTypeUpdateWithoutHazardStrategiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    hazardId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultFrequency?: StringFieldUpdateOperationsInput | string
    defaultImpact?: StringFieldUpdateOperationsInput | string
    seasonalPattern?: NullableStringFieldUpdateOperationsInput | string | null
    peakMonths?: NullableStringFieldUpdateOperationsInput | string | null
    warningTime?: NullableStringFieldUpdateOperationsInput | string | null
    geographicScope?: NullableStringFieldUpdateOperationsInput | string | null
    cascadingRisks?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessTypeHazards?: AdminBusinessTypeHazardUpdateManyWithoutHazardNestedInput
    locationHazards?: AdminLocationHazardUpdateManyWithoutHazardNestedInput
    hazardActionPlans?: AdminHazardActionPlanUpdateManyWithoutHazardNestedInput
    AdminActionPlan?: AdminActionPlanUpdateOneWithoutHazardNestedInput
    translations?: HazardTranslationUpdateManyWithoutHazardNestedInput
  }

  export type AdminHazardTypeUncheckedUpdateWithoutHazardStrategiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    hazardId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultFrequency?: StringFieldUpdateOperationsInput | string
    defaultImpact?: StringFieldUpdateOperationsInput | string
    seasonalPattern?: NullableStringFieldUpdateOperationsInput | string | null
    peakMonths?: NullableStringFieldUpdateOperationsInput | string | null
    warningTime?: NullableStringFieldUpdateOperationsInput | string | null
    geographicScope?: NullableStringFieldUpdateOperationsInput | string | null
    cascadingRisks?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessTypeHazards?: AdminBusinessTypeHazardUncheckedUpdateManyWithoutHazardNestedInput
    locationHazards?: AdminLocationHazardUncheckedUpdateManyWithoutHazardNestedInput
    hazardActionPlans?: AdminHazardActionPlanUncheckedUpdateManyWithoutHazardNestedInput
    AdminActionPlan?: AdminActionPlanUncheckedUpdateOneWithoutHazardNestedInput
    translations?: HazardTranslationUncheckedUpdateManyWithoutHazardNestedInput
  }

  export type AdminStrategyUpsertWithoutHazardStrategiesInput = {
    update: XOR<AdminStrategyUpdateWithoutHazardStrategiesInput, AdminStrategyUncheckedUpdateWithoutHazardStrategiesInput>
    create: XOR<AdminStrategyCreateWithoutHazardStrategiesInput, AdminStrategyUncheckedCreateWithoutHazardStrategiesInput>
    where?: AdminStrategyWhereInput
  }

  export type AdminStrategyUpdateToOneWithWhereWithoutHazardStrategiesInput = {
    where?: AdminStrategyWhereInput
    data: XOR<AdminStrategyUpdateWithoutHazardStrategiesInput, AdminStrategyUncheckedUpdateWithoutHazardStrategiesInput>
  }

  export type AdminStrategyUpdateWithoutHazardStrategiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    strategyId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminStrategyUncheckedUpdateWithoutHazardStrategiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    strategyId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminHazardTypeCreateWithoutAdminActionPlanInput = {
    id?: string
    hazardId: string
    name: string
    category: string
    description?: string | null
    defaultFrequency: string
    defaultImpact: string
    seasonalPattern?: string | null
    peakMonths?: string | null
    warningTime?: string | null
    geographicScope?: string | null
    cascadingRisks?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    businessTypeHazards?: AdminBusinessTypeHazardCreateNestedManyWithoutHazardInput
    locationHazards?: AdminLocationHazardCreateNestedManyWithoutHazardInput
    hazardStrategies?: AdminHazardStrategyCreateNestedManyWithoutHazardInput
    hazardActionPlans?: AdminHazardActionPlanCreateNestedManyWithoutHazardInput
    translations?: HazardTranslationCreateNestedManyWithoutHazardInput
  }

  export type AdminHazardTypeUncheckedCreateWithoutAdminActionPlanInput = {
    id?: string
    hazardId: string
    name: string
    category: string
    description?: string | null
    defaultFrequency: string
    defaultImpact: string
    seasonalPattern?: string | null
    peakMonths?: string | null
    warningTime?: string | null
    geographicScope?: string | null
    cascadingRisks?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    businessTypeHazards?: AdminBusinessTypeHazardUncheckedCreateNestedManyWithoutHazardInput
    locationHazards?: AdminLocationHazardUncheckedCreateNestedManyWithoutHazardInput
    hazardStrategies?: AdminHazardStrategyUncheckedCreateNestedManyWithoutHazardInput
    hazardActionPlans?: AdminHazardActionPlanUncheckedCreateNestedManyWithoutHazardInput
    translations?: HazardTranslationUncheckedCreateNestedManyWithoutHazardInput
  }

  export type AdminHazardTypeCreateOrConnectWithoutAdminActionPlanInput = {
    where: AdminHazardTypeWhereUniqueInput
    create: XOR<AdminHazardTypeCreateWithoutAdminActionPlanInput, AdminHazardTypeUncheckedCreateWithoutAdminActionPlanInput>
  }

  export type AdminHazardActionPlanCreateWithoutActionPlanInput = {
    id?: string
    businessTypes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    hazard: AdminHazardTypeCreateNestedOneWithoutHazardActionPlansInput
  }

  export type AdminHazardActionPlanUncheckedCreateWithoutActionPlanInput = {
    id?: string
    hazardId: string
    businessTypes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminHazardActionPlanCreateOrConnectWithoutActionPlanInput = {
    where: AdminHazardActionPlanWhereUniqueInput
    create: XOR<AdminHazardActionPlanCreateWithoutActionPlanInput, AdminHazardActionPlanUncheckedCreateWithoutActionPlanInput>
  }

  export type AdminHazardActionPlanCreateManyActionPlanInputEnvelope = {
    data: AdminHazardActionPlanCreateManyActionPlanInput | AdminHazardActionPlanCreateManyActionPlanInput[]
    skipDuplicates?: boolean
  }

  export type AdminHazardTypeUpsertWithoutAdminActionPlanInput = {
    update: XOR<AdminHazardTypeUpdateWithoutAdminActionPlanInput, AdminHazardTypeUncheckedUpdateWithoutAdminActionPlanInput>
    create: XOR<AdminHazardTypeCreateWithoutAdminActionPlanInput, AdminHazardTypeUncheckedCreateWithoutAdminActionPlanInput>
    where?: AdminHazardTypeWhereInput
  }

  export type AdminHazardTypeUpdateToOneWithWhereWithoutAdminActionPlanInput = {
    where?: AdminHazardTypeWhereInput
    data: XOR<AdminHazardTypeUpdateWithoutAdminActionPlanInput, AdminHazardTypeUncheckedUpdateWithoutAdminActionPlanInput>
  }

  export type AdminHazardTypeUpdateWithoutAdminActionPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    hazardId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultFrequency?: StringFieldUpdateOperationsInput | string
    defaultImpact?: StringFieldUpdateOperationsInput | string
    seasonalPattern?: NullableStringFieldUpdateOperationsInput | string | null
    peakMonths?: NullableStringFieldUpdateOperationsInput | string | null
    warningTime?: NullableStringFieldUpdateOperationsInput | string | null
    geographicScope?: NullableStringFieldUpdateOperationsInput | string | null
    cascadingRisks?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessTypeHazards?: AdminBusinessTypeHazardUpdateManyWithoutHazardNestedInput
    locationHazards?: AdminLocationHazardUpdateManyWithoutHazardNestedInput
    hazardStrategies?: AdminHazardStrategyUpdateManyWithoutHazardNestedInput
    hazardActionPlans?: AdminHazardActionPlanUpdateManyWithoutHazardNestedInput
    translations?: HazardTranslationUpdateManyWithoutHazardNestedInput
  }

  export type AdminHazardTypeUncheckedUpdateWithoutAdminActionPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    hazardId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultFrequency?: StringFieldUpdateOperationsInput | string
    defaultImpact?: StringFieldUpdateOperationsInput | string
    seasonalPattern?: NullableStringFieldUpdateOperationsInput | string | null
    peakMonths?: NullableStringFieldUpdateOperationsInput | string | null
    warningTime?: NullableStringFieldUpdateOperationsInput | string | null
    geographicScope?: NullableStringFieldUpdateOperationsInput | string | null
    cascadingRisks?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessTypeHazards?: AdminBusinessTypeHazardUncheckedUpdateManyWithoutHazardNestedInput
    locationHazards?: AdminLocationHazardUncheckedUpdateManyWithoutHazardNestedInput
    hazardStrategies?: AdminHazardStrategyUncheckedUpdateManyWithoutHazardNestedInput
    hazardActionPlans?: AdminHazardActionPlanUncheckedUpdateManyWithoutHazardNestedInput
    translations?: HazardTranslationUncheckedUpdateManyWithoutHazardNestedInput
  }

  export type AdminHazardActionPlanUpsertWithWhereUniqueWithoutActionPlanInput = {
    where: AdminHazardActionPlanWhereUniqueInput
    update: XOR<AdminHazardActionPlanUpdateWithoutActionPlanInput, AdminHazardActionPlanUncheckedUpdateWithoutActionPlanInput>
    create: XOR<AdminHazardActionPlanCreateWithoutActionPlanInput, AdminHazardActionPlanUncheckedCreateWithoutActionPlanInput>
  }

  export type AdminHazardActionPlanUpdateWithWhereUniqueWithoutActionPlanInput = {
    where: AdminHazardActionPlanWhereUniqueInput
    data: XOR<AdminHazardActionPlanUpdateWithoutActionPlanInput, AdminHazardActionPlanUncheckedUpdateWithoutActionPlanInput>
  }

  export type AdminHazardActionPlanUpdateManyWithWhereWithoutActionPlanInput = {
    where: AdminHazardActionPlanScalarWhereInput
    data: XOR<AdminHazardActionPlanUpdateManyMutationInput, AdminHazardActionPlanUncheckedUpdateManyWithoutActionPlanInput>
  }

  export type AdminHazardTypeCreateWithoutHazardActionPlansInput = {
    id?: string
    hazardId: string
    name: string
    category: string
    description?: string | null
    defaultFrequency: string
    defaultImpact: string
    seasonalPattern?: string | null
    peakMonths?: string | null
    warningTime?: string | null
    geographicScope?: string | null
    cascadingRisks?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    businessTypeHazards?: AdminBusinessTypeHazardCreateNestedManyWithoutHazardInput
    locationHazards?: AdminLocationHazardCreateNestedManyWithoutHazardInput
    hazardStrategies?: AdminHazardStrategyCreateNestedManyWithoutHazardInput
    AdminActionPlan?: AdminActionPlanCreateNestedOneWithoutHazardInput
    translations?: HazardTranslationCreateNestedManyWithoutHazardInput
  }

  export type AdminHazardTypeUncheckedCreateWithoutHazardActionPlansInput = {
    id?: string
    hazardId: string
    name: string
    category: string
    description?: string | null
    defaultFrequency: string
    defaultImpact: string
    seasonalPattern?: string | null
    peakMonths?: string | null
    warningTime?: string | null
    geographicScope?: string | null
    cascadingRisks?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    businessTypeHazards?: AdminBusinessTypeHazardUncheckedCreateNestedManyWithoutHazardInput
    locationHazards?: AdminLocationHazardUncheckedCreateNestedManyWithoutHazardInput
    hazardStrategies?: AdminHazardStrategyUncheckedCreateNestedManyWithoutHazardInput
    AdminActionPlan?: AdminActionPlanUncheckedCreateNestedOneWithoutHazardInput
    translations?: HazardTranslationUncheckedCreateNestedManyWithoutHazardInput
  }

  export type AdminHazardTypeCreateOrConnectWithoutHazardActionPlansInput = {
    where: AdminHazardTypeWhereUniqueInput
    create: XOR<AdminHazardTypeCreateWithoutHazardActionPlansInput, AdminHazardTypeUncheckedCreateWithoutHazardActionPlansInput>
  }

  export type AdminActionPlanCreateWithoutAdminHazardActionPlanInput = {
    id?: string
    resourcesNeeded: string
    immediateActions: string
    shortTermActions: string
    mediumTermActions: string
    longTermReduction: string
    businessTypeModifiers?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    hazard: AdminHazardTypeCreateNestedOneWithoutAdminActionPlanInput
  }

  export type AdminActionPlanUncheckedCreateWithoutAdminHazardActionPlanInput = {
    id?: string
    hazardId: string
    resourcesNeeded: string
    immediateActions: string
    shortTermActions: string
    mediumTermActions: string
    longTermReduction: string
    businessTypeModifiers?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminActionPlanCreateOrConnectWithoutAdminHazardActionPlanInput = {
    where: AdminActionPlanWhereUniqueInput
    create: XOR<AdminActionPlanCreateWithoutAdminHazardActionPlanInput, AdminActionPlanUncheckedCreateWithoutAdminHazardActionPlanInput>
  }

  export type AdminHazardTypeUpsertWithoutHazardActionPlansInput = {
    update: XOR<AdminHazardTypeUpdateWithoutHazardActionPlansInput, AdminHazardTypeUncheckedUpdateWithoutHazardActionPlansInput>
    create: XOR<AdminHazardTypeCreateWithoutHazardActionPlansInput, AdminHazardTypeUncheckedCreateWithoutHazardActionPlansInput>
    where?: AdminHazardTypeWhereInput
  }

  export type AdminHazardTypeUpdateToOneWithWhereWithoutHazardActionPlansInput = {
    where?: AdminHazardTypeWhereInput
    data: XOR<AdminHazardTypeUpdateWithoutHazardActionPlansInput, AdminHazardTypeUncheckedUpdateWithoutHazardActionPlansInput>
  }

  export type AdminHazardTypeUpdateWithoutHazardActionPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    hazardId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultFrequency?: StringFieldUpdateOperationsInput | string
    defaultImpact?: StringFieldUpdateOperationsInput | string
    seasonalPattern?: NullableStringFieldUpdateOperationsInput | string | null
    peakMonths?: NullableStringFieldUpdateOperationsInput | string | null
    warningTime?: NullableStringFieldUpdateOperationsInput | string | null
    geographicScope?: NullableStringFieldUpdateOperationsInput | string | null
    cascadingRisks?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessTypeHazards?: AdminBusinessTypeHazardUpdateManyWithoutHazardNestedInput
    locationHazards?: AdminLocationHazardUpdateManyWithoutHazardNestedInput
    hazardStrategies?: AdminHazardStrategyUpdateManyWithoutHazardNestedInput
    AdminActionPlan?: AdminActionPlanUpdateOneWithoutHazardNestedInput
    translations?: HazardTranslationUpdateManyWithoutHazardNestedInput
  }

  export type AdminHazardTypeUncheckedUpdateWithoutHazardActionPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    hazardId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultFrequency?: StringFieldUpdateOperationsInput | string
    defaultImpact?: StringFieldUpdateOperationsInput | string
    seasonalPattern?: NullableStringFieldUpdateOperationsInput | string | null
    peakMonths?: NullableStringFieldUpdateOperationsInput | string | null
    warningTime?: NullableStringFieldUpdateOperationsInput | string | null
    geographicScope?: NullableStringFieldUpdateOperationsInput | string | null
    cascadingRisks?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessTypeHazards?: AdminBusinessTypeHazardUncheckedUpdateManyWithoutHazardNestedInput
    locationHazards?: AdminLocationHazardUncheckedUpdateManyWithoutHazardNestedInput
    hazardStrategies?: AdminHazardStrategyUncheckedUpdateManyWithoutHazardNestedInput
    AdminActionPlan?: AdminActionPlanUncheckedUpdateOneWithoutHazardNestedInput
    translations?: HazardTranslationUncheckedUpdateManyWithoutHazardNestedInput
  }

  export type AdminActionPlanUpsertWithoutAdminHazardActionPlanInput = {
    update: XOR<AdminActionPlanUpdateWithoutAdminHazardActionPlanInput, AdminActionPlanUncheckedUpdateWithoutAdminHazardActionPlanInput>
    create: XOR<AdminActionPlanCreateWithoutAdminHazardActionPlanInput, AdminActionPlanUncheckedCreateWithoutAdminHazardActionPlanInput>
    where?: AdminActionPlanWhereInput
  }

  export type AdminActionPlanUpdateToOneWithWhereWithoutAdminHazardActionPlanInput = {
    where?: AdminActionPlanWhereInput
    data: XOR<AdminActionPlanUpdateWithoutAdminHazardActionPlanInput, AdminActionPlanUncheckedUpdateWithoutAdminHazardActionPlanInput>
  }

  export type AdminActionPlanUpdateWithoutAdminHazardActionPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    resourcesNeeded?: StringFieldUpdateOperationsInput | string
    immediateActions?: StringFieldUpdateOperationsInput | string
    shortTermActions?: StringFieldUpdateOperationsInput | string
    mediumTermActions?: StringFieldUpdateOperationsInput | string
    longTermReduction?: StringFieldUpdateOperationsInput | string
    businessTypeModifiers?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hazard?: AdminHazardTypeUpdateOneRequiredWithoutAdminActionPlanNestedInput
  }

  export type AdminActionPlanUncheckedUpdateWithoutAdminHazardActionPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    hazardId?: StringFieldUpdateOperationsInput | string
    resourcesNeeded?: StringFieldUpdateOperationsInput | string
    immediateActions?: StringFieldUpdateOperationsInput | string
    shortTermActions?: StringFieldUpdateOperationsInput | string
    mediumTermActions?: StringFieldUpdateOperationsInput | string
    longTermReduction?: StringFieldUpdateOperationsInput | string
    businessTypeModifiers?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminBusinessTypeCreateWithoutRiskProfilesInput = {
    id?: string
    businessTypeId: string
    name: string
    localName: string
    category: string
    description?: string | null
    typicalOperatingHours?: string | null
    minimumStaff?: string | null
    minimumEquipment?: string | null
    minimumUtilities?: string | null
    minimumSpace?: string | null
    essentialFunctions?: string | null
    criticalSuppliers?: string | null
    exampleBusinessPurposes?: string | null
    exampleProducts?: string | null
    exampleKeyPersonnel?: string | null
    exampleCustomerBase?: string | null
    dependencies?: string | null
    vulnerabilityMatrix?: string | null
    operationalThresholds?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    businessTypeHazards?: AdminBusinessTypeHazardCreateNestedManyWithoutBusinessTypeInput
  }

  export type AdminBusinessTypeUncheckedCreateWithoutRiskProfilesInput = {
    id?: string
    businessTypeId: string
    name: string
    localName: string
    category: string
    description?: string | null
    typicalOperatingHours?: string | null
    minimumStaff?: string | null
    minimumEquipment?: string | null
    minimumUtilities?: string | null
    minimumSpace?: string | null
    essentialFunctions?: string | null
    criticalSuppliers?: string | null
    exampleBusinessPurposes?: string | null
    exampleProducts?: string | null
    exampleKeyPersonnel?: string | null
    exampleCustomerBase?: string | null
    dependencies?: string | null
    vulnerabilityMatrix?: string | null
    operationalThresholds?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    businessTypeHazards?: AdminBusinessTypeHazardUncheckedCreateNestedManyWithoutBusinessTypeInput
  }

  export type AdminBusinessTypeCreateOrConnectWithoutRiskProfilesInput = {
    where: AdminBusinessTypeWhereUniqueInput
    create: XOR<AdminBusinessTypeCreateWithoutRiskProfilesInput, AdminBusinessTypeUncheckedCreateWithoutRiskProfilesInput>
  }

  export type AdminLocationCreateWithoutRiskProfilesInput = {
    id?: string
    country: string
    countryCode: string
    parish?: string | null
    isCoastal?: boolean
    isUrban?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    locationHazards?: AdminLocationHazardCreateNestedManyWithoutLocationInput
  }

  export type AdminLocationUncheckedCreateWithoutRiskProfilesInput = {
    id?: string
    country: string
    countryCode: string
    parish?: string | null
    isCoastal?: boolean
    isUrban?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    locationHazards?: AdminLocationHazardUncheckedCreateNestedManyWithoutLocationInput
  }

  export type AdminLocationCreateOrConnectWithoutRiskProfilesInput = {
    where: AdminLocationWhereUniqueInput
    create: XOR<AdminLocationCreateWithoutRiskProfilesInput, AdminLocationUncheckedCreateWithoutRiskProfilesInput>
  }

  export type AdminBusinessTypeUpsertWithoutRiskProfilesInput = {
    update: XOR<AdminBusinessTypeUpdateWithoutRiskProfilesInput, AdminBusinessTypeUncheckedUpdateWithoutRiskProfilesInput>
    create: XOR<AdminBusinessTypeCreateWithoutRiskProfilesInput, AdminBusinessTypeUncheckedCreateWithoutRiskProfilesInput>
    where?: AdminBusinessTypeWhereInput
  }

  export type AdminBusinessTypeUpdateToOneWithWhereWithoutRiskProfilesInput = {
    where?: AdminBusinessTypeWhereInput
    data: XOR<AdminBusinessTypeUpdateWithoutRiskProfilesInput, AdminBusinessTypeUncheckedUpdateWithoutRiskProfilesInput>
  }

  export type AdminBusinessTypeUpdateWithoutRiskProfilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessTypeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    localName?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    typicalOperatingHours?: NullableStringFieldUpdateOperationsInput | string | null
    minimumStaff?: NullableStringFieldUpdateOperationsInput | string | null
    minimumEquipment?: NullableStringFieldUpdateOperationsInput | string | null
    minimumUtilities?: NullableStringFieldUpdateOperationsInput | string | null
    minimumSpace?: NullableStringFieldUpdateOperationsInput | string | null
    essentialFunctions?: NullableStringFieldUpdateOperationsInput | string | null
    criticalSuppliers?: NullableStringFieldUpdateOperationsInput | string | null
    exampleBusinessPurposes?: NullableStringFieldUpdateOperationsInput | string | null
    exampleProducts?: NullableStringFieldUpdateOperationsInput | string | null
    exampleKeyPersonnel?: NullableStringFieldUpdateOperationsInput | string | null
    exampleCustomerBase?: NullableStringFieldUpdateOperationsInput | string | null
    dependencies?: NullableStringFieldUpdateOperationsInput | string | null
    vulnerabilityMatrix?: NullableStringFieldUpdateOperationsInput | string | null
    operationalThresholds?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessTypeHazards?: AdminBusinessTypeHazardUpdateManyWithoutBusinessTypeNestedInput
  }

  export type AdminBusinessTypeUncheckedUpdateWithoutRiskProfilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessTypeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    localName?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    typicalOperatingHours?: NullableStringFieldUpdateOperationsInput | string | null
    minimumStaff?: NullableStringFieldUpdateOperationsInput | string | null
    minimumEquipment?: NullableStringFieldUpdateOperationsInput | string | null
    minimumUtilities?: NullableStringFieldUpdateOperationsInput | string | null
    minimumSpace?: NullableStringFieldUpdateOperationsInput | string | null
    essentialFunctions?: NullableStringFieldUpdateOperationsInput | string | null
    criticalSuppliers?: NullableStringFieldUpdateOperationsInput | string | null
    exampleBusinessPurposes?: NullableStringFieldUpdateOperationsInput | string | null
    exampleProducts?: NullableStringFieldUpdateOperationsInput | string | null
    exampleKeyPersonnel?: NullableStringFieldUpdateOperationsInput | string | null
    exampleCustomerBase?: NullableStringFieldUpdateOperationsInput | string | null
    dependencies?: NullableStringFieldUpdateOperationsInput | string | null
    vulnerabilityMatrix?: NullableStringFieldUpdateOperationsInput | string | null
    operationalThresholds?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessTypeHazards?: AdminBusinessTypeHazardUncheckedUpdateManyWithoutBusinessTypeNestedInput
  }

  export type AdminLocationUpsertWithoutRiskProfilesInput = {
    update: XOR<AdminLocationUpdateWithoutRiskProfilesInput, AdminLocationUncheckedUpdateWithoutRiskProfilesInput>
    create: XOR<AdminLocationCreateWithoutRiskProfilesInput, AdminLocationUncheckedCreateWithoutRiskProfilesInput>
    where?: AdminLocationWhereInput
  }

  export type AdminLocationUpdateToOneWithWhereWithoutRiskProfilesInput = {
    where?: AdminLocationWhereInput
    data: XOR<AdminLocationUpdateWithoutRiskProfilesInput, AdminLocationUncheckedUpdateWithoutRiskProfilesInput>
  }

  export type AdminLocationUpdateWithoutRiskProfilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    parish?: NullableStringFieldUpdateOperationsInput | string | null
    isCoastal?: BoolFieldUpdateOperationsInput | boolean
    isUrban?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationHazards?: AdminLocationHazardUpdateManyWithoutLocationNestedInput
  }

  export type AdminLocationUncheckedUpdateWithoutRiskProfilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    parish?: NullableStringFieldUpdateOperationsInput | string | null
    isCoastal?: BoolFieldUpdateOperationsInput | boolean
    isUrban?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationHazards?: AdminLocationHazardUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type AdminUnitCreateWithoutCountryInput = {
    id?: string
    name: string
    localName?: string | null
    type?: string
    region?: string | null
    population?: number
    area?: number | null
    elevation?: number | null
    coordinates?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    adminUnitRisk?: AdminUnitRiskCreateNestedOneWithoutAdminUnitInput
  }

  export type AdminUnitUncheckedCreateWithoutCountryInput = {
    id?: string
    name: string
    localName?: string | null
    type?: string
    region?: string | null
    population?: number
    area?: number | null
    elevation?: number | null
    coordinates?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    adminUnitRisk?: AdminUnitRiskUncheckedCreateNestedOneWithoutAdminUnitInput
  }

  export type AdminUnitCreateOrConnectWithoutCountryInput = {
    where: AdminUnitWhereUniqueInput
    create: XOR<AdminUnitCreateWithoutCountryInput, AdminUnitUncheckedCreateWithoutCountryInput>
  }

  export type AdminUnitCreateManyCountryInputEnvelope = {
    data: AdminUnitCreateManyCountryInput | AdminUnitCreateManyCountryInput[]
    skipDuplicates?: boolean
  }

  export type AdminUnitUpsertWithWhereUniqueWithoutCountryInput = {
    where: AdminUnitWhereUniqueInput
    update: XOR<AdminUnitUpdateWithoutCountryInput, AdminUnitUncheckedUpdateWithoutCountryInput>
    create: XOR<AdminUnitCreateWithoutCountryInput, AdminUnitUncheckedCreateWithoutCountryInput>
  }

  export type AdminUnitUpdateWithWhereUniqueWithoutCountryInput = {
    where: AdminUnitWhereUniqueInput
    data: XOR<AdminUnitUpdateWithoutCountryInput, AdminUnitUncheckedUpdateWithoutCountryInput>
  }

  export type AdminUnitUpdateManyWithWhereWithoutCountryInput = {
    where: AdminUnitScalarWhereInput
    data: XOR<AdminUnitUpdateManyMutationInput, AdminUnitUncheckedUpdateManyWithoutCountryInput>
  }

  export type AdminUnitScalarWhereInput = {
    AND?: AdminUnitScalarWhereInput | AdminUnitScalarWhereInput[]
    OR?: AdminUnitScalarWhereInput[]
    NOT?: AdminUnitScalarWhereInput | AdminUnitScalarWhereInput[]
    id?: StringFilter<"AdminUnit"> | string
    name?: StringFilter<"AdminUnit"> | string
    localName?: StringNullableFilter<"AdminUnit"> | string | null
    type?: StringFilter<"AdminUnit"> | string
    region?: StringNullableFilter<"AdminUnit"> | string | null
    countryId?: StringFilter<"AdminUnit"> | string
    population?: IntFilter<"AdminUnit"> | number
    area?: FloatNullableFilter<"AdminUnit"> | number | null
    elevation?: FloatNullableFilter<"AdminUnit"> | number | null
    coordinates?: StringNullableFilter<"AdminUnit"> | string | null
    createdAt?: DateTimeFilter<"AdminUnit"> | Date | string
    updatedAt?: DateTimeFilter<"AdminUnit"> | Date | string
    isActive?: BoolFilter<"AdminUnit"> | boolean
  }

  export type CountryCreateWithoutAdminUnitsInput = {
    id?: string
    name: string
    code: string
    region?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CountryUncheckedCreateWithoutAdminUnitsInput = {
    id?: string
    name: string
    code: string
    region?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CountryCreateOrConnectWithoutAdminUnitsInput = {
    where: CountryWhereUniqueInput
    create: XOR<CountryCreateWithoutAdminUnitsInput, CountryUncheckedCreateWithoutAdminUnitsInput>
  }

  export type AdminUnitRiskCreateWithoutAdminUnitInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUpdated?: Date | string
    updatedBy?: string
    hurricaneLevel?: number
    hurricaneNotes?: string
    floodLevel?: number
    floodNotes?: string
    earthquakeLevel?: number
    earthquakeNotes?: string
    droughtLevel?: number
    droughtNotes?: string
    landslideLevel?: number
    landslideNotes?: string
    powerOutageLevel?: number
    powerOutageNotes?: string
    riskProfileJson?: string
    isActive?: boolean
    changeLogs?: AdminUnitRiskChangeLogCreateNestedManyWithoutAdminUnitRiskInput
  }

  export type AdminUnitRiskUncheckedCreateWithoutAdminUnitInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUpdated?: Date | string
    updatedBy?: string
    hurricaneLevel?: number
    hurricaneNotes?: string
    floodLevel?: number
    floodNotes?: string
    earthquakeLevel?: number
    earthquakeNotes?: string
    droughtLevel?: number
    droughtNotes?: string
    landslideLevel?: number
    landslideNotes?: string
    powerOutageLevel?: number
    powerOutageNotes?: string
    riskProfileJson?: string
    isActive?: boolean
    changeLogs?: AdminUnitRiskChangeLogUncheckedCreateNestedManyWithoutAdminUnitRiskInput
  }

  export type AdminUnitRiskCreateOrConnectWithoutAdminUnitInput = {
    where: AdminUnitRiskWhereUniqueInput
    create: XOR<AdminUnitRiskCreateWithoutAdminUnitInput, AdminUnitRiskUncheckedCreateWithoutAdminUnitInput>
  }

  export type CountryUpsertWithoutAdminUnitsInput = {
    update: XOR<CountryUpdateWithoutAdminUnitsInput, CountryUncheckedUpdateWithoutAdminUnitsInput>
    create: XOR<CountryCreateWithoutAdminUnitsInput, CountryUncheckedCreateWithoutAdminUnitsInput>
    where?: CountryWhereInput
  }

  export type CountryUpdateToOneWithWhereWithoutAdminUnitsInput = {
    where?: CountryWhereInput
    data: XOR<CountryUpdateWithoutAdminUnitsInput, CountryUncheckedUpdateWithoutAdminUnitsInput>
  }

  export type CountryUpdateWithoutAdminUnitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CountryUncheckedUpdateWithoutAdminUnitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUnitRiskUpsertWithoutAdminUnitInput = {
    update: XOR<AdminUnitRiskUpdateWithoutAdminUnitInput, AdminUnitRiskUncheckedUpdateWithoutAdminUnitInput>
    create: XOR<AdminUnitRiskCreateWithoutAdminUnitInput, AdminUnitRiskUncheckedCreateWithoutAdminUnitInput>
    where?: AdminUnitRiskWhereInput
  }

  export type AdminUnitRiskUpdateToOneWithWhereWithoutAdminUnitInput = {
    where?: AdminUnitRiskWhereInput
    data: XOR<AdminUnitRiskUpdateWithoutAdminUnitInput, AdminUnitRiskUncheckedUpdateWithoutAdminUnitInput>
  }

  export type AdminUnitRiskUpdateWithoutAdminUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    hurricaneLevel?: IntFieldUpdateOperationsInput | number
    hurricaneNotes?: StringFieldUpdateOperationsInput | string
    floodLevel?: IntFieldUpdateOperationsInput | number
    floodNotes?: StringFieldUpdateOperationsInput | string
    earthquakeLevel?: IntFieldUpdateOperationsInput | number
    earthquakeNotes?: StringFieldUpdateOperationsInput | string
    droughtLevel?: IntFieldUpdateOperationsInput | number
    droughtNotes?: StringFieldUpdateOperationsInput | string
    landslideLevel?: IntFieldUpdateOperationsInput | number
    landslideNotes?: StringFieldUpdateOperationsInput | string
    powerOutageLevel?: IntFieldUpdateOperationsInput | number
    powerOutageNotes?: StringFieldUpdateOperationsInput | string
    riskProfileJson?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    changeLogs?: AdminUnitRiskChangeLogUpdateManyWithoutAdminUnitRiskNestedInput
  }

  export type AdminUnitRiskUncheckedUpdateWithoutAdminUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    hurricaneLevel?: IntFieldUpdateOperationsInput | number
    hurricaneNotes?: StringFieldUpdateOperationsInput | string
    floodLevel?: IntFieldUpdateOperationsInput | number
    floodNotes?: StringFieldUpdateOperationsInput | string
    earthquakeLevel?: IntFieldUpdateOperationsInput | number
    earthquakeNotes?: StringFieldUpdateOperationsInput | string
    droughtLevel?: IntFieldUpdateOperationsInput | number
    droughtNotes?: StringFieldUpdateOperationsInput | string
    landslideLevel?: IntFieldUpdateOperationsInput | number
    landslideNotes?: StringFieldUpdateOperationsInput | string
    powerOutageLevel?: IntFieldUpdateOperationsInput | number
    powerOutageNotes?: StringFieldUpdateOperationsInput | string
    riskProfileJson?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    changeLogs?: AdminUnitRiskChangeLogUncheckedUpdateManyWithoutAdminUnitRiskNestedInput
  }

  export type ParishRiskCreateWithoutParishInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUpdated?: Date | string
    updatedBy?: string
    hurricaneLevel?: number
    hurricaneNotes?: string
    floodLevel?: number
    floodNotes?: string
    earthquakeLevel?: number
    earthquakeNotes?: string
    droughtLevel?: number
    droughtNotes?: string
    landslideLevel?: number
    landslideNotes?: string
    powerOutageLevel?: number
    powerOutageNotes?: string
    riskProfileJson?: string
    isActive?: boolean
    changeLogs?: RiskChangeLogCreateNestedManyWithoutParishRiskInput
  }

  export type ParishRiskUncheckedCreateWithoutParishInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUpdated?: Date | string
    updatedBy?: string
    hurricaneLevel?: number
    hurricaneNotes?: string
    floodLevel?: number
    floodNotes?: string
    earthquakeLevel?: number
    earthquakeNotes?: string
    droughtLevel?: number
    droughtNotes?: string
    landslideLevel?: number
    landslideNotes?: string
    powerOutageLevel?: number
    powerOutageNotes?: string
    riskProfileJson?: string
    isActive?: boolean
    changeLogs?: RiskChangeLogUncheckedCreateNestedManyWithoutParishRiskInput
  }

  export type ParishRiskCreateOrConnectWithoutParishInput = {
    where: ParishRiskWhereUniqueInput
    create: XOR<ParishRiskCreateWithoutParishInput, ParishRiskUncheckedCreateWithoutParishInput>
  }

  export type BusinessRiskProfileCreateWithoutParishInput = {
    id?: string
    combinedRisks: string
    recommendedStrategies: string
    overallRiskScore: number
    priorityActions?: string | null
    calculatedAt?: Date | string
    calculatedBy?: string | null
    isActive?: boolean
    businessType: BusinessTypeCreateNestedOneWithoutBusinessRiskProfilesInput
  }

  export type BusinessRiskProfileUncheckedCreateWithoutParishInput = {
    id?: string
    businessTypeId: string
    combinedRisks: string
    recommendedStrategies: string
    overallRiskScore: number
    priorityActions?: string | null
    calculatedAt?: Date | string
    calculatedBy?: string | null
    isActive?: boolean
  }

  export type BusinessRiskProfileCreateOrConnectWithoutParishInput = {
    where: BusinessRiskProfileWhereUniqueInput
    create: XOR<BusinessRiskProfileCreateWithoutParishInput, BusinessRiskProfileUncheckedCreateWithoutParishInput>
  }

  export type BusinessRiskProfileCreateManyParishInputEnvelope = {
    data: BusinessRiskProfileCreateManyParishInput | BusinessRiskProfileCreateManyParishInput[]
    skipDuplicates?: boolean
  }

  export type ParishRiskUpsertWithoutParishInput = {
    update: XOR<ParishRiskUpdateWithoutParishInput, ParishRiskUncheckedUpdateWithoutParishInput>
    create: XOR<ParishRiskCreateWithoutParishInput, ParishRiskUncheckedCreateWithoutParishInput>
    where?: ParishRiskWhereInput
  }

  export type ParishRiskUpdateToOneWithWhereWithoutParishInput = {
    where?: ParishRiskWhereInput
    data: XOR<ParishRiskUpdateWithoutParishInput, ParishRiskUncheckedUpdateWithoutParishInput>
  }

  export type ParishRiskUpdateWithoutParishInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    hurricaneLevel?: IntFieldUpdateOperationsInput | number
    hurricaneNotes?: StringFieldUpdateOperationsInput | string
    floodLevel?: IntFieldUpdateOperationsInput | number
    floodNotes?: StringFieldUpdateOperationsInput | string
    earthquakeLevel?: IntFieldUpdateOperationsInput | number
    earthquakeNotes?: StringFieldUpdateOperationsInput | string
    droughtLevel?: IntFieldUpdateOperationsInput | number
    droughtNotes?: StringFieldUpdateOperationsInput | string
    landslideLevel?: IntFieldUpdateOperationsInput | number
    landslideNotes?: StringFieldUpdateOperationsInput | string
    powerOutageLevel?: IntFieldUpdateOperationsInput | number
    powerOutageNotes?: StringFieldUpdateOperationsInput | string
    riskProfileJson?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    changeLogs?: RiskChangeLogUpdateManyWithoutParishRiskNestedInput
  }

  export type ParishRiskUncheckedUpdateWithoutParishInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    hurricaneLevel?: IntFieldUpdateOperationsInput | number
    hurricaneNotes?: StringFieldUpdateOperationsInput | string
    floodLevel?: IntFieldUpdateOperationsInput | number
    floodNotes?: StringFieldUpdateOperationsInput | string
    earthquakeLevel?: IntFieldUpdateOperationsInput | number
    earthquakeNotes?: StringFieldUpdateOperationsInput | string
    droughtLevel?: IntFieldUpdateOperationsInput | number
    droughtNotes?: StringFieldUpdateOperationsInput | string
    landslideLevel?: IntFieldUpdateOperationsInput | number
    landslideNotes?: StringFieldUpdateOperationsInput | string
    powerOutageLevel?: IntFieldUpdateOperationsInput | number
    powerOutageNotes?: StringFieldUpdateOperationsInput | string
    riskProfileJson?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    changeLogs?: RiskChangeLogUncheckedUpdateManyWithoutParishRiskNestedInput
  }

  export type BusinessRiskProfileUpsertWithWhereUniqueWithoutParishInput = {
    where: BusinessRiskProfileWhereUniqueInput
    update: XOR<BusinessRiskProfileUpdateWithoutParishInput, BusinessRiskProfileUncheckedUpdateWithoutParishInput>
    create: XOR<BusinessRiskProfileCreateWithoutParishInput, BusinessRiskProfileUncheckedCreateWithoutParishInput>
  }

  export type BusinessRiskProfileUpdateWithWhereUniqueWithoutParishInput = {
    where: BusinessRiskProfileWhereUniqueInput
    data: XOR<BusinessRiskProfileUpdateWithoutParishInput, BusinessRiskProfileUncheckedUpdateWithoutParishInput>
  }

  export type BusinessRiskProfileUpdateManyWithWhereWithoutParishInput = {
    where: BusinessRiskProfileScalarWhereInput
    data: XOR<BusinessRiskProfileUpdateManyMutationInput, BusinessRiskProfileUncheckedUpdateManyWithoutParishInput>
  }

  export type BusinessRiskProfileScalarWhereInput = {
    AND?: BusinessRiskProfileScalarWhereInput | BusinessRiskProfileScalarWhereInput[]
    OR?: BusinessRiskProfileScalarWhereInput[]
    NOT?: BusinessRiskProfileScalarWhereInput | BusinessRiskProfileScalarWhereInput[]
    id?: StringFilter<"BusinessRiskProfile"> | string
    businessTypeId?: StringFilter<"BusinessRiskProfile"> | string
    parishId?: StringFilter<"BusinessRiskProfile"> | string
    combinedRisks?: StringFilter<"BusinessRiskProfile"> | string
    recommendedStrategies?: StringFilter<"BusinessRiskProfile"> | string
    overallRiskScore?: IntFilter<"BusinessRiskProfile"> | number
    priorityActions?: StringNullableFilter<"BusinessRiskProfile"> | string | null
    calculatedAt?: DateTimeFilter<"BusinessRiskProfile"> | Date | string
    calculatedBy?: StringNullableFilter<"BusinessRiskProfile"> | string | null
    isActive?: BoolFilter<"BusinessRiskProfile"> | boolean
  }

  export type AdminUnitCreateWithoutAdminUnitRiskInput = {
    id?: string
    name: string
    localName?: string | null
    type?: string
    region?: string | null
    population?: number
    area?: number | null
    elevation?: number | null
    coordinates?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    country: CountryCreateNestedOneWithoutAdminUnitsInput
  }

  export type AdminUnitUncheckedCreateWithoutAdminUnitRiskInput = {
    id?: string
    name: string
    localName?: string | null
    type?: string
    region?: string | null
    countryId: string
    population?: number
    area?: number | null
    elevation?: number | null
    coordinates?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
  }

  export type AdminUnitCreateOrConnectWithoutAdminUnitRiskInput = {
    where: AdminUnitWhereUniqueInput
    create: XOR<AdminUnitCreateWithoutAdminUnitRiskInput, AdminUnitUncheckedCreateWithoutAdminUnitRiskInput>
  }

  export type AdminUnitRiskChangeLogCreateWithoutAdminUnitRiskInput = {
    id?: string
    riskType: string
    oldLevel: number
    newLevel: number
    oldNotes?: string
    newNotes?: string
    changedBy: string
    changeReason?: string | null
    createdAt?: Date | string
  }

  export type AdminUnitRiskChangeLogUncheckedCreateWithoutAdminUnitRiskInput = {
    id?: string
    riskType: string
    oldLevel: number
    newLevel: number
    oldNotes?: string
    newNotes?: string
    changedBy: string
    changeReason?: string | null
    createdAt?: Date | string
  }

  export type AdminUnitRiskChangeLogCreateOrConnectWithoutAdminUnitRiskInput = {
    where: AdminUnitRiskChangeLogWhereUniqueInput
    create: XOR<AdminUnitRiskChangeLogCreateWithoutAdminUnitRiskInput, AdminUnitRiskChangeLogUncheckedCreateWithoutAdminUnitRiskInput>
  }

  export type AdminUnitRiskChangeLogCreateManyAdminUnitRiskInputEnvelope = {
    data: AdminUnitRiskChangeLogCreateManyAdminUnitRiskInput | AdminUnitRiskChangeLogCreateManyAdminUnitRiskInput[]
    skipDuplicates?: boolean
  }

  export type AdminUnitUpsertWithoutAdminUnitRiskInput = {
    update: XOR<AdminUnitUpdateWithoutAdminUnitRiskInput, AdminUnitUncheckedUpdateWithoutAdminUnitRiskInput>
    create: XOR<AdminUnitCreateWithoutAdminUnitRiskInput, AdminUnitUncheckedCreateWithoutAdminUnitRiskInput>
    where?: AdminUnitWhereInput
  }

  export type AdminUnitUpdateToOneWithWhereWithoutAdminUnitRiskInput = {
    where?: AdminUnitWhereInput
    data: XOR<AdminUnitUpdateWithoutAdminUnitRiskInput, AdminUnitUncheckedUpdateWithoutAdminUnitRiskInput>
  }

  export type AdminUnitUpdateWithoutAdminUnitRiskInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    localName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    population?: IntFieldUpdateOperationsInput | number
    area?: NullableFloatFieldUpdateOperationsInput | number | null
    elevation?: NullableFloatFieldUpdateOperationsInput | number | null
    coordinates?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    country?: CountryUpdateOneRequiredWithoutAdminUnitsNestedInput
  }

  export type AdminUnitUncheckedUpdateWithoutAdminUnitRiskInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    localName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    countryId?: StringFieldUpdateOperationsInput | string
    population?: IntFieldUpdateOperationsInput | number
    area?: NullableFloatFieldUpdateOperationsInput | number | null
    elevation?: NullableFloatFieldUpdateOperationsInput | number | null
    coordinates?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AdminUnitRiskChangeLogUpsertWithWhereUniqueWithoutAdminUnitRiskInput = {
    where: AdminUnitRiskChangeLogWhereUniqueInput
    update: XOR<AdminUnitRiskChangeLogUpdateWithoutAdminUnitRiskInput, AdminUnitRiskChangeLogUncheckedUpdateWithoutAdminUnitRiskInput>
    create: XOR<AdminUnitRiskChangeLogCreateWithoutAdminUnitRiskInput, AdminUnitRiskChangeLogUncheckedCreateWithoutAdminUnitRiskInput>
  }

  export type AdminUnitRiskChangeLogUpdateWithWhereUniqueWithoutAdminUnitRiskInput = {
    where: AdminUnitRiskChangeLogWhereUniqueInput
    data: XOR<AdminUnitRiskChangeLogUpdateWithoutAdminUnitRiskInput, AdminUnitRiskChangeLogUncheckedUpdateWithoutAdminUnitRiskInput>
  }

  export type AdminUnitRiskChangeLogUpdateManyWithWhereWithoutAdminUnitRiskInput = {
    where: AdminUnitRiskChangeLogScalarWhereInput
    data: XOR<AdminUnitRiskChangeLogUpdateManyMutationInput, AdminUnitRiskChangeLogUncheckedUpdateManyWithoutAdminUnitRiskInput>
  }

  export type AdminUnitRiskChangeLogScalarWhereInput = {
    AND?: AdminUnitRiskChangeLogScalarWhereInput | AdminUnitRiskChangeLogScalarWhereInput[]
    OR?: AdminUnitRiskChangeLogScalarWhereInput[]
    NOT?: AdminUnitRiskChangeLogScalarWhereInput | AdminUnitRiskChangeLogScalarWhereInput[]
    id?: StringFilter<"AdminUnitRiskChangeLog"> | string
    adminUnitRiskId?: StringFilter<"AdminUnitRiskChangeLog"> | string
    riskType?: StringFilter<"AdminUnitRiskChangeLog"> | string
    oldLevel?: IntFilter<"AdminUnitRiskChangeLog"> | number
    newLevel?: IntFilter<"AdminUnitRiskChangeLog"> | number
    oldNotes?: StringFilter<"AdminUnitRiskChangeLog"> | string
    newNotes?: StringFilter<"AdminUnitRiskChangeLog"> | string
    changedBy?: StringFilter<"AdminUnitRiskChangeLog"> | string
    changeReason?: StringNullableFilter<"AdminUnitRiskChangeLog"> | string | null
    createdAt?: DateTimeFilter<"AdminUnitRiskChangeLog"> | Date | string
  }

  export type AdminUnitRiskCreateWithoutChangeLogsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUpdated?: Date | string
    updatedBy?: string
    hurricaneLevel?: number
    hurricaneNotes?: string
    floodLevel?: number
    floodNotes?: string
    earthquakeLevel?: number
    earthquakeNotes?: string
    droughtLevel?: number
    droughtNotes?: string
    landslideLevel?: number
    landslideNotes?: string
    powerOutageLevel?: number
    powerOutageNotes?: string
    riskProfileJson?: string
    isActive?: boolean
    adminUnit: AdminUnitCreateNestedOneWithoutAdminUnitRiskInput
  }

  export type AdminUnitRiskUncheckedCreateWithoutChangeLogsInput = {
    id?: string
    adminUnitId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUpdated?: Date | string
    updatedBy?: string
    hurricaneLevel?: number
    hurricaneNotes?: string
    floodLevel?: number
    floodNotes?: string
    earthquakeLevel?: number
    earthquakeNotes?: string
    droughtLevel?: number
    droughtNotes?: string
    landslideLevel?: number
    landslideNotes?: string
    powerOutageLevel?: number
    powerOutageNotes?: string
    riskProfileJson?: string
    isActive?: boolean
  }

  export type AdminUnitRiskCreateOrConnectWithoutChangeLogsInput = {
    where: AdminUnitRiskWhereUniqueInput
    create: XOR<AdminUnitRiskCreateWithoutChangeLogsInput, AdminUnitRiskUncheckedCreateWithoutChangeLogsInput>
  }

  export type AdminUnitRiskUpsertWithoutChangeLogsInput = {
    update: XOR<AdminUnitRiskUpdateWithoutChangeLogsInput, AdminUnitRiskUncheckedUpdateWithoutChangeLogsInput>
    create: XOR<AdminUnitRiskCreateWithoutChangeLogsInput, AdminUnitRiskUncheckedCreateWithoutChangeLogsInput>
    where?: AdminUnitRiskWhereInput
  }

  export type AdminUnitRiskUpdateToOneWithWhereWithoutChangeLogsInput = {
    where?: AdminUnitRiskWhereInput
    data: XOR<AdminUnitRiskUpdateWithoutChangeLogsInput, AdminUnitRiskUncheckedUpdateWithoutChangeLogsInput>
  }

  export type AdminUnitRiskUpdateWithoutChangeLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    hurricaneLevel?: IntFieldUpdateOperationsInput | number
    hurricaneNotes?: StringFieldUpdateOperationsInput | string
    floodLevel?: IntFieldUpdateOperationsInput | number
    floodNotes?: StringFieldUpdateOperationsInput | string
    earthquakeLevel?: IntFieldUpdateOperationsInput | number
    earthquakeNotes?: StringFieldUpdateOperationsInput | string
    droughtLevel?: IntFieldUpdateOperationsInput | number
    droughtNotes?: StringFieldUpdateOperationsInput | string
    landslideLevel?: IntFieldUpdateOperationsInput | number
    landslideNotes?: StringFieldUpdateOperationsInput | string
    powerOutageLevel?: IntFieldUpdateOperationsInput | number
    powerOutageNotes?: StringFieldUpdateOperationsInput | string
    riskProfileJson?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    adminUnit?: AdminUnitUpdateOneRequiredWithoutAdminUnitRiskNestedInput
  }

  export type AdminUnitRiskUncheckedUpdateWithoutChangeLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminUnitId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    hurricaneLevel?: IntFieldUpdateOperationsInput | number
    hurricaneNotes?: StringFieldUpdateOperationsInput | string
    floodLevel?: IntFieldUpdateOperationsInput | number
    floodNotes?: StringFieldUpdateOperationsInput | string
    earthquakeLevel?: IntFieldUpdateOperationsInput | number
    earthquakeNotes?: StringFieldUpdateOperationsInput | string
    droughtLevel?: IntFieldUpdateOperationsInput | number
    droughtNotes?: StringFieldUpdateOperationsInput | string
    landslideLevel?: IntFieldUpdateOperationsInput | number
    landslideNotes?: StringFieldUpdateOperationsInput | string
    powerOutageLevel?: IntFieldUpdateOperationsInput | number
    powerOutageNotes?: StringFieldUpdateOperationsInput | string
    riskProfileJson?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ParishCreateWithoutParishRiskInput = {
    id?: string
    name: string
    region: string
    countryCode?: string
    population?: number
    area?: number | null
    elevation?: number | null
    coordinates?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    businessRiskProfiles?: BusinessRiskProfileCreateNestedManyWithoutParishInput
  }

  export type ParishUncheckedCreateWithoutParishRiskInput = {
    id?: string
    name: string
    region: string
    countryCode?: string
    population?: number
    area?: number | null
    elevation?: number | null
    coordinates?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    businessRiskProfiles?: BusinessRiskProfileUncheckedCreateNestedManyWithoutParishInput
  }

  export type ParishCreateOrConnectWithoutParishRiskInput = {
    where: ParishWhereUniqueInput
    create: XOR<ParishCreateWithoutParishRiskInput, ParishUncheckedCreateWithoutParishRiskInput>
  }

  export type RiskChangeLogCreateWithoutParishRiskInput = {
    id?: string
    riskType: string
    oldLevel: number
    newLevel: number
    oldNotes?: string
    newNotes?: string
    changedBy: string
    changeReason?: string | null
    createdAt?: Date | string
  }

  export type RiskChangeLogUncheckedCreateWithoutParishRiskInput = {
    id?: string
    riskType: string
    oldLevel: number
    newLevel: number
    oldNotes?: string
    newNotes?: string
    changedBy: string
    changeReason?: string | null
    createdAt?: Date | string
  }

  export type RiskChangeLogCreateOrConnectWithoutParishRiskInput = {
    where: RiskChangeLogWhereUniqueInput
    create: XOR<RiskChangeLogCreateWithoutParishRiskInput, RiskChangeLogUncheckedCreateWithoutParishRiskInput>
  }

  export type RiskChangeLogCreateManyParishRiskInputEnvelope = {
    data: RiskChangeLogCreateManyParishRiskInput | RiskChangeLogCreateManyParishRiskInput[]
    skipDuplicates?: boolean
  }

  export type ParishUpsertWithoutParishRiskInput = {
    update: XOR<ParishUpdateWithoutParishRiskInput, ParishUncheckedUpdateWithoutParishRiskInput>
    create: XOR<ParishCreateWithoutParishRiskInput, ParishUncheckedCreateWithoutParishRiskInput>
    where?: ParishWhereInput
  }

  export type ParishUpdateToOneWithWhereWithoutParishRiskInput = {
    where?: ParishWhereInput
    data: XOR<ParishUpdateWithoutParishRiskInput, ParishUncheckedUpdateWithoutParishRiskInput>
  }

  export type ParishUpdateWithoutParishRiskInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    population?: IntFieldUpdateOperationsInput | number
    area?: NullableFloatFieldUpdateOperationsInput | number | null
    elevation?: NullableFloatFieldUpdateOperationsInput | number | null
    coordinates?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    businessRiskProfiles?: BusinessRiskProfileUpdateManyWithoutParishNestedInput
  }

  export type ParishUncheckedUpdateWithoutParishRiskInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    population?: IntFieldUpdateOperationsInput | number
    area?: NullableFloatFieldUpdateOperationsInput | number | null
    elevation?: NullableFloatFieldUpdateOperationsInput | number | null
    coordinates?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    businessRiskProfiles?: BusinessRiskProfileUncheckedUpdateManyWithoutParishNestedInput
  }

  export type RiskChangeLogUpsertWithWhereUniqueWithoutParishRiskInput = {
    where: RiskChangeLogWhereUniqueInput
    update: XOR<RiskChangeLogUpdateWithoutParishRiskInput, RiskChangeLogUncheckedUpdateWithoutParishRiskInput>
    create: XOR<RiskChangeLogCreateWithoutParishRiskInput, RiskChangeLogUncheckedCreateWithoutParishRiskInput>
  }

  export type RiskChangeLogUpdateWithWhereUniqueWithoutParishRiskInput = {
    where: RiskChangeLogWhereUniqueInput
    data: XOR<RiskChangeLogUpdateWithoutParishRiskInput, RiskChangeLogUncheckedUpdateWithoutParishRiskInput>
  }

  export type RiskChangeLogUpdateManyWithWhereWithoutParishRiskInput = {
    where: RiskChangeLogScalarWhereInput
    data: XOR<RiskChangeLogUpdateManyMutationInput, RiskChangeLogUncheckedUpdateManyWithoutParishRiskInput>
  }

  export type RiskChangeLogScalarWhereInput = {
    AND?: RiskChangeLogScalarWhereInput | RiskChangeLogScalarWhereInput[]
    OR?: RiskChangeLogScalarWhereInput[]
    NOT?: RiskChangeLogScalarWhereInput | RiskChangeLogScalarWhereInput[]
    id?: StringFilter<"RiskChangeLog"> | string
    parishRiskId?: StringFilter<"RiskChangeLog"> | string
    riskType?: StringFilter<"RiskChangeLog"> | string
    oldLevel?: IntFilter<"RiskChangeLog"> | number
    newLevel?: IntFilter<"RiskChangeLog"> | number
    oldNotes?: StringFilter<"RiskChangeLog"> | string
    newNotes?: StringFilter<"RiskChangeLog"> | string
    changedBy?: StringFilter<"RiskChangeLog"> | string
    changeReason?: StringNullableFilter<"RiskChangeLog"> | string | null
    createdAt?: DateTimeFilter<"RiskChangeLog"> | Date | string
  }

  export type ParishRiskCreateWithoutChangeLogsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUpdated?: Date | string
    updatedBy?: string
    hurricaneLevel?: number
    hurricaneNotes?: string
    floodLevel?: number
    floodNotes?: string
    earthquakeLevel?: number
    earthquakeNotes?: string
    droughtLevel?: number
    droughtNotes?: string
    landslideLevel?: number
    landslideNotes?: string
    powerOutageLevel?: number
    powerOutageNotes?: string
    riskProfileJson?: string
    isActive?: boolean
    parish: ParishCreateNestedOneWithoutParishRiskInput
  }

  export type ParishRiskUncheckedCreateWithoutChangeLogsInput = {
    id?: string
    parishId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUpdated?: Date | string
    updatedBy?: string
    hurricaneLevel?: number
    hurricaneNotes?: string
    floodLevel?: number
    floodNotes?: string
    earthquakeLevel?: number
    earthquakeNotes?: string
    droughtLevel?: number
    droughtNotes?: string
    landslideLevel?: number
    landslideNotes?: string
    powerOutageLevel?: number
    powerOutageNotes?: string
    riskProfileJson?: string
    isActive?: boolean
  }

  export type ParishRiskCreateOrConnectWithoutChangeLogsInput = {
    where: ParishRiskWhereUniqueInput
    create: XOR<ParishRiskCreateWithoutChangeLogsInput, ParishRiskUncheckedCreateWithoutChangeLogsInput>
  }

  export type ParishRiskUpsertWithoutChangeLogsInput = {
    update: XOR<ParishRiskUpdateWithoutChangeLogsInput, ParishRiskUncheckedUpdateWithoutChangeLogsInput>
    create: XOR<ParishRiskCreateWithoutChangeLogsInput, ParishRiskUncheckedCreateWithoutChangeLogsInput>
    where?: ParishRiskWhereInput
  }

  export type ParishRiskUpdateToOneWithWhereWithoutChangeLogsInput = {
    where?: ParishRiskWhereInput
    data: XOR<ParishRiskUpdateWithoutChangeLogsInput, ParishRiskUncheckedUpdateWithoutChangeLogsInput>
  }

  export type ParishRiskUpdateWithoutChangeLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    hurricaneLevel?: IntFieldUpdateOperationsInput | number
    hurricaneNotes?: StringFieldUpdateOperationsInput | string
    floodLevel?: IntFieldUpdateOperationsInput | number
    floodNotes?: StringFieldUpdateOperationsInput | string
    earthquakeLevel?: IntFieldUpdateOperationsInput | number
    earthquakeNotes?: StringFieldUpdateOperationsInput | string
    droughtLevel?: IntFieldUpdateOperationsInput | number
    droughtNotes?: StringFieldUpdateOperationsInput | string
    landslideLevel?: IntFieldUpdateOperationsInput | number
    landslideNotes?: StringFieldUpdateOperationsInput | string
    powerOutageLevel?: IntFieldUpdateOperationsInput | number
    powerOutageNotes?: StringFieldUpdateOperationsInput | string
    riskProfileJson?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    parish?: ParishUpdateOneRequiredWithoutParishRiskNestedInput
  }

  export type ParishRiskUncheckedUpdateWithoutChangeLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    parishId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    hurricaneLevel?: IntFieldUpdateOperationsInput | number
    hurricaneNotes?: StringFieldUpdateOperationsInput | string
    floodLevel?: IntFieldUpdateOperationsInput | number
    floodNotes?: StringFieldUpdateOperationsInput | string
    earthquakeLevel?: IntFieldUpdateOperationsInput | number
    earthquakeNotes?: StringFieldUpdateOperationsInput | string
    droughtLevel?: IntFieldUpdateOperationsInput | number
    droughtNotes?: StringFieldUpdateOperationsInput | string
    landslideLevel?: IntFieldUpdateOperationsInput | number
    landslideNotes?: StringFieldUpdateOperationsInput | string
    powerOutageLevel?: IntFieldUpdateOperationsInput | number
    powerOutageNotes?: StringFieldUpdateOperationsInput | string
    riskProfileJson?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BusinessRiskVulnerabilityCreateWithoutBusinessTypeInput = {
    id?: string
    riskType: string
    vulnerabilityLevel?: number
    impactSeverity?: number
    recoveryTime?: string | null
    reasoning?: string
    mitigationDifficulty?: number | null
    costToRecover?: string | null
    businessImpactAreas?: string | null
    criticalDependencies?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusinessRiskVulnerabilityUncheckedCreateWithoutBusinessTypeInput = {
    id?: string
    riskType: string
    vulnerabilityLevel?: number
    impactSeverity?: number
    recoveryTime?: string | null
    reasoning?: string
    mitigationDifficulty?: number | null
    costToRecover?: string | null
    businessImpactAreas?: string | null
    criticalDependencies?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusinessRiskVulnerabilityCreateOrConnectWithoutBusinessTypeInput = {
    where: BusinessRiskVulnerabilityWhereUniqueInput
    create: XOR<BusinessRiskVulnerabilityCreateWithoutBusinessTypeInput, BusinessRiskVulnerabilityUncheckedCreateWithoutBusinessTypeInput>
  }

  export type BusinessRiskVulnerabilityCreateManyBusinessTypeInputEnvelope = {
    data: BusinessRiskVulnerabilityCreateManyBusinessTypeInput | BusinessRiskVulnerabilityCreateManyBusinessTypeInput[]
    skipDuplicates?: boolean
  }

  export type BusinessTypeStrategyCreateWithoutBusinessTypeInput = {
    id?: string
    relevanceScore?: number | null
    customNotes?: string | null
    isRecommended?: boolean | null
    priority?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    strategy: RiskMitigationStrategyCreateNestedOneWithoutBusinessTypeStrategiesInput
  }

  export type BusinessTypeStrategyUncheckedCreateWithoutBusinessTypeInput = {
    id?: string
    strategyId: string
    relevanceScore?: number | null
    customNotes?: string | null
    isRecommended?: boolean | null
    priority?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusinessTypeStrategyCreateOrConnectWithoutBusinessTypeInput = {
    where: BusinessTypeStrategyWhereUniqueInput
    create: XOR<BusinessTypeStrategyCreateWithoutBusinessTypeInput, BusinessTypeStrategyUncheckedCreateWithoutBusinessTypeInput>
  }

  export type BusinessTypeStrategyCreateManyBusinessTypeInputEnvelope = {
    data: BusinessTypeStrategyCreateManyBusinessTypeInput | BusinessTypeStrategyCreateManyBusinessTypeInput[]
    skipDuplicates?: boolean
  }

  export type BusinessRiskProfileCreateWithoutBusinessTypeInput = {
    id?: string
    combinedRisks: string
    recommendedStrategies: string
    overallRiskScore: number
    priorityActions?: string | null
    calculatedAt?: Date | string
    calculatedBy?: string | null
    isActive?: boolean
    parish: ParishCreateNestedOneWithoutBusinessRiskProfilesInput
  }

  export type BusinessRiskProfileUncheckedCreateWithoutBusinessTypeInput = {
    id?: string
    parishId: string
    combinedRisks: string
    recommendedStrategies: string
    overallRiskScore: number
    priorityActions?: string | null
    calculatedAt?: Date | string
    calculatedBy?: string | null
    isActive?: boolean
  }

  export type BusinessRiskProfileCreateOrConnectWithoutBusinessTypeInput = {
    where: BusinessRiskProfileWhereUniqueInput
    create: XOR<BusinessRiskProfileCreateWithoutBusinessTypeInput, BusinessRiskProfileUncheckedCreateWithoutBusinessTypeInput>
  }

  export type BusinessRiskProfileCreateManyBusinessTypeInputEnvelope = {
    data: BusinessRiskProfileCreateManyBusinessTypeInput | BusinessRiskProfileCreateManyBusinessTypeInput[]
    skipDuplicates?: boolean
  }

  export type BusinessTypeTranslationCreateWithoutBusinessTypeInput = {
    id?: string
    locale: string
    name: string
    description?: string | null
    exampleBusinessPurposes?: NullableJsonNullValueInput | InputJsonValue
    exampleProducts?: NullableJsonNullValueInput | InputJsonValue
    exampleKeyPersonnel?: NullableJsonNullValueInput | InputJsonValue
    exampleCustomerBase?: NullableJsonNullValueInput | InputJsonValue
    minimumEquipment?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusinessTypeTranslationUncheckedCreateWithoutBusinessTypeInput = {
    id?: string
    locale: string
    name: string
    description?: string | null
    exampleBusinessPurposes?: NullableJsonNullValueInput | InputJsonValue
    exampleProducts?: NullableJsonNullValueInput | InputJsonValue
    exampleKeyPersonnel?: NullableJsonNullValueInput | InputJsonValue
    exampleCustomerBase?: NullableJsonNullValueInput | InputJsonValue
    minimumEquipment?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusinessTypeTranslationCreateOrConnectWithoutBusinessTypeInput = {
    where: BusinessTypeTranslationWhereUniqueInput
    create: XOR<BusinessTypeTranslationCreateWithoutBusinessTypeInput, BusinessTypeTranslationUncheckedCreateWithoutBusinessTypeInput>
  }

  export type BusinessTypeTranslationCreateManyBusinessTypeInputEnvelope = {
    data: BusinessTypeTranslationCreateManyBusinessTypeInput | BusinessTypeTranslationCreateManyBusinessTypeInput[]
    skipDuplicates?: boolean
  }

  export type BusinessRiskVulnerabilityUpsertWithWhereUniqueWithoutBusinessTypeInput = {
    where: BusinessRiskVulnerabilityWhereUniqueInput
    update: XOR<BusinessRiskVulnerabilityUpdateWithoutBusinessTypeInput, BusinessRiskVulnerabilityUncheckedUpdateWithoutBusinessTypeInput>
    create: XOR<BusinessRiskVulnerabilityCreateWithoutBusinessTypeInput, BusinessRiskVulnerabilityUncheckedCreateWithoutBusinessTypeInput>
  }

  export type BusinessRiskVulnerabilityUpdateWithWhereUniqueWithoutBusinessTypeInput = {
    where: BusinessRiskVulnerabilityWhereUniqueInput
    data: XOR<BusinessRiskVulnerabilityUpdateWithoutBusinessTypeInput, BusinessRiskVulnerabilityUncheckedUpdateWithoutBusinessTypeInput>
  }

  export type BusinessRiskVulnerabilityUpdateManyWithWhereWithoutBusinessTypeInput = {
    where: BusinessRiskVulnerabilityScalarWhereInput
    data: XOR<BusinessRiskVulnerabilityUpdateManyMutationInput, BusinessRiskVulnerabilityUncheckedUpdateManyWithoutBusinessTypeInput>
  }

  export type BusinessRiskVulnerabilityScalarWhereInput = {
    AND?: BusinessRiskVulnerabilityScalarWhereInput | BusinessRiskVulnerabilityScalarWhereInput[]
    OR?: BusinessRiskVulnerabilityScalarWhereInput[]
    NOT?: BusinessRiskVulnerabilityScalarWhereInput | BusinessRiskVulnerabilityScalarWhereInput[]
    id?: StringFilter<"BusinessRiskVulnerability"> | string
    businessTypeId?: StringFilter<"BusinessRiskVulnerability"> | string
    riskType?: StringFilter<"BusinessRiskVulnerability"> | string
    vulnerabilityLevel?: IntFilter<"BusinessRiskVulnerability"> | number
    impactSeverity?: IntFilter<"BusinessRiskVulnerability"> | number
    recoveryTime?: StringNullableFilter<"BusinessRiskVulnerability"> | string | null
    reasoning?: StringFilter<"BusinessRiskVulnerability"> | string
    mitigationDifficulty?: IntNullableFilter<"BusinessRiskVulnerability"> | number | null
    costToRecover?: StringNullableFilter<"BusinessRiskVulnerability"> | string | null
    businessImpactAreas?: StringNullableFilter<"BusinessRiskVulnerability"> | string | null
    criticalDependencies?: StringNullableFilter<"BusinessRiskVulnerability"> | string | null
    isActive?: BoolFilter<"BusinessRiskVulnerability"> | boolean
    createdAt?: DateTimeFilter<"BusinessRiskVulnerability"> | Date | string
    updatedAt?: DateTimeFilter<"BusinessRiskVulnerability"> | Date | string
  }

  export type BusinessTypeStrategyUpsertWithWhereUniqueWithoutBusinessTypeInput = {
    where: BusinessTypeStrategyWhereUniqueInput
    update: XOR<BusinessTypeStrategyUpdateWithoutBusinessTypeInput, BusinessTypeStrategyUncheckedUpdateWithoutBusinessTypeInput>
    create: XOR<BusinessTypeStrategyCreateWithoutBusinessTypeInput, BusinessTypeStrategyUncheckedCreateWithoutBusinessTypeInput>
  }

  export type BusinessTypeStrategyUpdateWithWhereUniqueWithoutBusinessTypeInput = {
    where: BusinessTypeStrategyWhereUniqueInput
    data: XOR<BusinessTypeStrategyUpdateWithoutBusinessTypeInput, BusinessTypeStrategyUncheckedUpdateWithoutBusinessTypeInput>
  }

  export type BusinessTypeStrategyUpdateManyWithWhereWithoutBusinessTypeInput = {
    where: BusinessTypeStrategyScalarWhereInput
    data: XOR<BusinessTypeStrategyUpdateManyMutationInput, BusinessTypeStrategyUncheckedUpdateManyWithoutBusinessTypeInput>
  }

  export type BusinessTypeStrategyScalarWhereInput = {
    AND?: BusinessTypeStrategyScalarWhereInput | BusinessTypeStrategyScalarWhereInput[]
    OR?: BusinessTypeStrategyScalarWhereInput[]
    NOT?: BusinessTypeStrategyScalarWhereInput | BusinessTypeStrategyScalarWhereInput[]
    id?: StringFilter<"BusinessTypeStrategy"> | string
    businessTypeId?: StringFilter<"BusinessTypeStrategy"> | string
    strategyId?: StringFilter<"BusinessTypeStrategy"> | string
    relevanceScore?: IntNullableFilter<"BusinessTypeStrategy"> | number | null
    customNotes?: StringNullableFilter<"BusinessTypeStrategy"> | string | null
    isRecommended?: BoolNullableFilter<"BusinessTypeStrategy"> | boolean | null
    priority?: StringNullableFilter<"BusinessTypeStrategy"> | string | null
    createdAt?: DateTimeFilter<"BusinessTypeStrategy"> | Date | string
    updatedAt?: DateTimeFilter<"BusinessTypeStrategy"> | Date | string
  }

  export type BusinessRiskProfileUpsertWithWhereUniqueWithoutBusinessTypeInput = {
    where: BusinessRiskProfileWhereUniqueInput
    update: XOR<BusinessRiskProfileUpdateWithoutBusinessTypeInput, BusinessRiskProfileUncheckedUpdateWithoutBusinessTypeInput>
    create: XOR<BusinessRiskProfileCreateWithoutBusinessTypeInput, BusinessRiskProfileUncheckedCreateWithoutBusinessTypeInput>
  }

  export type BusinessRiskProfileUpdateWithWhereUniqueWithoutBusinessTypeInput = {
    where: BusinessRiskProfileWhereUniqueInput
    data: XOR<BusinessRiskProfileUpdateWithoutBusinessTypeInput, BusinessRiskProfileUncheckedUpdateWithoutBusinessTypeInput>
  }

  export type BusinessRiskProfileUpdateManyWithWhereWithoutBusinessTypeInput = {
    where: BusinessRiskProfileScalarWhereInput
    data: XOR<BusinessRiskProfileUpdateManyMutationInput, BusinessRiskProfileUncheckedUpdateManyWithoutBusinessTypeInput>
  }

  export type BusinessTypeTranslationUpsertWithWhereUniqueWithoutBusinessTypeInput = {
    where: BusinessTypeTranslationWhereUniqueInput
    update: XOR<BusinessTypeTranslationUpdateWithoutBusinessTypeInput, BusinessTypeTranslationUncheckedUpdateWithoutBusinessTypeInput>
    create: XOR<BusinessTypeTranslationCreateWithoutBusinessTypeInput, BusinessTypeTranslationUncheckedCreateWithoutBusinessTypeInput>
  }

  export type BusinessTypeTranslationUpdateWithWhereUniqueWithoutBusinessTypeInput = {
    where: BusinessTypeTranslationWhereUniqueInput
    data: XOR<BusinessTypeTranslationUpdateWithoutBusinessTypeInput, BusinessTypeTranslationUncheckedUpdateWithoutBusinessTypeInput>
  }

  export type BusinessTypeTranslationUpdateManyWithWhereWithoutBusinessTypeInput = {
    where: BusinessTypeTranslationScalarWhereInput
    data: XOR<BusinessTypeTranslationUpdateManyMutationInput, BusinessTypeTranslationUncheckedUpdateManyWithoutBusinessTypeInput>
  }

  export type BusinessTypeTranslationScalarWhereInput = {
    AND?: BusinessTypeTranslationScalarWhereInput | BusinessTypeTranslationScalarWhereInput[]
    OR?: BusinessTypeTranslationScalarWhereInput[]
    NOT?: BusinessTypeTranslationScalarWhereInput | BusinessTypeTranslationScalarWhereInput[]
    id?: StringFilter<"BusinessTypeTranslation"> | string
    businessTypeId?: StringFilter<"BusinessTypeTranslation"> | string
    locale?: StringFilter<"BusinessTypeTranslation"> | string
    name?: StringFilter<"BusinessTypeTranslation"> | string
    description?: StringNullableFilter<"BusinessTypeTranslation"> | string | null
    exampleBusinessPurposes?: JsonNullableFilter<"BusinessTypeTranslation">
    exampleProducts?: JsonNullableFilter<"BusinessTypeTranslation">
    exampleKeyPersonnel?: JsonNullableFilter<"BusinessTypeTranslation">
    exampleCustomerBase?: JsonNullableFilter<"BusinessTypeTranslation">
    minimumEquipment?: JsonNullableFilter<"BusinessTypeTranslation">
    createdAt?: DateTimeFilter<"BusinessTypeTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"BusinessTypeTranslation"> | Date | string
  }

  export type BusinessTypeCreateWithoutRiskVulnerabilitiesInput = {
    id?: string
    businessTypeId: string
    name: string
    category: string
    subcategory?: string | null
    description?: string | null
    exampleBusinessPurposes?: string | null
    exampleProducts?: string | null
    exampleKeyPersonnel?: string | null
    exampleCustomerBase?: string | null
    minimumEquipment?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    businessTypeStrategies?: BusinessTypeStrategyCreateNestedManyWithoutBusinessTypeInput
    businessRiskProfiles?: BusinessRiskProfileCreateNestedManyWithoutBusinessTypeInput
    translations?: BusinessTypeTranslationCreateNestedManyWithoutBusinessTypeInput
  }

  export type BusinessTypeUncheckedCreateWithoutRiskVulnerabilitiesInput = {
    id?: string
    businessTypeId: string
    name: string
    category: string
    subcategory?: string | null
    description?: string | null
    exampleBusinessPurposes?: string | null
    exampleProducts?: string | null
    exampleKeyPersonnel?: string | null
    exampleCustomerBase?: string | null
    minimumEquipment?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    businessTypeStrategies?: BusinessTypeStrategyUncheckedCreateNestedManyWithoutBusinessTypeInput
    businessRiskProfiles?: BusinessRiskProfileUncheckedCreateNestedManyWithoutBusinessTypeInput
    translations?: BusinessTypeTranslationUncheckedCreateNestedManyWithoutBusinessTypeInput
  }

  export type BusinessTypeCreateOrConnectWithoutRiskVulnerabilitiesInput = {
    where: BusinessTypeWhereUniqueInput
    create: XOR<BusinessTypeCreateWithoutRiskVulnerabilitiesInput, BusinessTypeUncheckedCreateWithoutRiskVulnerabilitiesInput>
  }

  export type BusinessTypeUpsertWithoutRiskVulnerabilitiesInput = {
    update: XOR<BusinessTypeUpdateWithoutRiskVulnerabilitiesInput, BusinessTypeUncheckedUpdateWithoutRiskVulnerabilitiesInput>
    create: XOR<BusinessTypeCreateWithoutRiskVulnerabilitiesInput, BusinessTypeUncheckedCreateWithoutRiskVulnerabilitiesInput>
    where?: BusinessTypeWhereInput
  }

  export type BusinessTypeUpdateToOneWithWhereWithoutRiskVulnerabilitiesInput = {
    where?: BusinessTypeWhereInput
    data: XOR<BusinessTypeUpdateWithoutRiskVulnerabilitiesInput, BusinessTypeUncheckedUpdateWithoutRiskVulnerabilitiesInput>
  }

  export type BusinessTypeUpdateWithoutRiskVulnerabilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessTypeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    exampleBusinessPurposes?: NullableStringFieldUpdateOperationsInput | string | null
    exampleProducts?: NullableStringFieldUpdateOperationsInput | string | null
    exampleKeyPersonnel?: NullableStringFieldUpdateOperationsInput | string | null
    exampleCustomerBase?: NullableStringFieldUpdateOperationsInput | string | null
    minimumEquipment?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessTypeStrategies?: BusinessTypeStrategyUpdateManyWithoutBusinessTypeNestedInput
    businessRiskProfiles?: BusinessRiskProfileUpdateManyWithoutBusinessTypeNestedInput
    translations?: BusinessTypeTranslationUpdateManyWithoutBusinessTypeNestedInput
  }

  export type BusinessTypeUncheckedUpdateWithoutRiskVulnerabilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessTypeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    exampleBusinessPurposes?: NullableStringFieldUpdateOperationsInput | string | null
    exampleProducts?: NullableStringFieldUpdateOperationsInput | string | null
    exampleKeyPersonnel?: NullableStringFieldUpdateOperationsInput | string | null
    exampleCustomerBase?: NullableStringFieldUpdateOperationsInput | string | null
    minimumEquipment?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessTypeStrategies?: BusinessTypeStrategyUncheckedUpdateManyWithoutBusinessTypeNestedInput
    businessRiskProfiles?: BusinessRiskProfileUncheckedUpdateManyWithoutBusinessTypeNestedInput
    translations?: BusinessTypeTranslationUncheckedUpdateManyWithoutBusinessTypeNestedInput
  }

  export type BusinessTypeStrategyCreateWithoutStrategyInput = {
    id?: string
    relevanceScore?: number | null
    customNotes?: string | null
    isRecommended?: boolean | null
    priority?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    businessType: BusinessTypeCreateNestedOneWithoutBusinessTypeStrategiesInput
  }

  export type BusinessTypeStrategyUncheckedCreateWithoutStrategyInput = {
    id?: string
    businessTypeId: string
    relevanceScore?: number | null
    customNotes?: string | null
    isRecommended?: boolean | null
    priority?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusinessTypeStrategyCreateOrConnectWithoutStrategyInput = {
    where: BusinessTypeStrategyWhereUniqueInput
    create: XOR<BusinessTypeStrategyCreateWithoutStrategyInput, BusinessTypeStrategyUncheckedCreateWithoutStrategyInput>
  }

  export type BusinessTypeStrategyCreateManyStrategyInputEnvelope = {
    data: BusinessTypeStrategyCreateManyStrategyInput | BusinessTypeStrategyCreateManyStrategyInput[]
    skipDuplicates?: boolean
  }

  export type ActionStepCreateWithoutStrategyInput = {
    id?: string
    stepId: string
    phase?: string
    title: string
    description: string
    smeAction?: string | null
    whyThisStepMatters?: string | null
    whatHappensIfSkipped?: string | null
    timeframe?: string | null
    estimatedMinutes?: number | null
    difficultyLevel?: string | null
    responsibility?: string | null
    estimatedCost?: string | null
    estimatedCostJMD?: string | null
    resources?: string | null
    checklist?: string | null
    howToKnowItsDone?: string | null
    exampleOutput?: string | null
    dependsOnSteps?: string | null
    isOptional?: boolean
    skipConditions?: string | null
    freeAlternative?: string | null
    lowTechOption?: string | null
    commonMistakesForStep?: string | null
    videoTutorialUrl?: string | null
    externalResourceUrl?: string | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    itemCosts?: ActionStepItemCostCreateNestedManyWithoutActionStepInput
    translations?: ActionStepTranslationCreateNestedManyWithoutActionStepInput
  }

  export type ActionStepUncheckedCreateWithoutStrategyInput = {
    id?: string
    stepId: string
    phase?: string
    title: string
    description: string
    smeAction?: string | null
    whyThisStepMatters?: string | null
    whatHappensIfSkipped?: string | null
    timeframe?: string | null
    estimatedMinutes?: number | null
    difficultyLevel?: string | null
    responsibility?: string | null
    estimatedCost?: string | null
    estimatedCostJMD?: string | null
    resources?: string | null
    checklist?: string | null
    howToKnowItsDone?: string | null
    exampleOutput?: string | null
    dependsOnSteps?: string | null
    isOptional?: boolean
    skipConditions?: string | null
    freeAlternative?: string | null
    lowTechOption?: string | null
    commonMistakesForStep?: string | null
    videoTutorialUrl?: string | null
    externalResourceUrl?: string | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    itemCosts?: ActionStepItemCostUncheckedCreateNestedManyWithoutActionStepInput
    translations?: ActionStepTranslationUncheckedCreateNestedManyWithoutActionStepInput
  }

  export type ActionStepCreateOrConnectWithoutStrategyInput = {
    where: ActionStepWhereUniqueInput
    create: XOR<ActionStepCreateWithoutStrategyInput, ActionStepUncheckedCreateWithoutStrategyInput>
  }

  export type ActionStepCreateManyStrategyInputEnvelope = {
    data: ActionStepCreateManyStrategyInput | ActionStepCreateManyStrategyInput[]
    skipDuplicates?: boolean
  }

  export type StrategyItemCostCreateWithoutStrategyInput = {
    id?: string
    quantity?: number
    customNotes?: string | null
    countryOverrides?: string | null
    isRequired?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    item: CostItemCreateNestedOneWithoutStrategyItemsInput
  }

  export type StrategyItemCostUncheckedCreateWithoutStrategyInput = {
    id?: string
    itemId: string
    quantity?: number
    customNotes?: string | null
    countryOverrides?: string | null
    isRequired?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StrategyItemCostCreateOrConnectWithoutStrategyInput = {
    where: StrategyItemCostWhereUniqueInput
    create: XOR<StrategyItemCostCreateWithoutStrategyInput, StrategyItemCostUncheckedCreateWithoutStrategyInput>
  }

  export type StrategyItemCostCreateManyStrategyInputEnvelope = {
    data: StrategyItemCostCreateManyStrategyInput | StrategyItemCostCreateManyStrategyInput[]
    skipDuplicates?: boolean
  }

  export type StrategyTranslationCreateWithoutStrategyInput = {
    id?: string
    locale: string
    name: string
    description: string
    smeTitle?: string | null
    smeSummary?: string | null
    realWorldExample?: string | null
    whyImportant?: string | null
    whenToImplement?: string | null
    expectedOutcome?: string | null
    benefitsBullets?: NullableJsonNullValueInput | InputJsonValue
    helpfulTips?: NullableJsonNullValueInput | InputJsonValue
    commonMistakes?: NullableJsonNullValueInput | InputJsonValue
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    requiredResources?: NullableJsonNullValueInput | InputJsonValue
    lowBudgetAlternative?: string | null
    diyApproach?: string | null
    bcpTemplateText?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StrategyTranslationUncheckedCreateWithoutStrategyInput = {
    id?: string
    locale: string
    name: string
    description: string
    smeTitle?: string | null
    smeSummary?: string | null
    realWorldExample?: string | null
    whyImportant?: string | null
    whenToImplement?: string | null
    expectedOutcome?: string | null
    benefitsBullets?: NullableJsonNullValueInput | InputJsonValue
    helpfulTips?: NullableJsonNullValueInput | InputJsonValue
    commonMistakes?: NullableJsonNullValueInput | InputJsonValue
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    requiredResources?: NullableJsonNullValueInput | InputJsonValue
    lowBudgetAlternative?: string | null
    diyApproach?: string | null
    bcpTemplateText?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StrategyTranslationCreateOrConnectWithoutStrategyInput = {
    where: StrategyTranslationWhereUniqueInput
    create: XOR<StrategyTranslationCreateWithoutStrategyInput, StrategyTranslationUncheckedCreateWithoutStrategyInput>
  }

  export type StrategyTranslationCreateManyStrategyInputEnvelope = {
    data: StrategyTranslationCreateManyStrategyInput | StrategyTranslationCreateManyStrategyInput[]
    skipDuplicates?: boolean
  }

  export type BusinessTypeStrategyUpsertWithWhereUniqueWithoutStrategyInput = {
    where: BusinessTypeStrategyWhereUniqueInput
    update: XOR<BusinessTypeStrategyUpdateWithoutStrategyInput, BusinessTypeStrategyUncheckedUpdateWithoutStrategyInput>
    create: XOR<BusinessTypeStrategyCreateWithoutStrategyInput, BusinessTypeStrategyUncheckedCreateWithoutStrategyInput>
  }

  export type BusinessTypeStrategyUpdateWithWhereUniqueWithoutStrategyInput = {
    where: BusinessTypeStrategyWhereUniqueInput
    data: XOR<BusinessTypeStrategyUpdateWithoutStrategyInput, BusinessTypeStrategyUncheckedUpdateWithoutStrategyInput>
  }

  export type BusinessTypeStrategyUpdateManyWithWhereWithoutStrategyInput = {
    where: BusinessTypeStrategyScalarWhereInput
    data: XOR<BusinessTypeStrategyUpdateManyMutationInput, BusinessTypeStrategyUncheckedUpdateManyWithoutStrategyInput>
  }

  export type ActionStepUpsertWithWhereUniqueWithoutStrategyInput = {
    where: ActionStepWhereUniqueInput
    update: XOR<ActionStepUpdateWithoutStrategyInput, ActionStepUncheckedUpdateWithoutStrategyInput>
    create: XOR<ActionStepCreateWithoutStrategyInput, ActionStepUncheckedCreateWithoutStrategyInput>
  }

  export type ActionStepUpdateWithWhereUniqueWithoutStrategyInput = {
    where: ActionStepWhereUniqueInput
    data: XOR<ActionStepUpdateWithoutStrategyInput, ActionStepUncheckedUpdateWithoutStrategyInput>
  }

  export type ActionStepUpdateManyWithWhereWithoutStrategyInput = {
    where: ActionStepScalarWhereInput
    data: XOR<ActionStepUpdateManyMutationInput, ActionStepUncheckedUpdateManyWithoutStrategyInput>
  }

  export type ActionStepScalarWhereInput = {
    AND?: ActionStepScalarWhereInput | ActionStepScalarWhereInput[]
    OR?: ActionStepScalarWhereInput[]
    NOT?: ActionStepScalarWhereInput | ActionStepScalarWhereInput[]
    id?: StringFilter<"ActionStep"> | string
    strategyId?: StringFilter<"ActionStep"> | string
    stepId?: StringFilter<"ActionStep"> | string
    phase?: StringFilter<"ActionStep"> | string
    title?: StringFilter<"ActionStep"> | string
    description?: StringFilter<"ActionStep"> | string
    smeAction?: StringNullableFilter<"ActionStep"> | string | null
    whyThisStepMatters?: StringNullableFilter<"ActionStep"> | string | null
    whatHappensIfSkipped?: StringNullableFilter<"ActionStep"> | string | null
    timeframe?: StringNullableFilter<"ActionStep"> | string | null
    estimatedMinutes?: IntNullableFilter<"ActionStep"> | number | null
    difficultyLevel?: StringNullableFilter<"ActionStep"> | string | null
    responsibility?: StringNullableFilter<"ActionStep"> | string | null
    estimatedCost?: StringNullableFilter<"ActionStep"> | string | null
    estimatedCostJMD?: StringNullableFilter<"ActionStep"> | string | null
    resources?: StringNullableFilter<"ActionStep"> | string | null
    checklist?: StringNullableFilter<"ActionStep"> | string | null
    howToKnowItsDone?: StringNullableFilter<"ActionStep"> | string | null
    exampleOutput?: StringNullableFilter<"ActionStep"> | string | null
    dependsOnSteps?: StringNullableFilter<"ActionStep"> | string | null
    isOptional?: BoolFilter<"ActionStep"> | boolean
    skipConditions?: StringNullableFilter<"ActionStep"> | string | null
    freeAlternative?: StringNullableFilter<"ActionStep"> | string | null
    lowTechOption?: StringNullableFilter<"ActionStep"> | string | null
    commonMistakesForStep?: StringNullableFilter<"ActionStep"> | string | null
    videoTutorialUrl?: StringNullableFilter<"ActionStep"> | string | null
    externalResourceUrl?: StringNullableFilter<"ActionStep"> | string | null
    sortOrder?: IntFilter<"ActionStep"> | number
    isActive?: BoolFilter<"ActionStep"> | boolean
    createdAt?: DateTimeFilter<"ActionStep"> | Date | string
    updatedAt?: DateTimeFilter<"ActionStep"> | Date | string
  }

  export type StrategyItemCostUpsertWithWhereUniqueWithoutStrategyInput = {
    where: StrategyItemCostWhereUniqueInput
    update: XOR<StrategyItemCostUpdateWithoutStrategyInput, StrategyItemCostUncheckedUpdateWithoutStrategyInput>
    create: XOR<StrategyItemCostCreateWithoutStrategyInput, StrategyItemCostUncheckedCreateWithoutStrategyInput>
  }

  export type StrategyItemCostUpdateWithWhereUniqueWithoutStrategyInput = {
    where: StrategyItemCostWhereUniqueInput
    data: XOR<StrategyItemCostUpdateWithoutStrategyInput, StrategyItemCostUncheckedUpdateWithoutStrategyInput>
  }

  export type StrategyItemCostUpdateManyWithWhereWithoutStrategyInput = {
    where: StrategyItemCostScalarWhereInput
    data: XOR<StrategyItemCostUpdateManyMutationInput, StrategyItemCostUncheckedUpdateManyWithoutStrategyInput>
  }

  export type StrategyItemCostScalarWhereInput = {
    AND?: StrategyItemCostScalarWhereInput | StrategyItemCostScalarWhereInput[]
    OR?: StrategyItemCostScalarWhereInput[]
    NOT?: StrategyItemCostScalarWhereInput | StrategyItemCostScalarWhereInput[]
    id?: StringFilter<"StrategyItemCost"> | string
    strategyId?: StringFilter<"StrategyItemCost"> | string
    itemId?: StringFilter<"StrategyItemCost"> | string
    quantity?: IntFilter<"StrategyItemCost"> | number
    customNotes?: StringNullableFilter<"StrategyItemCost"> | string | null
    countryOverrides?: StringNullableFilter<"StrategyItemCost"> | string | null
    isRequired?: BoolFilter<"StrategyItemCost"> | boolean
    displayOrder?: IntFilter<"StrategyItemCost"> | number
    createdAt?: DateTimeFilter<"StrategyItemCost"> | Date | string
    updatedAt?: DateTimeFilter<"StrategyItemCost"> | Date | string
  }

  export type StrategyTranslationUpsertWithWhereUniqueWithoutStrategyInput = {
    where: StrategyTranslationWhereUniqueInput
    update: XOR<StrategyTranslationUpdateWithoutStrategyInput, StrategyTranslationUncheckedUpdateWithoutStrategyInput>
    create: XOR<StrategyTranslationCreateWithoutStrategyInput, StrategyTranslationUncheckedCreateWithoutStrategyInput>
  }

  export type StrategyTranslationUpdateWithWhereUniqueWithoutStrategyInput = {
    where: StrategyTranslationWhereUniqueInput
    data: XOR<StrategyTranslationUpdateWithoutStrategyInput, StrategyTranslationUncheckedUpdateWithoutStrategyInput>
  }

  export type StrategyTranslationUpdateManyWithWhereWithoutStrategyInput = {
    where: StrategyTranslationScalarWhereInput
    data: XOR<StrategyTranslationUpdateManyMutationInput, StrategyTranslationUncheckedUpdateManyWithoutStrategyInput>
  }

  export type StrategyTranslationScalarWhereInput = {
    AND?: StrategyTranslationScalarWhereInput | StrategyTranslationScalarWhereInput[]
    OR?: StrategyTranslationScalarWhereInput[]
    NOT?: StrategyTranslationScalarWhereInput | StrategyTranslationScalarWhereInput[]
    id?: StringFilter<"StrategyTranslation"> | string
    strategyId?: StringFilter<"StrategyTranslation"> | string
    locale?: StringFilter<"StrategyTranslation"> | string
    name?: StringFilter<"StrategyTranslation"> | string
    description?: StringFilter<"StrategyTranslation"> | string
    smeTitle?: StringNullableFilter<"StrategyTranslation"> | string | null
    smeSummary?: StringNullableFilter<"StrategyTranslation"> | string | null
    realWorldExample?: StringNullableFilter<"StrategyTranslation"> | string | null
    whyImportant?: StringNullableFilter<"StrategyTranslation"> | string | null
    whenToImplement?: StringNullableFilter<"StrategyTranslation"> | string | null
    expectedOutcome?: StringNullableFilter<"StrategyTranslation"> | string | null
    benefitsBullets?: JsonNullableFilter<"StrategyTranslation">
    helpfulTips?: JsonNullableFilter<"StrategyTranslation">
    commonMistakes?: JsonNullableFilter<"StrategyTranslation">
    successMetrics?: JsonNullableFilter<"StrategyTranslation">
    requiredResources?: JsonNullableFilter<"StrategyTranslation">
    lowBudgetAlternative?: StringNullableFilter<"StrategyTranslation"> | string | null
    diyApproach?: StringNullableFilter<"StrategyTranslation"> | string | null
    bcpTemplateText?: StringNullableFilter<"StrategyTranslation"> | string | null
    createdAt?: DateTimeFilter<"StrategyTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"StrategyTranslation"> | Date | string
  }

  export type RiskMitigationStrategyCreateWithoutActionStepsInput = {
    id?: string
    strategyId: string
    name: string
    description: string
    smeTitle?: string | null
    smeSummary?: string | null
    smeDescription?: string | null
    whyImportant?: string | null
    benefitsBullets?: string | null
    realWorldExample?: string | null
    calculatedCostUSD?: Decimal | DecimalJsLike | number | string | null
    calculatedCostLocal?: Decimal | DecimalJsLike | number | string | null
    currencyCode?: string | null
    currencySymbol?: string | null
    totalEstimatedHours?: number | null
    selectionTier?: string | null
    requiredForRisks?: string | null
    helpfulTips?: string | null
    commonMistakes?: string | null
    successMetrics?: string | null
    lowBudgetAlternative?: string | null
    applicableRisks: string
    applicableBusinessTypes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    businessTypeStrategies?: BusinessTypeStrategyCreateNestedManyWithoutStrategyInput
    itemCosts?: StrategyItemCostCreateNestedManyWithoutStrategyInput
    translations?: StrategyTranslationCreateNestedManyWithoutStrategyInput
  }

  export type RiskMitigationStrategyUncheckedCreateWithoutActionStepsInput = {
    id?: string
    strategyId: string
    name: string
    description: string
    smeTitle?: string | null
    smeSummary?: string | null
    smeDescription?: string | null
    whyImportant?: string | null
    benefitsBullets?: string | null
    realWorldExample?: string | null
    calculatedCostUSD?: Decimal | DecimalJsLike | number | string | null
    calculatedCostLocal?: Decimal | DecimalJsLike | number | string | null
    currencyCode?: string | null
    currencySymbol?: string | null
    totalEstimatedHours?: number | null
    selectionTier?: string | null
    requiredForRisks?: string | null
    helpfulTips?: string | null
    commonMistakes?: string | null
    successMetrics?: string | null
    lowBudgetAlternative?: string | null
    applicableRisks: string
    applicableBusinessTypes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    businessTypeStrategies?: BusinessTypeStrategyUncheckedCreateNestedManyWithoutStrategyInput
    itemCosts?: StrategyItemCostUncheckedCreateNestedManyWithoutStrategyInput
    translations?: StrategyTranslationUncheckedCreateNestedManyWithoutStrategyInput
  }

  export type RiskMitigationStrategyCreateOrConnectWithoutActionStepsInput = {
    where: RiskMitigationStrategyWhereUniqueInput
    create: XOR<RiskMitigationStrategyCreateWithoutActionStepsInput, RiskMitigationStrategyUncheckedCreateWithoutActionStepsInput>
  }

  export type ActionStepItemCostCreateWithoutActionStepInput = {
    id?: string
    quantity?: number
    customNotes?: string | null
    countryOverrides?: string | null
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    item: CostItemCreateNestedOneWithoutActionStepItemsInput
  }

  export type ActionStepItemCostUncheckedCreateWithoutActionStepInput = {
    id?: string
    itemId: string
    quantity?: number
    customNotes?: string | null
    countryOverrides?: string | null
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActionStepItemCostCreateOrConnectWithoutActionStepInput = {
    where: ActionStepItemCostWhereUniqueInput
    create: XOR<ActionStepItemCostCreateWithoutActionStepInput, ActionStepItemCostUncheckedCreateWithoutActionStepInput>
  }

  export type ActionStepItemCostCreateManyActionStepInputEnvelope = {
    data: ActionStepItemCostCreateManyActionStepInput | ActionStepItemCostCreateManyActionStepInput[]
    skipDuplicates?: boolean
  }

  export type ActionStepTranslationCreateWithoutActionStepInput = {
    id?: string
    locale: string
    title: string
    description?: string | null
    smeAction?: string | null
    timeframe?: string | null
    whyThisStepMatters?: string | null
    howToKnowItsDone?: string | null
    whatHappensIfSkipped?: string | null
    exampleOutput?: string | null
    freeAlternative?: string | null
    lowTechOption?: string | null
    commonMistakesForStep?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActionStepTranslationUncheckedCreateWithoutActionStepInput = {
    id?: string
    locale: string
    title: string
    description?: string | null
    smeAction?: string | null
    timeframe?: string | null
    whyThisStepMatters?: string | null
    howToKnowItsDone?: string | null
    whatHappensIfSkipped?: string | null
    exampleOutput?: string | null
    freeAlternative?: string | null
    lowTechOption?: string | null
    commonMistakesForStep?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActionStepTranslationCreateOrConnectWithoutActionStepInput = {
    where: ActionStepTranslationWhereUniqueInput
    create: XOR<ActionStepTranslationCreateWithoutActionStepInput, ActionStepTranslationUncheckedCreateWithoutActionStepInput>
  }

  export type ActionStepTranslationCreateManyActionStepInputEnvelope = {
    data: ActionStepTranslationCreateManyActionStepInput | ActionStepTranslationCreateManyActionStepInput[]
    skipDuplicates?: boolean
  }

  export type RiskMitigationStrategyUpsertWithoutActionStepsInput = {
    update: XOR<RiskMitigationStrategyUpdateWithoutActionStepsInput, RiskMitigationStrategyUncheckedUpdateWithoutActionStepsInput>
    create: XOR<RiskMitigationStrategyCreateWithoutActionStepsInput, RiskMitigationStrategyUncheckedCreateWithoutActionStepsInput>
    where?: RiskMitigationStrategyWhereInput
  }

  export type RiskMitigationStrategyUpdateToOneWithWhereWithoutActionStepsInput = {
    where?: RiskMitigationStrategyWhereInput
    data: XOR<RiskMitigationStrategyUpdateWithoutActionStepsInput, RiskMitigationStrategyUncheckedUpdateWithoutActionStepsInput>
  }

  export type RiskMitigationStrategyUpdateWithoutActionStepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    strategyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    smeTitle?: NullableStringFieldUpdateOperationsInput | string | null
    smeSummary?: NullableStringFieldUpdateOperationsInput | string | null
    smeDescription?: NullableStringFieldUpdateOperationsInput | string | null
    whyImportant?: NullableStringFieldUpdateOperationsInput | string | null
    benefitsBullets?: NullableStringFieldUpdateOperationsInput | string | null
    realWorldExample?: NullableStringFieldUpdateOperationsInput | string | null
    calculatedCostUSD?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    calculatedCostLocal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currencyCode?: NullableStringFieldUpdateOperationsInput | string | null
    currencySymbol?: NullableStringFieldUpdateOperationsInput | string | null
    totalEstimatedHours?: NullableIntFieldUpdateOperationsInput | number | null
    selectionTier?: NullableStringFieldUpdateOperationsInput | string | null
    requiredForRisks?: NullableStringFieldUpdateOperationsInput | string | null
    helpfulTips?: NullableStringFieldUpdateOperationsInput | string | null
    commonMistakes?: NullableStringFieldUpdateOperationsInput | string | null
    successMetrics?: NullableStringFieldUpdateOperationsInput | string | null
    lowBudgetAlternative?: NullableStringFieldUpdateOperationsInput | string | null
    applicableRisks?: StringFieldUpdateOperationsInput | string
    applicableBusinessTypes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessTypeStrategies?: BusinessTypeStrategyUpdateManyWithoutStrategyNestedInput
    itemCosts?: StrategyItemCostUpdateManyWithoutStrategyNestedInput
    translations?: StrategyTranslationUpdateManyWithoutStrategyNestedInput
  }

  export type RiskMitigationStrategyUncheckedUpdateWithoutActionStepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    strategyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    smeTitle?: NullableStringFieldUpdateOperationsInput | string | null
    smeSummary?: NullableStringFieldUpdateOperationsInput | string | null
    smeDescription?: NullableStringFieldUpdateOperationsInput | string | null
    whyImportant?: NullableStringFieldUpdateOperationsInput | string | null
    benefitsBullets?: NullableStringFieldUpdateOperationsInput | string | null
    realWorldExample?: NullableStringFieldUpdateOperationsInput | string | null
    calculatedCostUSD?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    calculatedCostLocal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currencyCode?: NullableStringFieldUpdateOperationsInput | string | null
    currencySymbol?: NullableStringFieldUpdateOperationsInput | string | null
    totalEstimatedHours?: NullableIntFieldUpdateOperationsInput | number | null
    selectionTier?: NullableStringFieldUpdateOperationsInput | string | null
    requiredForRisks?: NullableStringFieldUpdateOperationsInput | string | null
    helpfulTips?: NullableStringFieldUpdateOperationsInput | string | null
    commonMistakes?: NullableStringFieldUpdateOperationsInput | string | null
    successMetrics?: NullableStringFieldUpdateOperationsInput | string | null
    lowBudgetAlternative?: NullableStringFieldUpdateOperationsInput | string | null
    applicableRisks?: StringFieldUpdateOperationsInput | string
    applicableBusinessTypes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessTypeStrategies?: BusinessTypeStrategyUncheckedUpdateManyWithoutStrategyNestedInput
    itemCosts?: StrategyItemCostUncheckedUpdateManyWithoutStrategyNestedInput
    translations?: StrategyTranslationUncheckedUpdateManyWithoutStrategyNestedInput
  }

  export type ActionStepItemCostUpsertWithWhereUniqueWithoutActionStepInput = {
    where: ActionStepItemCostWhereUniqueInput
    update: XOR<ActionStepItemCostUpdateWithoutActionStepInput, ActionStepItemCostUncheckedUpdateWithoutActionStepInput>
    create: XOR<ActionStepItemCostCreateWithoutActionStepInput, ActionStepItemCostUncheckedCreateWithoutActionStepInput>
  }

  export type ActionStepItemCostUpdateWithWhereUniqueWithoutActionStepInput = {
    where: ActionStepItemCostWhereUniqueInput
    data: XOR<ActionStepItemCostUpdateWithoutActionStepInput, ActionStepItemCostUncheckedUpdateWithoutActionStepInput>
  }

  export type ActionStepItemCostUpdateManyWithWhereWithoutActionStepInput = {
    where: ActionStepItemCostScalarWhereInput
    data: XOR<ActionStepItemCostUpdateManyMutationInput, ActionStepItemCostUncheckedUpdateManyWithoutActionStepInput>
  }

  export type ActionStepItemCostScalarWhereInput = {
    AND?: ActionStepItemCostScalarWhereInput | ActionStepItemCostScalarWhereInput[]
    OR?: ActionStepItemCostScalarWhereInput[]
    NOT?: ActionStepItemCostScalarWhereInput | ActionStepItemCostScalarWhereInput[]
    id?: StringFilter<"ActionStepItemCost"> | string
    actionStepId?: StringFilter<"ActionStepItemCost"> | string
    itemId?: StringFilter<"ActionStepItemCost"> | string
    quantity?: IntFilter<"ActionStepItemCost"> | number
    customNotes?: StringNullableFilter<"ActionStepItemCost"> | string | null
    countryOverrides?: StringNullableFilter<"ActionStepItemCost"> | string | null
    displayOrder?: IntFilter<"ActionStepItemCost"> | number
    createdAt?: DateTimeFilter<"ActionStepItemCost"> | Date | string
    updatedAt?: DateTimeFilter<"ActionStepItemCost"> | Date | string
  }

  export type ActionStepTranslationUpsertWithWhereUniqueWithoutActionStepInput = {
    where: ActionStepTranslationWhereUniqueInput
    update: XOR<ActionStepTranslationUpdateWithoutActionStepInput, ActionStepTranslationUncheckedUpdateWithoutActionStepInput>
    create: XOR<ActionStepTranslationCreateWithoutActionStepInput, ActionStepTranslationUncheckedCreateWithoutActionStepInput>
  }

  export type ActionStepTranslationUpdateWithWhereUniqueWithoutActionStepInput = {
    where: ActionStepTranslationWhereUniqueInput
    data: XOR<ActionStepTranslationUpdateWithoutActionStepInput, ActionStepTranslationUncheckedUpdateWithoutActionStepInput>
  }

  export type ActionStepTranslationUpdateManyWithWhereWithoutActionStepInput = {
    where: ActionStepTranslationScalarWhereInput
    data: XOR<ActionStepTranslationUpdateManyMutationInput, ActionStepTranslationUncheckedUpdateManyWithoutActionStepInput>
  }

  export type ActionStepTranslationScalarWhereInput = {
    AND?: ActionStepTranslationScalarWhereInput | ActionStepTranslationScalarWhereInput[]
    OR?: ActionStepTranslationScalarWhereInput[]
    NOT?: ActionStepTranslationScalarWhereInput | ActionStepTranslationScalarWhereInput[]
    id?: StringFilter<"ActionStepTranslation"> | string
    actionStepId?: StringFilter<"ActionStepTranslation"> | string
    locale?: StringFilter<"ActionStepTranslation"> | string
    title?: StringFilter<"ActionStepTranslation"> | string
    description?: StringNullableFilter<"ActionStepTranslation"> | string | null
    smeAction?: StringNullableFilter<"ActionStepTranslation"> | string | null
    timeframe?: StringNullableFilter<"ActionStepTranslation"> | string | null
    whyThisStepMatters?: StringNullableFilter<"ActionStepTranslation"> | string | null
    howToKnowItsDone?: StringNullableFilter<"ActionStepTranslation"> | string | null
    whatHappensIfSkipped?: StringNullableFilter<"ActionStepTranslation"> | string | null
    exampleOutput?: StringNullableFilter<"ActionStepTranslation"> | string | null
    freeAlternative?: StringNullableFilter<"ActionStepTranslation"> | string | null
    lowTechOption?: StringNullableFilter<"ActionStepTranslation"> | string | null
    commonMistakesForStep?: JsonNullableFilter<"ActionStepTranslation">
    createdAt?: DateTimeFilter<"ActionStepTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"ActionStepTranslation"> | Date | string
  }

  export type BusinessTypeCreateWithoutBusinessTypeStrategiesInput = {
    id?: string
    businessTypeId: string
    name: string
    category: string
    subcategory?: string | null
    description?: string | null
    exampleBusinessPurposes?: string | null
    exampleProducts?: string | null
    exampleKeyPersonnel?: string | null
    exampleCustomerBase?: string | null
    minimumEquipment?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    riskVulnerabilities?: BusinessRiskVulnerabilityCreateNestedManyWithoutBusinessTypeInput
    businessRiskProfiles?: BusinessRiskProfileCreateNestedManyWithoutBusinessTypeInput
    translations?: BusinessTypeTranslationCreateNestedManyWithoutBusinessTypeInput
  }

  export type BusinessTypeUncheckedCreateWithoutBusinessTypeStrategiesInput = {
    id?: string
    businessTypeId: string
    name: string
    category: string
    subcategory?: string | null
    description?: string | null
    exampleBusinessPurposes?: string | null
    exampleProducts?: string | null
    exampleKeyPersonnel?: string | null
    exampleCustomerBase?: string | null
    minimumEquipment?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    riskVulnerabilities?: BusinessRiskVulnerabilityUncheckedCreateNestedManyWithoutBusinessTypeInput
    businessRiskProfiles?: BusinessRiskProfileUncheckedCreateNestedManyWithoutBusinessTypeInput
    translations?: BusinessTypeTranslationUncheckedCreateNestedManyWithoutBusinessTypeInput
  }

  export type BusinessTypeCreateOrConnectWithoutBusinessTypeStrategiesInput = {
    where: BusinessTypeWhereUniqueInput
    create: XOR<BusinessTypeCreateWithoutBusinessTypeStrategiesInput, BusinessTypeUncheckedCreateWithoutBusinessTypeStrategiesInput>
  }

  export type RiskMitigationStrategyCreateWithoutBusinessTypeStrategiesInput = {
    id?: string
    strategyId: string
    name: string
    description: string
    smeTitle?: string | null
    smeSummary?: string | null
    smeDescription?: string | null
    whyImportant?: string | null
    benefitsBullets?: string | null
    realWorldExample?: string | null
    calculatedCostUSD?: Decimal | DecimalJsLike | number | string | null
    calculatedCostLocal?: Decimal | DecimalJsLike | number | string | null
    currencyCode?: string | null
    currencySymbol?: string | null
    totalEstimatedHours?: number | null
    selectionTier?: string | null
    requiredForRisks?: string | null
    helpfulTips?: string | null
    commonMistakes?: string | null
    successMetrics?: string | null
    lowBudgetAlternative?: string | null
    applicableRisks: string
    applicableBusinessTypes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    actionSteps?: ActionStepCreateNestedManyWithoutStrategyInput
    itemCosts?: StrategyItemCostCreateNestedManyWithoutStrategyInput
    translations?: StrategyTranslationCreateNestedManyWithoutStrategyInput
  }

  export type RiskMitigationStrategyUncheckedCreateWithoutBusinessTypeStrategiesInput = {
    id?: string
    strategyId: string
    name: string
    description: string
    smeTitle?: string | null
    smeSummary?: string | null
    smeDescription?: string | null
    whyImportant?: string | null
    benefitsBullets?: string | null
    realWorldExample?: string | null
    calculatedCostUSD?: Decimal | DecimalJsLike | number | string | null
    calculatedCostLocal?: Decimal | DecimalJsLike | number | string | null
    currencyCode?: string | null
    currencySymbol?: string | null
    totalEstimatedHours?: number | null
    selectionTier?: string | null
    requiredForRisks?: string | null
    helpfulTips?: string | null
    commonMistakes?: string | null
    successMetrics?: string | null
    lowBudgetAlternative?: string | null
    applicableRisks: string
    applicableBusinessTypes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    actionSteps?: ActionStepUncheckedCreateNestedManyWithoutStrategyInput
    itemCosts?: StrategyItemCostUncheckedCreateNestedManyWithoutStrategyInput
    translations?: StrategyTranslationUncheckedCreateNestedManyWithoutStrategyInput
  }

  export type RiskMitigationStrategyCreateOrConnectWithoutBusinessTypeStrategiesInput = {
    where: RiskMitigationStrategyWhereUniqueInput
    create: XOR<RiskMitigationStrategyCreateWithoutBusinessTypeStrategiesInput, RiskMitigationStrategyUncheckedCreateWithoutBusinessTypeStrategiesInput>
  }

  export type BusinessTypeUpsertWithoutBusinessTypeStrategiesInput = {
    update: XOR<BusinessTypeUpdateWithoutBusinessTypeStrategiesInput, BusinessTypeUncheckedUpdateWithoutBusinessTypeStrategiesInput>
    create: XOR<BusinessTypeCreateWithoutBusinessTypeStrategiesInput, BusinessTypeUncheckedCreateWithoutBusinessTypeStrategiesInput>
    where?: BusinessTypeWhereInput
  }

  export type BusinessTypeUpdateToOneWithWhereWithoutBusinessTypeStrategiesInput = {
    where?: BusinessTypeWhereInput
    data: XOR<BusinessTypeUpdateWithoutBusinessTypeStrategiesInput, BusinessTypeUncheckedUpdateWithoutBusinessTypeStrategiesInput>
  }

  export type BusinessTypeUpdateWithoutBusinessTypeStrategiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessTypeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    exampleBusinessPurposes?: NullableStringFieldUpdateOperationsInput | string | null
    exampleProducts?: NullableStringFieldUpdateOperationsInput | string | null
    exampleKeyPersonnel?: NullableStringFieldUpdateOperationsInput | string | null
    exampleCustomerBase?: NullableStringFieldUpdateOperationsInput | string | null
    minimumEquipment?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    riskVulnerabilities?: BusinessRiskVulnerabilityUpdateManyWithoutBusinessTypeNestedInput
    businessRiskProfiles?: BusinessRiskProfileUpdateManyWithoutBusinessTypeNestedInput
    translations?: BusinessTypeTranslationUpdateManyWithoutBusinessTypeNestedInput
  }

  export type BusinessTypeUncheckedUpdateWithoutBusinessTypeStrategiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessTypeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    exampleBusinessPurposes?: NullableStringFieldUpdateOperationsInput | string | null
    exampleProducts?: NullableStringFieldUpdateOperationsInput | string | null
    exampleKeyPersonnel?: NullableStringFieldUpdateOperationsInput | string | null
    exampleCustomerBase?: NullableStringFieldUpdateOperationsInput | string | null
    minimumEquipment?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    riskVulnerabilities?: BusinessRiskVulnerabilityUncheckedUpdateManyWithoutBusinessTypeNestedInput
    businessRiskProfiles?: BusinessRiskProfileUncheckedUpdateManyWithoutBusinessTypeNestedInput
    translations?: BusinessTypeTranslationUncheckedUpdateManyWithoutBusinessTypeNestedInput
  }

  export type RiskMitigationStrategyUpsertWithoutBusinessTypeStrategiesInput = {
    update: XOR<RiskMitigationStrategyUpdateWithoutBusinessTypeStrategiesInput, RiskMitigationStrategyUncheckedUpdateWithoutBusinessTypeStrategiesInput>
    create: XOR<RiskMitigationStrategyCreateWithoutBusinessTypeStrategiesInput, RiskMitigationStrategyUncheckedCreateWithoutBusinessTypeStrategiesInput>
    where?: RiskMitigationStrategyWhereInput
  }

  export type RiskMitigationStrategyUpdateToOneWithWhereWithoutBusinessTypeStrategiesInput = {
    where?: RiskMitigationStrategyWhereInput
    data: XOR<RiskMitigationStrategyUpdateWithoutBusinessTypeStrategiesInput, RiskMitigationStrategyUncheckedUpdateWithoutBusinessTypeStrategiesInput>
  }

  export type RiskMitigationStrategyUpdateWithoutBusinessTypeStrategiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    strategyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    smeTitle?: NullableStringFieldUpdateOperationsInput | string | null
    smeSummary?: NullableStringFieldUpdateOperationsInput | string | null
    smeDescription?: NullableStringFieldUpdateOperationsInput | string | null
    whyImportant?: NullableStringFieldUpdateOperationsInput | string | null
    benefitsBullets?: NullableStringFieldUpdateOperationsInput | string | null
    realWorldExample?: NullableStringFieldUpdateOperationsInput | string | null
    calculatedCostUSD?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    calculatedCostLocal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currencyCode?: NullableStringFieldUpdateOperationsInput | string | null
    currencySymbol?: NullableStringFieldUpdateOperationsInput | string | null
    totalEstimatedHours?: NullableIntFieldUpdateOperationsInput | number | null
    selectionTier?: NullableStringFieldUpdateOperationsInput | string | null
    requiredForRisks?: NullableStringFieldUpdateOperationsInput | string | null
    helpfulTips?: NullableStringFieldUpdateOperationsInput | string | null
    commonMistakes?: NullableStringFieldUpdateOperationsInput | string | null
    successMetrics?: NullableStringFieldUpdateOperationsInput | string | null
    lowBudgetAlternative?: NullableStringFieldUpdateOperationsInput | string | null
    applicableRisks?: StringFieldUpdateOperationsInput | string
    applicableBusinessTypes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actionSteps?: ActionStepUpdateManyWithoutStrategyNestedInput
    itemCosts?: StrategyItemCostUpdateManyWithoutStrategyNestedInput
    translations?: StrategyTranslationUpdateManyWithoutStrategyNestedInput
  }

  export type RiskMitigationStrategyUncheckedUpdateWithoutBusinessTypeStrategiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    strategyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    smeTitle?: NullableStringFieldUpdateOperationsInput | string | null
    smeSummary?: NullableStringFieldUpdateOperationsInput | string | null
    smeDescription?: NullableStringFieldUpdateOperationsInput | string | null
    whyImportant?: NullableStringFieldUpdateOperationsInput | string | null
    benefitsBullets?: NullableStringFieldUpdateOperationsInput | string | null
    realWorldExample?: NullableStringFieldUpdateOperationsInput | string | null
    calculatedCostUSD?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    calculatedCostLocal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currencyCode?: NullableStringFieldUpdateOperationsInput | string | null
    currencySymbol?: NullableStringFieldUpdateOperationsInput | string | null
    totalEstimatedHours?: NullableIntFieldUpdateOperationsInput | number | null
    selectionTier?: NullableStringFieldUpdateOperationsInput | string | null
    requiredForRisks?: NullableStringFieldUpdateOperationsInput | string | null
    helpfulTips?: NullableStringFieldUpdateOperationsInput | string | null
    commonMistakes?: NullableStringFieldUpdateOperationsInput | string | null
    successMetrics?: NullableStringFieldUpdateOperationsInput | string | null
    lowBudgetAlternative?: NullableStringFieldUpdateOperationsInput | string | null
    applicableRisks?: StringFieldUpdateOperationsInput | string
    applicableBusinessTypes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actionSteps?: ActionStepUncheckedUpdateManyWithoutStrategyNestedInput
    itemCosts?: StrategyItemCostUncheckedUpdateManyWithoutStrategyNestedInput
    translations?: StrategyTranslationUncheckedUpdateManyWithoutStrategyNestedInput
  }

  export type BusinessTypeCreateWithoutBusinessRiskProfilesInput = {
    id?: string
    businessTypeId: string
    name: string
    category: string
    subcategory?: string | null
    description?: string | null
    exampleBusinessPurposes?: string | null
    exampleProducts?: string | null
    exampleKeyPersonnel?: string | null
    exampleCustomerBase?: string | null
    minimumEquipment?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    riskVulnerabilities?: BusinessRiskVulnerabilityCreateNestedManyWithoutBusinessTypeInput
    businessTypeStrategies?: BusinessTypeStrategyCreateNestedManyWithoutBusinessTypeInput
    translations?: BusinessTypeTranslationCreateNestedManyWithoutBusinessTypeInput
  }

  export type BusinessTypeUncheckedCreateWithoutBusinessRiskProfilesInput = {
    id?: string
    businessTypeId: string
    name: string
    category: string
    subcategory?: string | null
    description?: string | null
    exampleBusinessPurposes?: string | null
    exampleProducts?: string | null
    exampleKeyPersonnel?: string | null
    exampleCustomerBase?: string | null
    minimumEquipment?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    riskVulnerabilities?: BusinessRiskVulnerabilityUncheckedCreateNestedManyWithoutBusinessTypeInput
    businessTypeStrategies?: BusinessTypeStrategyUncheckedCreateNestedManyWithoutBusinessTypeInput
    translations?: BusinessTypeTranslationUncheckedCreateNestedManyWithoutBusinessTypeInput
  }

  export type BusinessTypeCreateOrConnectWithoutBusinessRiskProfilesInput = {
    where: BusinessTypeWhereUniqueInput
    create: XOR<BusinessTypeCreateWithoutBusinessRiskProfilesInput, BusinessTypeUncheckedCreateWithoutBusinessRiskProfilesInput>
  }

  export type ParishCreateWithoutBusinessRiskProfilesInput = {
    id?: string
    name: string
    region: string
    countryCode?: string
    population?: number
    area?: number | null
    elevation?: number | null
    coordinates?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    parishRisk?: ParishRiskCreateNestedOneWithoutParishInput
  }

  export type ParishUncheckedCreateWithoutBusinessRiskProfilesInput = {
    id?: string
    name: string
    region: string
    countryCode?: string
    population?: number
    area?: number | null
    elevation?: number | null
    coordinates?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    parishRisk?: ParishRiskUncheckedCreateNestedOneWithoutParishInput
  }

  export type ParishCreateOrConnectWithoutBusinessRiskProfilesInput = {
    where: ParishWhereUniqueInput
    create: XOR<ParishCreateWithoutBusinessRiskProfilesInput, ParishUncheckedCreateWithoutBusinessRiskProfilesInput>
  }

  export type BusinessTypeUpsertWithoutBusinessRiskProfilesInput = {
    update: XOR<BusinessTypeUpdateWithoutBusinessRiskProfilesInput, BusinessTypeUncheckedUpdateWithoutBusinessRiskProfilesInput>
    create: XOR<BusinessTypeCreateWithoutBusinessRiskProfilesInput, BusinessTypeUncheckedCreateWithoutBusinessRiskProfilesInput>
    where?: BusinessTypeWhereInput
  }

  export type BusinessTypeUpdateToOneWithWhereWithoutBusinessRiskProfilesInput = {
    where?: BusinessTypeWhereInput
    data: XOR<BusinessTypeUpdateWithoutBusinessRiskProfilesInput, BusinessTypeUncheckedUpdateWithoutBusinessRiskProfilesInput>
  }

  export type BusinessTypeUpdateWithoutBusinessRiskProfilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessTypeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    exampleBusinessPurposes?: NullableStringFieldUpdateOperationsInput | string | null
    exampleProducts?: NullableStringFieldUpdateOperationsInput | string | null
    exampleKeyPersonnel?: NullableStringFieldUpdateOperationsInput | string | null
    exampleCustomerBase?: NullableStringFieldUpdateOperationsInput | string | null
    minimumEquipment?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    riskVulnerabilities?: BusinessRiskVulnerabilityUpdateManyWithoutBusinessTypeNestedInput
    businessTypeStrategies?: BusinessTypeStrategyUpdateManyWithoutBusinessTypeNestedInput
    translations?: BusinessTypeTranslationUpdateManyWithoutBusinessTypeNestedInput
  }

  export type BusinessTypeUncheckedUpdateWithoutBusinessRiskProfilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessTypeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    exampleBusinessPurposes?: NullableStringFieldUpdateOperationsInput | string | null
    exampleProducts?: NullableStringFieldUpdateOperationsInput | string | null
    exampleKeyPersonnel?: NullableStringFieldUpdateOperationsInput | string | null
    exampleCustomerBase?: NullableStringFieldUpdateOperationsInput | string | null
    minimumEquipment?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    riskVulnerabilities?: BusinessRiskVulnerabilityUncheckedUpdateManyWithoutBusinessTypeNestedInput
    businessTypeStrategies?: BusinessTypeStrategyUncheckedUpdateManyWithoutBusinessTypeNestedInput
    translations?: BusinessTypeTranslationUncheckedUpdateManyWithoutBusinessTypeNestedInput
  }

  export type ParishUpsertWithoutBusinessRiskProfilesInput = {
    update: XOR<ParishUpdateWithoutBusinessRiskProfilesInput, ParishUncheckedUpdateWithoutBusinessRiskProfilesInput>
    create: XOR<ParishCreateWithoutBusinessRiskProfilesInput, ParishUncheckedCreateWithoutBusinessRiskProfilesInput>
    where?: ParishWhereInput
  }

  export type ParishUpdateToOneWithWhereWithoutBusinessRiskProfilesInput = {
    where?: ParishWhereInput
    data: XOR<ParishUpdateWithoutBusinessRiskProfilesInput, ParishUncheckedUpdateWithoutBusinessRiskProfilesInput>
  }

  export type ParishUpdateWithoutBusinessRiskProfilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    population?: IntFieldUpdateOperationsInput | number
    area?: NullableFloatFieldUpdateOperationsInput | number | null
    elevation?: NullableFloatFieldUpdateOperationsInput | number | null
    coordinates?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    parishRisk?: ParishRiskUpdateOneWithoutParishNestedInput
  }

  export type ParishUncheckedUpdateWithoutBusinessRiskProfilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    population?: IntFieldUpdateOperationsInput | number
    area?: NullableFloatFieldUpdateOperationsInput | number | null
    elevation?: NullableFloatFieldUpdateOperationsInput | number | null
    coordinates?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    parishRisk?: ParishRiskUncheckedUpdateOneWithoutParishNestedInput
  }

  export type RiskMultiplierTranslationCreateWithoutRiskMultiplierInput = {
    id?: string
    locale: string
    name: string
    description?: string | null
    reasoning?: string | null
    wizardQuestion?: string | null
    wizardHelpText?: string | null
    wizardAnswerOptions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RiskMultiplierTranslationUncheckedCreateWithoutRiskMultiplierInput = {
    id?: string
    locale: string
    name: string
    description?: string | null
    reasoning?: string | null
    wizardQuestion?: string | null
    wizardHelpText?: string | null
    wizardAnswerOptions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RiskMultiplierTranslationCreateOrConnectWithoutRiskMultiplierInput = {
    where: RiskMultiplierTranslationWhereUniqueInput
    create: XOR<RiskMultiplierTranslationCreateWithoutRiskMultiplierInput, RiskMultiplierTranslationUncheckedCreateWithoutRiskMultiplierInput>
  }

  export type RiskMultiplierTranslationCreateManyRiskMultiplierInputEnvelope = {
    data: RiskMultiplierTranslationCreateManyRiskMultiplierInput | RiskMultiplierTranslationCreateManyRiskMultiplierInput[]
    skipDuplicates?: boolean
  }

  export type RiskMultiplierTranslationUpsertWithWhereUniqueWithoutRiskMultiplierInput = {
    where: RiskMultiplierTranslationWhereUniqueInput
    update: XOR<RiskMultiplierTranslationUpdateWithoutRiskMultiplierInput, RiskMultiplierTranslationUncheckedUpdateWithoutRiskMultiplierInput>
    create: XOR<RiskMultiplierTranslationCreateWithoutRiskMultiplierInput, RiskMultiplierTranslationUncheckedCreateWithoutRiskMultiplierInput>
  }

  export type RiskMultiplierTranslationUpdateWithWhereUniqueWithoutRiskMultiplierInput = {
    where: RiskMultiplierTranslationWhereUniqueInput
    data: XOR<RiskMultiplierTranslationUpdateWithoutRiskMultiplierInput, RiskMultiplierTranslationUncheckedUpdateWithoutRiskMultiplierInput>
  }

  export type RiskMultiplierTranslationUpdateManyWithWhereWithoutRiskMultiplierInput = {
    where: RiskMultiplierTranslationScalarWhereInput
    data: XOR<RiskMultiplierTranslationUpdateManyMutationInput, RiskMultiplierTranslationUncheckedUpdateManyWithoutRiskMultiplierInput>
  }

  export type RiskMultiplierTranslationScalarWhereInput = {
    AND?: RiskMultiplierTranslationScalarWhereInput | RiskMultiplierTranslationScalarWhereInput[]
    OR?: RiskMultiplierTranslationScalarWhereInput[]
    NOT?: RiskMultiplierTranslationScalarWhereInput | RiskMultiplierTranslationScalarWhereInput[]
    id?: StringFilter<"RiskMultiplierTranslation"> | string
    riskMultiplierId?: StringFilter<"RiskMultiplierTranslation"> | string
    locale?: StringFilter<"RiskMultiplierTranslation"> | string
    name?: StringFilter<"RiskMultiplierTranslation"> | string
    description?: StringNullableFilter<"RiskMultiplierTranslation"> | string | null
    reasoning?: StringNullableFilter<"RiskMultiplierTranslation"> | string | null
    wizardQuestion?: StringNullableFilter<"RiskMultiplierTranslation"> | string | null
    wizardHelpText?: StringNullableFilter<"RiskMultiplierTranslation"> | string | null
    wizardAnswerOptions?: JsonNullableFilter<"RiskMultiplierTranslation">
    createdAt?: DateTimeFilter<"RiskMultiplierTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"RiskMultiplierTranslation"> | Date | string
  }

  export type StrategyItemCostCreateWithoutItemInput = {
    id?: string
    quantity?: number
    customNotes?: string | null
    countryOverrides?: string | null
    isRequired?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    strategy: RiskMitigationStrategyCreateNestedOneWithoutItemCostsInput
  }

  export type StrategyItemCostUncheckedCreateWithoutItemInput = {
    id?: string
    strategyId: string
    quantity?: number
    customNotes?: string | null
    countryOverrides?: string | null
    isRequired?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StrategyItemCostCreateOrConnectWithoutItemInput = {
    where: StrategyItemCostWhereUniqueInput
    create: XOR<StrategyItemCostCreateWithoutItemInput, StrategyItemCostUncheckedCreateWithoutItemInput>
  }

  export type StrategyItemCostCreateManyItemInputEnvelope = {
    data: StrategyItemCostCreateManyItemInput | StrategyItemCostCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type ActionStepItemCostCreateWithoutItemInput = {
    id?: string
    quantity?: number
    customNotes?: string | null
    countryOverrides?: string | null
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    actionStep: ActionStepCreateNestedOneWithoutItemCostsInput
  }

  export type ActionStepItemCostUncheckedCreateWithoutItemInput = {
    id?: string
    actionStepId: string
    quantity?: number
    customNotes?: string | null
    countryOverrides?: string | null
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActionStepItemCostCreateOrConnectWithoutItemInput = {
    where: ActionStepItemCostWhereUniqueInput
    create: XOR<ActionStepItemCostCreateWithoutItemInput, ActionStepItemCostUncheckedCreateWithoutItemInput>
  }

  export type ActionStepItemCostCreateManyItemInputEnvelope = {
    data: ActionStepItemCostCreateManyItemInput | ActionStepItemCostCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type StrategyItemCostUpsertWithWhereUniqueWithoutItemInput = {
    where: StrategyItemCostWhereUniqueInput
    update: XOR<StrategyItemCostUpdateWithoutItemInput, StrategyItemCostUncheckedUpdateWithoutItemInput>
    create: XOR<StrategyItemCostCreateWithoutItemInput, StrategyItemCostUncheckedCreateWithoutItemInput>
  }

  export type StrategyItemCostUpdateWithWhereUniqueWithoutItemInput = {
    where: StrategyItemCostWhereUniqueInput
    data: XOR<StrategyItemCostUpdateWithoutItemInput, StrategyItemCostUncheckedUpdateWithoutItemInput>
  }

  export type StrategyItemCostUpdateManyWithWhereWithoutItemInput = {
    where: StrategyItemCostScalarWhereInput
    data: XOR<StrategyItemCostUpdateManyMutationInput, StrategyItemCostUncheckedUpdateManyWithoutItemInput>
  }

  export type ActionStepItemCostUpsertWithWhereUniqueWithoutItemInput = {
    where: ActionStepItemCostWhereUniqueInput
    update: XOR<ActionStepItemCostUpdateWithoutItemInput, ActionStepItemCostUncheckedUpdateWithoutItemInput>
    create: XOR<ActionStepItemCostCreateWithoutItemInput, ActionStepItemCostUncheckedCreateWithoutItemInput>
  }

  export type ActionStepItemCostUpdateWithWhereUniqueWithoutItemInput = {
    where: ActionStepItemCostWhereUniqueInput
    data: XOR<ActionStepItemCostUpdateWithoutItemInput, ActionStepItemCostUncheckedUpdateWithoutItemInput>
  }

  export type ActionStepItemCostUpdateManyWithWhereWithoutItemInput = {
    where: ActionStepItemCostScalarWhereInput
    data: XOR<ActionStepItemCostUpdateManyMutationInput, ActionStepItemCostUncheckedUpdateManyWithoutItemInput>
  }

  export type RiskMitigationStrategyCreateWithoutItemCostsInput = {
    id?: string
    strategyId: string
    name: string
    description: string
    smeTitle?: string | null
    smeSummary?: string | null
    smeDescription?: string | null
    whyImportant?: string | null
    benefitsBullets?: string | null
    realWorldExample?: string | null
    calculatedCostUSD?: Decimal | DecimalJsLike | number | string | null
    calculatedCostLocal?: Decimal | DecimalJsLike | number | string | null
    currencyCode?: string | null
    currencySymbol?: string | null
    totalEstimatedHours?: number | null
    selectionTier?: string | null
    requiredForRisks?: string | null
    helpfulTips?: string | null
    commonMistakes?: string | null
    successMetrics?: string | null
    lowBudgetAlternative?: string | null
    applicableRisks: string
    applicableBusinessTypes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    businessTypeStrategies?: BusinessTypeStrategyCreateNestedManyWithoutStrategyInput
    actionSteps?: ActionStepCreateNestedManyWithoutStrategyInput
    translations?: StrategyTranslationCreateNestedManyWithoutStrategyInput
  }

  export type RiskMitigationStrategyUncheckedCreateWithoutItemCostsInput = {
    id?: string
    strategyId: string
    name: string
    description: string
    smeTitle?: string | null
    smeSummary?: string | null
    smeDescription?: string | null
    whyImportant?: string | null
    benefitsBullets?: string | null
    realWorldExample?: string | null
    calculatedCostUSD?: Decimal | DecimalJsLike | number | string | null
    calculatedCostLocal?: Decimal | DecimalJsLike | number | string | null
    currencyCode?: string | null
    currencySymbol?: string | null
    totalEstimatedHours?: number | null
    selectionTier?: string | null
    requiredForRisks?: string | null
    helpfulTips?: string | null
    commonMistakes?: string | null
    successMetrics?: string | null
    lowBudgetAlternative?: string | null
    applicableRisks: string
    applicableBusinessTypes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    businessTypeStrategies?: BusinessTypeStrategyUncheckedCreateNestedManyWithoutStrategyInput
    actionSteps?: ActionStepUncheckedCreateNestedManyWithoutStrategyInput
    translations?: StrategyTranslationUncheckedCreateNestedManyWithoutStrategyInput
  }

  export type RiskMitigationStrategyCreateOrConnectWithoutItemCostsInput = {
    where: RiskMitigationStrategyWhereUniqueInput
    create: XOR<RiskMitigationStrategyCreateWithoutItemCostsInput, RiskMitigationStrategyUncheckedCreateWithoutItemCostsInput>
  }

  export type CostItemCreateWithoutStrategyItemsInput = {
    id?: string
    itemId: string
    name: string
    description?: string | null
    category: string
    baseUSD: number
    baseUSDMin?: number | null
    baseUSDMax?: number | null
    unit?: string | null
    complexity?: string
    notes?: string | null
    tags?: string | null
    budgetAlternativeId?: string | null
    premiumAlternativeId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    actionStepItems?: ActionStepItemCostCreateNestedManyWithoutItemInput
  }

  export type CostItemUncheckedCreateWithoutStrategyItemsInput = {
    id?: string
    itemId: string
    name: string
    description?: string | null
    category: string
    baseUSD: number
    baseUSDMin?: number | null
    baseUSDMax?: number | null
    unit?: string | null
    complexity?: string
    notes?: string | null
    tags?: string | null
    budgetAlternativeId?: string | null
    premiumAlternativeId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    actionStepItems?: ActionStepItemCostUncheckedCreateNestedManyWithoutItemInput
  }

  export type CostItemCreateOrConnectWithoutStrategyItemsInput = {
    where: CostItemWhereUniqueInput
    create: XOR<CostItemCreateWithoutStrategyItemsInput, CostItemUncheckedCreateWithoutStrategyItemsInput>
  }

  export type RiskMitigationStrategyUpsertWithoutItemCostsInput = {
    update: XOR<RiskMitigationStrategyUpdateWithoutItemCostsInput, RiskMitigationStrategyUncheckedUpdateWithoutItemCostsInput>
    create: XOR<RiskMitigationStrategyCreateWithoutItemCostsInput, RiskMitigationStrategyUncheckedCreateWithoutItemCostsInput>
    where?: RiskMitigationStrategyWhereInput
  }

  export type RiskMitigationStrategyUpdateToOneWithWhereWithoutItemCostsInput = {
    where?: RiskMitigationStrategyWhereInput
    data: XOR<RiskMitigationStrategyUpdateWithoutItemCostsInput, RiskMitigationStrategyUncheckedUpdateWithoutItemCostsInput>
  }

  export type RiskMitigationStrategyUpdateWithoutItemCostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    strategyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    smeTitle?: NullableStringFieldUpdateOperationsInput | string | null
    smeSummary?: NullableStringFieldUpdateOperationsInput | string | null
    smeDescription?: NullableStringFieldUpdateOperationsInput | string | null
    whyImportant?: NullableStringFieldUpdateOperationsInput | string | null
    benefitsBullets?: NullableStringFieldUpdateOperationsInput | string | null
    realWorldExample?: NullableStringFieldUpdateOperationsInput | string | null
    calculatedCostUSD?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    calculatedCostLocal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currencyCode?: NullableStringFieldUpdateOperationsInput | string | null
    currencySymbol?: NullableStringFieldUpdateOperationsInput | string | null
    totalEstimatedHours?: NullableIntFieldUpdateOperationsInput | number | null
    selectionTier?: NullableStringFieldUpdateOperationsInput | string | null
    requiredForRisks?: NullableStringFieldUpdateOperationsInput | string | null
    helpfulTips?: NullableStringFieldUpdateOperationsInput | string | null
    commonMistakes?: NullableStringFieldUpdateOperationsInput | string | null
    successMetrics?: NullableStringFieldUpdateOperationsInput | string | null
    lowBudgetAlternative?: NullableStringFieldUpdateOperationsInput | string | null
    applicableRisks?: StringFieldUpdateOperationsInput | string
    applicableBusinessTypes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessTypeStrategies?: BusinessTypeStrategyUpdateManyWithoutStrategyNestedInput
    actionSteps?: ActionStepUpdateManyWithoutStrategyNestedInput
    translations?: StrategyTranslationUpdateManyWithoutStrategyNestedInput
  }

  export type RiskMitigationStrategyUncheckedUpdateWithoutItemCostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    strategyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    smeTitle?: NullableStringFieldUpdateOperationsInput | string | null
    smeSummary?: NullableStringFieldUpdateOperationsInput | string | null
    smeDescription?: NullableStringFieldUpdateOperationsInput | string | null
    whyImportant?: NullableStringFieldUpdateOperationsInput | string | null
    benefitsBullets?: NullableStringFieldUpdateOperationsInput | string | null
    realWorldExample?: NullableStringFieldUpdateOperationsInput | string | null
    calculatedCostUSD?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    calculatedCostLocal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currencyCode?: NullableStringFieldUpdateOperationsInput | string | null
    currencySymbol?: NullableStringFieldUpdateOperationsInput | string | null
    totalEstimatedHours?: NullableIntFieldUpdateOperationsInput | number | null
    selectionTier?: NullableStringFieldUpdateOperationsInput | string | null
    requiredForRisks?: NullableStringFieldUpdateOperationsInput | string | null
    helpfulTips?: NullableStringFieldUpdateOperationsInput | string | null
    commonMistakes?: NullableStringFieldUpdateOperationsInput | string | null
    successMetrics?: NullableStringFieldUpdateOperationsInput | string | null
    lowBudgetAlternative?: NullableStringFieldUpdateOperationsInput | string | null
    applicableRisks?: StringFieldUpdateOperationsInput | string
    applicableBusinessTypes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessTypeStrategies?: BusinessTypeStrategyUncheckedUpdateManyWithoutStrategyNestedInput
    actionSteps?: ActionStepUncheckedUpdateManyWithoutStrategyNestedInput
    translations?: StrategyTranslationUncheckedUpdateManyWithoutStrategyNestedInput
  }

  export type CostItemUpsertWithoutStrategyItemsInput = {
    update: XOR<CostItemUpdateWithoutStrategyItemsInput, CostItemUncheckedUpdateWithoutStrategyItemsInput>
    create: XOR<CostItemCreateWithoutStrategyItemsInput, CostItemUncheckedCreateWithoutStrategyItemsInput>
    where?: CostItemWhereInput
  }

  export type CostItemUpdateToOneWithWhereWithoutStrategyItemsInput = {
    where?: CostItemWhereInput
    data: XOR<CostItemUpdateWithoutStrategyItemsInput, CostItemUncheckedUpdateWithoutStrategyItemsInput>
  }

  export type CostItemUpdateWithoutStrategyItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    baseUSD?: FloatFieldUpdateOperationsInput | number
    baseUSDMin?: NullableFloatFieldUpdateOperationsInput | number | null
    baseUSDMax?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    complexity?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    budgetAlternativeId?: NullableStringFieldUpdateOperationsInput | string | null
    premiumAlternativeId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actionStepItems?: ActionStepItemCostUpdateManyWithoutItemNestedInput
  }

  export type CostItemUncheckedUpdateWithoutStrategyItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    baseUSD?: FloatFieldUpdateOperationsInput | number
    baseUSDMin?: NullableFloatFieldUpdateOperationsInput | number | null
    baseUSDMax?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    complexity?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    budgetAlternativeId?: NullableStringFieldUpdateOperationsInput | string | null
    premiumAlternativeId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actionStepItems?: ActionStepItemCostUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ActionStepCreateWithoutItemCostsInput = {
    id?: string
    stepId: string
    phase?: string
    title: string
    description: string
    smeAction?: string | null
    whyThisStepMatters?: string | null
    whatHappensIfSkipped?: string | null
    timeframe?: string | null
    estimatedMinutes?: number | null
    difficultyLevel?: string | null
    responsibility?: string | null
    estimatedCost?: string | null
    estimatedCostJMD?: string | null
    resources?: string | null
    checklist?: string | null
    howToKnowItsDone?: string | null
    exampleOutput?: string | null
    dependsOnSteps?: string | null
    isOptional?: boolean
    skipConditions?: string | null
    freeAlternative?: string | null
    lowTechOption?: string | null
    commonMistakesForStep?: string | null
    videoTutorialUrl?: string | null
    externalResourceUrl?: string | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    strategy: RiskMitigationStrategyCreateNestedOneWithoutActionStepsInput
    translations?: ActionStepTranslationCreateNestedManyWithoutActionStepInput
  }

  export type ActionStepUncheckedCreateWithoutItemCostsInput = {
    id?: string
    strategyId: string
    stepId: string
    phase?: string
    title: string
    description: string
    smeAction?: string | null
    whyThisStepMatters?: string | null
    whatHappensIfSkipped?: string | null
    timeframe?: string | null
    estimatedMinutes?: number | null
    difficultyLevel?: string | null
    responsibility?: string | null
    estimatedCost?: string | null
    estimatedCostJMD?: string | null
    resources?: string | null
    checklist?: string | null
    howToKnowItsDone?: string | null
    exampleOutput?: string | null
    dependsOnSteps?: string | null
    isOptional?: boolean
    skipConditions?: string | null
    freeAlternative?: string | null
    lowTechOption?: string | null
    commonMistakesForStep?: string | null
    videoTutorialUrl?: string | null
    externalResourceUrl?: string | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: ActionStepTranslationUncheckedCreateNestedManyWithoutActionStepInput
  }

  export type ActionStepCreateOrConnectWithoutItemCostsInput = {
    where: ActionStepWhereUniqueInput
    create: XOR<ActionStepCreateWithoutItemCostsInput, ActionStepUncheckedCreateWithoutItemCostsInput>
  }

  export type CostItemCreateWithoutActionStepItemsInput = {
    id?: string
    itemId: string
    name: string
    description?: string | null
    category: string
    baseUSD: number
    baseUSDMin?: number | null
    baseUSDMax?: number | null
    unit?: string | null
    complexity?: string
    notes?: string | null
    tags?: string | null
    budgetAlternativeId?: string | null
    premiumAlternativeId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    strategyItems?: StrategyItemCostCreateNestedManyWithoutItemInput
  }

  export type CostItemUncheckedCreateWithoutActionStepItemsInput = {
    id?: string
    itemId: string
    name: string
    description?: string | null
    category: string
    baseUSD: number
    baseUSDMin?: number | null
    baseUSDMax?: number | null
    unit?: string | null
    complexity?: string
    notes?: string | null
    tags?: string | null
    budgetAlternativeId?: string | null
    premiumAlternativeId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    strategyItems?: StrategyItemCostUncheckedCreateNestedManyWithoutItemInput
  }

  export type CostItemCreateOrConnectWithoutActionStepItemsInput = {
    where: CostItemWhereUniqueInput
    create: XOR<CostItemCreateWithoutActionStepItemsInput, CostItemUncheckedCreateWithoutActionStepItemsInput>
  }

  export type ActionStepUpsertWithoutItemCostsInput = {
    update: XOR<ActionStepUpdateWithoutItemCostsInput, ActionStepUncheckedUpdateWithoutItemCostsInput>
    create: XOR<ActionStepCreateWithoutItemCostsInput, ActionStepUncheckedCreateWithoutItemCostsInput>
    where?: ActionStepWhereInput
  }

  export type ActionStepUpdateToOneWithWhereWithoutItemCostsInput = {
    where?: ActionStepWhereInput
    data: XOR<ActionStepUpdateWithoutItemCostsInput, ActionStepUncheckedUpdateWithoutItemCostsInput>
  }

  export type ActionStepUpdateWithoutItemCostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepId?: StringFieldUpdateOperationsInput | string
    phase?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    smeAction?: NullableStringFieldUpdateOperationsInput | string | null
    whyThisStepMatters?: NullableStringFieldUpdateOperationsInput | string | null
    whatHappensIfSkipped?: NullableStringFieldUpdateOperationsInput | string | null
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    difficultyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    responsibility?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCost?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCostJMD?: NullableStringFieldUpdateOperationsInput | string | null
    resources?: NullableStringFieldUpdateOperationsInput | string | null
    checklist?: NullableStringFieldUpdateOperationsInput | string | null
    howToKnowItsDone?: NullableStringFieldUpdateOperationsInput | string | null
    exampleOutput?: NullableStringFieldUpdateOperationsInput | string | null
    dependsOnSteps?: NullableStringFieldUpdateOperationsInput | string | null
    isOptional?: BoolFieldUpdateOperationsInput | boolean
    skipConditions?: NullableStringFieldUpdateOperationsInput | string | null
    freeAlternative?: NullableStringFieldUpdateOperationsInput | string | null
    lowTechOption?: NullableStringFieldUpdateOperationsInput | string | null
    commonMistakesForStep?: NullableStringFieldUpdateOperationsInput | string | null
    videoTutorialUrl?: NullableStringFieldUpdateOperationsInput | string | null
    externalResourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    strategy?: RiskMitigationStrategyUpdateOneRequiredWithoutActionStepsNestedInput
    translations?: ActionStepTranslationUpdateManyWithoutActionStepNestedInput
  }

  export type ActionStepUncheckedUpdateWithoutItemCostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    strategyId?: StringFieldUpdateOperationsInput | string
    stepId?: StringFieldUpdateOperationsInput | string
    phase?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    smeAction?: NullableStringFieldUpdateOperationsInput | string | null
    whyThisStepMatters?: NullableStringFieldUpdateOperationsInput | string | null
    whatHappensIfSkipped?: NullableStringFieldUpdateOperationsInput | string | null
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    difficultyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    responsibility?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCost?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCostJMD?: NullableStringFieldUpdateOperationsInput | string | null
    resources?: NullableStringFieldUpdateOperationsInput | string | null
    checklist?: NullableStringFieldUpdateOperationsInput | string | null
    howToKnowItsDone?: NullableStringFieldUpdateOperationsInput | string | null
    exampleOutput?: NullableStringFieldUpdateOperationsInput | string | null
    dependsOnSteps?: NullableStringFieldUpdateOperationsInput | string | null
    isOptional?: BoolFieldUpdateOperationsInput | boolean
    skipConditions?: NullableStringFieldUpdateOperationsInput | string | null
    freeAlternative?: NullableStringFieldUpdateOperationsInput | string | null
    lowTechOption?: NullableStringFieldUpdateOperationsInput | string | null
    commonMistakesForStep?: NullableStringFieldUpdateOperationsInput | string | null
    videoTutorialUrl?: NullableStringFieldUpdateOperationsInput | string | null
    externalResourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: ActionStepTranslationUncheckedUpdateManyWithoutActionStepNestedInput
  }

  export type CostItemUpsertWithoutActionStepItemsInput = {
    update: XOR<CostItemUpdateWithoutActionStepItemsInput, CostItemUncheckedUpdateWithoutActionStepItemsInput>
    create: XOR<CostItemCreateWithoutActionStepItemsInput, CostItemUncheckedCreateWithoutActionStepItemsInput>
    where?: CostItemWhereInput
  }

  export type CostItemUpdateToOneWithWhereWithoutActionStepItemsInput = {
    where?: CostItemWhereInput
    data: XOR<CostItemUpdateWithoutActionStepItemsInput, CostItemUncheckedUpdateWithoutActionStepItemsInput>
  }

  export type CostItemUpdateWithoutActionStepItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    baseUSD?: FloatFieldUpdateOperationsInput | number
    baseUSDMin?: NullableFloatFieldUpdateOperationsInput | number | null
    baseUSDMax?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    complexity?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    budgetAlternativeId?: NullableStringFieldUpdateOperationsInput | string | null
    premiumAlternativeId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    strategyItems?: StrategyItemCostUpdateManyWithoutItemNestedInput
  }

  export type CostItemUncheckedUpdateWithoutActionStepItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    baseUSD?: FloatFieldUpdateOperationsInput | number
    baseUSDMin?: NullableFloatFieldUpdateOperationsInput | number | null
    baseUSDMax?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    complexity?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    budgetAlternativeId?: NullableStringFieldUpdateOperationsInput | string | null
    premiumAlternativeId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    strategyItems?: StrategyItemCostUncheckedUpdateManyWithoutItemNestedInput
  }

  export type BusinessTypeCreateWithoutTranslationsInput = {
    id?: string
    businessTypeId: string
    name: string
    category: string
    subcategory?: string | null
    description?: string | null
    exampleBusinessPurposes?: string | null
    exampleProducts?: string | null
    exampleKeyPersonnel?: string | null
    exampleCustomerBase?: string | null
    minimumEquipment?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    riskVulnerabilities?: BusinessRiskVulnerabilityCreateNestedManyWithoutBusinessTypeInput
    businessTypeStrategies?: BusinessTypeStrategyCreateNestedManyWithoutBusinessTypeInput
    businessRiskProfiles?: BusinessRiskProfileCreateNestedManyWithoutBusinessTypeInput
  }

  export type BusinessTypeUncheckedCreateWithoutTranslationsInput = {
    id?: string
    businessTypeId: string
    name: string
    category: string
    subcategory?: string | null
    description?: string | null
    exampleBusinessPurposes?: string | null
    exampleProducts?: string | null
    exampleKeyPersonnel?: string | null
    exampleCustomerBase?: string | null
    minimumEquipment?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    riskVulnerabilities?: BusinessRiskVulnerabilityUncheckedCreateNestedManyWithoutBusinessTypeInput
    businessTypeStrategies?: BusinessTypeStrategyUncheckedCreateNestedManyWithoutBusinessTypeInput
    businessRiskProfiles?: BusinessRiskProfileUncheckedCreateNestedManyWithoutBusinessTypeInput
  }

  export type BusinessTypeCreateOrConnectWithoutTranslationsInput = {
    where: BusinessTypeWhereUniqueInput
    create: XOR<BusinessTypeCreateWithoutTranslationsInput, BusinessTypeUncheckedCreateWithoutTranslationsInput>
  }

  export type BusinessTypeUpsertWithoutTranslationsInput = {
    update: XOR<BusinessTypeUpdateWithoutTranslationsInput, BusinessTypeUncheckedUpdateWithoutTranslationsInput>
    create: XOR<BusinessTypeCreateWithoutTranslationsInput, BusinessTypeUncheckedCreateWithoutTranslationsInput>
    where?: BusinessTypeWhereInput
  }

  export type BusinessTypeUpdateToOneWithWhereWithoutTranslationsInput = {
    where?: BusinessTypeWhereInput
    data: XOR<BusinessTypeUpdateWithoutTranslationsInput, BusinessTypeUncheckedUpdateWithoutTranslationsInput>
  }

  export type BusinessTypeUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessTypeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    exampleBusinessPurposes?: NullableStringFieldUpdateOperationsInput | string | null
    exampleProducts?: NullableStringFieldUpdateOperationsInput | string | null
    exampleKeyPersonnel?: NullableStringFieldUpdateOperationsInput | string | null
    exampleCustomerBase?: NullableStringFieldUpdateOperationsInput | string | null
    minimumEquipment?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    riskVulnerabilities?: BusinessRiskVulnerabilityUpdateManyWithoutBusinessTypeNestedInput
    businessTypeStrategies?: BusinessTypeStrategyUpdateManyWithoutBusinessTypeNestedInput
    businessRiskProfiles?: BusinessRiskProfileUpdateManyWithoutBusinessTypeNestedInput
  }

  export type BusinessTypeUncheckedUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessTypeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    exampleBusinessPurposes?: NullableStringFieldUpdateOperationsInput | string | null
    exampleProducts?: NullableStringFieldUpdateOperationsInput | string | null
    exampleKeyPersonnel?: NullableStringFieldUpdateOperationsInput | string | null
    exampleCustomerBase?: NullableStringFieldUpdateOperationsInput | string | null
    minimumEquipment?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    riskVulnerabilities?: BusinessRiskVulnerabilityUncheckedUpdateManyWithoutBusinessTypeNestedInput
    businessTypeStrategies?: BusinessTypeStrategyUncheckedUpdateManyWithoutBusinessTypeNestedInput
    businessRiskProfiles?: BusinessRiskProfileUncheckedUpdateManyWithoutBusinessTypeNestedInput
  }

  export type RiskMitigationStrategyCreateWithoutTranslationsInput = {
    id?: string
    strategyId: string
    name: string
    description: string
    smeTitle?: string | null
    smeSummary?: string | null
    smeDescription?: string | null
    whyImportant?: string | null
    benefitsBullets?: string | null
    realWorldExample?: string | null
    calculatedCostUSD?: Decimal | DecimalJsLike | number | string | null
    calculatedCostLocal?: Decimal | DecimalJsLike | number | string | null
    currencyCode?: string | null
    currencySymbol?: string | null
    totalEstimatedHours?: number | null
    selectionTier?: string | null
    requiredForRisks?: string | null
    helpfulTips?: string | null
    commonMistakes?: string | null
    successMetrics?: string | null
    lowBudgetAlternative?: string | null
    applicableRisks: string
    applicableBusinessTypes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    businessTypeStrategies?: BusinessTypeStrategyCreateNestedManyWithoutStrategyInput
    actionSteps?: ActionStepCreateNestedManyWithoutStrategyInput
    itemCosts?: StrategyItemCostCreateNestedManyWithoutStrategyInput
  }

  export type RiskMitigationStrategyUncheckedCreateWithoutTranslationsInput = {
    id?: string
    strategyId: string
    name: string
    description: string
    smeTitle?: string | null
    smeSummary?: string | null
    smeDescription?: string | null
    whyImportant?: string | null
    benefitsBullets?: string | null
    realWorldExample?: string | null
    calculatedCostUSD?: Decimal | DecimalJsLike | number | string | null
    calculatedCostLocal?: Decimal | DecimalJsLike | number | string | null
    currencyCode?: string | null
    currencySymbol?: string | null
    totalEstimatedHours?: number | null
    selectionTier?: string | null
    requiredForRisks?: string | null
    helpfulTips?: string | null
    commonMistakes?: string | null
    successMetrics?: string | null
    lowBudgetAlternative?: string | null
    applicableRisks: string
    applicableBusinessTypes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    businessTypeStrategies?: BusinessTypeStrategyUncheckedCreateNestedManyWithoutStrategyInput
    actionSteps?: ActionStepUncheckedCreateNestedManyWithoutStrategyInput
    itemCosts?: StrategyItemCostUncheckedCreateNestedManyWithoutStrategyInput
  }

  export type RiskMitigationStrategyCreateOrConnectWithoutTranslationsInput = {
    where: RiskMitigationStrategyWhereUniqueInput
    create: XOR<RiskMitigationStrategyCreateWithoutTranslationsInput, RiskMitigationStrategyUncheckedCreateWithoutTranslationsInput>
  }

  export type RiskMitigationStrategyUpsertWithoutTranslationsInput = {
    update: XOR<RiskMitigationStrategyUpdateWithoutTranslationsInput, RiskMitigationStrategyUncheckedUpdateWithoutTranslationsInput>
    create: XOR<RiskMitigationStrategyCreateWithoutTranslationsInput, RiskMitigationStrategyUncheckedCreateWithoutTranslationsInput>
    where?: RiskMitigationStrategyWhereInput
  }

  export type RiskMitigationStrategyUpdateToOneWithWhereWithoutTranslationsInput = {
    where?: RiskMitigationStrategyWhereInput
    data: XOR<RiskMitigationStrategyUpdateWithoutTranslationsInput, RiskMitigationStrategyUncheckedUpdateWithoutTranslationsInput>
  }

  export type RiskMitigationStrategyUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    strategyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    smeTitle?: NullableStringFieldUpdateOperationsInput | string | null
    smeSummary?: NullableStringFieldUpdateOperationsInput | string | null
    smeDescription?: NullableStringFieldUpdateOperationsInput | string | null
    whyImportant?: NullableStringFieldUpdateOperationsInput | string | null
    benefitsBullets?: NullableStringFieldUpdateOperationsInput | string | null
    realWorldExample?: NullableStringFieldUpdateOperationsInput | string | null
    calculatedCostUSD?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    calculatedCostLocal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currencyCode?: NullableStringFieldUpdateOperationsInput | string | null
    currencySymbol?: NullableStringFieldUpdateOperationsInput | string | null
    totalEstimatedHours?: NullableIntFieldUpdateOperationsInput | number | null
    selectionTier?: NullableStringFieldUpdateOperationsInput | string | null
    requiredForRisks?: NullableStringFieldUpdateOperationsInput | string | null
    helpfulTips?: NullableStringFieldUpdateOperationsInput | string | null
    commonMistakes?: NullableStringFieldUpdateOperationsInput | string | null
    successMetrics?: NullableStringFieldUpdateOperationsInput | string | null
    lowBudgetAlternative?: NullableStringFieldUpdateOperationsInput | string | null
    applicableRisks?: StringFieldUpdateOperationsInput | string
    applicableBusinessTypes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessTypeStrategies?: BusinessTypeStrategyUpdateManyWithoutStrategyNestedInput
    actionSteps?: ActionStepUpdateManyWithoutStrategyNestedInput
    itemCosts?: StrategyItemCostUpdateManyWithoutStrategyNestedInput
  }

  export type RiskMitigationStrategyUncheckedUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    strategyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    smeTitle?: NullableStringFieldUpdateOperationsInput | string | null
    smeSummary?: NullableStringFieldUpdateOperationsInput | string | null
    smeDescription?: NullableStringFieldUpdateOperationsInput | string | null
    whyImportant?: NullableStringFieldUpdateOperationsInput | string | null
    benefitsBullets?: NullableStringFieldUpdateOperationsInput | string | null
    realWorldExample?: NullableStringFieldUpdateOperationsInput | string | null
    calculatedCostUSD?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    calculatedCostLocal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currencyCode?: NullableStringFieldUpdateOperationsInput | string | null
    currencySymbol?: NullableStringFieldUpdateOperationsInput | string | null
    totalEstimatedHours?: NullableIntFieldUpdateOperationsInput | number | null
    selectionTier?: NullableStringFieldUpdateOperationsInput | string | null
    requiredForRisks?: NullableStringFieldUpdateOperationsInput | string | null
    helpfulTips?: NullableStringFieldUpdateOperationsInput | string | null
    commonMistakes?: NullableStringFieldUpdateOperationsInput | string | null
    successMetrics?: NullableStringFieldUpdateOperationsInput | string | null
    lowBudgetAlternative?: NullableStringFieldUpdateOperationsInput | string | null
    applicableRisks?: StringFieldUpdateOperationsInput | string
    applicableBusinessTypes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessTypeStrategies?: BusinessTypeStrategyUncheckedUpdateManyWithoutStrategyNestedInput
    actionSteps?: ActionStepUncheckedUpdateManyWithoutStrategyNestedInput
    itemCosts?: StrategyItemCostUncheckedUpdateManyWithoutStrategyNestedInput
  }

  export type ActionStepCreateWithoutTranslationsInput = {
    id?: string
    stepId: string
    phase?: string
    title: string
    description: string
    smeAction?: string | null
    whyThisStepMatters?: string | null
    whatHappensIfSkipped?: string | null
    timeframe?: string | null
    estimatedMinutes?: number | null
    difficultyLevel?: string | null
    responsibility?: string | null
    estimatedCost?: string | null
    estimatedCostJMD?: string | null
    resources?: string | null
    checklist?: string | null
    howToKnowItsDone?: string | null
    exampleOutput?: string | null
    dependsOnSteps?: string | null
    isOptional?: boolean
    skipConditions?: string | null
    freeAlternative?: string | null
    lowTechOption?: string | null
    commonMistakesForStep?: string | null
    videoTutorialUrl?: string | null
    externalResourceUrl?: string | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    strategy: RiskMitigationStrategyCreateNestedOneWithoutActionStepsInput
    itemCosts?: ActionStepItemCostCreateNestedManyWithoutActionStepInput
  }

  export type ActionStepUncheckedCreateWithoutTranslationsInput = {
    id?: string
    strategyId: string
    stepId: string
    phase?: string
    title: string
    description: string
    smeAction?: string | null
    whyThisStepMatters?: string | null
    whatHappensIfSkipped?: string | null
    timeframe?: string | null
    estimatedMinutes?: number | null
    difficultyLevel?: string | null
    responsibility?: string | null
    estimatedCost?: string | null
    estimatedCostJMD?: string | null
    resources?: string | null
    checklist?: string | null
    howToKnowItsDone?: string | null
    exampleOutput?: string | null
    dependsOnSteps?: string | null
    isOptional?: boolean
    skipConditions?: string | null
    freeAlternative?: string | null
    lowTechOption?: string | null
    commonMistakesForStep?: string | null
    videoTutorialUrl?: string | null
    externalResourceUrl?: string | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    itemCosts?: ActionStepItemCostUncheckedCreateNestedManyWithoutActionStepInput
  }

  export type ActionStepCreateOrConnectWithoutTranslationsInput = {
    where: ActionStepWhereUniqueInput
    create: XOR<ActionStepCreateWithoutTranslationsInput, ActionStepUncheckedCreateWithoutTranslationsInput>
  }

  export type ActionStepUpsertWithoutTranslationsInput = {
    update: XOR<ActionStepUpdateWithoutTranslationsInput, ActionStepUncheckedUpdateWithoutTranslationsInput>
    create: XOR<ActionStepCreateWithoutTranslationsInput, ActionStepUncheckedCreateWithoutTranslationsInput>
    where?: ActionStepWhereInput
  }

  export type ActionStepUpdateToOneWithWhereWithoutTranslationsInput = {
    where?: ActionStepWhereInput
    data: XOR<ActionStepUpdateWithoutTranslationsInput, ActionStepUncheckedUpdateWithoutTranslationsInput>
  }

  export type ActionStepUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepId?: StringFieldUpdateOperationsInput | string
    phase?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    smeAction?: NullableStringFieldUpdateOperationsInput | string | null
    whyThisStepMatters?: NullableStringFieldUpdateOperationsInput | string | null
    whatHappensIfSkipped?: NullableStringFieldUpdateOperationsInput | string | null
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    difficultyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    responsibility?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCost?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCostJMD?: NullableStringFieldUpdateOperationsInput | string | null
    resources?: NullableStringFieldUpdateOperationsInput | string | null
    checklist?: NullableStringFieldUpdateOperationsInput | string | null
    howToKnowItsDone?: NullableStringFieldUpdateOperationsInput | string | null
    exampleOutput?: NullableStringFieldUpdateOperationsInput | string | null
    dependsOnSteps?: NullableStringFieldUpdateOperationsInput | string | null
    isOptional?: BoolFieldUpdateOperationsInput | boolean
    skipConditions?: NullableStringFieldUpdateOperationsInput | string | null
    freeAlternative?: NullableStringFieldUpdateOperationsInput | string | null
    lowTechOption?: NullableStringFieldUpdateOperationsInput | string | null
    commonMistakesForStep?: NullableStringFieldUpdateOperationsInput | string | null
    videoTutorialUrl?: NullableStringFieldUpdateOperationsInput | string | null
    externalResourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    strategy?: RiskMitigationStrategyUpdateOneRequiredWithoutActionStepsNestedInput
    itemCosts?: ActionStepItemCostUpdateManyWithoutActionStepNestedInput
  }

  export type ActionStepUncheckedUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    strategyId?: StringFieldUpdateOperationsInput | string
    stepId?: StringFieldUpdateOperationsInput | string
    phase?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    smeAction?: NullableStringFieldUpdateOperationsInput | string | null
    whyThisStepMatters?: NullableStringFieldUpdateOperationsInput | string | null
    whatHappensIfSkipped?: NullableStringFieldUpdateOperationsInput | string | null
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    difficultyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    responsibility?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCost?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCostJMD?: NullableStringFieldUpdateOperationsInput | string | null
    resources?: NullableStringFieldUpdateOperationsInput | string | null
    checklist?: NullableStringFieldUpdateOperationsInput | string | null
    howToKnowItsDone?: NullableStringFieldUpdateOperationsInput | string | null
    exampleOutput?: NullableStringFieldUpdateOperationsInput | string | null
    dependsOnSteps?: NullableStringFieldUpdateOperationsInput | string | null
    isOptional?: BoolFieldUpdateOperationsInput | boolean
    skipConditions?: NullableStringFieldUpdateOperationsInput | string | null
    freeAlternative?: NullableStringFieldUpdateOperationsInput | string | null
    lowTechOption?: NullableStringFieldUpdateOperationsInput | string | null
    commonMistakesForStep?: NullableStringFieldUpdateOperationsInput | string | null
    videoTutorialUrl?: NullableStringFieldUpdateOperationsInput | string | null
    externalResourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itemCosts?: ActionStepItemCostUncheckedUpdateManyWithoutActionStepNestedInput
  }

  export type AdminHazardTypeCreateWithoutTranslationsInput = {
    id?: string
    hazardId: string
    name: string
    category: string
    description?: string | null
    defaultFrequency: string
    defaultImpact: string
    seasonalPattern?: string | null
    peakMonths?: string | null
    warningTime?: string | null
    geographicScope?: string | null
    cascadingRisks?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    businessTypeHazards?: AdminBusinessTypeHazardCreateNestedManyWithoutHazardInput
    locationHazards?: AdminLocationHazardCreateNestedManyWithoutHazardInput
    hazardStrategies?: AdminHazardStrategyCreateNestedManyWithoutHazardInput
    hazardActionPlans?: AdminHazardActionPlanCreateNestedManyWithoutHazardInput
    AdminActionPlan?: AdminActionPlanCreateNestedOneWithoutHazardInput
  }

  export type AdminHazardTypeUncheckedCreateWithoutTranslationsInput = {
    id?: string
    hazardId: string
    name: string
    category: string
    description?: string | null
    defaultFrequency: string
    defaultImpact: string
    seasonalPattern?: string | null
    peakMonths?: string | null
    warningTime?: string | null
    geographicScope?: string | null
    cascadingRisks?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    businessTypeHazards?: AdminBusinessTypeHazardUncheckedCreateNestedManyWithoutHazardInput
    locationHazards?: AdminLocationHazardUncheckedCreateNestedManyWithoutHazardInput
    hazardStrategies?: AdminHazardStrategyUncheckedCreateNestedManyWithoutHazardInput
    hazardActionPlans?: AdminHazardActionPlanUncheckedCreateNestedManyWithoutHazardInput
    AdminActionPlan?: AdminActionPlanUncheckedCreateNestedOneWithoutHazardInput
  }

  export type AdminHazardTypeCreateOrConnectWithoutTranslationsInput = {
    where: AdminHazardTypeWhereUniqueInput
    create: XOR<AdminHazardTypeCreateWithoutTranslationsInput, AdminHazardTypeUncheckedCreateWithoutTranslationsInput>
  }

  export type AdminHazardTypeUpsertWithoutTranslationsInput = {
    update: XOR<AdminHazardTypeUpdateWithoutTranslationsInput, AdminHazardTypeUncheckedUpdateWithoutTranslationsInput>
    create: XOR<AdminHazardTypeCreateWithoutTranslationsInput, AdminHazardTypeUncheckedCreateWithoutTranslationsInput>
    where?: AdminHazardTypeWhereInput
  }

  export type AdminHazardTypeUpdateToOneWithWhereWithoutTranslationsInput = {
    where?: AdminHazardTypeWhereInput
    data: XOR<AdminHazardTypeUpdateWithoutTranslationsInput, AdminHazardTypeUncheckedUpdateWithoutTranslationsInput>
  }

  export type AdminHazardTypeUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    hazardId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultFrequency?: StringFieldUpdateOperationsInput | string
    defaultImpact?: StringFieldUpdateOperationsInput | string
    seasonalPattern?: NullableStringFieldUpdateOperationsInput | string | null
    peakMonths?: NullableStringFieldUpdateOperationsInput | string | null
    warningTime?: NullableStringFieldUpdateOperationsInput | string | null
    geographicScope?: NullableStringFieldUpdateOperationsInput | string | null
    cascadingRisks?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessTypeHazards?: AdminBusinessTypeHazardUpdateManyWithoutHazardNestedInput
    locationHazards?: AdminLocationHazardUpdateManyWithoutHazardNestedInput
    hazardStrategies?: AdminHazardStrategyUpdateManyWithoutHazardNestedInput
    hazardActionPlans?: AdminHazardActionPlanUpdateManyWithoutHazardNestedInput
    AdminActionPlan?: AdminActionPlanUpdateOneWithoutHazardNestedInput
  }

  export type AdminHazardTypeUncheckedUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    hazardId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultFrequency?: StringFieldUpdateOperationsInput | string
    defaultImpact?: StringFieldUpdateOperationsInput | string
    seasonalPattern?: NullableStringFieldUpdateOperationsInput | string | null
    peakMonths?: NullableStringFieldUpdateOperationsInput | string | null
    warningTime?: NullableStringFieldUpdateOperationsInput | string | null
    geographicScope?: NullableStringFieldUpdateOperationsInput | string | null
    cascadingRisks?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessTypeHazards?: AdminBusinessTypeHazardUncheckedUpdateManyWithoutHazardNestedInput
    locationHazards?: AdminLocationHazardUncheckedUpdateManyWithoutHazardNestedInput
    hazardStrategies?: AdminHazardStrategyUncheckedUpdateManyWithoutHazardNestedInput
    hazardActionPlans?: AdminHazardActionPlanUncheckedUpdateManyWithoutHazardNestedInput
    AdminActionPlan?: AdminActionPlanUncheckedUpdateOneWithoutHazardNestedInput
  }

  export type RiskMultiplierCreateWithoutTranslationsInput = {
    id?: string
    name: string
    description: string
    characteristicType: string
    conditionType: string
    thresholdValue?: number | null
    minValue?: number | null
    maxValue?: number | null
    multiplierFactor: number
    applicableHazards: string
    wizardQuestion?: string | null
    wizardAnswerOptions?: string | null
    wizardHelpText?: string | null
    isActive?: boolean
    priority?: number
    reasoning?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string
  }

  export type RiskMultiplierUncheckedCreateWithoutTranslationsInput = {
    id?: string
    name: string
    description: string
    characteristicType: string
    conditionType: string
    thresholdValue?: number | null
    minValue?: number | null
    maxValue?: number | null
    multiplierFactor: number
    applicableHazards: string
    wizardQuestion?: string | null
    wizardAnswerOptions?: string | null
    wizardHelpText?: string | null
    isActive?: boolean
    priority?: number
    reasoning?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string
  }

  export type RiskMultiplierCreateOrConnectWithoutTranslationsInput = {
    where: RiskMultiplierWhereUniqueInput
    create: XOR<RiskMultiplierCreateWithoutTranslationsInput, RiskMultiplierUncheckedCreateWithoutTranslationsInput>
  }

  export type RiskMultiplierUpsertWithoutTranslationsInput = {
    update: XOR<RiskMultiplierUpdateWithoutTranslationsInput, RiskMultiplierUncheckedUpdateWithoutTranslationsInput>
    create: XOR<RiskMultiplierCreateWithoutTranslationsInput, RiskMultiplierUncheckedCreateWithoutTranslationsInput>
    where?: RiskMultiplierWhereInput
  }

  export type RiskMultiplierUpdateToOneWithWhereWithoutTranslationsInput = {
    where?: RiskMultiplierWhereInput
    data: XOR<RiskMultiplierUpdateWithoutTranslationsInput, RiskMultiplierUncheckedUpdateWithoutTranslationsInput>
  }

  export type RiskMultiplierUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    characteristicType?: StringFieldUpdateOperationsInput | string
    conditionType?: StringFieldUpdateOperationsInput | string
    thresholdValue?: NullableFloatFieldUpdateOperationsInput | number | null
    minValue?: NullableFloatFieldUpdateOperationsInput | number | null
    maxValue?: NullableFloatFieldUpdateOperationsInput | number | null
    multiplierFactor?: FloatFieldUpdateOperationsInput | number
    applicableHazards?: StringFieldUpdateOperationsInput | string
    wizardQuestion?: NullableStringFieldUpdateOperationsInput | string | null
    wizardAnswerOptions?: NullableStringFieldUpdateOperationsInput | string | null
    wizardHelpText?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type RiskMultiplierUncheckedUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    characteristicType?: StringFieldUpdateOperationsInput | string
    conditionType?: StringFieldUpdateOperationsInput | string
    thresholdValue?: NullableFloatFieldUpdateOperationsInput | number | null
    minValue?: NullableFloatFieldUpdateOperationsInput | number | null
    maxValue?: NullableFloatFieldUpdateOperationsInput | number | null
    multiplierFactor?: FloatFieldUpdateOperationsInput | number
    applicableHazards?: StringFieldUpdateOperationsInput | string
    wizardQuestion?: NullableStringFieldUpdateOperationsInput | string | null
    wizardAnswerOptions?: NullableStringFieldUpdateOperationsInput | string | null
    wizardHelpText?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type AdminBusinessTypeHazardCreateManyBusinessTypeInput = {
    id?: string
    hazardId: string
    riskLevel: string
    frequency?: string | null
    impact?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminRiskProfileCreateManyBusinessTypeInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    locationId: string
    calculatedRisks: string
    recommendedStrategies: string
    lastCalculated?: Date | string
    riskScore: number
  }

  export type AdminBusinessTypeHazardUpdateWithoutBusinessTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    riskLevel?: StringFieldUpdateOperationsInput | string
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    impact?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hazard?: AdminHazardTypeUpdateOneRequiredWithoutBusinessTypeHazardsNestedInput
  }

  export type AdminBusinessTypeHazardUncheckedUpdateWithoutBusinessTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    hazardId?: StringFieldUpdateOperationsInput | string
    riskLevel?: StringFieldUpdateOperationsInput | string
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    impact?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminBusinessTypeHazardUncheckedUpdateManyWithoutBusinessTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    hazardId?: StringFieldUpdateOperationsInput | string
    riskLevel?: StringFieldUpdateOperationsInput | string
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    impact?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminRiskProfileUpdateWithoutBusinessTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calculatedRisks?: StringFieldUpdateOperationsInput | string
    recommendedStrategies?: StringFieldUpdateOperationsInput | string
    lastCalculated?: DateTimeFieldUpdateOperationsInput | Date | string
    riskScore?: IntFieldUpdateOperationsInput | number
    location?: AdminLocationUpdateOneRequiredWithoutRiskProfilesNestedInput
  }

  export type AdminRiskProfileUncheckedUpdateWithoutBusinessTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: StringFieldUpdateOperationsInput | string
    calculatedRisks?: StringFieldUpdateOperationsInput | string
    recommendedStrategies?: StringFieldUpdateOperationsInput | string
    lastCalculated?: DateTimeFieldUpdateOperationsInput | Date | string
    riskScore?: IntFieldUpdateOperationsInput | number
  }

  export type AdminRiskProfileUncheckedUpdateManyWithoutBusinessTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: StringFieldUpdateOperationsInput | string
    calculatedRisks?: StringFieldUpdateOperationsInput | string
    recommendedStrategies?: StringFieldUpdateOperationsInput | string
    lastCalculated?: DateTimeFieldUpdateOperationsInput | Date | string
    riskScore?: IntFieldUpdateOperationsInput | number
  }

  export type AdminBusinessTypeHazardCreateManyHazardInput = {
    id?: string
    businessTypeId: string
    riskLevel: string
    frequency?: string | null
    impact?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminLocationHazardCreateManyHazardInput = {
    id?: string
    locationId: string
    riskLevel: string
    frequency?: string | null
    impact?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminHazardStrategyCreateManyHazardInput = {
    id?: string
    strategyId: string
    businessTypes?: string | null
    priority?: string
    isRecommended?: boolean
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminHazardActionPlanCreateManyHazardInput = {
    id?: string
    actionPlanId: string
    businessTypes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HazardTranslationCreateManyHazardInput = {
    id?: string
    locale: string
    name: string
    description?: string | null
    impact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminBusinessTypeHazardUpdateWithoutHazardInput = {
    id?: StringFieldUpdateOperationsInput | string
    riskLevel?: StringFieldUpdateOperationsInput | string
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    impact?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessType?: AdminBusinessTypeUpdateOneRequiredWithoutBusinessTypeHazardsNestedInput
  }

  export type AdminBusinessTypeHazardUncheckedUpdateWithoutHazardInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessTypeId?: StringFieldUpdateOperationsInput | string
    riskLevel?: StringFieldUpdateOperationsInput | string
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    impact?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminBusinessTypeHazardUncheckedUpdateManyWithoutHazardInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessTypeId?: StringFieldUpdateOperationsInput | string
    riskLevel?: StringFieldUpdateOperationsInput | string
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    impact?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminLocationHazardUpdateWithoutHazardInput = {
    id?: StringFieldUpdateOperationsInput | string
    riskLevel?: StringFieldUpdateOperationsInput | string
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    impact?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: AdminLocationUpdateOneRequiredWithoutLocationHazardsNestedInput
  }

  export type AdminLocationHazardUncheckedUpdateWithoutHazardInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    riskLevel?: StringFieldUpdateOperationsInput | string
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    impact?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminLocationHazardUncheckedUpdateManyWithoutHazardInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    riskLevel?: StringFieldUpdateOperationsInput | string
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    impact?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminHazardStrategyUpdateWithoutHazardInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessTypes?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    isRecommended?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    strategy?: AdminStrategyUpdateOneRequiredWithoutHazardStrategiesNestedInput
  }

  export type AdminHazardStrategyUncheckedUpdateWithoutHazardInput = {
    id?: StringFieldUpdateOperationsInput | string
    strategyId?: StringFieldUpdateOperationsInput | string
    businessTypes?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    isRecommended?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminHazardStrategyUncheckedUpdateManyWithoutHazardInput = {
    id?: StringFieldUpdateOperationsInput | string
    strategyId?: StringFieldUpdateOperationsInput | string
    businessTypes?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    isRecommended?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminHazardActionPlanUpdateWithoutHazardInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessTypes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actionPlan?: AdminActionPlanUpdateOneRequiredWithoutAdminHazardActionPlanNestedInput
  }

  export type AdminHazardActionPlanUncheckedUpdateWithoutHazardInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionPlanId?: StringFieldUpdateOperationsInput | string
    businessTypes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminHazardActionPlanUncheckedUpdateManyWithoutHazardInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionPlanId?: StringFieldUpdateOperationsInput | string
    businessTypes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HazardTranslationUpdateWithoutHazardInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    impact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HazardTranslationUncheckedUpdateWithoutHazardInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    impact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HazardTranslationUncheckedUpdateManyWithoutHazardInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    impact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminLocationHazardCreateManyLocationInput = {
    id?: string
    hazardId: string
    riskLevel: string
    frequency?: string | null
    impact?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminRiskProfileCreateManyLocationInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    businessTypeId: string
    calculatedRisks: string
    recommendedStrategies: string
    lastCalculated?: Date | string
    riskScore: number
  }

  export type AdminLocationHazardUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    riskLevel?: StringFieldUpdateOperationsInput | string
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    impact?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hazard?: AdminHazardTypeUpdateOneRequiredWithoutLocationHazardsNestedInput
  }

  export type AdminLocationHazardUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    hazardId?: StringFieldUpdateOperationsInput | string
    riskLevel?: StringFieldUpdateOperationsInput | string
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    impact?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminLocationHazardUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    hazardId?: StringFieldUpdateOperationsInput | string
    riskLevel?: StringFieldUpdateOperationsInput | string
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    impact?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminRiskProfileUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calculatedRisks?: StringFieldUpdateOperationsInput | string
    recommendedStrategies?: StringFieldUpdateOperationsInput | string
    lastCalculated?: DateTimeFieldUpdateOperationsInput | Date | string
    riskScore?: IntFieldUpdateOperationsInput | number
    businessType?: AdminBusinessTypeUpdateOneRequiredWithoutRiskProfilesNestedInput
  }

  export type AdminRiskProfileUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessTypeId?: StringFieldUpdateOperationsInput | string
    calculatedRisks?: StringFieldUpdateOperationsInput | string
    recommendedStrategies?: StringFieldUpdateOperationsInput | string
    lastCalculated?: DateTimeFieldUpdateOperationsInput | Date | string
    riskScore?: IntFieldUpdateOperationsInput | number
  }

  export type AdminRiskProfileUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessTypeId?: StringFieldUpdateOperationsInput | string
    calculatedRisks?: StringFieldUpdateOperationsInput | string
    recommendedStrategies?: StringFieldUpdateOperationsInput | string
    lastCalculated?: DateTimeFieldUpdateOperationsInput | Date | string
    riskScore?: IntFieldUpdateOperationsInput | number
  }

  export type AdminHazardStrategyCreateManyStrategyInput = {
    id?: string
    hazardId: string
    businessTypes?: string | null
    priority?: string
    isRecommended?: boolean
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminHazardStrategyUpdateWithoutStrategyInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessTypes?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    isRecommended?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hazard?: AdminHazardTypeUpdateOneRequiredWithoutHazardStrategiesNestedInput
  }

  export type AdminHazardStrategyUncheckedUpdateWithoutStrategyInput = {
    id?: StringFieldUpdateOperationsInput | string
    hazardId?: StringFieldUpdateOperationsInput | string
    businessTypes?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    isRecommended?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminHazardStrategyUncheckedUpdateManyWithoutStrategyInput = {
    id?: StringFieldUpdateOperationsInput | string
    hazardId?: StringFieldUpdateOperationsInput | string
    businessTypes?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    isRecommended?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminHazardActionPlanCreateManyActionPlanInput = {
    id?: string
    hazardId: string
    businessTypes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminHazardActionPlanUpdateWithoutActionPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessTypes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hazard?: AdminHazardTypeUpdateOneRequiredWithoutHazardActionPlansNestedInput
  }

  export type AdminHazardActionPlanUncheckedUpdateWithoutActionPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    hazardId?: StringFieldUpdateOperationsInput | string
    businessTypes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminHazardActionPlanUncheckedUpdateManyWithoutActionPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    hazardId?: StringFieldUpdateOperationsInput | string
    businessTypes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUnitCreateManyCountryInput = {
    id?: string
    name: string
    localName?: string | null
    type?: string
    region?: string | null
    population?: number
    area?: number | null
    elevation?: number | null
    coordinates?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
  }

  export type AdminUnitUpdateWithoutCountryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    localName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    population?: IntFieldUpdateOperationsInput | number
    area?: NullableFloatFieldUpdateOperationsInput | number | null
    elevation?: NullableFloatFieldUpdateOperationsInput | number | null
    coordinates?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    adminUnitRisk?: AdminUnitRiskUpdateOneWithoutAdminUnitNestedInput
  }

  export type AdminUnitUncheckedUpdateWithoutCountryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    localName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    population?: IntFieldUpdateOperationsInput | number
    area?: NullableFloatFieldUpdateOperationsInput | number | null
    elevation?: NullableFloatFieldUpdateOperationsInput | number | null
    coordinates?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    adminUnitRisk?: AdminUnitRiskUncheckedUpdateOneWithoutAdminUnitNestedInput
  }

  export type AdminUnitUncheckedUpdateManyWithoutCountryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    localName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    population?: IntFieldUpdateOperationsInput | number
    area?: NullableFloatFieldUpdateOperationsInput | number | null
    elevation?: NullableFloatFieldUpdateOperationsInput | number | null
    coordinates?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BusinessRiskProfileCreateManyParishInput = {
    id?: string
    businessTypeId: string
    combinedRisks: string
    recommendedStrategies: string
    overallRiskScore: number
    priorityActions?: string | null
    calculatedAt?: Date | string
    calculatedBy?: string | null
    isActive?: boolean
  }

  export type BusinessRiskProfileUpdateWithoutParishInput = {
    id?: StringFieldUpdateOperationsInput | string
    combinedRisks?: StringFieldUpdateOperationsInput | string
    recommendedStrategies?: StringFieldUpdateOperationsInput | string
    overallRiskScore?: IntFieldUpdateOperationsInput | number
    priorityActions?: NullableStringFieldUpdateOperationsInput | string | null
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calculatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    businessType?: BusinessTypeUpdateOneRequiredWithoutBusinessRiskProfilesNestedInput
  }

  export type BusinessRiskProfileUncheckedUpdateWithoutParishInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessTypeId?: StringFieldUpdateOperationsInput | string
    combinedRisks?: StringFieldUpdateOperationsInput | string
    recommendedStrategies?: StringFieldUpdateOperationsInput | string
    overallRiskScore?: IntFieldUpdateOperationsInput | number
    priorityActions?: NullableStringFieldUpdateOperationsInput | string | null
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calculatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BusinessRiskProfileUncheckedUpdateManyWithoutParishInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessTypeId?: StringFieldUpdateOperationsInput | string
    combinedRisks?: StringFieldUpdateOperationsInput | string
    recommendedStrategies?: StringFieldUpdateOperationsInput | string
    overallRiskScore?: IntFieldUpdateOperationsInput | number
    priorityActions?: NullableStringFieldUpdateOperationsInput | string | null
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calculatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AdminUnitRiskChangeLogCreateManyAdminUnitRiskInput = {
    id?: string
    riskType: string
    oldLevel: number
    newLevel: number
    oldNotes?: string
    newNotes?: string
    changedBy: string
    changeReason?: string | null
    createdAt?: Date | string
  }

  export type AdminUnitRiskChangeLogUpdateWithoutAdminUnitRiskInput = {
    id?: StringFieldUpdateOperationsInput | string
    riskType?: StringFieldUpdateOperationsInput | string
    oldLevel?: IntFieldUpdateOperationsInput | number
    newLevel?: IntFieldUpdateOperationsInput | number
    oldNotes?: StringFieldUpdateOperationsInput | string
    newNotes?: StringFieldUpdateOperationsInput | string
    changedBy?: StringFieldUpdateOperationsInput | string
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUnitRiskChangeLogUncheckedUpdateWithoutAdminUnitRiskInput = {
    id?: StringFieldUpdateOperationsInput | string
    riskType?: StringFieldUpdateOperationsInput | string
    oldLevel?: IntFieldUpdateOperationsInput | number
    newLevel?: IntFieldUpdateOperationsInput | number
    oldNotes?: StringFieldUpdateOperationsInput | string
    newNotes?: StringFieldUpdateOperationsInput | string
    changedBy?: StringFieldUpdateOperationsInput | string
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUnitRiskChangeLogUncheckedUpdateManyWithoutAdminUnitRiskInput = {
    id?: StringFieldUpdateOperationsInput | string
    riskType?: StringFieldUpdateOperationsInput | string
    oldLevel?: IntFieldUpdateOperationsInput | number
    newLevel?: IntFieldUpdateOperationsInput | number
    oldNotes?: StringFieldUpdateOperationsInput | string
    newNotes?: StringFieldUpdateOperationsInput | string
    changedBy?: StringFieldUpdateOperationsInput | string
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RiskChangeLogCreateManyParishRiskInput = {
    id?: string
    riskType: string
    oldLevel: number
    newLevel: number
    oldNotes?: string
    newNotes?: string
    changedBy: string
    changeReason?: string | null
    createdAt?: Date | string
  }

  export type RiskChangeLogUpdateWithoutParishRiskInput = {
    id?: StringFieldUpdateOperationsInput | string
    riskType?: StringFieldUpdateOperationsInput | string
    oldLevel?: IntFieldUpdateOperationsInput | number
    newLevel?: IntFieldUpdateOperationsInput | number
    oldNotes?: StringFieldUpdateOperationsInput | string
    newNotes?: StringFieldUpdateOperationsInput | string
    changedBy?: StringFieldUpdateOperationsInput | string
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RiskChangeLogUncheckedUpdateWithoutParishRiskInput = {
    id?: StringFieldUpdateOperationsInput | string
    riskType?: StringFieldUpdateOperationsInput | string
    oldLevel?: IntFieldUpdateOperationsInput | number
    newLevel?: IntFieldUpdateOperationsInput | number
    oldNotes?: StringFieldUpdateOperationsInput | string
    newNotes?: StringFieldUpdateOperationsInput | string
    changedBy?: StringFieldUpdateOperationsInput | string
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RiskChangeLogUncheckedUpdateManyWithoutParishRiskInput = {
    id?: StringFieldUpdateOperationsInput | string
    riskType?: StringFieldUpdateOperationsInput | string
    oldLevel?: IntFieldUpdateOperationsInput | number
    newLevel?: IntFieldUpdateOperationsInput | number
    oldNotes?: StringFieldUpdateOperationsInput | string
    newNotes?: StringFieldUpdateOperationsInput | string
    changedBy?: StringFieldUpdateOperationsInput | string
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessRiskVulnerabilityCreateManyBusinessTypeInput = {
    id?: string
    riskType: string
    vulnerabilityLevel?: number
    impactSeverity?: number
    recoveryTime?: string | null
    reasoning?: string
    mitigationDifficulty?: number | null
    costToRecover?: string | null
    businessImpactAreas?: string | null
    criticalDependencies?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusinessTypeStrategyCreateManyBusinessTypeInput = {
    id?: string
    strategyId: string
    relevanceScore?: number | null
    customNotes?: string | null
    isRecommended?: boolean | null
    priority?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusinessRiskProfileCreateManyBusinessTypeInput = {
    id?: string
    parishId: string
    combinedRisks: string
    recommendedStrategies: string
    overallRiskScore: number
    priorityActions?: string | null
    calculatedAt?: Date | string
    calculatedBy?: string | null
    isActive?: boolean
  }

  export type BusinessTypeTranslationCreateManyBusinessTypeInput = {
    id?: string
    locale: string
    name: string
    description?: string | null
    exampleBusinessPurposes?: NullableJsonNullValueInput | InputJsonValue
    exampleProducts?: NullableJsonNullValueInput | InputJsonValue
    exampleKeyPersonnel?: NullableJsonNullValueInput | InputJsonValue
    exampleCustomerBase?: NullableJsonNullValueInput | InputJsonValue
    minimumEquipment?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusinessRiskVulnerabilityUpdateWithoutBusinessTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    riskType?: StringFieldUpdateOperationsInput | string
    vulnerabilityLevel?: IntFieldUpdateOperationsInput | number
    impactSeverity?: IntFieldUpdateOperationsInput | number
    recoveryTime?: NullableStringFieldUpdateOperationsInput | string | null
    reasoning?: StringFieldUpdateOperationsInput | string
    mitigationDifficulty?: NullableIntFieldUpdateOperationsInput | number | null
    costToRecover?: NullableStringFieldUpdateOperationsInput | string | null
    businessImpactAreas?: NullableStringFieldUpdateOperationsInput | string | null
    criticalDependencies?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessRiskVulnerabilityUncheckedUpdateWithoutBusinessTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    riskType?: StringFieldUpdateOperationsInput | string
    vulnerabilityLevel?: IntFieldUpdateOperationsInput | number
    impactSeverity?: IntFieldUpdateOperationsInput | number
    recoveryTime?: NullableStringFieldUpdateOperationsInput | string | null
    reasoning?: StringFieldUpdateOperationsInput | string
    mitigationDifficulty?: NullableIntFieldUpdateOperationsInput | number | null
    costToRecover?: NullableStringFieldUpdateOperationsInput | string | null
    businessImpactAreas?: NullableStringFieldUpdateOperationsInput | string | null
    criticalDependencies?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessRiskVulnerabilityUncheckedUpdateManyWithoutBusinessTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    riskType?: StringFieldUpdateOperationsInput | string
    vulnerabilityLevel?: IntFieldUpdateOperationsInput | number
    impactSeverity?: IntFieldUpdateOperationsInput | number
    recoveryTime?: NullableStringFieldUpdateOperationsInput | string | null
    reasoning?: StringFieldUpdateOperationsInput | string
    mitigationDifficulty?: NullableIntFieldUpdateOperationsInput | number | null
    costToRecover?: NullableStringFieldUpdateOperationsInput | string | null
    businessImpactAreas?: NullableStringFieldUpdateOperationsInput | string | null
    criticalDependencies?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessTypeStrategyUpdateWithoutBusinessTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    relevanceScore?: NullableIntFieldUpdateOperationsInput | number | null
    customNotes?: NullableStringFieldUpdateOperationsInput | string | null
    isRecommended?: NullableBoolFieldUpdateOperationsInput | boolean | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    strategy?: RiskMitigationStrategyUpdateOneRequiredWithoutBusinessTypeStrategiesNestedInput
  }

  export type BusinessTypeStrategyUncheckedUpdateWithoutBusinessTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    strategyId?: StringFieldUpdateOperationsInput | string
    relevanceScore?: NullableIntFieldUpdateOperationsInput | number | null
    customNotes?: NullableStringFieldUpdateOperationsInput | string | null
    isRecommended?: NullableBoolFieldUpdateOperationsInput | boolean | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessTypeStrategyUncheckedUpdateManyWithoutBusinessTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    strategyId?: StringFieldUpdateOperationsInput | string
    relevanceScore?: NullableIntFieldUpdateOperationsInput | number | null
    customNotes?: NullableStringFieldUpdateOperationsInput | string | null
    isRecommended?: NullableBoolFieldUpdateOperationsInput | boolean | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessRiskProfileUpdateWithoutBusinessTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    combinedRisks?: StringFieldUpdateOperationsInput | string
    recommendedStrategies?: StringFieldUpdateOperationsInput | string
    overallRiskScore?: IntFieldUpdateOperationsInput | number
    priorityActions?: NullableStringFieldUpdateOperationsInput | string | null
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calculatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    parish?: ParishUpdateOneRequiredWithoutBusinessRiskProfilesNestedInput
  }

  export type BusinessRiskProfileUncheckedUpdateWithoutBusinessTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    parishId?: StringFieldUpdateOperationsInput | string
    combinedRisks?: StringFieldUpdateOperationsInput | string
    recommendedStrategies?: StringFieldUpdateOperationsInput | string
    overallRiskScore?: IntFieldUpdateOperationsInput | number
    priorityActions?: NullableStringFieldUpdateOperationsInput | string | null
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calculatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BusinessRiskProfileUncheckedUpdateManyWithoutBusinessTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    parishId?: StringFieldUpdateOperationsInput | string
    combinedRisks?: StringFieldUpdateOperationsInput | string
    recommendedStrategies?: StringFieldUpdateOperationsInput | string
    overallRiskScore?: IntFieldUpdateOperationsInput | number
    priorityActions?: NullableStringFieldUpdateOperationsInput | string | null
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calculatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BusinessTypeTranslationUpdateWithoutBusinessTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    exampleBusinessPurposes?: NullableJsonNullValueInput | InputJsonValue
    exampleProducts?: NullableJsonNullValueInput | InputJsonValue
    exampleKeyPersonnel?: NullableJsonNullValueInput | InputJsonValue
    exampleCustomerBase?: NullableJsonNullValueInput | InputJsonValue
    minimumEquipment?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessTypeTranslationUncheckedUpdateWithoutBusinessTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    exampleBusinessPurposes?: NullableJsonNullValueInput | InputJsonValue
    exampleProducts?: NullableJsonNullValueInput | InputJsonValue
    exampleKeyPersonnel?: NullableJsonNullValueInput | InputJsonValue
    exampleCustomerBase?: NullableJsonNullValueInput | InputJsonValue
    minimumEquipment?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessTypeTranslationUncheckedUpdateManyWithoutBusinessTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    exampleBusinessPurposes?: NullableJsonNullValueInput | InputJsonValue
    exampleProducts?: NullableJsonNullValueInput | InputJsonValue
    exampleKeyPersonnel?: NullableJsonNullValueInput | InputJsonValue
    exampleCustomerBase?: NullableJsonNullValueInput | InputJsonValue
    minimumEquipment?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessTypeStrategyCreateManyStrategyInput = {
    id?: string
    businessTypeId: string
    relevanceScore?: number | null
    customNotes?: string | null
    isRecommended?: boolean | null
    priority?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActionStepCreateManyStrategyInput = {
    id?: string
    stepId: string
    phase?: string
    title: string
    description: string
    smeAction?: string | null
    whyThisStepMatters?: string | null
    whatHappensIfSkipped?: string | null
    timeframe?: string | null
    estimatedMinutes?: number | null
    difficultyLevel?: string | null
    responsibility?: string | null
    estimatedCost?: string | null
    estimatedCostJMD?: string | null
    resources?: string | null
    checklist?: string | null
    howToKnowItsDone?: string | null
    exampleOutput?: string | null
    dependsOnSteps?: string | null
    isOptional?: boolean
    skipConditions?: string | null
    freeAlternative?: string | null
    lowTechOption?: string | null
    commonMistakesForStep?: string | null
    videoTutorialUrl?: string | null
    externalResourceUrl?: string | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StrategyItemCostCreateManyStrategyInput = {
    id?: string
    itemId: string
    quantity?: number
    customNotes?: string | null
    countryOverrides?: string | null
    isRequired?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StrategyTranslationCreateManyStrategyInput = {
    id?: string
    locale: string
    name: string
    description: string
    smeTitle?: string | null
    smeSummary?: string | null
    realWorldExample?: string | null
    whyImportant?: string | null
    whenToImplement?: string | null
    expectedOutcome?: string | null
    benefitsBullets?: NullableJsonNullValueInput | InputJsonValue
    helpfulTips?: NullableJsonNullValueInput | InputJsonValue
    commonMistakes?: NullableJsonNullValueInput | InputJsonValue
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    requiredResources?: NullableJsonNullValueInput | InputJsonValue
    lowBudgetAlternative?: string | null
    diyApproach?: string | null
    bcpTemplateText?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusinessTypeStrategyUpdateWithoutStrategyInput = {
    id?: StringFieldUpdateOperationsInput | string
    relevanceScore?: NullableIntFieldUpdateOperationsInput | number | null
    customNotes?: NullableStringFieldUpdateOperationsInput | string | null
    isRecommended?: NullableBoolFieldUpdateOperationsInput | boolean | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessType?: BusinessTypeUpdateOneRequiredWithoutBusinessTypeStrategiesNestedInput
  }

  export type BusinessTypeStrategyUncheckedUpdateWithoutStrategyInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessTypeId?: StringFieldUpdateOperationsInput | string
    relevanceScore?: NullableIntFieldUpdateOperationsInput | number | null
    customNotes?: NullableStringFieldUpdateOperationsInput | string | null
    isRecommended?: NullableBoolFieldUpdateOperationsInput | boolean | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessTypeStrategyUncheckedUpdateManyWithoutStrategyInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessTypeId?: StringFieldUpdateOperationsInput | string
    relevanceScore?: NullableIntFieldUpdateOperationsInput | number | null
    customNotes?: NullableStringFieldUpdateOperationsInput | string | null
    isRecommended?: NullableBoolFieldUpdateOperationsInput | boolean | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActionStepUpdateWithoutStrategyInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepId?: StringFieldUpdateOperationsInput | string
    phase?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    smeAction?: NullableStringFieldUpdateOperationsInput | string | null
    whyThisStepMatters?: NullableStringFieldUpdateOperationsInput | string | null
    whatHappensIfSkipped?: NullableStringFieldUpdateOperationsInput | string | null
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    difficultyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    responsibility?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCost?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCostJMD?: NullableStringFieldUpdateOperationsInput | string | null
    resources?: NullableStringFieldUpdateOperationsInput | string | null
    checklist?: NullableStringFieldUpdateOperationsInput | string | null
    howToKnowItsDone?: NullableStringFieldUpdateOperationsInput | string | null
    exampleOutput?: NullableStringFieldUpdateOperationsInput | string | null
    dependsOnSteps?: NullableStringFieldUpdateOperationsInput | string | null
    isOptional?: BoolFieldUpdateOperationsInput | boolean
    skipConditions?: NullableStringFieldUpdateOperationsInput | string | null
    freeAlternative?: NullableStringFieldUpdateOperationsInput | string | null
    lowTechOption?: NullableStringFieldUpdateOperationsInput | string | null
    commonMistakesForStep?: NullableStringFieldUpdateOperationsInput | string | null
    videoTutorialUrl?: NullableStringFieldUpdateOperationsInput | string | null
    externalResourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itemCosts?: ActionStepItemCostUpdateManyWithoutActionStepNestedInput
    translations?: ActionStepTranslationUpdateManyWithoutActionStepNestedInput
  }

  export type ActionStepUncheckedUpdateWithoutStrategyInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepId?: StringFieldUpdateOperationsInput | string
    phase?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    smeAction?: NullableStringFieldUpdateOperationsInput | string | null
    whyThisStepMatters?: NullableStringFieldUpdateOperationsInput | string | null
    whatHappensIfSkipped?: NullableStringFieldUpdateOperationsInput | string | null
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    difficultyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    responsibility?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCost?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCostJMD?: NullableStringFieldUpdateOperationsInput | string | null
    resources?: NullableStringFieldUpdateOperationsInput | string | null
    checklist?: NullableStringFieldUpdateOperationsInput | string | null
    howToKnowItsDone?: NullableStringFieldUpdateOperationsInput | string | null
    exampleOutput?: NullableStringFieldUpdateOperationsInput | string | null
    dependsOnSteps?: NullableStringFieldUpdateOperationsInput | string | null
    isOptional?: BoolFieldUpdateOperationsInput | boolean
    skipConditions?: NullableStringFieldUpdateOperationsInput | string | null
    freeAlternative?: NullableStringFieldUpdateOperationsInput | string | null
    lowTechOption?: NullableStringFieldUpdateOperationsInput | string | null
    commonMistakesForStep?: NullableStringFieldUpdateOperationsInput | string | null
    videoTutorialUrl?: NullableStringFieldUpdateOperationsInput | string | null
    externalResourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itemCosts?: ActionStepItemCostUncheckedUpdateManyWithoutActionStepNestedInput
    translations?: ActionStepTranslationUncheckedUpdateManyWithoutActionStepNestedInput
  }

  export type ActionStepUncheckedUpdateManyWithoutStrategyInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepId?: StringFieldUpdateOperationsInput | string
    phase?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    smeAction?: NullableStringFieldUpdateOperationsInput | string | null
    whyThisStepMatters?: NullableStringFieldUpdateOperationsInput | string | null
    whatHappensIfSkipped?: NullableStringFieldUpdateOperationsInput | string | null
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    difficultyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    responsibility?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCost?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCostJMD?: NullableStringFieldUpdateOperationsInput | string | null
    resources?: NullableStringFieldUpdateOperationsInput | string | null
    checklist?: NullableStringFieldUpdateOperationsInput | string | null
    howToKnowItsDone?: NullableStringFieldUpdateOperationsInput | string | null
    exampleOutput?: NullableStringFieldUpdateOperationsInput | string | null
    dependsOnSteps?: NullableStringFieldUpdateOperationsInput | string | null
    isOptional?: BoolFieldUpdateOperationsInput | boolean
    skipConditions?: NullableStringFieldUpdateOperationsInput | string | null
    freeAlternative?: NullableStringFieldUpdateOperationsInput | string | null
    lowTechOption?: NullableStringFieldUpdateOperationsInput | string | null
    commonMistakesForStep?: NullableStringFieldUpdateOperationsInput | string | null
    videoTutorialUrl?: NullableStringFieldUpdateOperationsInput | string | null
    externalResourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StrategyItemCostUpdateWithoutStrategyInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    customNotes?: NullableStringFieldUpdateOperationsInput | string | null
    countryOverrides?: NullableStringFieldUpdateOperationsInput | string | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: CostItemUpdateOneRequiredWithoutStrategyItemsNestedInput
  }

  export type StrategyItemCostUncheckedUpdateWithoutStrategyInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    customNotes?: NullableStringFieldUpdateOperationsInput | string | null
    countryOverrides?: NullableStringFieldUpdateOperationsInput | string | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StrategyItemCostUncheckedUpdateManyWithoutStrategyInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    customNotes?: NullableStringFieldUpdateOperationsInput | string | null
    countryOverrides?: NullableStringFieldUpdateOperationsInput | string | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StrategyTranslationUpdateWithoutStrategyInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    smeTitle?: NullableStringFieldUpdateOperationsInput | string | null
    smeSummary?: NullableStringFieldUpdateOperationsInput | string | null
    realWorldExample?: NullableStringFieldUpdateOperationsInput | string | null
    whyImportant?: NullableStringFieldUpdateOperationsInput | string | null
    whenToImplement?: NullableStringFieldUpdateOperationsInput | string | null
    expectedOutcome?: NullableStringFieldUpdateOperationsInput | string | null
    benefitsBullets?: NullableJsonNullValueInput | InputJsonValue
    helpfulTips?: NullableJsonNullValueInput | InputJsonValue
    commonMistakes?: NullableJsonNullValueInput | InputJsonValue
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    requiredResources?: NullableJsonNullValueInput | InputJsonValue
    lowBudgetAlternative?: NullableStringFieldUpdateOperationsInput | string | null
    diyApproach?: NullableStringFieldUpdateOperationsInput | string | null
    bcpTemplateText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StrategyTranslationUncheckedUpdateWithoutStrategyInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    smeTitle?: NullableStringFieldUpdateOperationsInput | string | null
    smeSummary?: NullableStringFieldUpdateOperationsInput | string | null
    realWorldExample?: NullableStringFieldUpdateOperationsInput | string | null
    whyImportant?: NullableStringFieldUpdateOperationsInput | string | null
    whenToImplement?: NullableStringFieldUpdateOperationsInput | string | null
    expectedOutcome?: NullableStringFieldUpdateOperationsInput | string | null
    benefitsBullets?: NullableJsonNullValueInput | InputJsonValue
    helpfulTips?: NullableJsonNullValueInput | InputJsonValue
    commonMistakes?: NullableJsonNullValueInput | InputJsonValue
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    requiredResources?: NullableJsonNullValueInput | InputJsonValue
    lowBudgetAlternative?: NullableStringFieldUpdateOperationsInput | string | null
    diyApproach?: NullableStringFieldUpdateOperationsInput | string | null
    bcpTemplateText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StrategyTranslationUncheckedUpdateManyWithoutStrategyInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    smeTitle?: NullableStringFieldUpdateOperationsInput | string | null
    smeSummary?: NullableStringFieldUpdateOperationsInput | string | null
    realWorldExample?: NullableStringFieldUpdateOperationsInput | string | null
    whyImportant?: NullableStringFieldUpdateOperationsInput | string | null
    whenToImplement?: NullableStringFieldUpdateOperationsInput | string | null
    expectedOutcome?: NullableStringFieldUpdateOperationsInput | string | null
    benefitsBullets?: NullableJsonNullValueInput | InputJsonValue
    helpfulTips?: NullableJsonNullValueInput | InputJsonValue
    commonMistakes?: NullableJsonNullValueInput | InputJsonValue
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    requiredResources?: NullableJsonNullValueInput | InputJsonValue
    lowBudgetAlternative?: NullableStringFieldUpdateOperationsInput | string | null
    diyApproach?: NullableStringFieldUpdateOperationsInput | string | null
    bcpTemplateText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActionStepItemCostCreateManyActionStepInput = {
    id?: string
    itemId: string
    quantity?: number
    customNotes?: string | null
    countryOverrides?: string | null
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActionStepTranslationCreateManyActionStepInput = {
    id?: string
    locale: string
    title: string
    description?: string | null
    smeAction?: string | null
    timeframe?: string | null
    whyThisStepMatters?: string | null
    howToKnowItsDone?: string | null
    whatHappensIfSkipped?: string | null
    exampleOutput?: string | null
    freeAlternative?: string | null
    lowTechOption?: string | null
    commonMistakesForStep?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActionStepItemCostUpdateWithoutActionStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    customNotes?: NullableStringFieldUpdateOperationsInput | string | null
    countryOverrides?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: CostItemUpdateOneRequiredWithoutActionStepItemsNestedInput
  }

  export type ActionStepItemCostUncheckedUpdateWithoutActionStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    customNotes?: NullableStringFieldUpdateOperationsInput | string | null
    countryOverrides?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActionStepItemCostUncheckedUpdateManyWithoutActionStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    customNotes?: NullableStringFieldUpdateOperationsInput | string | null
    countryOverrides?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActionStepTranslationUpdateWithoutActionStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    smeAction?: NullableStringFieldUpdateOperationsInput | string | null
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null
    whyThisStepMatters?: NullableStringFieldUpdateOperationsInput | string | null
    howToKnowItsDone?: NullableStringFieldUpdateOperationsInput | string | null
    whatHappensIfSkipped?: NullableStringFieldUpdateOperationsInput | string | null
    exampleOutput?: NullableStringFieldUpdateOperationsInput | string | null
    freeAlternative?: NullableStringFieldUpdateOperationsInput | string | null
    lowTechOption?: NullableStringFieldUpdateOperationsInput | string | null
    commonMistakesForStep?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActionStepTranslationUncheckedUpdateWithoutActionStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    smeAction?: NullableStringFieldUpdateOperationsInput | string | null
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null
    whyThisStepMatters?: NullableStringFieldUpdateOperationsInput | string | null
    howToKnowItsDone?: NullableStringFieldUpdateOperationsInput | string | null
    whatHappensIfSkipped?: NullableStringFieldUpdateOperationsInput | string | null
    exampleOutput?: NullableStringFieldUpdateOperationsInput | string | null
    freeAlternative?: NullableStringFieldUpdateOperationsInput | string | null
    lowTechOption?: NullableStringFieldUpdateOperationsInput | string | null
    commonMistakesForStep?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActionStepTranslationUncheckedUpdateManyWithoutActionStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    smeAction?: NullableStringFieldUpdateOperationsInput | string | null
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null
    whyThisStepMatters?: NullableStringFieldUpdateOperationsInput | string | null
    howToKnowItsDone?: NullableStringFieldUpdateOperationsInput | string | null
    whatHappensIfSkipped?: NullableStringFieldUpdateOperationsInput | string | null
    exampleOutput?: NullableStringFieldUpdateOperationsInput | string | null
    freeAlternative?: NullableStringFieldUpdateOperationsInput | string | null
    lowTechOption?: NullableStringFieldUpdateOperationsInput | string | null
    commonMistakesForStep?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RiskMultiplierTranslationCreateManyRiskMultiplierInput = {
    id?: string
    locale: string
    name: string
    description?: string | null
    reasoning?: string | null
    wizardQuestion?: string | null
    wizardHelpText?: string | null
    wizardAnswerOptions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RiskMultiplierTranslationUpdateWithoutRiskMultiplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    wizardQuestion?: NullableStringFieldUpdateOperationsInput | string | null
    wizardHelpText?: NullableStringFieldUpdateOperationsInput | string | null
    wizardAnswerOptions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RiskMultiplierTranslationUncheckedUpdateWithoutRiskMultiplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    wizardQuestion?: NullableStringFieldUpdateOperationsInput | string | null
    wizardHelpText?: NullableStringFieldUpdateOperationsInput | string | null
    wizardAnswerOptions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RiskMultiplierTranslationUncheckedUpdateManyWithoutRiskMultiplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    wizardQuestion?: NullableStringFieldUpdateOperationsInput | string | null
    wizardHelpText?: NullableStringFieldUpdateOperationsInput | string | null
    wizardAnswerOptions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StrategyItemCostCreateManyItemInput = {
    id?: string
    strategyId: string
    quantity?: number
    customNotes?: string | null
    countryOverrides?: string | null
    isRequired?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActionStepItemCostCreateManyItemInput = {
    id?: string
    actionStepId: string
    quantity?: number
    customNotes?: string | null
    countryOverrides?: string | null
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StrategyItemCostUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    customNotes?: NullableStringFieldUpdateOperationsInput | string | null
    countryOverrides?: NullableStringFieldUpdateOperationsInput | string | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    strategy?: RiskMitigationStrategyUpdateOneRequiredWithoutItemCostsNestedInput
  }

  export type StrategyItemCostUncheckedUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    strategyId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    customNotes?: NullableStringFieldUpdateOperationsInput | string | null
    countryOverrides?: NullableStringFieldUpdateOperationsInput | string | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StrategyItemCostUncheckedUpdateManyWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    strategyId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    customNotes?: NullableStringFieldUpdateOperationsInput | string | null
    countryOverrides?: NullableStringFieldUpdateOperationsInput | string | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActionStepItemCostUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    customNotes?: NullableStringFieldUpdateOperationsInput | string | null
    countryOverrides?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actionStep?: ActionStepUpdateOneRequiredWithoutItemCostsNestedInput
  }

  export type ActionStepItemCostUncheckedUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionStepId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    customNotes?: NullableStringFieldUpdateOperationsInput | string | null
    countryOverrides?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActionStepItemCostUncheckedUpdateManyWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionStepId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    customNotes?: NullableStringFieldUpdateOperationsInput | string | null
    countryOverrides?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use AdminBusinessTypeCountOutputTypeDefaultArgs instead
     */
    export type AdminBusinessTypeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminBusinessTypeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdminHazardTypeCountOutputTypeDefaultArgs instead
     */
    export type AdminHazardTypeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminHazardTypeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdminLocationCountOutputTypeDefaultArgs instead
     */
    export type AdminLocationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminLocationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdminStrategyCountOutputTypeDefaultArgs instead
     */
    export type AdminStrategyCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminStrategyCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdminActionPlanCountOutputTypeDefaultArgs instead
     */
    export type AdminActionPlanCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminActionPlanCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CountryCountOutputTypeDefaultArgs instead
     */
    export type CountryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CountryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ParishCountOutputTypeDefaultArgs instead
     */
    export type ParishCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ParishCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdminUnitRiskCountOutputTypeDefaultArgs instead
     */
    export type AdminUnitRiskCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminUnitRiskCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ParishRiskCountOutputTypeDefaultArgs instead
     */
    export type ParishRiskCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ParishRiskCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BusinessTypeCountOutputTypeDefaultArgs instead
     */
    export type BusinessTypeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BusinessTypeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RiskMitigationStrategyCountOutputTypeDefaultArgs instead
     */
    export type RiskMitigationStrategyCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RiskMitigationStrategyCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ActionStepCountOutputTypeDefaultArgs instead
     */
    export type ActionStepCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ActionStepCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RiskMultiplierCountOutputTypeDefaultArgs instead
     */
    export type RiskMultiplierCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RiskMultiplierCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CostItemCountOutputTypeDefaultArgs instead
     */
    export type CostItemCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CostItemCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BusinessContinuityPlanDefaultArgs instead
     */
    export type BusinessContinuityPlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BusinessContinuityPlanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlanInformationDefaultArgs instead
     */
    export type PlanInformationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlanInformationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BusinessOverviewDefaultArgs instead
     */
    export type BusinessOverviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BusinessOverviewDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EssentialFunctionDefaultArgs instead
     */
    export type EssentialFunctionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EssentialFunctionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RiskAssessmentDefaultArgs instead
     */
    export type RiskAssessmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RiskAssessmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StrategyDefaultArgs instead
     */
    export type StrategyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StrategyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ActionPlanDefaultArgs instead
     */
    export type ActionPlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ActionPlanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionDefaultArgs instead
     */
    export type SessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BusinessProfileDefaultArgs instead
     */
    export type BusinessProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BusinessProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContactsInformationDefaultArgs instead
     */
    export type ContactsInformationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContactsInformationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TestingMaintenanceDefaultArgs instead
     */
    export type TestingMaintenanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TestingMaintenanceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AnonymousSessionDefaultArgs instead
     */
    export type AnonymousSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AnonymousSessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdminBusinessTypeDefaultArgs instead
     */
    export type AdminBusinessTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminBusinessTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdminHazardTypeDefaultArgs instead
     */
    export type AdminHazardTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminHazardTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdminLocationDefaultArgs instead
     */
    export type AdminLocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminLocationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdminBusinessTypeHazardDefaultArgs instead
     */
    export type AdminBusinessTypeHazardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminBusinessTypeHazardDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdminLocationHazardDefaultArgs instead
     */
    export type AdminLocationHazardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminLocationHazardDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdminStrategyDefaultArgs instead
     */
    export type AdminStrategyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminStrategyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdminHazardStrategyDefaultArgs instead
     */
    export type AdminHazardStrategyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminHazardStrategyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdminActionPlanDefaultArgs instead
     */
    export type AdminActionPlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminActionPlanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdminHazardActionPlanDefaultArgs instead
     */
    export type AdminHazardActionPlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminHazardActionPlanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdminRiskProfileDefaultArgs instead
     */
    export type AdminRiskProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminRiskProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CountryDefaultArgs instead
     */
    export type CountryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CountryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdminUnitDefaultArgs instead
     */
    export type AdminUnitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminUnitDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ParishDefaultArgs instead
     */
    export type ParishArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ParishDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdminUnitRiskDefaultArgs instead
     */
    export type AdminUnitRiskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminUnitRiskDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdminUnitRiskChangeLogDefaultArgs instead
     */
    export type AdminUnitRiskChangeLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminUnitRiskChangeLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ParishRiskDefaultArgs instead
     */
    export type ParishRiskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ParishRiskDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RiskChangeLogDefaultArgs instead
     */
    export type RiskChangeLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RiskChangeLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BusinessTypeDefaultArgs instead
     */
    export type BusinessTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BusinessTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BusinessRiskVulnerabilityDefaultArgs instead
     */
    export type BusinessRiskVulnerabilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BusinessRiskVulnerabilityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RiskMitigationStrategyDefaultArgs instead
     */
    export type RiskMitigationStrategyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RiskMitigationStrategyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ActionStepDefaultArgs instead
     */
    export type ActionStepArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ActionStepDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BusinessTypeStrategyDefaultArgs instead
     */
    export type BusinessTypeStrategyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BusinessTypeStrategyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BusinessRiskProfileDefaultArgs instead
     */
    export type BusinessRiskProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BusinessRiskProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RiskMultiplierDefaultArgs instead
     */
    export type RiskMultiplierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RiskMultiplierDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CostItemDefaultArgs instead
     */
    export type CostItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CostItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CountryCostMultiplierDefaultArgs instead
     */
    export type CountryCostMultiplierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CountryCostMultiplierDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StrategyItemCostDefaultArgs instead
     */
    export type StrategyItemCostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StrategyItemCostDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ActionStepItemCostDefaultArgs instead
     */
    export type ActionStepItemCostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ActionStepItemCostDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BusinessTypeTranslationDefaultArgs instead
     */
    export type BusinessTypeTranslationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BusinessTypeTranslationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StrategyTranslationDefaultArgs instead
     */
    export type StrategyTranslationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StrategyTranslationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ActionStepTranslationDefaultArgs instead
     */
    export type ActionStepTranslationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ActionStepTranslationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HazardTranslationDefaultArgs instead
     */
    export type HazardTranslationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HazardTranslationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RiskMultiplierTranslationDefaultArgs instead
     */
    export type RiskMultiplierTranslationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RiskMultiplierTranslationDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}